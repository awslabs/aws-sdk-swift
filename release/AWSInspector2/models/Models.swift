// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Inspector2ClientTypes.Account: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case resourceStatus
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let resourceStatus = resourceStatus {
            try encodeContainer.encode(resourceStatus, forKey: .resourceStatus)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let resourceStatusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ResourceStatus.self, forKey: .resourceStatus)
        resourceStatus = resourceStatusDecoded
    }
}

extension Inspector2ClientTypes {
    /// An Amazon Web Services account within your environment that Amazon Inspector has been enabled for.
    public struct Account: Swift.Equatable {
        /// The ID of the Amazon Web Services account.
        /// This member is required.
        public var accountId: Swift.String?
        /// Details of the status of Amazon Inspector scans by resource type.
        /// This member is required.
        public var resourceStatus: Inspector2ClientTypes.ResourceStatus?
        /// The status of Amazon Inspector for the account.
        /// This member is required.
        public var status: Inspector2ClientTypes.Status?

        public init (
            accountId: Swift.String? = nil,
            resourceStatus: Inspector2ClientTypes.ResourceStatus? = nil,
            status: Inspector2ClientTypes.Status? = nil
        )
        {
            self.accountId = accountId
            self.resourceStatus = resourceStatus
            self.status = status
        }
    }

}

extension Inspector2ClientTypes.AccountAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingType
        case resourceType
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingType = findingType {
            try encodeContainer.encode(findingType.rawValue, forKey: .findingType)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AggregationFindingType.self, forKey: .findingType)
        findingType = findingTypeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AggregationResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AccountSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that contains details about an aggregation response based on Amazon Web Services accounts.
    public struct AccountAggregation: Swift.Equatable {
        /// The type of finding.
        public var findingType: Inspector2ClientTypes.AggregationFindingType?
        /// The type of resource.
        public var resourceType: Inspector2ClientTypes.AggregationResourceType?
        /// The value to sort by.
        public var sortBy: Inspector2ClientTypes.AccountSortBy?
        /// The sort order (ascending or descending).
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init (
            findingType: Inspector2ClientTypes.AggregationFindingType? = nil,
            resourceType: Inspector2ClientTypes.AggregationResourceType? = nil,
            sortBy: Inspector2ClientTypes.AccountSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.findingType = findingType
            self.resourceType = resourceType
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes.AccountAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let severityCounts = severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
    }
}

extension Inspector2ClientTypes {
    /// An aggregation of findings by Amazon Web Services account ID.
    public struct AccountAggregationResponse: Swift.Equatable {
        /// The Amazon Web Services account ID.
        public var accountId: Swift.String?
        /// The number of findings by severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init (
            accountId: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    public enum AccountSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountSortBy] {
            return [
                .all,
                .critical,
                .high,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountSortBy(rawValue: rawValue) ?? AccountSortBy.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.AccountState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case resourceState
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let resourceState = resourceState {
            try encodeContainer.encode(resourceState, forKey: .resourceState)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.State.self, forKey: .state)
        state = stateDecoded
        let resourceStateDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ResourceState.self, forKey: .resourceState)
        resourceState = resourceStateDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object with details the status of an Amazon Web Services account within your Amazon Inspector environment
    public struct AccountState: Swift.Equatable {
        /// The Amazon Web Services account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// An object detailing which resources Amazon Inspector is enabled to scan for the account.
        /// This member is required.
        public var resourceState: Inspector2ClientTypes.ResourceState?
        /// An object detailing the status of Amazon Inspector for the account.
        /// This member is required.
        public var state: Inspector2ClientTypes.State?

        public init (
            accountId: Swift.String? = nil,
            resourceState: Inspector2ClientTypes.ResourceState? = nil,
            state: Inspector2ClientTypes.State? = nil
        )
        {
            self.accountId = accountId
            self.resourceState = resourceState
            self.state = state
        }
    }

}

extension Inspector2ClientTypes {
    public enum AggregationFindingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case networkReachability
        case packageVulnerability
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationFindingType] {
            return [
                .networkReachability,
                .packageVulnerability,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .networkReachability: return "NETWORK_REACHABILITY"
            case .packageVulnerability: return "PACKAGE_VULNERABILITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregationFindingType(rawValue: rawValue) ?? AggregationFindingType.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.AggregationRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountaggregation = "accountAggregation"
        case amiaggregation = "amiAggregation"
        case awsecrcontaineraggregation = "awsEcrContainerAggregation"
        case ec2instanceaggregation = "ec2InstanceAggregation"
        case findingtypeaggregation = "findingTypeAggregation"
        case imagelayeraggregation = "imageLayerAggregation"
        case packageaggregation = "packageAggregation"
        case repositoryaggregation = "repositoryAggregation"
        case sdkUnknown
        case titleaggregation = "titleAggregation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .accountaggregation(accountaggregation):
                try container.encode(accountaggregation, forKey: .accountaggregation)
            case let .amiaggregation(amiaggregation):
                try container.encode(amiaggregation, forKey: .amiaggregation)
            case let .awsecrcontaineraggregation(awsecrcontaineraggregation):
                try container.encode(awsecrcontaineraggregation, forKey: .awsecrcontaineraggregation)
            case let .ec2instanceaggregation(ec2instanceaggregation):
                try container.encode(ec2instanceaggregation, forKey: .ec2instanceaggregation)
            case let .findingtypeaggregation(findingtypeaggregation):
                try container.encode(findingtypeaggregation, forKey: .findingtypeaggregation)
            case let .imagelayeraggregation(imagelayeraggregation):
                try container.encode(imagelayeraggregation, forKey: .imagelayeraggregation)
            case let .packageaggregation(packageaggregation):
                try container.encode(packageaggregation, forKey: .packageaggregation)
            case let .repositoryaggregation(repositoryaggregation):
                try container.encode(repositoryaggregation, forKey: .repositoryaggregation)
            case let .titleaggregation(titleaggregation):
                try container.encode(titleaggregation, forKey: .titleaggregation)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let accountaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.AccountAggregation.self, forKey: .accountaggregation)
        if let accountaggregation = accountaggregationDecoded {
            self = .accountaggregation(accountaggregation)
            return
        }
        let amiaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.AmiAggregation.self, forKey: .amiaggregation)
        if let amiaggregation = amiaggregationDecoded {
            self = .amiaggregation(amiaggregation)
            return
        }
        let awsecrcontaineraggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.AwsEcrContainerAggregation.self, forKey: .awsecrcontaineraggregation)
        if let awsecrcontaineraggregation = awsecrcontaineraggregationDecoded {
            self = .awsecrcontaineraggregation(awsecrcontaineraggregation)
            return
        }
        let ec2instanceaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.Ec2InstanceAggregation.self, forKey: .ec2instanceaggregation)
        if let ec2instanceaggregation = ec2instanceaggregationDecoded {
            self = .ec2instanceaggregation(ec2instanceaggregation)
            return
        }
        let findingtypeaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.FindingTypeAggregation.self, forKey: .findingtypeaggregation)
        if let findingtypeaggregation = findingtypeaggregationDecoded {
            self = .findingtypeaggregation(findingtypeaggregation)
            return
        }
        let imagelayeraggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.ImageLayerAggregation.self, forKey: .imagelayeraggregation)
        if let imagelayeraggregation = imagelayeraggregationDecoded {
            self = .imagelayeraggregation(imagelayeraggregation)
            return
        }
        let packageaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.PackageAggregation.self, forKey: .packageaggregation)
        if let packageaggregation = packageaggregationDecoded {
            self = .packageaggregation(packageaggregation)
            return
        }
        let repositoryaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.RepositoryAggregation.self, forKey: .repositoryaggregation)
        if let repositoryaggregation = repositoryaggregationDecoded {
            self = .repositoryaggregation(repositoryaggregation)
            return
        }
        let titleaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.TitleAggregation.self, forKey: .titleaggregation)
        if let titleaggregation = titleaggregationDecoded {
            self = .titleaggregation(titleaggregation)
            return
        }
        self = .sdkUnknown("")
    }
}

extension Inspector2ClientTypes {
    /// Contains details about an aggregation request.
    public enum AggregationRequest: Swift.Equatable {
        /// An object that contains details about an aggregation request based on Amazon Web Services account IDs.
        case accountaggregation(Inspector2ClientTypes.AccountAggregation)
        /// An object that contains details about an aggregation request based on Amazon Machine Images (AMIs).
        case amiaggregation(Inspector2ClientTypes.AmiAggregation)
        /// An object that contains details about an aggregation request based on Amazon ECR container images.
        case awsecrcontaineraggregation(Inspector2ClientTypes.AwsEcrContainerAggregation)
        /// An object that contains details about an aggregation request based on Amazon EC2 instances.
        case ec2instanceaggregation(Inspector2ClientTypes.Ec2InstanceAggregation)
        /// An object that contains details about an aggregation request based on finding types.
        case findingtypeaggregation(Inspector2ClientTypes.FindingTypeAggregation)
        /// An object that contains details about an aggregation request based on container image layers.
        case imagelayeraggregation(Inspector2ClientTypes.ImageLayerAggregation)
        /// An object that contains details about an aggregation request based on operating system package type.
        case packageaggregation(Inspector2ClientTypes.PackageAggregation)
        /// An object that contains details about an aggregation request based on Amazon ECR repositories.
        case repositoryaggregation(Inspector2ClientTypes.RepositoryAggregation)
        /// An object that contains details about an aggregation request based on finding title.
        case titleaggregation(Inspector2ClientTypes.TitleAggregation)
        case sdkUnknown(Swift.String)
    }

}

extension Inspector2ClientTypes {
    public enum AggregationResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsEc2Instance
        case awsEcrContainerImage
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationResourceType] {
            return [
                .awsEc2Instance,
                .awsEcrContainerImage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsEc2Instance: return "AWS_EC2_INSTANCE"
            case .awsEcrContainerImage: return "AWS_ECR_CONTAINER_IMAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregationResourceType(rawValue: rawValue) ?? AggregationResourceType.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.AggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountaggregation = "accountAggregation"
        case amiaggregation = "amiAggregation"
        case awsecrcontaineraggregation = "awsEcrContainerAggregation"
        case ec2instanceaggregation = "ec2InstanceAggregation"
        case findingtypeaggregation = "findingTypeAggregation"
        case imagelayeraggregation = "imageLayerAggregation"
        case packageaggregation = "packageAggregation"
        case repositoryaggregation = "repositoryAggregation"
        case sdkUnknown
        case titleaggregation = "titleAggregation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .accountaggregation(accountaggregation):
                try container.encode(accountaggregation, forKey: .accountaggregation)
            case let .amiaggregation(amiaggregation):
                try container.encode(amiaggregation, forKey: .amiaggregation)
            case let .awsecrcontaineraggregation(awsecrcontaineraggregation):
                try container.encode(awsecrcontaineraggregation, forKey: .awsecrcontaineraggregation)
            case let .ec2instanceaggregation(ec2instanceaggregation):
                try container.encode(ec2instanceaggregation, forKey: .ec2instanceaggregation)
            case let .findingtypeaggregation(findingtypeaggregation):
                try container.encode(findingtypeaggregation, forKey: .findingtypeaggregation)
            case let .imagelayeraggregation(imagelayeraggregation):
                try container.encode(imagelayeraggregation, forKey: .imagelayeraggregation)
            case let .packageaggregation(packageaggregation):
                try container.encode(packageaggregation, forKey: .packageaggregation)
            case let .repositoryaggregation(repositoryaggregation):
                try container.encode(repositoryaggregation, forKey: .repositoryaggregation)
            case let .titleaggregation(titleaggregation):
                try container.encode(titleaggregation, forKey: .titleaggregation)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let accountaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.AccountAggregationResponse.self, forKey: .accountaggregation)
        if let accountaggregation = accountaggregationDecoded {
            self = .accountaggregation(accountaggregation)
            return
        }
        let amiaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.AmiAggregationResponse.self, forKey: .amiaggregation)
        if let amiaggregation = amiaggregationDecoded {
            self = .amiaggregation(amiaggregation)
            return
        }
        let awsecrcontaineraggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.AwsEcrContainerAggregationResponse.self, forKey: .awsecrcontaineraggregation)
        if let awsecrcontaineraggregation = awsecrcontaineraggregationDecoded {
            self = .awsecrcontaineraggregation(awsecrcontaineraggregation)
            return
        }
        let ec2instanceaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.Ec2InstanceAggregationResponse.self, forKey: .ec2instanceaggregation)
        if let ec2instanceaggregation = ec2instanceaggregationDecoded {
            self = .ec2instanceaggregation(ec2instanceaggregation)
            return
        }
        let findingtypeaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.FindingTypeAggregationResponse.self, forKey: .findingtypeaggregation)
        if let findingtypeaggregation = findingtypeaggregationDecoded {
            self = .findingtypeaggregation(findingtypeaggregation)
            return
        }
        let imagelayeraggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.ImageLayerAggregationResponse.self, forKey: .imagelayeraggregation)
        if let imagelayeraggregation = imagelayeraggregationDecoded {
            self = .imagelayeraggregation(imagelayeraggregation)
            return
        }
        let packageaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.PackageAggregationResponse.self, forKey: .packageaggregation)
        if let packageaggregation = packageaggregationDecoded {
            self = .packageaggregation(packageaggregation)
            return
        }
        let repositoryaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.RepositoryAggregationResponse.self, forKey: .repositoryaggregation)
        if let repositoryaggregation = repositoryaggregationDecoded {
            self = .repositoryaggregation(repositoryaggregation)
            return
        }
        let titleaggregationDecoded = try values.decodeIfPresent(Inspector2ClientTypes.TitleAggregationResponse.self, forKey: .titleaggregation)
        if let titleaggregation = titleaggregationDecoded {
            self = .titleaggregation(titleaggregation)
            return
        }
        self = .sdkUnknown("")
    }
}

extension Inspector2ClientTypes {
    /// A structure that contains details about the results of an aggregation type.
    public enum AggregationResponse: Swift.Equatable {
        /// An object that contains details about an aggregation response based on Amazon Web Services account IDs.
        case accountaggregation(Inspector2ClientTypes.AccountAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon Machine Images (AMIs).
        case amiaggregation(Inspector2ClientTypes.AmiAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon ECR container images.
        case awsecrcontaineraggregation(Inspector2ClientTypes.AwsEcrContainerAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon EC2 instances.
        case ec2instanceaggregation(Inspector2ClientTypes.Ec2InstanceAggregationResponse)
        /// An object that contains details about an aggregation response based on finding types.
        case findingtypeaggregation(Inspector2ClientTypes.FindingTypeAggregationResponse)
        /// An object that contains details about an aggregation response based on container image layers.
        case imagelayeraggregation(Inspector2ClientTypes.ImageLayerAggregationResponse)
        /// An object that contains details about an aggregation response based on operating system package type.
        case packageaggregation(Inspector2ClientTypes.PackageAggregationResponse)
        /// An object that contains details about an aggregation response based on Amazon ECR repositories.
        case repositoryaggregation(Inspector2ClientTypes.RepositoryAggregationResponse)
        /// An object that contains details about an aggregation response based on finding title.
        case titleaggregation(Inspector2ClientTypes.TitleAggregationResponse)
        case sdkUnknown(Swift.String)
    }

}

extension Inspector2ClientTypes {
    public enum AggregationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case ami
        case awsEc2Instance
        case awsEcrContainer
        case findingType
        case imageLayer
        case package
        case repository
        case title
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationType] {
            return [
                .account,
                .ami,
                .awsEc2Instance,
                .awsEcrContainer,
                .findingType,
                .imageLayer,
                .package,
                .repository,
                .title,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .ami: return "AMI"
            case .awsEc2Instance: return "AWS_EC2_INSTANCE"
            case .awsEcrContainer: return "AWS_ECR_CONTAINER"
            case .findingType: return "FINDING_TYPE"
            case .imageLayer: return "IMAGE_LAYER"
            case .package: return "PACKAGE"
            case .repository: return "REPOSITORY"
            case .title: return "TITLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregationType(rawValue: rawValue) ?? AggregationType.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.AmiAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amis
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amis = amis {
            var amisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .amis)
            for stringfilterlist0 in amis {
                try amisContainer.encode(stringfilterlist0)
            }
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amisContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .amis)
        var amisDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let amisContainer = amisContainer {
            amisDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in amisContainer {
                if let structure0 = structure0 {
                    amisDecoded0?.append(structure0)
                }
            }
        }
        amis = amisDecoded0
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AmiSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on Amazon machine images (AMIs).
    public struct AmiAggregation: Swift.Equatable {
        /// The IDs of AMIs to aggregate findings for.
        public var amis: [Inspector2ClientTypes.StringFilter]?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.AmiSortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init (
            amis: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.AmiSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.amis = amis
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes.AmiAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case affectedInstances
        case ami
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let affectedInstances = affectedInstances {
            try encodeContainer.encode(affectedInstances, forKey: .affectedInstances)
        }
        if let ami = ami {
            try encodeContainer.encode(ami, forKey: .ami)
        }
        if let severityCounts = severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ami)
        ami = amiDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
        let affectedInstancesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .affectedInstances)
        affectedInstances = affectedInstancesDecoded
    }
}

extension Inspector2ClientTypes {
    /// A response that contains the results of a finding aggregation by AMI.
    public struct AmiAggregationResponse: Swift.Equatable {
        /// The Amazon Web Services account ID that the AMI belongs.
        public var accountId: Swift.String?
        /// The IDs of Amazon EC2 instances using this AMI.
        public var affectedInstances: Swift.Int?
        /// The ID of the AMI that findings were aggregated for.
        /// This member is required.
        public var ami: Swift.String?
        /// An object that contains the count of matched findings per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init (
            accountId: Swift.String? = nil,
            affectedInstances: Swift.Int? = nil,
            ami: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.affectedInstances = affectedInstances
            self.ami = ami
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    public enum AmiSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case affectedInstances
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [AmiSortBy] {
            return [
                .affectedInstances,
                .all,
                .critical,
                .high,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .affectedInstances: return "AFFECTED_INSTANCES"
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AmiSortBy(rawValue: rawValue) ?? AmiSortBy.sdkUnknown(rawValue)
        }
    }
}

extension AssociateMemberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }
}

extension AssociateMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/members/associate"
    }
}

public struct AssociateMemberInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the member account to be associated.
    /// This member is required.
    public var accountId: Swift.String?

    public init (
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct AssociateMemberInputBody: Swift.Equatable {
    let accountId: Swift.String?
}

extension AssociateMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension AssociateMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateMemberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateMemberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
        } else {
            self.accountId = nil
        }
    }
}

public struct AssociateMemberOutputResponse: Swift.Equatable {
    /// The Amazon Web Services account ID of the successfully associated member account.
    /// This member is required.
    public var accountId: Swift.String?

    public init (
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct AssociateMemberOutputResponseBody: Swift.Equatable {
    let accountId: Swift.String?
}

extension AssociateMemberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension Inspector2ClientTypes.AutoEnable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2
        case ecr
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2 = ec2 {
            try encodeContainer.encode(ec2, forKey: .ec2)
        }
        if let ecr = ecr {
            try encodeContainer.encode(ecr, forKey: .ecr)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2Decoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ec2)
        ec2 = ec2Decoded
        let ecrDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ecr)
        ecr = ecrDecoded
    }
}

extension Inspector2ClientTypes {
    /// Represents which scan types are automatically enabled for new members of your Amazon Inspector organization.
    public struct AutoEnable: Swift.Equatable {
        /// Represents whether Amazon EC2 scans are automatically enabled for new members of your Amazon Inspector organization.
        /// This member is required.
        public var ec2: Swift.Bool?
        /// Represents whether Amazon ECR scans are automatically enabled for new members of your Amazon Inspector organization.
        /// This member is required.
        public var ecr: Swift.Bool?

        public init (
            ec2: Swift.Bool? = nil,
            ecr: Swift.Bool? = nil
        )
        {
            self.ec2 = ec2
            self.ecr = ecr
        }
    }

}

extension Inspector2ClientTypes.AwsEc2InstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamInstanceProfileArn
        case imageId
        case ipV4Addresses
        case ipV6Addresses
        case keyName
        case launchedAt
        case platform
        case subnetId
        case type
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamInstanceProfileArn = iamInstanceProfileArn {
            try encodeContainer.encode(iamInstanceProfileArn, forKey: .iamInstanceProfileArn)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let ipV4Addresses = ipV4Addresses {
            var ipV4AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipV4Addresses)
            for ipv4addresslist0 in ipV4Addresses {
                try ipV4AddressesContainer.encode(ipv4addresslist0)
            }
        }
        if let ipV6Addresses = ipV6Addresses {
            var ipV6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipV6Addresses)
            for ipv6addresslist0 in ipV6Addresses {
                try ipV6AddressesContainer.encode(ipv6addresslist0)
            }
        }
        if let keyName = keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
        if let launchedAt = launchedAt {
            try encodeContainer.encode(launchedAt.timeIntervalSince1970, forKey: .launchedAt)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let ipV4AddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipV4Addresses)
        var ipV4AddressesDecoded0:[Swift.String]? = nil
        if let ipV4AddressesContainer = ipV4AddressesContainer {
            ipV4AddressesDecoded0 = [Swift.String]()
            for string0 in ipV4AddressesContainer {
                if let string0 = string0 {
                    ipV4AddressesDecoded0?.append(string0)
                }
            }
        }
        ipV4Addresses = ipV4AddressesDecoded0
        let ipV6AddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipV6Addresses)
        var ipV6AddressesDecoded0:[Swift.String]? = nil
        if let ipV6AddressesContainer = ipV6AddressesContainer {
            ipV6AddressesDecoded0 = [Swift.String]()
            for string0 in ipV6AddressesContainer {
                if let string0 = string0 {
                    ipV6AddressesDecoded0?.append(string0)
                }
            }
        }
        ipV6Addresses = ipV6AddressesDecoded0
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let iamInstanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamInstanceProfileArn)
        iamInstanceProfileArn = iamInstanceProfileArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let launchedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .launchedAt)
        launchedAt = launchedAtDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details of the Amazon EC2 instance involved in a finding.
    public struct AwsEc2InstanceDetails: Swift.Equatable {
        /// The IAM instance profile ARN of the Amazon EC2 instance.
        public var iamInstanceProfileArn: Swift.String?
        /// The image ID of the Amazon EC2 instance.
        public var imageId: Swift.String?
        /// The IPv4 addresses of the Amazon EC2 instance.
        public var ipV4Addresses: [Swift.String]?
        /// The IPv6 addresses of the Amazon EC2 instance.
        public var ipV6Addresses: [Swift.String]?
        /// The name of the key pair used to launch the Amazon EC2 instance.
        public var keyName: Swift.String?
        /// The date and time the Amazon EC2 instance was launched at.
        public var launchedAt: ClientRuntime.Date?
        /// The platform of the Amazon EC2 instance.
        public var platform: Swift.String?
        /// The subnet ID of the Amazon EC2 instance.
        public var subnetId: Swift.String?
        /// The type of the Amazon EC2 instance.
        public var type: Swift.String?
        /// The VPC ID of the Amazon EC2 instance.
        public var vpcId: Swift.String?

        public init (
            iamInstanceProfileArn: Swift.String? = nil,
            imageId: Swift.String? = nil,
            ipV4Addresses: [Swift.String]? = nil,
            ipV6Addresses: [Swift.String]? = nil,
            keyName: Swift.String? = nil,
            launchedAt: ClientRuntime.Date? = nil,
            platform: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            type: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.iamInstanceProfileArn = iamInstanceProfileArn
            self.imageId = imageId
            self.ipV4Addresses = ipV4Addresses
            self.ipV6Addresses = ipV6Addresses
            self.keyName = keyName
            self.launchedAt = launchedAt
            self.platform = platform
            self.subnetId = subnetId
            self.type = type
            self.vpcId = vpcId
        }
    }

}

extension Inspector2ClientTypes.AwsEcrContainerAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures
        case imageShas
        case imageTags
        case repositories
        case resourceIds
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for stringfilterlist0 in architectures {
                try architecturesContainer.encode(stringfilterlist0)
            }
        }
        if let imageShas = imageShas {
            var imageShasContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageShas)
            for stringfilterlist0 in imageShas {
                try imageShasContainer.encode(stringfilterlist0)
            }
        }
        if let imageTags = imageTags {
            var imageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageTags)
            for stringfilterlist0 in imageTags {
                try imageTagsContainer.encode(stringfilterlist0)
            }
        }
        if let repositories = repositories {
            var repositoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositories)
            for stringfilterlist0 in repositories {
                try repositoriesContainer.encode(stringfilterlist0)
            }
        }
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for stringfilterlist0 in resourceIds {
                try resourceIdsContainer.encode(stringfilterlist0)
            }
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in resourceIdsContainer {
                if let structure0 = structure0 {
                    resourceIdsDecoded0?.append(structure0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
        let imageShasContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .imageShas)
        var imageShasDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let imageShasContainer = imageShasContainer {
            imageShasDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in imageShasContainer {
                if let structure0 = structure0 {
                    imageShasDecoded0?.append(structure0)
                }
            }
        }
        imageShas = imageShasDecoded0
        let repositoriesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .repositories)
        var repositoriesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let architecturesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .architectures)
        var architecturesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in architecturesContainer {
                if let structure0 = structure0 {
                    architecturesDecoded0?.append(structure0)
                }
            }
        }
        architectures = architecturesDecoded0
        let imageTagsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .imageTags)
        var imageTagsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let imageTagsContainer = imageTagsContainer {
            imageTagsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in imageTagsContainer {
                if let structure0 = structure0 {
                    imageTagsDecoded0?.append(structure0)
                }
            }
        }
        imageTags = imageTagsDecoded0
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AwsEcrContainerSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// An aggregation of information about Amazon ECR containers.
    public struct AwsEcrContainerAggregation: Swift.Equatable {
        /// The architecture of the containers.
        public var architectures: [Inspector2ClientTypes.StringFilter]?
        /// The image SHA values.
        public var imageShas: [Inspector2ClientTypes.StringFilter]?
        /// The image tags.
        public var imageTags: [Inspector2ClientTypes.StringFilter]?
        /// The container repositories.
        public var repositories: [Inspector2ClientTypes.StringFilter]?
        /// The container resource IDs.
        public var resourceIds: [Inspector2ClientTypes.StringFilter]?
        /// The value to sort by.
        public var sortBy: Inspector2ClientTypes.AwsEcrContainerSortBy?
        /// The sort order (ascending or descending).
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init (
            architectures: [Inspector2ClientTypes.StringFilter]? = nil,
            imageShas: [Inspector2ClientTypes.StringFilter]? = nil,
            imageTags: [Inspector2ClientTypes.StringFilter]? = nil,
            repositories: [Inspector2ClientTypes.StringFilter]? = nil,
            resourceIds: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.AwsEcrContainerSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.architectures = architectures
            self.imageShas = imageShas
            self.imageTags = imageTags
            self.repositories = repositories
            self.resourceIds = resourceIds
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes.AwsEcrContainerAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case architecture
        case imageSha
        case imageTags
        case repository
        case resourceId
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let architecture = architecture {
            try encodeContainer.encode(architecture, forKey: .architecture)
        }
        if let imageSha = imageSha {
            try encodeContainer.encode(imageSha, forKey: .imageSha)
        }
        if let imageTags = imageTags {
            var imageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageTags)
            for stringlist0 in imageTags {
                try imageTagsContainer.encode(stringlist0)
            }
        }
        if let repository = repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let severityCounts = severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let imageShaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageSha)
        imageSha = imageShaDecoded
        let repositoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repository)
        repository = repositoryDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecture)
        architecture = architectureDecoded
        let imageTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageTags)
        var imageTagsDecoded0:[Swift.String]? = nil
        if let imageTagsContainer = imageTagsContainer {
            imageTagsDecoded0 = [Swift.String]()
            for string0 in imageTagsContainer {
                if let string0 = string0 {
                    imageTagsDecoded0?.append(string0)
                }
            }
        }
        imageTags = imageTagsDecoded0
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
    }
}

extension Inspector2ClientTypes {
    /// An aggregation of information about Amazon ECR containers.
    public struct AwsEcrContainerAggregationResponse: Swift.Equatable {
        /// The Amazon Web Services account ID of the account that owns the container.
        public var accountId: Swift.String?
        /// The architecture of the container.
        public var architecture: Swift.String?
        /// The SHA value of the container image.
        public var imageSha: Swift.String?
        /// The container image stags.
        public var imageTags: [Swift.String]?
        /// The container repository.
        public var repository: Swift.String?
        /// The resource ID of the container.
        /// This member is required.
        public var resourceId: Swift.String?
        /// The number of finding by severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init (
            accountId: Swift.String? = nil,
            architecture: Swift.String? = nil,
            imageSha: Swift.String? = nil,
            imageTags: [Swift.String]? = nil,
            repository: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.architecture = architecture
            self.imageSha = imageSha
            self.imageTags = imageTags
            self.repository = repository
            self.resourceId = resourceId
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes.AwsEcrContainerImageDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case author
        case imageHash
        case imageTags
        case platform
        case pushedAt
        case registry
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = architecture {
            try encodeContainer.encode(architecture, forKey: .architecture)
        }
        if let author = author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let imageHash = imageHash {
            try encodeContainer.encode(imageHash, forKey: .imageHash)
        }
        if let imageTags = imageTags {
            var imageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageTags)
            for imagetaglist0 in imageTags {
                try imageTagsContainer.encode(imagetaglist0)
            }
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let pushedAt = pushedAt {
            try encodeContainer.encode(pushedAt.timeIntervalSince1970, forKey: .pushedAt)
        }
        if let registry = registry {
            try encodeContainer.encode(registry, forKey: .registry)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageTags)
        var imageTagsDecoded0:[Swift.String]? = nil
        if let imageTagsContainer = imageTagsContainer {
            imageTagsDecoded0 = [Swift.String]()
            for string0 in imageTagsContainer {
                if let string0 = string0 {
                    imageTagsDecoded0?.append(string0)
                }
            }
        }
        imageTags = imageTagsDecoded0
        let pushedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .pushedAt)
        pushedAt = pushedAtDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecture)
        architecture = architectureDecoded
        let imageHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageHash)
        imageHash = imageHashDecoded
        let registryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registry)
        registry = registryDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
    }
}

extension Inspector2ClientTypes {
    /// The image details of the Amazon ECR container image.
    public struct AwsEcrContainerImageDetails: Swift.Equatable {
        /// The architecture of the Amazon ECR container image.
        public var architecture: Swift.String?
        /// The image author of the Amazon ECR container image.
        public var author: Swift.String?
        /// The image hash of the Amazon ECR container image.
        /// This member is required.
        public var imageHash: Swift.String?
        /// The image tags attached to the Amazon ECR container image.
        public var imageTags: [Swift.String]?
        /// The platform of the Amazon ECR container image.
        public var platform: Swift.String?
        /// The date and time the Amazon ECR container image was pushed.
        public var pushedAt: ClientRuntime.Date?
        /// The registry the Amazon ECR container image belongs to.
        /// This member is required.
        public var registry: Swift.String?
        /// The name of the repository the Amazon ECR container image resides in.
        /// This member is required.
        public var repositoryName: Swift.String?

        public init (
            architecture: Swift.String? = nil,
            author: Swift.String? = nil,
            imageHash: Swift.String? = nil,
            imageTags: [Swift.String]? = nil,
            platform: Swift.String? = nil,
            pushedAt: ClientRuntime.Date? = nil,
            registry: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.author = author
            self.imageHash = imageHash
            self.imageTags = imageTags
            self.platform = platform
            self.pushedAt = pushedAt
            self.registry = registry
            self.repositoryName = repositoryName
        }
    }

}

extension Inspector2ClientTypes {
    public enum AwsEcrContainerSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsEcrContainerSortBy] {
            return [
                .all,
                .critical,
                .high,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AwsEcrContainerSortBy(rawValue: rawValue) ?? AwsEcrContainerSortBy.sdkUnknown(rawValue)
        }
    }
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more tags submitted as part of the request is not valid.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchGetAccountStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountidset0 in accountIds {
                try accountIdsContainer.encode(accountidset0)
            }
        }
    }
}

extension BatchGetAccountStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/status/batch/get"
    }
}

public struct BatchGetAccountStatusInput: Swift.Equatable {
    /// The 12-digit Amazon Web Services account IDs of the accounts to retrieve Amazon Inspector status for.
    public var accountIds: Swift.Set<Swift.String>?

    public init (
        accountIds: Swift.Set<Swift.String>? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct BatchGetAccountStatusInputBody: Swift.Equatable {
    let accountIds: Swift.Set<Swift.String>?
}

extension BatchGetAccountStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent(Swift.Set<Swift.String>.self, forKey: .accountIds)
        var accountIdsDecoded0:Swift.Set<Swift.String>? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = Swift.Set<Swift.String>()
            for string0 in accountIdsContainer {
                accountIdsDecoded0?.insert(string0)
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension BatchGetAccountStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetAccountStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetAccountStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetAccountStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchGetAccountStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accounts = output.accounts
            self.failedAccounts = output.failedAccounts
        } else {
            self.accounts = nil
            self.failedAccounts = nil
        }
    }
}

public struct BatchGetAccountStatusOutputResponse: Swift.Equatable {
    /// An array of objects that provide details on the status of Amazon Inspector for each of the requested accounts.
    /// This member is required.
    public var accounts: [Inspector2ClientTypes.AccountState]?
    /// An array of objects detailing any accounts that failed to enable Amazon Inspector and why.
    public var failedAccounts: [Inspector2ClientTypes.FailedAccount]?

    public init (
        accounts: [Inspector2ClientTypes.AccountState]? = nil,
        failedAccounts: [Inspector2ClientTypes.FailedAccount]? = nil
    )
    {
        self.accounts = accounts
        self.failedAccounts = failedAccounts
    }
}

struct BatchGetAccountStatusOutputResponseBody: Swift.Equatable {
    let accounts: [Inspector2ClientTypes.AccountState]?
    let failedAccounts: [Inspector2ClientTypes.FailedAccount]?
}

extension BatchGetAccountStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts
        case failedAccounts
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.AccountState?].self, forKey: .accounts)
        var accountsDecoded0:[Inspector2ClientTypes.AccountState]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [Inspector2ClientTypes.AccountState]()
            for structure0 in accountsContainer {
                if let structure0 = structure0 {
                    accountsDecoded0?.append(structure0)
                }
            }
        }
        accounts = accountsDecoded0
        let failedAccountsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.FailedAccount?].self, forKey: .failedAccounts)
        var failedAccountsDecoded0:[Inspector2ClientTypes.FailedAccount]? = nil
        if let failedAccountsContainer = failedAccountsContainer {
            failedAccountsDecoded0 = [Inspector2ClientTypes.FailedAccount]()
            for structure0 in failedAccountsContainer {
                if let structure0 = structure0 {
                    failedAccountsDecoded0?.append(structure0)
                }
            }
        }
        failedAccounts = failedAccountsDecoded0
    }
}

extension BatchGetFreeTrialInfoInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for meteringaccountidlist0 in accountIds {
                try accountIdsContainer.encode(meteringaccountidlist0)
            }
        }
    }
}

extension BatchGetFreeTrialInfoInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/freetrialinfo/batchget"
    }
}

public struct BatchGetFreeTrialInfoInput: Swift.Equatable {
    /// The account IDs to get free trial status for.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init (
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct BatchGetFreeTrialInfoInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension BatchGetFreeTrialInfoInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension BatchGetFreeTrialInfoOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetFreeTrialInfoOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetFreeTrialInfoOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetFreeTrialInfoOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchGetFreeTrialInfoOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accounts = output.accounts
            self.failedAccounts = output.failedAccounts
        } else {
            self.accounts = nil
            self.failedAccounts = nil
        }
    }
}

public struct BatchGetFreeTrialInfoOutputResponse: Swift.Equatable {
    /// An array of objects that provide Amazon Inspector free trial details for each of the requested accounts.
    /// This member is required.
    public var accounts: [Inspector2ClientTypes.FreeTrialAccountInfo]?
    /// An array of objects detailing any accounts that free trial data could not be returned for.
    /// This member is required.
    public var failedAccounts: [Inspector2ClientTypes.FreeTrialInfoError]?

    public init (
        accounts: [Inspector2ClientTypes.FreeTrialAccountInfo]? = nil,
        failedAccounts: [Inspector2ClientTypes.FreeTrialInfoError]? = nil
    )
    {
        self.accounts = accounts
        self.failedAccounts = failedAccounts
    }
}

struct BatchGetFreeTrialInfoOutputResponseBody: Swift.Equatable {
    let accounts: [Inspector2ClientTypes.FreeTrialAccountInfo]?
    let failedAccounts: [Inspector2ClientTypes.FreeTrialInfoError]?
}

extension BatchGetFreeTrialInfoOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts
        case failedAccounts
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.FreeTrialAccountInfo?].self, forKey: .accounts)
        var accountsDecoded0:[Inspector2ClientTypes.FreeTrialAccountInfo]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [Inspector2ClientTypes.FreeTrialAccountInfo]()
            for structure0 in accountsContainer {
                if let structure0 = structure0 {
                    accountsDecoded0?.append(structure0)
                }
            }
        }
        accounts = accountsDecoded0
        let failedAccountsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.FreeTrialInfoError?].self, forKey: .failedAccounts)
        var failedAccountsDecoded0:[Inspector2ClientTypes.FreeTrialInfoError]? = nil
        if let failedAccountsContainer = failedAccountsContainer {
            failedAccountsDecoded0 = [Inspector2ClientTypes.FreeTrialInfoError]()
            for structure0 in failedAccountsContainer {
                if let structure0 = structure0 {
                    failedAccountsDecoded0?.append(structure0)
                }
            }
        }
        failedAccounts = failedAccountsDecoded0
    }
}

extension CancelFindingsReportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportId = reportId {
            try encodeContainer.encode(reportId, forKey: .reportId)
        }
    }
}

extension CancelFindingsReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/reporting/cancel"
    }
}

public struct CancelFindingsReportInput: Swift.Equatable {
    /// The ID of the report to be canceled.
    /// This member is required.
    public var reportId: Swift.String?

    public init (
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct CancelFindingsReportInputBody: Swift.Equatable {
    let reportId: Swift.String?
}

extension CancelFindingsReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

extension CancelFindingsReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelFindingsReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelFindingsReportOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelFindingsReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelFindingsReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reportId = output.reportId
        } else {
            self.reportId = nil
        }
    }
}

public struct CancelFindingsReportOutputResponse: Swift.Equatable {
    /// The ID of the canceled report.
    /// This member is required.
    public var reportId: Swift.String?

    public init (
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct CancelFindingsReportOutputResponseBody: Swift.Equatable {
    let reportId: Swift.String?
}

extension CancelFindingsReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A conflict occurred.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the conflicting resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of the conflicting resource.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension Inspector2ClientTypes.Counts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case groupKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let groupKey = groupKey {
            try encodeContainer.encode(groupKey.rawValue, forKey: .groupKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decode(Swift.Int.self, forKey: .count)
        count = countDecoded
        let groupKeyDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.GroupKey.self, forKey: .groupKey)
        groupKey = groupKeyDecoded
    }
}

extension Inspector2ClientTypes {
    /// a structure that contains information on the count of resources within a group.
    public struct Counts: Swift.Equatable {
        /// The number of resources.
        public var count: Swift.Int
        /// The key associated with this group
        public var groupKey: Inspector2ClientTypes.GroupKey?

        public init (
            count: Swift.Int = 0,
            groupKey: Inspector2ClientTypes.GroupKey? = nil
        )
        {
            self.count = count
            self.groupKey = groupKey
        }
    }

}

extension Inspector2ClientTypes.CoverageFilterCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case ec2InstanceTags
        case ecrImageTags
        case ecrRepositoryName
        case resourceId
        case resourceType
        case scanStatusCode
        case scanStatusReason
        case scanType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            var accountIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountId)
            for coveragestringfilterlist0 in accountId {
                try accountIdContainer.encode(coveragestringfilterlist0)
            }
        }
        if let ec2InstanceTags = ec2InstanceTags {
            var ec2InstanceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceTags)
            for coveragemapfilterlist0 in ec2InstanceTags {
                try ec2InstanceTagsContainer.encode(coveragemapfilterlist0)
            }
        }
        if let ecrImageTags = ecrImageTags {
            var ecrImageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrImageTags)
            for coveragestringfilterlist0 in ecrImageTags {
                try ecrImageTagsContainer.encode(coveragestringfilterlist0)
            }
        }
        if let ecrRepositoryName = ecrRepositoryName {
            var ecrRepositoryNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrRepositoryName)
            for coveragestringfilterlist0 in ecrRepositoryName {
                try ecrRepositoryNameContainer.encode(coveragestringfilterlist0)
            }
        }
        if let resourceId = resourceId {
            var resourceIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceId)
            for coveragestringfilterlist0 in resourceId {
                try resourceIdContainer.encode(coveragestringfilterlist0)
            }
        }
        if let resourceType = resourceType {
            var resourceTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceType)
            for coveragestringfilterlist0 in resourceType {
                try resourceTypeContainer.encode(coveragestringfilterlist0)
            }
        }
        if let scanStatusCode = scanStatusCode {
            var scanStatusCodeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scanStatusCode)
            for coveragestringfilterlist0 in scanStatusCode {
                try scanStatusCodeContainer.encode(coveragestringfilterlist0)
            }
        }
        if let scanStatusReason = scanStatusReason {
            var scanStatusReasonContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scanStatusReason)
            for coveragestringfilterlist0 in scanStatusReason {
                try scanStatusReasonContainer.encode(coveragestringfilterlist0)
            }
        }
        if let scanType = scanType {
            var scanTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scanType)
            for coveragestringfilterlist0 in scanType {
                try scanTypeContainer.encode(coveragestringfilterlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanStatusCodeContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageStringFilter?].self, forKey: .scanStatusCode)
        var scanStatusCodeDecoded0:[Inspector2ClientTypes.CoverageStringFilter]? = nil
        if let scanStatusCodeContainer = scanStatusCodeContainer {
            scanStatusCodeDecoded0 = [Inspector2ClientTypes.CoverageStringFilter]()
            for structure0 in scanStatusCodeContainer {
                if let structure0 = structure0 {
                    scanStatusCodeDecoded0?.append(structure0)
                }
            }
        }
        scanStatusCode = scanStatusCodeDecoded0
        let scanStatusReasonContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageStringFilter?].self, forKey: .scanStatusReason)
        var scanStatusReasonDecoded0:[Inspector2ClientTypes.CoverageStringFilter]? = nil
        if let scanStatusReasonContainer = scanStatusReasonContainer {
            scanStatusReasonDecoded0 = [Inspector2ClientTypes.CoverageStringFilter]()
            for structure0 in scanStatusReasonContainer {
                if let structure0 = structure0 {
                    scanStatusReasonDecoded0?.append(structure0)
                }
            }
        }
        scanStatusReason = scanStatusReasonDecoded0
        let accountIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageStringFilter?].self, forKey: .accountId)
        var accountIdDecoded0:[Inspector2ClientTypes.CoverageStringFilter]? = nil
        if let accountIdContainer = accountIdContainer {
            accountIdDecoded0 = [Inspector2ClientTypes.CoverageStringFilter]()
            for structure0 in accountIdContainer {
                if let structure0 = structure0 {
                    accountIdDecoded0?.append(structure0)
                }
            }
        }
        accountId = accountIdDecoded0
        let resourceIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageStringFilter?].self, forKey: .resourceId)
        var resourceIdDecoded0:[Inspector2ClientTypes.CoverageStringFilter]? = nil
        if let resourceIdContainer = resourceIdContainer {
            resourceIdDecoded0 = [Inspector2ClientTypes.CoverageStringFilter]()
            for structure0 in resourceIdContainer {
                if let structure0 = structure0 {
                    resourceIdDecoded0?.append(structure0)
                }
            }
        }
        resourceId = resourceIdDecoded0
        let resourceTypeContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageStringFilter?].self, forKey: .resourceType)
        var resourceTypeDecoded0:[Inspector2ClientTypes.CoverageStringFilter]? = nil
        if let resourceTypeContainer = resourceTypeContainer {
            resourceTypeDecoded0 = [Inspector2ClientTypes.CoverageStringFilter]()
            for structure0 in resourceTypeContainer {
                if let structure0 = structure0 {
                    resourceTypeDecoded0?.append(structure0)
                }
            }
        }
        resourceType = resourceTypeDecoded0
        let scanTypeContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageStringFilter?].self, forKey: .scanType)
        var scanTypeDecoded0:[Inspector2ClientTypes.CoverageStringFilter]? = nil
        if let scanTypeContainer = scanTypeContainer {
            scanTypeDecoded0 = [Inspector2ClientTypes.CoverageStringFilter]()
            for structure0 in scanTypeContainer {
                if let structure0 = structure0 {
                    scanTypeDecoded0?.append(structure0)
                }
            }
        }
        scanType = scanTypeDecoded0
        let ecrRepositoryNameContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageStringFilter?].self, forKey: .ecrRepositoryName)
        var ecrRepositoryNameDecoded0:[Inspector2ClientTypes.CoverageStringFilter]? = nil
        if let ecrRepositoryNameContainer = ecrRepositoryNameContainer {
            ecrRepositoryNameDecoded0 = [Inspector2ClientTypes.CoverageStringFilter]()
            for structure0 in ecrRepositoryNameContainer {
                if let structure0 = structure0 {
                    ecrRepositoryNameDecoded0?.append(structure0)
                }
            }
        }
        ecrRepositoryName = ecrRepositoryNameDecoded0
        let ecrImageTagsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageStringFilter?].self, forKey: .ecrImageTags)
        var ecrImageTagsDecoded0:[Inspector2ClientTypes.CoverageStringFilter]? = nil
        if let ecrImageTagsContainer = ecrImageTagsContainer {
            ecrImageTagsDecoded0 = [Inspector2ClientTypes.CoverageStringFilter]()
            for structure0 in ecrImageTagsContainer {
                if let structure0 = structure0 {
                    ecrImageTagsDecoded0?.append(structure0)
                }
            }
        }
        ecrImageTags = ecrImageTagsDecoded0
        let ec2InstanceTagsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoverageMapFilter?].self, forKey: .ec2InstanceTags)
        var ec2InstanceTagsDecoded0:[Inspector2ClientTypes.CoverageMapFilter]? = nil
        if let ec2InstanceTagsContainer = ec2InstanceTagsContainer {
            ec2InstanceTagsDecoded0 = [Inspector2ClientTypes.CoverageMapFilter]()
            for structure0 in ec2InstanceTagsContainer {
                if let structure0 = structure0 {
                    ec2InstanceTagsDecoded0?.append(structure0)
                }
            }
        }
        ec2InstanceTags = ec2InstanceTagsDecoded0
    }
}

extension Inspector2ClientTypes {
    /// A structure that identifies filter criteria for GetCoverageStatistics.
    public struct CoverageFilterCriteria: Swift.Equatable {
        /// An array of Amazon Web Services account IDs to return coverage statistics for.
        public var accountId: [Inspector2ClientTypes.CoverageStringFilter]?
        /// The Amazon EC2 instance tags to filter on.
        public var ec2InstanceTags: [Inspector2ClientTypes.CoverageMapFilter]?
        /// The Amazon ECR image tags to filter on.
        public var ecrImageTags: [Inspector2ClientTypes.CoverageStringFilter]?
        /// The Amazon ECR repository name to filter on.
        public var ecrRepositoryName: [Inspector2ClientTypes.CoverageStringFilter]?
        /// An array of Amazon Web Services resource IDs to return coverage statistics for.
        public var resourceId: [Inspector2ClientTypes.CoverageStringFilter]?
        /// An array of Amazon Web Services resource types to return coverage statistics for.
        public var resourceType: [Inspector2ClientTypes.CoverageStringFilter]?
        /// The scan status code to filter on.
        public var scanStatusCode: [Inspector2ClientTypes.CoverageStringFilter]?
        /// The scan status reason to filter on.
        public var scanStatusReason: [Inspector2ClientTypes.CoverageStringFilter]?
        /// An array of Amazon Inspector scan types to return coverage statistics for.
        public var scanType: [Inspector2ClientTypes.CoverageStringFilter]?

        public init (
            accountId: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            ec2InstanceTags: [Inspector2ClientTypes.CoverageMapFilter]? = nil,
            ecrImageTags: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            ecrRepositoryName: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            resourceId: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            resourceType: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            scanStatusCode: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            scanStatusReason: [Inspector2ClientTypes.CoverageStringFilter]? = nil,
            scanType: [Inspector2ClientTypes.CoverageStringFilter]? = nil
        )
        {
            self.accountId = accountId
            self.ec2InstanceTags = ec2InstanceTags
            self.ecrImageTags = ecrImageTags
            self.ecrRepositoryName = ecrRepositoryName
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.scanStatusCode = scanStatusCode
            self.scanStatusReason = scanStatusReason
            self.scanType = scanType
        }
    }

}

extension Inspector2ClientTypes {
    public enum CoverageMapComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [CoverageMapComparison] {
            return [
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CoverageMapComparison(rawValue: rawValue) ?? CoverageMapComparison.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.CoverageMapFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparison
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = comparison {
            try encodeContainer.encode(comparison.rawValue, forKey: .comparison)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.CoverageMapComparison.self, forKey: .comparison)
        comparison = comparisonDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains details of a coverage map filter.
    public struct CoverageMapFilter: Swift.Equatable {
        /// The operator to compare coverage on.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.CoverageMapComparison?
        /// The tag key associated with the coverage map filter.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value associated with the coverage map filter.
        public var value: Swift.String?

        public init (
            comparison: Inspector2ClientTypes.CoverageMapComparison? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.key = key
            self.value = value
        }
    }

}

extension Inspector2ClientTypes {
    public enum CoverageResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsEc2Instance
        case awsEcrContainerImage
        case awsEcrRepository
        case sdkUnknown(Swift.String)

        public static var allCases: [CoverageResourceType] {
            return [
                .awsEc2Instance,
                .awsEcrContainerImage,
                .awsEcrRepository,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsEc2Instance: return "AWS_EC2_INSTANCE"
            case .awsEcrContainerImage: return "AWS_ECR_CONTAINER_IMAGE"
            case .awsEcrRepository: return "AWS_ECR_REPOSITORY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CoverageResourceType(rawValue: rawValue) ?? CoverageResourceType.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum CoverageStringComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [CoverageStringComparison] {
            return [
                .equals,
                .notEquals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CoverageStringComparison(rawValue: rawValue) ?? CoverageStringComparison.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.CoverageStringFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparison
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = comparison {
            try encodeContainer.encode(comparison.rawValue, forKey: .comparison)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.CoverageStringComparison.self, forKey: .comparison)
        comparison = comparisonDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains details of a coverage string filter.
    public struct CoverageStringFilter: Swift.Equatable {
        /// The operator to compare strings on.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.CoverageStringComparison?
        /// The value to compare strings on.
        /// This member is required.
        public var value: Swift.String?

        public init (
            comparison: Inspector2ClientTypes.CoverageStringComparison? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.value = value
        }
    }

}

extension Inspector2ClientTypes.CoveredResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case resourceId
        case resourceMetadata
        case resourceType
        case scanStatus
        case scanType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceMetadata = resourceMetadata {
            try encodeContainer.encode(resourceMetadata, forKey: .resourceMetadata)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let scanStatus = scanStatus {
            try encodeContainer.encode(scanStatus, forKey: .scanStatus)
        }
        if let scanType = scanType {
            try encodeContainer.encode(scanType.rawValue, forKey: .scanType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.CoverageResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let scanTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ScanType.self, forKey: .scanType)
        scanType = scanTypeDecoded
        let scanStatusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ScanStatus.self, forKey: .scanStatus)
        scanStatus = scanStatusDecoded
        let resourceMetadataDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ResourceScanMetadata.self, forKey: .resourceMetadata)
        resourceMetadata = resourceMetadataDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that contains details about a resource covered by Amazon Inspector.
    public struct CoveredResource: Swift.Equatable {
        /// The Amazon Web Services account ID of the covered resource.
        /// This member is required.
        public var accountId: Swift.String?
        /// The ID of the covered resource.
        /// This member is required.
        public var resourceId: Swift.String?
        /// An object that contains details about the metadata.
        public var resourceMetadata: Inspector2ClientTypes.ResourceScanMetadata?
        /// The type of the covered resource.
        /// This member is required.
        public var resourceType: Inspector2ClientTypes.CoverageResourceType?
        /// The status of the scan covering the resource.
        public var scanStatus: Inspector2ClientTypes.ScanStatus?
        /// The Amazon Inspector scan type covering the resource.
        /// This member is required.
        public var scanType: Inspector2ClientTypes.ScanType?

        public init (
            accountId: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceMetadata: Inspector2ClientTypes.ResourceScanMetadata? = nil,
            resourceType: Inspector2ClientTypes.CoverageResourceType? = nil,
            scanStatus: Inspector2ClientTypes.ScanStatus? = nil,
            scanType: Inspector2ClientTypes.ScanType? = nil
        )
        {
            self.accountId = accountId
            self.resourceId = resourceId
            self.resourceMetadata = resourceMetadata
            self.resourceType = resourceType
            self.scanStatus = scanStatus
            self.scanType = scanType
        }
    }

}

extension CreateFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case description
        case filterCriteria
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let filterCriteria = filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/filters/create"
    }
}

public struct CreateFilterInput: Swift.Equatable {
    /// Defines the action that is to be applied to the findings that match the filter.
    /// This member is required.
    public var action: Inspector2ClientTypes.FilterAction?
    /// A description of the filter.
    public var description: Swift.String?
    /// Defines the criteria to be used in the filter for querying findings.
    /// This member is required.
    public var filterCriteria: Inspector2ClientTypes.FilterCriteria?
    /// The name of the filter. Minimum length of 3. Maximum length of 64. Valid characters include alphanumeric characters, dot (.), underscore (_), and dash (-). Spaces are not allowed.
    /// This member is required.
    public var name: Swift.String?
    /// A list of tags for the filter.
    public var tags: [Swift.String:Swift.String]?

    public init (
        action: Inspector2ClientTypes.FilterAction? = nil,
        description: Swift.String? = nil,
        filterCriteria: Inspector2ClientTypes.FilterCriteria? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.action = action
        self.description = description
        self.filterCriteria = filterCriteria
        self.name = name
        self.tags = tags
    }
}

struct CreateFilterInputBody: Swift.Equatable {
    let action: Inspector2ClientTypes.FilterAction?
    let description: Swift.String?
    let filterCriteria: Inspector2ClientTypes.FilterCriteria?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case description
        case filterCriteria
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterAction.self, forKey: .action)
        action = actionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, mapvalue0) in tagsContainer {
                if let mapvalue0 = mapvalue0 {
                    tagsDecoded0?[key0] = mapvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFilterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFilterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFilterOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFilterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFilterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreateFilterOutputResponse: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the successfully created filter.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateFilterOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension CreateFilterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CreateFindingsReportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria
        case reportFormat
        case s3Destination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterCriteria = filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let reportFormat = reportFormat {
            try encodeContainer.encode(reportFormat.rawValue, forKey: .reportFormat)
        }
        if let s3Destination = s3Destination {
            try encodeContainer.encode(s3Destination, forKey: .s3Destination)
        }
    }
}

extension CreateFindingsReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/reporting/create"
    }
}

public struct CreateFindingsReportInput: Swift.Equatable {
    /// The filter criteria to apply to the results of the finding report.
    public var filterCriteria: Inspector2ClientTypes.FilterCriteria?
    /// The format to generate the report in.
    /// This member is required.
    public var reportFormat: Inspector2ClientTypes.ReportFormat?
    /// The Amazon S3 export destination for the report.
    /// This member is required.
    public var s3Destination: Inspector2ClientTypes.Destination?

    public init (
        filterCriteria: Inspector2ClientTypes.FilterCriteria? = nil,
        reportFormat: Inspector2ClientTypes.ReportFormat? = nil,
        s3Destination: Inspector2ClientTypes.Destination? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.reportFormat = reportFormat
        self.s3Destination = s3Destination
    }
}

struct CreateFindingsReportInputBody: Swift.Equatable {
    let filterCriteria: Inspector2ClientTypes.FilterCriteria?
    let reportFormat: Inspector2ClientTypes.ReportFormat?
    let s3Destination: Inspector2ClientTypes.Destination?
}

extension CreateFindingsReportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria
        case reportFormat
        case s3Destination
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let reportFormatDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ReportFormat.self, forKey: .reportFormat)
        reportFormat = reportFormatDecoded
        let s3DestinationDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Destination.self, forKey: .s3Destination)
        s3Destination = s3DestinationDecoded
    }
}

extension CreateFindingsReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFindingsReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFindingsReportOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFindingsReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFindingsReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reportId = output.reportId
        } else {
            self.reportId = nil
        }
    }
}

public struct CreateFindingsReportOutputResponse: Swift.Equatable {
    /// The ID of the report.
    public var reportId: Swift.String?

    public init (
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct CreateFindingsReportOutputResponseBody: Swift.Equatable {
    let reportId: Swift.String?
}

extension CreateFindingsReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

extension Inspector2ClientTypes {
    public enum Currency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case usd
        case sdkUnknown(Swift.String)

        public static var allCases: [Currency] {
            return [
                .usd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .usd: return "USD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Currency(rawValue: rawValue) ?? Currency.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.CvssScore: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseScore
        case scoringVector
        case source
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseScore = baseScore {
            try encodeContainer.encode(baseScore, forKey: .baseScore)
        }
        if let scoringVector = scoringVector {
            try encodeContainer.encode(scoringVector, forKey: .scoringVector)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .baseScore)
        baseScore = baseScoreDecoded
        let scoringVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scoringVector)
        scoringVector = scoringVectorDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension Inspector2ClientTypes {
    /// The CVSS score for a finding.
    public struct CvssScore: Swift.Equatable {
        /// The base CVSS score used for the finding.
        /// This member is required.
        public var baseScore: Swift.Double?
        /// The vector string of the CVSS score.
        /// This member is required.
        public var scoringVector: Swift.String?
        /// The source of the CVSS score.
        /// This member is required.
        public var source: Swift.String?
        /// The version of CVSS used for the score.
        /// This member is required.
        public var version: Swift.String?

        public init (
            baseScore: Swift.Double? = nil,
            scoringVector: Swift.String? = nil,
            source: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.baseScore = baseScore
            self.scoringVector = scoringVector
            self.source = source
            self.version = version
        }
    }

}

extension Inspector2ClientTypes.CvssScoreAdjustment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metric
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details on adjustments Amazon Inspector made to the CVSS score for a finding.
    public struct CvssScoreAdjustment: Swift.Equatable {
        /// The metric used to adjust the CVSS score.
        /// This member is required.
        public var metric: Swift.String?
        /// The reason the CVSS score has been adjustment.
        /// This member is required.
        public var reason: Swift.String?

        public init (
            metric: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.metric = metric
            self.reason = reason
        }
    }

}

extension Inspector2ClientTypes.CvssScoreDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adjustments
        case cvssSource
        case score
        case scoreSource
        case scoringVector
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adjustments = adjustments {
            var adjustmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adjustments)
            for cvssscoreadjustmentlist0 in adjustments {
                try adjustmentsContainer.encode(cvssscoreadjustmentlist0)
            }
        }
        if let cvssSource = cvssSource {
            try encodeContainer.encode(cvssSource, forKey: .cvssSource)
        }
        if let score = score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let scoreSource = scoreSource {
            try encodeContainer.encode(scoreSource, forKey: .scoreSource)
        }
        if let scoringVector = scoringVector {
            try encodeContainer.encode(scoringVector, forKey: .scoringVector)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scoreSource)
        scoreSource = scoreSourceDecoded
        let cvssSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cvssSource)
        cvssSource = cvssSourceDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .score)
        score = scoreDecoded
        let scoringVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scoringVector)
        scoringVector = scoringVectorDecoded
        let adjustmentsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CvssScoreAdjustment?].self, forKey: .adjustments)
        var adjustmentsDecoded0:[Inspector2ClientTypes.CvssScoreAdjustment]? = nil
        if let adjustmentsContainer = adjustmentsContainer {
            adjustmentsDecoded0 = [Inspector2ClientTypes.CvssScoreAdjustment]()
            for structure0 in adjustmentsContainer {
                if let structure0 = structure0 {
                    adjustmentsDecoded0?.append(structure0)
                }
            }
        }
        adjustments = adjustmentsDecoded0
    }
}

extension Inspector2ClientTypes {
    /// Information about the CVSS score.
    public struct CvssScoreDetails: Swift.Equatable {
        /// An object that contains details about adjustment Amazon Inspector made to the CVSS score.
        public var adjustments: [Inspector2ClientTypes.CvssScoreAdjustment]?
        /// The source of the CVSS data.
        public var cvssSource: Swift.String?
        /// The CVSS score.
        /// This member is required.
        public var score: Swift.Double?
        /// The source for the CVSS score.
        /// This member is required.
        public var scoreSource: Swift.String?
        /// The vector for the CVSS score.
        /// This member is required.
        public var scoringVector: Swift.String?
        /// The CVSS version used in scoring.
        /// This member is required.
        public var version: Swift.String?

        public init (
            adjustments: [Inspector2ClientTypes.CvssScoreAdjustment]? = nil,
            cvssSource: Swift.String? = nil,
            score: Swift.Double? = nil,
            scoreSource: Swift.String? = nil,
            scoringVector: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.adjustments = adjustments
            self.cvssSource = cvssSource
            self.score = score
            self.scoreSource = scoreSource
            self.scoringVector = scoringVector
            self.version = version
        }
    }

}

extension Inspector2ClientTypes.DateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endInclusive
        case startInclusive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endInclusive = endInclusive {
            try encodeContainer.encode(endInclusive.timeIntervalSince1970, forKey: .endInclusive)
        }
        if let startInclusive = startInclusive {
            try encodeContainer.encode(startInclusive.timeIntervalSince1970, forKey: .startInclusive)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startInclusiveDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startInclusive)
        startInclusive = startInclusiveDecoded
        let endInclusiveDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endInclusive)
        endInclusive = endInclusiveDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains details on the time range used to filter findings.
    public struct DateFilter: Swift.Equatable {
        /// A timestamp representing the end of the time period filtered on.
        public var endInclusive: ClientRuntime.Date?
        /// A timestamp representing the start of the time period filtered on.
        public var startInclusive: ClientRuntime.Date?

        public init (
            endInclusive: ClientRuntime.Date? = nil,
            startInclusive: ClientRuntime.Date? = nil
        )
        {
            self.endInclusive = endInclusive
            self.startInclusive = startInclusive
        }
    }

}

extension Inspector2ClientTypes.DelegatedAdmin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case relationshipStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let relationshipStatus = relationshipStatus {
            try encodeContainer.encode(relationshipStatus.rawValue, forKey: .relationshipStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.RelationshipStatus.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details of the Amazon Inspector delegated administrator for your organization.
    public struct DelegatedAdmin: Swift.Equatable {
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator for your organization.
        public var accountId: Swift.String?
        /// The status of the Amazon Inspector delegated administrator.
        public var relationshipStatus: Inspector2ClientTypes.RelationshipStatus?

        public init (
            accountId: Swift.String? = nil,
            relationshipStatus: Inspector2ClientTypes.RelationshipStatus? = nil
        )
        {
            self.accountId = accountId
            self.relationshipStatus = relationshipStatus
        }
    }

}

extension Inspector2ClientTypes.DelegatedAdminAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.DelegatedAdminStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details of the Amazon Inspector delegated administrator for your organization.
    public struct DelegatedAdminAccount: Swift.Equatable {
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator for your organization.
        public var accountId: Swift.String?
        /// The status of the Amazon Inspector delegated administrator.
        public var status: Inspector2ClientTypes.DelegatedAdminStatus?

        public init (
            accountId: Swift.String? = nil,
            status: Inspector2ClientTypes.DelegatedAdminStatus? = nil
        )
        {
            self.accountId = accountId
            self.status = status
        }
    }

}

extension Inspector2ClientTypes {
    public enum DelegatedAdminStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disableInProgress
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DelegatedAdminStatus] {
            return [
                .disableInProgress,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disableInProgress: return "DISABLE_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DelegatedAdminStatus(rawValue: rawValue) ?? DelegatedAdminStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeleteFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/filters/delete"
    }
}

public struct DeleteFilterInput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the filter to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteFilterInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteFilterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFilterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFilterOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFilterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteFilterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct DeleteFilterOutputResponse: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the filter that has been deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteFilterOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteFilterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DescribeOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organizationconfiguration/describe"
    }
}

public struct DescribeOrganizationConfigurationInput: Swift.Equatable {

}

struct DescribeOrganizationConfigurationInputBody: Swift.Equatable {
}

extension DescribeOrganizationConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeOrganizationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrganizationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOrganizationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoEnable = output.autoEnable
            self.maxAccountLimitReached = output.maxAccountLimitReached
        } else {
            self.autoEnable = nil
            self.maxAccountLimitReached = nil
        }
    }
}

public struct DescribeOrganizationConfigurationOutputResponse: Swift.Equatable {
    /// The scan types are automatically enabled for new members of your organization.
    public var autoEnable: Inspector2ClientTypes.AutoEnable?
    /// Represents whether your organization has reached the maximum Amazon Web Services account limit for Amazon Inspector.
    public var maxAccountLimitReached: Swift.Bool?

    public init (
        autoEnable: Inspector2ClientTypes.AutoEnable? = nil,
        maxAccountLimitReached: Swift.Bool? = nil
    )
    {
        self.autoEnable = autoEnable
        self.maxAccountLimitReached = maxAccountLimitReached
    }
}

struct DescribeOrganizationConfigurationOutputResponseBody: Swift.Equatable {
    let autoEnable: Inspector2ClientTypes.AutoEnable?
    let maxAccountLimitReached: Swift.Bool?
}

extension DescribeOrganizationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable
        case maxAccountLimitReached
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AutoEnable.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
        let maxAccountLimitReachedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .maxAccountLimitReached)
        maxAccountLimitReached = maxAccountLimitReachedDecoded
    }
}

extension Inspector2ClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case keyPrefix
        case kmsKeyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let keyPrefix = keyPrefix {
            try encodeContainer.encode(keyPrefix, forKey: .keyPrefix)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let keyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPrefix)
        keyPrefix = keyPrefixDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains details of the Amazon S3 bucket and KMS key used to export findings.
    public struct Destination: Swift.Equatable {
        /// The name of the Amazon S3 bucket to export findings to.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The prefix of the KMS key used to export findings.
        public var keyPrefix: Swift.String?
        /// The ARN of the KMS key used to encrypt data when exporting findings.
        /// This member is required.
        public var kmsKeyArn: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            keyPrefix: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.keyPrefix = keyPrefix
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

extension DisableDelegatedAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdminAccountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delegatedAdminAccountId = delegatedAdminAccountId {
            try encodeContainer.encode(delegatedAdminAccountId, forKey: .delegatedAdminAccountId)
        }
    }
}

extension DisableDelegatedAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delegatedadminaccounts/disable"
    }
}

public struct DisableDelegatedAdminAccountInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the current Amazon Inspector delegated administrator.
    /// This member is required.
    public var delegatedAdminAccountId: Swift.String?

    public init (
        delegatedAdminAccountId: Swift.String? = nil
    )
    {
        self.delegatedAdminAccountId = delegatedAdminAccountId
    }
}

struct DisableDelegatedAdminAccountInputBody: Swift.Equatable {
    let delegatedAdminAccountId: Swift.String?
}

extension DisableDelegatedAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdminAccountId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegatedAdminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delegatedAdminAccountId)
        delegatedAdminAccountId = delegatedAdminAccountIdDecoded
    }
}

extension DisableDelegatedAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableDelegatedAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableDelegatedAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableDelegatedAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisableDelegatedAdminAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.delegatedAdminAccountId = output.delegatedAdminAccountId
        } else {
            self.delegatedAdminAccountId = nil
        }
    }
}

public struct DisableDelegatedAdminAccountOutputResponse: Swift.Equatable {
    /// The Amazon Web Services account ID of the successfully disabled delegated administrator.
    /// This member is required.
    public var delegatedAdminAccountId: Swift.String?

    public init (
        delegatedAdminAccountId: Swift.String? = nil
    )
    {
        self.delegatedAdminAccountId = delegatedAdminAccountId
    }
}

struct DisableDelegatedAdminAccountOutputResponseBody: Swift.Equatable {
    let delegatedAdminAccountId: Swift.String?
}

extension DisableDelegatedAdminAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdminAccountId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegatedAdminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delegatedAdminAccountId)
        delegatedAdminAccountId = delegatedAdminAccountIdDecoded
    }
}

extension DisableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case resourceTypes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountidset0 in accountIds {
                try accountIdsContainer.encode(accountidset0)
            }
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for disableresourcetypelist0 in resourceTypes {
                try resourceTypesContainer.encode(disableresourcetypelist0.rawValue)
            }
        }
    }
}

extension DisableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/disable"
    }
}

public struct DisableInput: Swift.Equatable {
    /// An array of account IDs you want to disable Amazon Inspector scans for.
    public var accountIds: Swift.Set<Swift.String>?
    /// The resource scan types you want to disable.
    public var resourceTypes: [Inspector2ClientTypes.ResourceScanType]?

    public init (
        accountIds: Swift.Set<Swift.String>? = nil,
        resourceTypes: [Inspector2ClientTypes.ResourceScanType]? = nil
    )
    {
        self.accountIds = accountIds
        self.resourceTypes = resourceTypes
    }
}

struct DisableInputBody: Swift.Equatable {
    let accountIds: Swift.Set<Swift.String>?
    let resourceTypes: [Inspector2ClientTypes.ResourceScanType]?
}

extension DisableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case resourceTypes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent(Swift.Set<Swift.String>.self, forKey: .accountIds)
        var accountIdsDecoded0:Swift.Set<Swift.String>? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = Swift.Set<Swift.String>()
            for string0 in accountIdsContainer {
                accountIdsDecoded0?.insert(string0)
            }
        }
        accountIds = accountIdsDecoded0
        let resourceTypesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.ResourceScanType?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Inspector2ClientTypes.ResourceScanType]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Inspector2ClientTypes.ResourceScanType]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
    }
}

extension DisableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisableOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accounts = output.accounts
            self.failedAccounts = output.failedAccounts
        } else {
            self.accounts = nil
            self.failedAccounts = nil
        }
    }
}

public struct DisableOutputResponse: Swift.Equatable {
    /// Information on the accounts that have had Amazon Inspector scans successfully disabled. Details are provided for each account.
    /// This member is required.
    public var accounts: [Inspector2ClientTypes.Account]?
    /// Information on any accounts for which Amazon Inspector scans could not be disabled. Details are provided for each account.
    public var failedAccounts: [Inspector2ClientTypes.FailedAccount]?

    public init (
        accounts: [Inspector2ClientTypes.Account]? = nil,
        failedAccounts: [Inspector2ClientTypes.FailedAccount]? = nil
    )
    {
        self.accounts = accounts
        self.failedAccounts = failedAccounts
    }
}

struct DisableOutputResponseBody: Swift.Equatable {
    let accounts: [Inspector2ClientTypes.Account]?
    let failedAccounts: [Inspector2ClientTypes.FailedAccount]?
}

extension DisableOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts
        case failedAccounts
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Account?].self, forKey: .accounts)
        var accountsDecoded0:[Inspector2ClientTypes.Account]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [Inspector2ClientTypes.Account]()
            for structure0 in accountsContainer {
                if let structure0 = structure0 {
                    accountsDecoded0?.append(structure0)
                }
            }
        }
        accounts = accountsDecoded0
        let failedAccountsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.FailedAccount?].self, forKey: .failedAccounts)
        var failedAccountsDecoded0:[Inspector2ClientTypes.FailedAccount]? = nil
        if let failedAccountsContainer = failedAccountsContainer {
            failedAccountsDecoded0 = [Inspector2ClientTypes.FailedAccount]()
            for structure0 in failedAccountsContainer {
                if let structure0 = structure0 {
                    failedAccountsDecoded0?.append(structure0)
                }
            }
        }
        failedAccounts = failedAccountsDecoded0
    }
}

extension DisassociateMemberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }
}

extension DisassociateMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/members/disassociate"
    }
}

public struct DisassociateMemberInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the member account to disassociate.
    /// This member is required.
    public var accountId: Swift.String?

    public init (
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct DisassociateMemberInputBody: Swift.Equatable {
    let accountId: Swift.String?
}

extension DisassociateMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension DisassociateMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateMemberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateMemberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
        } else {
            self.accountId = nil
        }
    }
}

public struct DisassociateMemberOutputResponse: Swift.Equatable {
    /// The Amazon Web Services account ID of the successfully disassociated member.
    /// This member is required.
    public var accountId: Swift.String?

    public init (
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct DisassociateMemberOutputResponseBody: Swift.Equatable {
    let accountId: Swift.String?
}

extension DisassociateMemberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension Inspector2ClientTypes.Ec2InstanceAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amis
        case instanceIds
        case instanceTags
        case operatingSystems
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amis = amis {
            var amisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .amis)
            for stringfilterlist0 in amis {
                try amisContainer.encode(stringfilterlist0)
            }
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for stringfilterlist0 in instanceIds {
                try instanceIdsContainer.encode(stringfilterlist0)
            }
        }
        if let instanceTags = instanceTags {
            var instanceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTags)
            for mapfilterlist0 in instanceTags {
                try instanceTagsContainer.encode(mapfilterlist0)
            }
        }
        if let operatingSystems = operatingSystems {
            var operatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operatingSystems)
            for stringfilterlist0 in operatingSystems {
                try operatingSystemsContainer.encode(stringfilterlist0)
            }
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amisContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .amis)
        var amisDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let amisContainer = amisContainer {
            amisDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in amisContainer {
                if let structure0 = structure0 {
                    amisDecoded0?.append(structure0)
                }
            }
        }
        amis = amisDecoded0
        let operatingSystemsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .operatingSystems)
        var operatingSystemsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let operatingSystemsContainer = operatingSystemsContainer {
            operatingSystemsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in operatingSystemsContainer {
                if let structure0 = structure0 {
                    operatingSystemsDecoded0?.append(structure0)
                }
            }
        }
        operatingSystems = operatingSystemsDecoded0
        let instanceIdsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in instanceIdsContainer {
                if let structure0 = structure0 {
                    instanceIdsDecoded0?.append(structure0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
        let instanceTagsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.MapFilter?].self, forKey: .instanceTags)
        var instanceTagsDecoded0:[Inspector2ClientTypes.MapFilter]? = nil
        if let instanceTagsContainer = instanceTagsContainer {
            instanceTagsDecoded0 = [Inspector2ClientTypes.MapFilter]()
            for structure0 in instanceTagsContainer {
                if let structure0 = structure0 {
                    instanceTagsDecoded0?.append(structure0)
                }
            }
        }
        instanceTags = instanceTagsDecoded0
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Ec2InstanceSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on Amazon EC2 instances.
    public struct Ec2InstanceAggregation: Swift.Equatable {
        /// The AMI IDs associated with the Amazon EC2 instances to aggregate findings for.
        public var amis: [Inspector2ClientTypes.StringFilter]?
        /// The Amazon EC2 instance IDs to aggregate findings for.
        public var instanceIds: [Inspector2ClientTypes.StringFilter]?
        /// The Amazon EC2 instance tags to aggregate findings for.
        public var instanceTags: [Inspector2ClientTypes.MapFilter]?
        /// The operating system types to aggregate findings for. Valid values must be uppercase and underscore separated, examples are ORACLE_LINUX_7 and ALPINE_LINUX_3_8.
        public var operatingSystems: [Inspector2ClientTypes.StringFilter]?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.Ec2InstanceSortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init (
            amis: [Inspector2ClientTypes.StringFilter]? = nil,
            instanceIds: [Inspector2ClientTypes.StringFilter]? = nil,
            instanceTags: [Inspector2ClientTypes.MapFilter]? = nil,
            operatingSystems: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.Ec2InstanceSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.amis = amis
            self.instanceIds = instanceIds
            self.instanceTags = instanceTags
            self.operatingSystems = operatingSystems
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes.Ec2InstanceAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case ami
        case instanceId
        case instanceTags
        case networkFindings
        case operatingSystem
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let ami = ami {
            try encodeContainer.encode(ami, forKey: .ami)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceTags = instanceTags {
            var instanceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .instanceTags)
            for (dictKey0, tagmap0) in instanceTags {
                try instanceTagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let networkFindings = networkFindings {
            try encodeContainer.encode(networkFindings, forKey: .networkFindings)
        }
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem, forKey: .operatingSystem)
        }
        if let severityCounts = severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let amiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ami)
        ami = amiDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let instanceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .instanceTags)
        var instanceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let instanceTagsContainer = instanceTagsContainer {
            instanceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, mapvalue0) in instanceTagsContainer {
                if let mapvalue0 = mapvalue0 {
                    instanceTagsDecoded0?[key0] = mapvalue0
                }
            }
        }
        instanceTags = instanceTagsDecoded0
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
        let networkFindingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .networkFindings)
        networkFindings = networkFindingsDecoded
    }
}

extension Inspector2ClientTypes {
    /// A response that contains the results of a finding aggregation by Amazon EC2 instance.
    public struct Ec2InstanceAggregationResponse: Swift.Equatable {
        /// The Amazon Web Services account the Amazon EC2 instance belongs to.
        public var accountId: Swift.String?
        /// The Amazon Machine Image (AMI) of the Amazon EC2 instance.
        public var ami: Swift.String?
        /// The Amazon EC2 instance ID.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The tags attached to the instance.
        public var instanceTags: [Swift.String:Swift.String]?
        /// The number of network findings for the Amazon EC2 instance.
        public var networkFindings: Swift.Int?
        /// The operating system of the Amazon EC2 instance.
        public var operatingSystem: Swift.String?
        /// An object that contains the count of matched findings per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init (
            accountId: Swift.String? = nil,
            ami: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceTags: [Swift.String:Swift.String]? = nil,
            networkFindings: Swift.Int? = nil,
            operatingSystem: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.ami = ami
            self.instanceId = instanceId
            self.instanceTags = instanceTags
            self.networkFindings = networkFindings
            self.operatingSystem = operatingSystem
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    public enum Ec2InstanceSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case critical
        case high
        case networkFindings
        case sdkUnknown(Swift.String)

        public static var allCases: [Ec2InstanceSortBy] {
            return [
                .all,
                .critical,
                .high,
                .networkFindings,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .networkFindings: return "NETWORK_FINDINGS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Ec2InstanceSortBy(rawValue: rawValue) ?? Ec2InstanceSortBy.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.Ec2Metadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiId
        case platform
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiId = amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, mapvalue0) in tagsContainer {
                if let mapvalue0 = mapvalue0 {
                    tagsDecoded0?[key0] = mapvalue0
                }
            }
        }
        tags = tagsDecoded0
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Ec2Platform.self, forKey: .platform)
        platform = platformDecoded
    }
}

extension Inspector2ClientTypes {
    /// Meta data details of an Amazon EC2 instance.
    public struct Ec2Metadata: Swift.Equatable {
        /// The ID of the Amazon Machine Image (AMI) used to launch the instance.
        public var amiId: Swift.String?
        /// The platform of the instance.
        public var platform: Inspector2ClientTypes.Ec2Platform?
        /// The tags attached to the instance.
        public var tags: [Swift.String:Swift.String]?

        public init (
            amiId: Swift.String? = nil,
            platform: Inspector2ClientTypes.Ec2Platform? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.amiId = amiId
            self.platform = platform
            self.tags = tags
        }
    }

}

extension Inspector2ClientTypes {
    public enum Ec2Platform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case unknown
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [Ec2Platform] {
            return [
                .linux,
                .unknown,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .unknown: return "UNKNOWN"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Ec2Platform(rawValue: rawValue) ?? Ec2Platform.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.EcrContainerImageMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tags)
        var tagsDecoded0:[Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String]()
            for string0 in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?.append(string0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Inspector2ClientTypes {
    /// Information on the Amazon ECR image metadata associated with a finding.
    public struct EcrContainerImageMetadata: Swift.Equatable {
        /// Tags associated with the Amazon ECR image metadata.
        public var tags: [Swift.String]?

        public init (
            tags: [Swift.String]? = nil
        )
        {
            self.tags = tags
        }
    }

}

extension Inspector2ClientTypes.EcrRepositoryMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case scanFrequency
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scanFrequency = scanFrequency {
            try encodeContainer.encode(scanFrequency.rawValue, forKey: .scanFrequency)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let scanFrequencyDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.EcrScanFrequency.self, forKey: .scanFrequency)
        scanFrequency = scanFrequencyDecoded
    }
}

extension Inspector2ClientTypes {
    /// Information on the Amazon ECR repository metadata associated with a finding.
    public struct EcrRepositoryMetadata: Swift.Equatable {
        /// The name of the Amazon ECR repository.
        public var name: Swift.String?
        /// The frequency of scans.
        public var scanFrequency: Inspector2ClientTypes.EcrScanFrequency?

        public init (
            name: Swift.String? = nil,
            scanFrequency: Inspector2ClientTypes.EcrScanFrequency? = nil
        )
        {
            self.name = name
            self.scanFrequency = scanFrequency
        }
    }

}

extension Inspector2ClientTypes {
    public enum EcrScanFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case continuousScan
        case manual
        case scanOnPush
        case sdkUnknown(Swift.String)

        public static var allCases: [EcrScanFrequency] {
            return [
                .continuousScan,
                .manual,
                .scanOnPush,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .continuousScan: return "CONTINUOUS_SCAN"
            case .manual: return "MANUAL"
            case .scanOnPush: return "SCAN_ON_PUSH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EcrScanFrequency(rawValue: rawValue) ?? EcrScanFrequency.sdkUnknown(rawValue)
        }
    }
}

extension EnableDelegatedAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case delegatedAdminAccountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let delegatedAdminAccountId = delegatedAdminAccountId {
            try encodeContainer.encode(delegatedAdminAccountId, forKey: .delegatedAdminAccountId)
        }
    }
}

extension EnableDelegatedAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delegatedadminaccounts/enable"
    }
}

public struct EnableDelegatedAdminAccountInput: Swift.Equatable {
    /// The idempotency token for the request.
    public var clientToken: Swift.String?
    /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator.
    /// This member is required.
    public var delegatedAdminAccountId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        delegatedAdminAccountId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.delegatedAdminAccountId = delegatedAdminAccountId
    }
}

struct EnableDelegatedAdminAccountInputBody: Swift.Equatable {
    let delegatedAdminAccountId: Swift.String?
    let clientToken: Swift.String?
}

extension EnableDelegatedAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case delegatedAdminAccountId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegatedAdminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delegatedAdminAccountId)
        delegatedAdminAccountId = delegatedAdminAccountIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension EnableDelegatedAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableDelegatedAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableDelegatedAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableDelegatedAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EnableDelegatedAdminAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.delegatedAdminAccountId = output.delegatedAdminAccountId
        } else {
            self.delegatedAdminAccountId = nil
        }
    }
}

public struct EnableDelegatedAdminAccountOutputResponse: Swift.Equatable {
    /// The Amazon Web Services account ID of the successfully Amazon Inspector delegated administrator.
    /// This member is required.
    public var delegatedAdminAccountId: Swift.String?

    public init (
        delegatedAdminAccountId: Swift.String? = nil
    )
    {
        self.delegatedAdminAccountId = delegatedAdminAccountId
    }
}

struct EnableDelegatedAdminAccountOutputResponseBody: Swift.Equatable {
    let delegatedAdminAccountId: Swift.String?
}

extension EnableDelegatedAdminAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdminAccountId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegatedAdminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delegatedAdminAccountId)
        delegatedAdminAccountId = delegatedAdminAccountIdDecoded
    }
}

extension EnableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case clientToken
        case resourceTypes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountidset0 in accountIds {
                try accountIdsContainer.encode(accountidset0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for enableresourcetypelist0 in resourceTypes {
                try resourceTypesContainer.encode(enableresourcetypelist0.rawValue)
            }
        }
    }
}

extension EnableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/enable"
    }
}

public struct EnableInput: Swift.Equatable {
    /// A list of account IDs you want to enable Amazon Inspector scans for.
    public var accountIds: Swift.Set<Swift.String>?
    /// The idempotency token for the request.
    public var clientToken: Swift.String?
    /// The resource scan types you want to enable.
    /// This member is required.
    public var resourceTypes: [Inspector2ClientTypes.ResourceScanType]?

    public init (
        accountIds: Swift.Set<Swift.String>? = nil,
        clientToken: Swift.String? = nil,
        resourceTypes: [Inspector2ClientTypes.ResourceScanType]? = nil
    )
    {
        self.accountIds = accountIds
        self.clientToken = clientToken
        self.resourceTypes = resourceTypes
    }
}

struct EnableInputBody: Swift.Equatable {
    let accountIds: Swift.Set<Swift.String>?
    let resourceTypes: [Inspector2ClientTypes.ResourceScanType]?
    let clientToken: Swift.String?
}

extension EnableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case clientToken
        case resourceTypes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent(Swift.Set<Swift.String>.self, forKey: .accountIds)
        var accountIdsDecoded0:Swift.Set<Swift.String>? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = Swift.Set<Swift.String>()
            for string0 in accountIdsContainer {
                accountIdsDecoded0?.insert(string0)
            }
        }
        accountIds = accountIdsDecoded0
        let resourceTypesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.ResourceScanType?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Inspector2ClientTypes.ResourceScanType]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Inspector2ClientTypes.ResourceScanType]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension EnableOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EnableOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accounts = output.accounts
            self.failedAccounts = output.failedAccounts
        } else {
            self.accounts = nil
            self.failedAccounts = nil
        }
    }
}

public struct EnableOutputResponse: Swift.Equatable {
    /// Information on the accounts that have had Amazon Inspector scans successfully enabled. Details are provided for each account.
    /// This member is required.
    public var accounts: [Inspector2ClientTypes.Account]?
    /// Information on any accounts for which Amazon Inspector scans could not be enabled. Details are provided for each account.
    public var failedAccounts: [Inspector2ClientTypes.FailedAccount]?

    public init (
        accounts: [Inspector2ClientTypes.Account]? = nil,
        failedAccounts: [Inspector2ClientTypes.FailedAccount]? = nil
    )
    {
        self.accounts = accounts
        self.failedAccounts = failedAccounts
    }
}

struct EnableOutputResponseBody: Swift.Equatable {
    let accounts: [Inspector2ClientTypes.Account]?
    let failedAccounts: [Inspector2ClientTypes.FailedAccount]?
}

extension EnableOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts
        case failedAccounts
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Account?].self, forKey: .accounts)
        var accountsDecoded0:[Inspector2ClientTypes.Account]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [Inspector2ClientTypes.Account]()
            for structure0 in accountsContainer {
                if let structure0 = structure0 {
                    accountsDecoded0?.append(structure0)
                }
            }
        }
        accounts = accountsDecoded0
        let failedAccountsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.FailedAccount?].self, forKey: .failedAccounts)
        var failedAccountsDecoded0:[Inspector2ClientTypes.FailedAccount]? = nil
        if let failedAccountsContainer = failedAccountsContainer {
            failedAccountsDecoded0 = [Inspector2ClientTypes.FailedAccount]()
            for structure0 in failedAccountsContainer {
                if let structure0 = structure0 {
                    failedAccountsDecoded0?.append(structure0)
                }
            }
        }
        failedAccounts = failedAccountsDecoded0
    }
}

extension Inspector2ClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case alreadyEnabled
        case disableInProgress
        case disassociateAllMembers
        case enableInProgress
        case eventbridgeThrottled
        case eventbridgeUnavailable
        case internalError
        case resourceNotFound
        case resourceScanNotDisabled
        case ssmThrottled
        case ssmUnavailable
        case suspendInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessDenied,
                .alreadyEnabled,
                .disableInProgress,
                .disassociateAllMembers,
                .enableInProgress,
                .eventbridgeThrottled,
                .eventbridgeUnavailable,
                .internalError,
                .resourceNotFound,
                .resourceScanNotDisabled,
                .ssmThrottled,
                .ssmUnavailable,
                .suspendInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .alreadyEnabled: return "ALREADY_ENABLED"
            case .disableInProgress: return "DISABLE_IN_PROGRESS"
            case .disassociateAllMembers: return "DISASSOCIATE_ALL_MEMBERS"
            case .enableInProgress: return "ENABLE_IN_PROGRESS"
            case .eventbridgeThrottled: return "EVENTBRIDGE_THROTTLED"
            case .eventbridgeUnavailable: return "EVENTBRIDGE_UNAVAILABLE"
            case .internalError: return "INTERNAL_ERROR"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case .resourceScanNotDisabled: return "RESOURCE_SCAN_NOT_DISABLED"
            case .ssmThrottled: return "SSM_THROTTLED"
            case .ssmUnavailable: return "SSM_UNAVAILABLE"
            case .suspendInProgress: return "SUSPEND_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum ExternalReportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ExternalReportStatus] {
            return [
                .cancelled,
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExternalReportStatus(rawValue: rawValue) ?? ExternalReportStatus.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.FailedAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case errorCode
        case errorMessage
        case resourceStatus
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let resourceStatus = resourceStatus {
            try encodeContainer.encode(resourceStatus, forKey: .resourceStatus)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let resourceStatusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ResourceStatus.self, forKey: .resourceStatus)
        resourceStatus = resourceStatusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object with details on why an account failed to enable Amazon Inspector.
    public struct FailedAccount: Swift.Equatable {
        /// The Amazon Web Services account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// The error code explaining why the account failed to enable Amazon Inspector.
        /// This member is required.
        public var errorCode: Inspector2ClientTypes.ErrorCode?
        /// The error message received when the account failed to enable Amazon Inspector.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// An object detailing which resources Amazon Inspector is enabled to scan for the account.
        public var resourceStatus: Inspector2ClientTypes.ResourceStatus?
        /// The status of Amazon Inspector for the account.
        public var status: Inspector2ClientTypes.Status?

        public init (
            accountId: Swift.String? = nil,
            errorCode: Inspector2ClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            resourceStatus: Inspector2ClientTypes.ResourceStatus? = nil,
            status: Inspector2ClientTypes.Status? = nil
        )
        {
            self.accountId = accountId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.resourceStatus = resourceStatus
            self.status = status
        }
    }

}

extension Inspector2ClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case arn
        case createdAt
        case criteria
        case description
        case name
        case ownerId
        case reason
        case tags
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let criteria = criteria {
            try encodeContainer.encode(criteria, forKey: .criteria)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerId = ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let criteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterCriteria.self, forKey: .criteria)
        criteria = criteriaDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterAction.self, forKey: .action)
        action = actionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, mapvalue0) in tagsContainer {
                if let mapvalue0 = mapvalue0 {
                    tagsDecoded0?[key0] = mapvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Inspector2ClientTypes {
    /// Details about a filter.
    public struct Filter: Swift.Equatable {
        /// The action that is to be applied to the findings that match the filter.
        /// This member is required.
        public var action: Inspector2ClientTypes.FilterAction?
        /// The Amazon Resource Number (ARN) associated with this filter.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time this filter was created at.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Details on the filter criteria associated with this filter.
        /// This member is required.
        public var criteria: Inspector2ClientTypes.FilterCriteria?
        /// A description of the filter.
        public var description: Swift.String?
        /// The name of the filter.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Web Services account ID of the account that created the filter.
        /// This member is required.
        public var ownerId: Swift.String?
        /// The reason for the filter.
        public var reason: Swift.String?
        /// The tags attached to the filter.
        public var tags: [Swift.String:Swift.String]?
        /// The date and time the filter was last updated at.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            action: Inspector2ClientTypes.FilterAction? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            criteria: Inspector2ClientTypes.FilterCriteria? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            reason: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.action = action
            self.arn = arn
            self.createdAt = createdAt
            self.criteria = criteria
            self.description = description
            self.name = name
            self.ownerId = ownerId
            self.reason = reason
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }

}

extension Inspector2ClientTypes {
    public enum FilterAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case suppress
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterAction] {
            return [
                .none,
                .suppress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .suppress: return "SUPPRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterAction(rawValue: rawValue) ?? FilterAction.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.FilterCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case componentId
        case componentType
        case ec2InstanceImageId
        case ec2InstanceSubnetId
        case ec2InstanceVpcId
        case ecrImageArchitecture
        case ecrImageHash
        case ecrImagePushedAt
        case ecrImageRegistry
        case ecrImageRepositoryName
        case ecrImageTags
        case findingArn
        case findingStatus
        case findingType
        case firstObservedAt
        case inspectorScore
        case lastObservedAt
        case networkProtocol
        case portRange
        case relatedVulnerabilities
        case resourceId
        case resourceTags
        case resourceType
        case severity
        case title
        case updatedAt
        case vendorSeverity
        case vulnerabilityId
        case vulnerabilitySource
        case vulnerablePackages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = awsAccountId {
            var awsAccountIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsAccountId)
            for stringfilterlist0 in awsAccountId {
                try awsAccountIdContainer.encode(stringfilterlist0)
            }
        }
        if let componentId = componentId {
            var componentIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .componentId)
            for stringfilterlist0 in componentId {
                try componentIdContainer.encode(stringfilterlist0)
            }
        }
        if let componentType = componentType {
            var componentTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .componentType)
            for stringfilterlist0 in componentType {
                try componentTypeContainer.encode(stringfilterlist0)
            }
        }
        if let ec2InstanceImageId = ec2InstanceImageId {
            var ec2InstanceImageIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceImageId)
            for stringfilterlist0 in ec2InstanceImageId {
                try ec2InstanceImageIdContainer.encode(stringfilterlist0)
            }
        }
        if let ec2InstanceSubnetId = ec2InstanceSubnetId {
            var ec2InstanceSubnetIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceSubnetId)
            for stringfilterlist0 in ec2InstanceSubnetId {
                try ec2InstanceSubnetIdContainer.encode(stringfilterlist0)
            }
        }
        if let ec2InstanceVpcId = ec2InstanceVpcId {
            var ec2InstanceVpcIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceVpcId)
            for stringfilterlist0 in ec2InstanceVpcId {
                try ec2InstanceVpcIdContainer.encode(stringfilterlist0)
            }
        }
        if let ecrImageArchitecture = ecrImageArchitecture {
            var ecrImageArchitectureContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrImageArchitecture)
            for stringfilterlist0 in ecrImageArchitecture {
                try ecrImageArchitectureContainer.encode(stringfilterlist0)
            }
        }
        if let ecrImageHash = ecrImageHash {
            var ecrImageHashContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrImageHash)
            for stringfilterlist0 in ecrImageHash {
                try ecrImageHashContainer.encode(stringfilterlist0)
            }
        }
        if let ecrImagePushedAt = ecrImagePushedAt {
            var ecrImagePushedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrImagePushedAt)
            for datefilterlist0 in ecrImagePushedAt {
                try ecrImagePushedAtContainer.encode(datefilterlist0)
            }
        }
        if let ecrImageRegistry = ecrImageRegistry {
            var ecrImageRegistryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrImageRegistry)
            for stringfilterlist0 in ecrImageRegistry {
                try ecrImageRegistryContainer.encode(stringfilterlist0)
            }
        }
        if let ecrImageRepositoryName = ecrImageRepositoryName {
            var ecrImageRepositoryNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrImageRepositoryName)
            for stringfilterlist0 in ecrImageRepositoryName {
                try ecrImageRepositoryNameContainer.encode(stringfilterlist0)
            }
        }
        if let ecrImageTags = ecrImageTags {
            var ecrImageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrImageTags)
            for stringfilterlist0 in ecrImageTags {
                try ecrImageTagsContainer.encode(stringfilterlist0)
            }
        }
        if let findingArn = findingArn {
            var findingArnContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingArn)
            for stringfilterlist0 in findingArn {
                try findingArnContainer.encode(stringfilterlist0)
            }
        }
        if let findingStatus = findingStatus {
            var findingStatusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingStatus)
            for stringfilterlist0 in findingStatus {
                try findingStatusContainer.encode(stringfilterlist0)
            }
        }
        if let findingType = findingType {
            var findingTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingType)
            for stringfilterlist0 in findingType {
                try findingTypeContainer.encode(stringfilterlist0)
            }
        }
        if let firstObservedAt = firstObservedAt {
            var firstObservedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .firstObservedAt)
            for datefilterlist0 in firstObservedAt {
                try firstObservedAtContainer.encode(datefilterlist0)
            }
        }
        if let inspectorScore = inspectorScore {
            var inspectorScoreContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inspectorScore)
            for numberfilterlist0 in inspectorScore {
                try inspectorScoreContainer.encode(numberfilterlist0)
            }
        }
        if let lastObservedAt = lastObservedAt {
            var lastObservedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lastObservedAt)
            for datefilterlist0 in lastObservedAt {
                try lastObservedAtContainer.encode(datefilterlist0)
            }
        }
        if let networkProtocol = networkProtocol {
            var networkProtocolContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkProtocol)
            for stringfilterlist0 in networkProtocol {
                try networkProtocolContainer.encode(stringfilterlist0)
            }
        }
        if let portRange = portRange {
            var portRangeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRange)
            for portrangefilterlist0 in portRange {
                try portRangeContainer.encode(portrangefilterlist0)
            }
        }
        if let relatedVulnerabilities = relatedVulnerabilities {
            var relatedVulnerabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedVulnerabilities)
            for stringfilterlist0 in relatedVulnerabilities {
                try relatedVulnerabilitiesContainer.encode(stringfilterlist0)
            }
        }
        if let resourceId = resourceId {
            var resourceIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceId)
            for stringfilterlist0 in resourceId {
                try resourceIdContainer.encode(stringfilterlist0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for mapfilterlist0 in resourceTags {
                try resourceTagsContainer.encode(mapfilterlist0)
            }
        }
        if let resourceType = resourceType {
            var resourceTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceType)
            for stringfilterlist0 in resourceType {
                try resourceTypeContainer.encode(stringfilterlist0)
            }
        }
        if let severity = severity {
            var severityContainer = encodeContainer.nestedUnkeyedContainer(forKey: .severity)
            for stringfilterlist0 in severity {
                try severityContainer.encode(stringfilterlist0)
            }
        }
        if let title = title {
            var titleContainer = encodeContainer.nestedUnkeyedContainer(forKey: .title)
            for stringfilterlist0 in title {
                try titleContainer.encode(stringfilterlist0)
            }
        }
        if let updatedAt = updatedAt {
            var updatedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updatedAt)
            for datefilterlist0 in updatedAt {
                try updatedAtContainer.encode(datefilterlist0)
            }
        }
        if let vendorSeverity = vendorSeverity {
            var vendorSeverityContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vendorSeverity)
            for stringfilterlist0 in vendorSeverity {
                try vendorSeverityContainer.encode(stringfilterlist0)
            }
        }
        if let vulnerabilityId = vulnerabilityId {
            var vulnerabilityIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerabilityId)
            for stringfilterlist0 in vulnerabilityId {
                try vulnerabilityIdContainer.encode(stringfilterlist0)
            }
        }
        if let vulnerabilitySource = vulnerabilitySource {
            var vulnerabilitySourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerabilitySource)
            for stringfilterlist0 in vulnerabilitySource {
                try vulnerabilitySourceContainer.encode(stringfilterlist0)
            }
        }
        if let vulnerablePackages = vulnerablePackages {
            var vulnerablePackagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerablePackages)
            for packagefilterlist0 in vulnerablePackages {
                try vulnerablePackagesContainer.encode(packagefilterlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .findingArn)
        var findingArnDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let findingArnContainer = findingArnContainer {
            findingArnDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in findingArnContainer {
                if let structure0 = structure0 {
                    findingArnDecoded0?.append(structure0)
                }
            }
        }
        findingArn = findingArnDecoded0
        let awsAccountIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .awsAccountId)
        var awsAccountIdDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let awsAccountIdContainer = awsAccountIdContainer {
            awsAccountIdDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in awsAccountIdContainer {
                if let structure0 = structure0 {
                    awsAccountIdDecoded0?.append(structure0)
                }
            }
        }
        awsAccountId = awsAccountIdDecoded0
        let findingTypeContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .findingType)
        var findingTypeDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let findingTypeContainer = findingTypeContainer {
            findingTypeDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in findingTypeContainer {
                if let structure0 = structure0 {
                    findingTypeDecoded0?.append(structure0)
                }
            }
        }
        findingType = findingTypeDecoded0
        let severityContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .severity)
        var severityDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let severityContainer = severityContainer {
            severityDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in severityContainer {
                if let structure0 = structure0 {
                    severityDecoded0?.append(structure0)
                }
            }
        }
        severity = severityDecoded0
        let firstObservedAtContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.DateFilter?].self, forKey: .firstObservedAt)
        var firstObservedAtDecoded0:[Inspector2ClientTypes.DateFilter]? = nil
        if let firstObservedAtContainer = firstObservedAtContainer {
            firstObservedAtDecoded0 = [Inspector2ClientTypes.DateFilter]()
            for structure0 in firstObservedAtContainer {
                if let structure0 = structure0 {
                    firstObservedAtDecoded0?.append(structure0)
                }
            }
        }
        firstObservedAt = firstObservedAtDecoded0
        let lastObservedAtContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.DateFilter?].self, forKey: .lastObservedAt)
        var lastObservedAtDecoded0:[Inspector2ClientTypes.DateFilter]? = nil
        if let lastObservedAtContainer = lastObservedAtContainer {
            lastObservedAtDecoded0 = [Inspector2ClientTypes.DateFilter]()
            for structure0 in lastObservedAtContainer {
                if let structure0 = structure0 {
                    lastObservedAtDecoded0?.append(structure0)
                }
            }
        }
        lastObservedAt = lastObservedAtDecoded0
        let updatedAtContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.DateFilter?].self, forKey: .updatedAt)
        var updatedAtDecoded0:[Inspector2ClientTypes.DateFilter]? = nil
        if let updatedAtContainer = updatedAtContainer {
            updatedAtDecoded0 = [Inspector2ClientTypes.DateFilter]()
            for structure0 in updatedAtContainer {
                if let structure0 = structure0 {
                    updatedAtDecoded0?.append(structure0)
                }
            }
        }
        updatedAt = updatedAtDecoded0
        let findingStatusContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .findingStatus)
        var findingStatusDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let findingStatusContainer = findingStatusContainer {
            findingStatusDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in findingStatusContainer {
                if let structure0 = structure0 {
                    findingStatusDecoded0?.append(structure0)
                }
            }
        }
        findingStatus = findingStatusDecoded0
        let titleContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .title)
        var titleDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let titleContainer = titleContainer {
            titleDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in titleContainer {
                if let structure0 = structure0 {
                    titleDecoded0?.append(structure0)
                }
            }
        }
        title = titleDecoded0
        let inspectorScoreContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.NumberFilter?].self, forKey: .inspectorScore)
        var inspectorScoreDecoded0:[Inspector2ClientTypes.NumberFilter]? = nil
        if let inspectorScoreContainer = inspectorScoreContainer {
            inspectorScoreDecoded0 = [Inspector2ClientTypes.NumberFilter]()
            for structure0 in inspectorScoreContainer {
                if let structure0 = structure0 {
                    inspectorScoreDecoded0?.append(structure0)
                }
            }
        }
        inspectorScore = inspectorScoreDecoded0
        let resourceTypeContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .resourceType)
        var resourceTypeDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let resourceTypeContainer = resourceTypeContainer {
            resourceTypeDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in resourceTypeContainer {
                if let structure0 = structure0 {
                    resourceTypeDecoded0?.append(structure0)
                }
            }
        }
        resourceType = resourceTypeDecoded0
        let resourceIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .resourceId)
        var resourceIdDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let resourceIdContainer = resourceIdContainer {
            resourceIdDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in resourceIdContainer {
                if let structure0 = structure0 {
                    resourceIdDecoded0?.append(structure0)
                }
            }
        }
        resourceId = resourceIdDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.MapFilter?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[Inspector2ClientTypes.MapFilter]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Inspector2ClientTypes.MapFilter]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let ec2InstanceImageIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .ec2InstanceImageId)
        var ec2InstanceImageIdDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let ec2InstanceImageIdContainer = ec2InstanceImageIdContainer {
            ec2InstanceImageIdDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in ec2InstanceImageIdContainer {
                if let structure0 = structure0 {
                    ec2InstanceImageIdDecoded0?.append(structure0)
                }
            }
        }
        ec2InstanceImageId = ec2InstanceImageIdDecoded0
        let ec2InstanceVpcIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .ec2InstanceVpcId)
        var ec2InstanceVpcIdDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let ec2InstanceVpcIdContainer = ec2InstanceVpcIdContainer {
            ec2InstanceVpcIdDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in ec2InstanceVpcIdContainer {
                if let structure0 = structure0 {
                    ec2InstanceVpcIdDecoded0?.append(structure0)
                }
            }
        }
        ec2InstanceVpcId = ec2InstanceVpcIdDecoded0
        let ec2InstanceSubnetIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .ec2InstanceSubnetId)
        var ec2InstanceSubnetIdDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let ec2InstanceSubnetIdContainer = ec2InstanceSubnetIdContainer {
            ec2InstanceSubnetIdDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in ec2InstanceSubnetIdContainer {
                if let structure0 = structure0 {
                    ec2InstanceSubnetIdDecoded0?.append(structure0)
                }
            }
        }
        ec2InstanceSubnetId = ec2InstanceSubnetIdDecoded0
        let ecrImagePushedAtContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.DateFilter?].self, forKey: .ecrImagePushedAt)
        var ecrImagePushedAtDecoded0:[Inspector2ClientTypes.DateFilter]? = nil
        if let ecrImagePushedAtContainer = ecrImagePushedAtContainer {
            ecrImagePushedAtDecoded0 = [Inspector2ClientTypes.DateFilter]()
            for structure0 in ecrImagePushedAtContainer {
                if let structure0 = structure0 {
                    ecrImagePushedAtDecoded0?.append(structure0)
                }
            }
        }
        ecrImagePushedAt = ecrImagePushedAtDecoded0
        let ecrImageArchitectureContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .ecrImageArchitecture)
        var ecrImageArchitectureDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let ecrImageArchitectureContainer = ecrImageArchitectureContainer {
            ecrImageArchitectureDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in ecrImageArchitectureContainer {
                if let structure0 = structure0 {
                    ecrImageArchitectureDecoded0?.append(structure0)
                }
            }
        }
        ecrImageArchitecture = ecrImageArchitectureDecoded0
        let ecrImageRegistryContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .ecrImageRegistry)
        var ecrImageRegistryDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let ecrImageRegistryContainer = ecrImageRegistryContainer {
            ecrImageRegistryDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in ecrImageRegistryContainer {
                if let structure0 = structure0 {
                    ecrImageRegistryDecoded0?.append(structure0)
                }
            }
        }
        ecrImageRegistry = ecrImageRegistryDecoded0
        let ecrImageRepositoryNameContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .ecrImageRepositoryName)
        var ecrImageRepositoryNameDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let ecrImageRepositoryNameContainer = ecrImageRepositoryNameContainer {
            ecrImageRepositoryNameDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in ecrImageRepositoryNameContainer {
                if let structure0 = structure0 {
                    ecrImageRepositoryNameDecoded0?.append(structure0)
                }
            }
        }
        ecrImageRepositoryName = ecrImageRepositoryNameDecoded0
        let ecrImageTagsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .ecrImageTags)
        var ecrImageTagsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let ecrImageTagsContainer = ecrImageTagsContainer {
            ecrImageTagsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in ecrImageTagsContainer {
                if let structure0 = structure0 {
                    ecrImageTagsDecoded0?.append(structure0)
                }
            }
        }
        ecrImageTags = ecrImageTagsDecoded0
        let ecrImageHashContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .ecrImageHash)
        var ecrImageHashDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let ecrImageHashContainer = ecrImageHashContainer {
            ecrImageHashDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in ecrImageHashContainer {
                if let structure0 = structure0 {
                    ecrImageHashDecoded0?.append(structure0)
                }
            }
        }
        ecrImageHash = ecrImageHashDecoded0
        let portRangeContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.PortRangeFilter?].self, forKey: .portRange)
        var portRangeDecoded0:[Inspector2ClientTypes.PortRangeFilter]? = nil
        if let portRangeContainer = portRangeContainer {
            portRangeDecoded0 = [Inspector2ClientTypes.PortRangeFilter]()
            for structure0 in portRangeContainer {
                if let structure0 = structure0 {
                    portRangeDecoded0?.append(structure0)
                }
            }
        }
        portRange = portRangeDecoded0
        let networkProtocolContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .networkProtocol)
        var networkProtocolDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let networkProtocolContainer = networkProtocolContainer {
            networkProtocolDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in networkProtocolContainer {
                if let structure0 = structure0 {
                    networkProtocolDecoded0?.append(structure0)
                }
            }
        }
        networkProtocol = networkProtocolDecoded0
        let componentIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .componentId)
        var componentIdDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let componentIdContainer = componentIdContainer {
            componentIdDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in componentIdContainer {
                if let structure0 = structure0 {
                    componentIdDecoded0?.append(structure0)
                }
            }
        }
        componentId = componentIdDecoded0
        let componentTypeContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .componentType)
        var componentTypeDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let componentTypeContainer = componentTypeContainer {
            componentTypeDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in componentTypeContainer {
                if let structure0 = structure0 {
                    componentTypeDecoded0?.append(structure0)
                }
            }
        }
        componentType = componentTypeDecoded0
        let vulnerabilityIdContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .vulnerabilityId)
        var vulnerabilityIdDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let vulnerabilityIdContainer = vulnerabilityIdContainer {
            vulnerabilityIdDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in vulnerabilityIdContainer {
                if let structure0 = structure0 {
                    vulnerabilityIdDecoded0?.append(structure0)
                }
            }
        }
        vulnerabilityId = vulnerabilityIdDecoded0
        let vulnerabilitySourceContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .vulnerabilitySource)
        var vulnerabilitySourceDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let vulnerabilitySourceContainer = vulnerabilitySourceContainer {
            vulnerabilitySourceDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in vulnerabilitySourceContainer {
                if let structure0 = structure0 {
                    vulnerabilitySourceDecoded0?.append(structure0)
                }
            }
        }
        vulnerabilitySource = vulnerabilitySourceDecoded0
        let vendorSeverityContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .vendorSeverity)
        var vendorSeverityDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let vendorSeverityContainer = vendorSeverityContainer {
            vendorSeverityDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in vendorSeverityContainer {
                if let structure0 = structure0 {
                    vendorSeverityDecoded0?.append(structure0)
                }
            }
        }
        vendorSeverity = vendorSeverityDecoded0
        let vulnerablePackagesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.PackageFilter?].self, forKey: .vulnerablePackages)
        var vulnerablePackagesDecoded0:[Inspector2ClientTypes.PackageFilter]? = nil
        if let vulnerablePackagesContainer = vulnerablePackagesContainer {
            vulnerablePackagesDecoded0 = [Inspector2ClientTypes.PackageFilter]()
            for structure0 in vulnerablePackagesContainer {
                if let structure0 = structure0 {
                    vulnerablePackagesDecoded0?.append(structure0)
                }
            }
        }
        vulnerablePackages = vulnerablePackagesDecoded0
        let relatedVulnerabilitiesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .relatedVulnerabilities)
        var relatedVulnerabilitiesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let relatedVulnerabilitiesContainer = relatedVulnerabilitiesContainer {
            relatedVulnerabilitiesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in relatedVulnerabilitiesContainer {
                if let structure0 = structure0 {
                    relatedVulnerabilitiesDecoded0?.append(structure0)
                }
            }
        }
        relatedVulnerabilities = relatedVulnerabilitiesDecoded0
    }
}

extension Inspector2ClientTypes {
    /// Details on the criteria used to define the filter.
    public struct FilterCriteria: Swift.Equatable {
        /// Details of the Amazon Web Services account IDs used to filter findings.
        public var awsAccountId: [Inspector2ClientTypes.StringFilter]?
        /// Details of the component IDs used to filter findings.
        public var componentId: [Inspector2ClientTypes.StringFilter]?
        /// Details of the component types used to filter findings.
        public var componentType: [Inspector2ClientTypes.StringFilter]?
        /// Details of the Amazon EC2 instance image IDs used to filter findings.
        public var ec2InstanceImageId: [Inspector2ClientTypes.StringFilter]?
        /// Details of the Amazon EC2 instance subnet IDs used to filter findings.
        public var ec2InstanceSubnetId: [Inspector2ClientTypes.StringFilter]?
        /// Details of the Amazon EC2 instance VPC IDs used to filter findings.
        public var ec2InstanceVpcId: [Inspector2ClientTypes.StringFilter]?
        /// Details of the Amazon ECR image architecture types used to filter findings.
        public var ecrImageArchitecture: [Inspector2ClientTypes.StringFilter]?
        /// Details of the Amazon ECR image hashes used to filter findings.
        public var ecrImageHash: [Inspector2ClientTypes.StringFilter]?
        /// Details on the Amazon ECR image push date and time used to filter findings.
        public var ecrImagePushedAt: [Inspector2ClientTypes.DateFilter]?
        /// Details on the Amazon ECR registry used to filter findings.
        public var ecrImageRegistry: [Inspector2ClientTypes.StringFilter]?
        /// Details on the name of the Amazon ECR repository used to filter findings.
        public var ecrImageRepositoryName: [Inspector2ClientTypes.StringFilter]?
        /// The tags attached to the Amazon ECR container image.
        public var ecrImageTags: [Inspector2ClientTypes.StringFilter]?
        /// Details on the finding ARNs used to filter findings.
        public var findingArn: [Inspector2ClientTypes.StringFilter]?
        /// Details on the finding status types used to filter findings.
        public var findingStatus: [Inspector2ClientTypes.StringFilter]?
        /// Details on the finding types used to filter findings.
        public var findingType: [Inspector2ClientTypes.StringFilter]?
        /// Details on the date and time a finding was first seen used to filter findings.
        public var firstObservedAt: [Inspector2ClientTypes.DateFilter]?
        /// The Amazon Inspector score to filter on.
        public var inspectorScore: [Inspector2ClientTypes.NumberFilter]?
        /// Details on the date and time a finding was last seen used to filter findings.
        public var lastObservedAt: [Inspector2ClientTypes.DateFilter]?
        /// Details on the ingress source addresses used to filter findings.
        public var networkProtocol: [Inspector2ClientTypes.StringFilter]?
        /// Details on the port ranges used to filter findings.
        public var portRange: [Inspector2ClientTypes.PortRangeFilter]?
        /// Details on the related vulnerabilities used to filter findings.
        public var relatedVulnerabilities: [Inspector2ClientTypes.StringFilter]?
        /// Details on the resource IDs used to filter findings.
        public var resourceId: [Inspector2ClientTypes.StringFilter]?
        /// Details on the resource tags used to filter findings.
        public var resourceTags: [Inspector2ClientTypes.MapFilter]?
        /// Details on the resource types used to filter findings.
        public var resourceType: [Inspector2ClientTypes.StringFilter]?
        /// Details on the severity used to filter findings.
        public var severity: [Inspector2ClientTypes.StringFilter]?
        /// Details on the finding title used to filter findings.
        public var title: [Inspector2ClientTypes.StringFilter]?
        /// Details on the date and time a finding was last updated at used to filter findings.
        public var updatedAt: [Inspector2ClientTypes.DateFilter]?
        /// Details on the vendor severity used to filter findings.
        public var vendorSeverity: [Inspector2ClientTypes.StringFilter]?
        /// Details on the vulnerability ID used to filter findings.
        public var vulnerabilityId: [Inspector2ClientTypes.StringFilter]?
        /// Details on the vulnerability type used to filter findings.
        public var vulnerabilitySource: [Inspector2ClientTypes.StringFilter]?
        /// Details on the vulnerable packages used to filter findings.
        public var vulnerablePackages: [Inspector2ClientTypes.PackageFilter]?

        public init (
            awsAccountId: [Inspector2ClientTypes.StringFilter]? = nil,
            componentId: [Inspector2ClientTypes.StringFilter]? = nil,
            componentType: [Inspector2ClientTypes.StringFilter]? = nil,
            ec2InstanceImageId: [Inspector2ClientTypes.StringFilter]? = nil,
            ec2InstanceSubnetId: [Inspector2ClientTypes.StringFilter]? = nil,
            ec2InstanceVpcId: [Inspector2ClientTypes.StringFilter]? = nil,
            ecrImageArchitecture: [Inspector2ClientTypes.StringFilter]? = nil,
            ecrImageHash: [Inspector2ClientTypes.StringFilter]? = nil,
            ecrImagePushedAt: [Inspector2ClientTypes.DateFilter]? = nil,
            ecrImageRegistry: [Inspector2ClientTypes.StringFilter]? = nil,
            ecrImageRepositoryName: [Inspector2ClientTypes.StringFilter]? = nil,
            ecrImageTags: [Inspector2ClientTypes.StringFilter]? = nil,
            findingArn: [Inspector2ClientTypes.StringFilter]? = nil,
            findingStatus: [Inspector2ClientTypes.StringFilter]? = nil,
            findingType: [Inspector2ClientTypes.StringFilter]? = nil,
            firstObservedAt: [Inspector2ClientTypes.DateFilter]? = nil,
            inspectorScore: [Inspector2ClientTypes.NumberFilter]? = nil,
            lastObservedAt: [Inspector2ClientTypes.DateFilter]? = nil,
            networkProtocol: [Inspector2ClientTypes.StringFilter]? = nil,
            portRange: [Inspector2ClientTypes.PortRangeFilter]? = nil,
            relatedVulnerabilities: [Inspector2ClientTypes.StringFilter]? = nil,
            resourceId: [Inspector2ClientTypes.StringFilter]? = nil,
            resourceTags: [Inspector2ClientTypes.MapFilter]? = nil,
            resourceType: [Inspector2ClientTypes.StringFilter]? = nil,
            severity: [Inspector2ClientTypes.StringFilter]? = nil,
            title: [Inspector2ClientTypes.StringFilter]? = nil,
            updatedAt: [Inspector2ClientTypes.DateFilter]? = nil,
            vendorSeverity: [Inspector2ClientTypes.StringFilter]? = nil,
            vulnerabilityId: [Inspector2ClientTypes.StringFilter]? = nil,
            vulnerabilitySource: [Inspector2ClientTypes.StringFilter]? = nil,
            vulnerablePackages: [Inspector2ClientTypes.PackageFilter]? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.componentId = componentId
            self.componentType = componentType
            self.ec2InstanceImageId = ec2InstanceImageId
            self.ec2InstanceSubnetId = ec2InstanceSubnetId
            self.ec2InstanceVpcId = ec2InstanceVpcId
            self.ecrImageArchitecture = ecrImageArchitecture
            self.ecrImageHash = ecrImageHash
            self.ecrImagePushedAt = ecrImagePushedAt
            self.ecrImageRegistry = ecrImageRegistry
            self.ecrImageRepositoryName = ecrImageRepositoryName
            self.ecrImageTags = ecrImageTags
            self.findingArn = findingArn
            self.findingStatus = findingStatus
            self.findingType = findingType
            self.firstObservedAt = firstObservedAt
            self.inspectorScore = inspectorScore
            self.lastObservedAt = lastObservedAt
            self.networkProtocol = networkProtocol
            self.portRange = portRange
            self.relatedVulnerabilities = relatedVulnerabilities
            self.resourceId = resourceId
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.severity = severity
            self.title = title
            self.updatedAt = updatedAt
            self.vendorSeverity = vendorSeverity
            self.vulnerabilityId = vulnerabilityId
            self.vulnerabilitySource = vulnerabilitySource
            self.vulnerablePackages = vulnerablePackages
        }
    }

}

extension Inspector2ClientTypes.Finding: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case description
        case findingArn
        case firstObservedAt
        case inspectorScore
        case inspectorScoreDetails
        case lastObservedAt
        case networkReachabilityDetails
        case packageVulnerabilityDetails
        case remediation
        case resources
        case severity
        case status
        case title
        case type
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let findingArn = findingArn {
            try encodeContainer.encode(findingArn, forKey: .findingArn)
        }
        if let firstObservedAt = firstObservedAt {
            try encodeContainer.encode(firstObservedAt.timeIntervalSince1970, forKey: .firstObservedAt)
        }
        if let inspectorScore = inspectorScore {
            try encodeContainer.encode(inspectorScore, forKey: .inspectorScore)
        }
        if let inspectorScoreDetails = inspectorScoreDetails {
            try encodeContainer.encode(inspectorScoreDetails, forKey: .inspectorScoreDetails)
        }
        if let lastObservedAt = lastObservedAt {
            try encodeContainer.encode(lastObservedAt.timeIntervalSince1970, forKey: .lastObservedAt)
        }
        if let networkReachabilityDetails = networkReachabilityDetails {
            try encodeContainer.encode(networkReachabilityDetails, forKey: .networkReachabilityDetails)
        }
        if let packageVulnerabilityDetails = packageVulnerabilityDetails {
            try encodeContainer.encode(packageVulnerabilityDetails, forKey: .packageVulnerabilityDetails)
        }
        if let remediation = remediation {
            try encodeContainer.encode(remediation, forKey: .remediation)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resourcelist0 in resources {
                try resourcesContainer.encode(resourcelist0)
            }
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingArn)
        findingArn = findingArnDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FindingType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let remediationDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Remediation.self, forKey: .remediation)
        remediation = remediationDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Severity.self, forKey: .severity)
        severity = severityDecoded
        let firstObservedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .firstObservedAt)
        firstObservedAt = firstObservedAtDecoded
        let lastObservedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastObservedAt)
        lastObservedAt = lastObservedAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FindingStatus.self, forKey: .status)
        status = statusDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Inspector2ClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Inspector2ClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let inspectorScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .inspectorScore)
        inspectorScore = inspectorScoreDecoded
        let inspectorScoreDetailsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.InspectorScoreDetails.self, forKey: .inspectorScoreDetails)
        inspectorScoreDetails = inspectorScoreDetailsDecoded
        let networkReachabilityDetailsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.NetworkReachabilityDetails.self, forKey: .networkReachabilityDetails)
        networkReachabilityDetails = networkReachabilityDetailsDecoded
        let packageVulnerabilityDetailsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.PackageVulnerabilityDetails.self, forKey: .packageVulnerabilityDetails)
        packageVulnerabilityDetails = packageVulnerabilityDetailsDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details about an Amazon Inspector finding.
    public struct Finding: Swift.Equatable {
        /// The Amazon Web Services account ID associated with the finding.
        /// This member is required.
        public var awsAccountId: Swift.String?
        /// The description of the finding.
        /// This member is required.
        public var description: Swift.String?
        /// The Amazon Resource Number (ARN) of the finding.
        /// This member is required.
        public var findingArn: Swift.String?
        /// The date and time that the finding was first observed.
        /// This member is required.
        public var firstObservedAt: ClientRuntime.Date?
        /// The Amazon Inspector score given to the finding.
        public var inspectorScore: Swift.Double?
        /// An object that contains details of the Amazon Inspector score.
        public var inspectorScoreDetails: Inspector2ClientTypes.InspectorScoreDetails?
        /// The date and time that the finding was last observed.
        /// This member is required.
        public var lastObservedAt: ClientRuntime.Date?
        /// An object that contains the details of a network reachability finding.
        public var networkReachabilityDetails: Inspector2ClientTypes.NetworkReachabilityDetails?
        /// An object that contains the details of a package vulnerability finding.
        public var packageVulnerabilityDetails: Inspector2ClientTypes.PackageVulnerabilityDetails?
        /// An object that contains the details about how to remediate a finding.
        /// This member is required.
        public var remediation: Inspector2ClientTypes.Remediation?
        /// Contains information on the resources involved in a finding.
        /// This member is required.
        public var resources: [Inspector2ClientTypes.Resource]?
        /// The severity of the finding.
        /// This member is required.
        public var severity: Inspector2ClientTypes.Severity?
        /// The status of the finding.
        /// This member is required.
        public var status: Inspector2ClientTypes.FindingStatus?
        /// The title of the finding.
        public var title: Swift.String?
        /// The type of the finding.
        /// This member is required.
        public var type: Inspector2ClientTypes.FindingType?
        /// The date and time the finding was last updated at.
        public var updatedAt: ClientRuntime.Date?

        public init (
            awsAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            findingArn: Swift.String? = nil,
            firstObservedAt: ClientRuntime.Date? = nil,
            inspectorScore: Swift.Double? = nil,
            inspectorScoreDetails: Inspector2ClientTypes.InspectorScoreDetails? = nil,
            lastObservedAt: ClientRuntime.Date? = nil,
            networkReachabilityDetails: Inspector2ClientTypes.NetworkReachabilityDetails? = nil,
            packageVulnerabilityDetails: Inspector2ClientTypes.PackageVulnerabilityDetails? = nil,
            remediation: Inspector2ClientTypes.Remediation? = nil,
            resources: [Inspector2ClientTypes.Resource]? = nil,
            severity: Inspector2ClientTypes.Severity? = nil,
            status: Inspector2ClientTypes.FindingStatus? = nil,
            title: Swift.String? = nil,
            type: Inspector2ClientTypes.FindingType? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.description = description
            self.findingArn = findingArn
            self.firstObservedAt = firstObservedAt
            self.inspectorScore = inspectorScore
            self.inspectorScoreDetails = inspectorScoreDetails
            self.lastObservedAt = lastObservedAt
            self.networkReachabilityDetails = networkReachabilityDetails
            self.packageVulnerabilityDetails = packageVulnerabilityDetails
            self.remediation = remediation
            self.resources = resources
            self.severity = severity
            self.status = status
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension Inspector2ClientTypes {
    public enum FindingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case closed
        case suppressed
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingStatus] {
            return [
                .active,
                .closed,
                .suppressed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .closed: return "CLOSED"
            case .suppressed: return "SUPPRESSED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingStatus(rawValue: rawValue) ?? FindingStatus.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum FindingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case networkReachability
        case packageVulnerability
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingType] {
            return [
                .networkReachability,
                .packageVulnerability,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .networkReachability: return "NETWORK_REACHABILITY"
            case .packageVulnerability: return "PACKAGE_VULNERABILITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingType(rawValue: rawValue) ?? FindingType.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.FindingTypeAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingType
        case resourceType
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingType = findingType {
            try encodeContainer.encode(findingType.rawValue, forKey: .findingType)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AggregationFindingType.self, forKey: .findingType)
        findingType = findingTypeDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AggregationResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FindingTypeSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on finding type.
    public struct FindingTypeAggregation: Swift.Equatable {
        /// The finding type to aggregate.
        public var findingType: Inspector2ClientTypes.AggregationFindingType?
        /// The resource type to aggregate.
        public var resourceType: Inspector2ClientTypes.AggregationResourceType?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.FindingTypeSortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init (
            findingType: Inspector2ClientTypes.AggregationFindingType? = nil,
            resourceType: Inspector2ClientTypes.AggregationResourceType? = nil,
            sortBy: Inspector2ClientTypes.FindingTypeSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.findingType = findingType
            self.resourceType = resourceType
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes.FindingTypeAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let severityCounts = severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
    }
}

extension Inspector2ClientTypes {
    /// A response that contains the results of a finding type aggregation.
    public struct FindingTypeAggregationResponse: Swift.Equatable {
        /// The ID of the Amazon Web Services account associated with the findings.
        public var accountId: Swift.String?
        /// The value to sort results by.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init (
            accountId: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    public enum FindingTypeSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingTypeSortBy] {
            return [
                .all,
                .critical,
                .high,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingTypeSortBy(rawValue: rawValue) ?? FindingTypeSortBy.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.FreeTrialAccountInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case freeTrialInfo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let freeTrialInfo = freeTrialInfo {
            var freeTrialInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .freeTrialInfo)
            for freetrialinfolist0 in freeTrialInfo {
                try freeTrialInfoContainer.encode(freetrialinfolist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let freeTrialInfoContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.FreeTrialInfo?].self, forKey: .freeTrialInfo)
        var freeTrialInfoDecoded0:[Inspector2ClientTypes.FreeTrialInfo]? = nil
        if let freeTrialInfoContainer = freeTrialInfoContainer {
            freeTrialInfoDecoded0 = [Inspector2ClientTypes.FreeTrialInfo]()
            for structure0 in freeTrialInfoContainer {
                if let structure0 = structure0 {
                    freeTrialInfoDecoded0?.append(structure0)
                }
            }
        }
        freeTrialInfo = freeTrialInfoDecoded0
    }
}

extension Inspector2ClientTypes {
    /// Information about the Amazon Inspector free trial for an account.
    public struct FreeTrialAccountInfo: Swift.Equatable {
        /// The account associated with the Amazon Inspector free trial information.
        /// This member is required.
        public var accountId: Swift.String?
        /// Contains information about the Amazon Inspector free trial for an account.
        /// This member is required.
        public var freeTrialInfo: [Inspector2ClientTypes.FreeTrialInfo]?

        public init (
            accountId: Swift.String? = nil,
            freeTrialInfo: [Inspector2ClientTypes.FreeTrialInfo]? = nil
        )
        {
            self.accountId = accountId
            self.freeTrialInfo = freeTrialInfo
        }
    }

}

extension Inspector2ClientTypes.FreeTrialInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case end
        case start
        case status
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = end {
            try encodeContainer.encode(end.timeIntervalSince1970, forKey: .end)
        }
        if let start = start {
            try encodeContainer.encode(start.timeIntervalSince1970, forKey: .start)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FreeTrialType.self, forKey: .type)
        type = typeDecoded
        let startDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .end)
        end = endDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FreeTrialStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that contains information about the Amazon Inspector free trial for an account.
    public struct FreeTrialInfo: Swift.Equatable {
        /// The date and time that the Amazon Inspector free trail ends for a given account.
        /// This member is required.
        public var end: ClientRuntime.Date?
        /// The date and time that the Amazon Inspector free trail started for a given account.
        /// This member is required.
        public var start: ClientRuntime.Date?
        /// The order to sort results by.
        /// This member is required.
        public var status: Inspector2ClientTypes.FreeTrialStatus?
        /// The type of scan covered by the Amazon Inspector free trail.
        /// This member is required.
        public var type: Inspector2ClientTypes.FreeTrialType?

        public init (
            end: ClientRuntime.Date? = nil,
            start: ClientRuntime.Date? = nil,
            status: Inspector2ClientTypes.FreeTrialStatus? = nil,
            type: Inspector2ClientTypes.FreeTrialType? = nil
        )
        {
            self.end = end
            self.start = start
            self.status = status
            self.type = type
        }
    }

}

extension Inspector2ClientTypes.FreeTrialInfoError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FreeTrialInfoErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Inspector2ClientTypes {
    /// Information about an error received while accessing free trail data for an account.
    public struct FreeTrialInfoError: Swift.Equatable {
        /// The account associated with the Amazon Inspector free trial information.
        /// This member is required.
        public var accountId: Swift.String?
        /// The error code.
        /// This member is required.
        public var code: Inspector2ClientTypes.FreeTrialInfoErrorCode?
        /// The error message returned.
        /// This member is required.
        public var message: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            code: Inspector2ClientTypes.FreeTrialInfoErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.code = code
            self.message = message
        }
    }

}

extension Inspector2ClientTypes {
    public enum FreeTrialInfoErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [FreeTrialInfoErrorCode] {
            return [
                .accessDenied,
                .internalError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .internalError: return "INTERNAL_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FreeTrialInfoErrorCode(rawValue: rawValue) ?? FreeTrialInfoErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum FreeTrialStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [FreeTrialStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FreeTrialStatus(rawValue: rawValue) ?? FreeTrialStatus.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum FreeTrialType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2
        case ecr
        case sdkUnknown(Swift.String)

        public static var allCases: [FreeTrialType] {
            return [
                .ec2,
                .ecr,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2: return "EC2"
            case .ecr: return "ECR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FreeTrialType(rawValue: rawValue) ?? FreeTrialType.sdkUnknown(rawValue)
        }
    }
}

extension GetDelegatedAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delegatedadminaccounts/get"
    }
}

public struct GetDelegatedAdminAccountInput: Swift.Equatable {

}

struct GetDelegatedAdminAccountInputBody: Swift.Equatable {
}

extension GetDelegatedAdminAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDelegatedAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDelegatedAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDelegatedAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDelegatedAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDelegatedAdminAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.delegatedAdmin = output.delegatedAdmin
        } else {
            self.delegatedAdmin = nil
        }
    }
}

public struct GetDelegatedAdminAccountOutputResponse: Swift.Equatable {
    /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator.
    public var delegatedAdmin: Inspector2ClientTypes.DelegatedAdmin?

    public init (
        delegatedAdmin: Inspector2ClientTypes.DelegatedAdmin? = nil
    )
    {
        self.delegatedAdmin = delegatedAdmin
    }
}

struct GetDelegatedAdminAccountOutputResponseBody: Swift.Equatable {
    let delegatedAdmin: Inspector2ClientTypes.DelegatedAdmin?
}

extension GetDelegatedAdminAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdmin
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegatedAdminDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.DelegatedAdmin.self, forKey: .delegatedAdmin)
        delegatedAdmin = delegatedAdminDecoded
    }
}

extension GetFindingsReportStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reportId = reportId {
            try encodeContainer.encode(reportId, forKey: .reportId)
        }
    }
}

extension GetFindingsReportStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/reporting/status/get"
    }
}

public struct GetFindingsReportStatusInput: Swift.Equatable {
    /// The ID of the report to retrieve the status of.
    public var reportId: Swift.String?

    public init (
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct GetFindingsReportStatusInputBody: Swift.Equatable {
    let reportId: Swift.String?
}

extension GetFindingsReportStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

extension GetFindingsReportStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingsReportStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFindingsReportStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingsReportStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFindingsReportStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destination = output.destination
            self.errorCode = output.errorCode
            self.errorMessage = output.errorMessage
            self.filterCriteria = output.filterCriteria
            self.reportId = output.reportId
            self.status = output.status
        } else {
            self.destination = nil
            self.errorCode = nil
            self.errorMessage = nil
            self.filterCriteria = nil
            self.reportId = nil
            self.status = nil
        }
    }
}

public struct GetFindingsReportStatusOutputResponse: Swift.Equatable {
    /// The destination of the report.
    public var destination: Inspector2ClientTypes.Destination?
    /// The error code of the report.
    public var errorCode: Inspector2ClientTypes.ReportingErrorCode?
    /// The error message of the report.
    public var errorMessage: Swift.String?
    /// The filter criteria associated with the report.
    public var filterCriteria: Inspector2ClientTypes.FilterCriteria?
    /// The ID of the report.
    public var reportId: Swift.String?
    /// The status of the report.
    public var status: Inspector2ClientTypes.ExternalReportStatus?

    public init (
        destination: Inspector2ClientTypes.Destination? = nil,
        errorCode: Inspector2ClientTypes.ReportingErrorCode? = nil,
        errorMessage: Swift.String? = nil,
        filterCriteria: Inspector2ClientTypes.FilterCriteria? = nil,
        reportId: Swift.String? = nil,
        status: Inspector2ClientTypes.ExternalReportStatus? = nil
    )
    {
        self.destination = destination
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.filterCriteria = filterCriteria
        self.reportId = reportId
        self.status = status
    }
}

struct GetFindingsReportStatusOutputResponseBody: Swift.Equatable {
    let reportId: Swift.String?
    let status: Inspector2ClientTypes.ExternalReportStatus?
    let errorCode: Inspector2ClientTypes.ReportingErrorCode?
    let errorMessage: Swift.String?
    let destination: Inspector2ClientTypes.Destination?
    let filterCriteria: Inspector2ClientTypes.FilterCriteria?
}

extension GetFindingsReportStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
        case errorCode
        case errorMessage
        case filterCriteria
        case reportId
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ExternalReportStatus.self, forKey: .status)
        status = statusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ReportingErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Destination.self, forKey: .destination)
        destination = destinationDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
    }
}

extension GetMemberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }
}

extension GetMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/members/get"
    }
}

public struct GetMemberInput: Swift.Equatable {
    /// The Amazon Web Services account ID of the member account to retrieve information on.
    /// This member is required.
    public var accountId: Swift.String?

    public init (
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct GetMemberInputBody: Swift.Equatable {
    let accountId: Swift.String?
}

extension GetMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension GetMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMemberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMemberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.member = output.member
        } else {
            self.member = nil
        }
    }
}

public struct GetMemberOutputResponse: Swift.Equatable {
    /// Details of the retrieved member account.
    public var member: Inspector2ClientTypes.Member?

    public init (
        member: Inspector2ClientTypes.Member? = nil
    )
    {
        self.member = member
    }
}

struct GetMemberOutputResponseBody: Swift.Equatable {
    let member: Inspector2ClientTypes.Member?
}

extension GetMemberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Member.self, forKey: .member)
        member = memberDecoded
    }
}

extension Inspector2ClientTypes {
    public enum GroupKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountId
        case ecrRepositoryName
        case resourceType
        case scanStatusCode
        case scanStatusReason
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupKey] {
            return [
                .accountId,
                .ecrRepositoryName,
                .resourceType,
                .scanStatusCode,
                .scanStatusReason,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .ecrRepositoryName: return "ECR_REPOSITORY_NAME"
            case .resourceType: return "RESOURCE_TYPE"
            case .scanStatusCode: return "SCAN_STATUS_CODE"
            case .scanStatusReason: return "SCAN_STATUS_REASON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GroupKey(rawValue: rawValue) ?? GroupKey.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.ImageLayerAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerHashes
        case repositories
        case resourceIds
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerHashes = layerHashes {
            var layerHashesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerHashes)
            for stringfilterlist0 in layerHashes {
                try layerHashesContainer.encode(stringfilterlist0)
            }
        }
        if let repositories = repositories {
            var repositoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositories)
            for stringfilterlist0 in repositories {
                try repositoriesContainer.encode(stringfilterlist0)
            }
        }
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for stringfilterlist0 in resourceIds {
                try resourceIdsContainer.encode(stringfilterlist0)
            }
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .repositories)
        var repositoriesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let resourceIdsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in resourceIdsContainer {
                if let structure0 = structure0 {
                    resourceIdsDecoded0?.append(structure0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
        let layerHashesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .layerHashes)
        var layerHashesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let layerHashesContainer = layerHashesContainer {
            layerHashesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in layerHashesContainer {
                if let structure0 = structure0 {
                    layerHashesDecoded0?.append(structure0)
                }
            }
        }
        layerHashes = layerHashesDecoded0
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ImageLayerSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on container image layers.
    public struct ImageLayerAggregation: Swift.Equatable {
        /// The hashes associated with the layers.
        public var layerHashes: [Inspector2ClientTypes.StringFilter]?
        /// The repository associated with the container image hosting the layers.
        public var repositories: [Inspector2ClientTypes.StringFilter]?
        /// The ID of the container image layer.
        public var resourceIds: [Inspector2ClientTypes.StringFilter]?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.ImageLayerSortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init (
            layerHashes: [Inspector2ClientTypes.StringFilter]? = nil,
            repositories: [Inspector2ClientTypes.StringFilter]? = nil,
            resourceIds: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.ImageLayerSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.layerHashes = layerHashes
            self.repositories = repositories
            self.resourceIds = resourceIds
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes.ImageLayerAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case layerHash
        case repository
        case resourceId
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let layerHash = layerHash {
            try encodeContainer.encode(layerHash, forKey: .layerHash)
        }
        if let repository = repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let severityCounts = severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repository)
        repository = repositoryDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let layerHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerHash)
        layerHash = layerHashDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
    }
}

extension Inspector2ClientTypes {
    /// A response that contains the results of a finding aggregation by image layer.
    public struct ImageLayerAggregationResponse: Swift.Equatable {
        /// The ID of the Amazon Web Services account that owns the container image hosting the layer image.
        /// This member is required.
        public var accountId: Swift.String?
        /// The layer hash.
        /// This member is required.
        public var layerHash: Swift.String?
        /// The repository the layer resides in.
        /// This member is required.
        public var repository: Swift.String?
        /// The resource ID of the container image layer.
        /// This member is required.
        public var resourceId: Swift.String?
        /// An object that represents the count of matched findings per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init (
            accountId: Swift.String? = nil,
            layerHash: Swift.String? = nil,
            repository: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.layerHash = layerHash
            self.repository = repository
            self.resourceId = resourceId
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    public enum ImageLayerSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageLayerSortBy] {
            return [
                .all,
                .critical,
                .high,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageLayerSortBy(rawValue: rawValue) ?? ImageLayerSortBy.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.InspectorScoreDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adjustedCvss
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adjustedCvss = adjustedCvss {
            try encodeContainer.encode(adjustedCvss, forKey: .adjustedCvss)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adjustedCvssDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.CvssScoreDetails.self, forKey: .adjustedCvss)
        adjustedCvss = adjustedCvssDecoded
    }
}

extension Inspector2ClientTypes {
    /// Information about the Amazon Inspector score given to a finding.
    public struct InspectorScoreDetails: Swift.Equatable {
        /// An object that contains details about the CVSS score given to a finding.
        public var adjustedCvss: Inspector2ClientTypes.CvssScoreDetails?

        public init (
            adjustedCvss: Inspector2ClientTypes.CvssScoreDetails? = nil
        )
        {
            self.adjustedCvss = adjustedCvss
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request has failed due to an internal failure of the Amazon Inspector service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// The number of seconds to wait before retrying the request.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAccountPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case service
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let service = service {
            try encodeContainer.encode(service.rawValue, forKey: .service)
        }
    }
}

extension ListAccountPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/accountpermissions/list"
    }
}

public struct ListAccountPermissionsInput: Swift.Equatable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// The service scan type to check permissions for.
    public var service: Inspector2ClientTypes.Service?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        service: Inspector2ClientTypes.Service? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.service = service
    }
}

struct ListAccountPermissionsInputBody: Swift.Equatable {
    let service: Inspector2ClientTypes.Service?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAccountPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case service
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccountPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccountPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccountPermissionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccountPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAccountPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListAccountPermissionsOutputResponse: Swift.Equatable {
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// Contains details on the permissions an account has to configure Amazon Inspector.
    /// This member is required.
    public var permissions: [Inspector2ClientTypes.Permission]?

    public init (
        nextToken: Swift.String? = nil,
        permissions: [Inspector2ClientTypes.Permission]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListAccountPermissionsOutputResponseBody: Swift.Equatable {
    let permissions: [Inspector2ClientTypes.Permission]?
    let nextToken: Swift.String?
}

extension ListAccountPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[Inspector2ClientTypes.Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Inspector2ClientTypes.Permission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCoverageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterCriteria = filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCoverageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/coverage/list"
    }
}

public struct ListCoverageInput: Swift.Equatable {
    /// An object that contains details on the filters to apply to the coverage data for your environment.
    public var filterCriteria: Inspector2ClientTypes.CoverageFilterCriteria?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init (
        filterCriteria: Inspector2ClientTypes.CoverageFilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCoverageInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filterCriteria: Inspector2ClientTypes.CoverageFilterCriteria?
}

extension ListCoverageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.CoverageFilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
    }
}

extension ListCoverageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCoverageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCoverageOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCoverageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCoverageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coveredResources = output.coveredResources
            self.nextToken = output.nextToken
        } else {
            self.coveredResources = nil
            self.nextToken = nil
        }
    }
}

public struct ListCoverageOutputResponse: Swift.Equatable {
    /// An object that contains details on the covered resources in your environment.
    public var coveredResources: [Inspector2ClientTypes.CoveredResource]?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init (
        coveredResources: [Inspector2ClientTypes.CoveredResource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coveredResources = coveredResources
        self.nextToken = nextToken
    }
}

struct ListCoverageOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let coveredResources: [Inspector2ClientTypes.CoveredResource]?
}

extension ListCoverageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coveredResources
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let coveredResourcesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CoveredResource?].self, forKey: .coveredResources)
        var coveredResourcesDecoded0:[Inspector2ClientTypes.CoveredResource]? = nil
        if let coveredResourcesContainer = coveredResourcesContainer {
            coveredResourcesDecoded0 = [Inspector2ClientTypes.CoveredResource]()
            for structure0 in coveredResourcesContainer {
                if let structure0 = structure0 {
                    coveredResourcesDecoded0?.append(structure0)
                }
            }
        }
        coveredResources = coveredResourcesDecoded0
    }
}

extension ListCoverageStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria
        case groupBy
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterCriteria = filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let groupBy = groupBy {
            try encodeContainer.encode(groupBy.rawValue, forKey: .groupBy)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCoverageStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/coverage/statistics/list"
    }
}

public struct ListCoverageStatisticsInput: Swift.Equatable {
    /// An object that contains details on the filters to apply to the coverage data for your environment.
    public var filterCriteria: Inspector2ClientTypes.CoverageFilterCriteria?
    /// The value to group the results by.
    public var groupBy: Inspector2ClientTypes.GroupKey?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init (
        filterCriteria: Inspector2ClientTypes.CoverageFilterCriteria? = nil,
        groupBy: Inspector2ClientTypes.GroupKey? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.groupBy = groupBy
        self.nextToken = nextToken
    }
}

struct ListCoverageStatisticsInputBody: Swift.Equatable {
    let filterCriteria: Inspector2ClientTypes.CoverageFilterCriteria?
    let groupBy: Inspector2ClientTypes.GroupKey?
    let nextToken: Swift.String?
}

extension ListCoverageStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria
        case groupBy
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.CoverageFilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let groupByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.GroupKey.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCoverageStatisticsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCoverageStatisticsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCoverageStatisticsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCoverageStatisticsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCoverageStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.countsByGroup = output.countsByGroup
            self.nextToken = output.nextToken
            self.totalCounts = output.totalCounts
        } else {
            self.countsByGroup = nil
            self.nextToken = nil
            self.totalCounts = nil
        }
    }
}

public struct ListCoverageStatisticsOutputResponse: Swift.Equatable {
    /// An array with the number for each group.
    public var countsByGroup: [Inspector2ClientTypes.Counts]?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// The total number for all groups.
    /// This member is required.
    public var totalCounts: Swift.Int?

    public init (
        countsByGroup: [Inspector2ClientTypes.Counts]? = nil,
        nextToken: Swift.String? = nil,
        totalCounts: Swift.Int? = nil
    )
    {
        self.countsByGroup = countsByGroup
        self.nextToken = nextToken
        self.totalCounts = totalCounts
    }
}

struct ListCoverageStatisticsOutputResponseBody: Swift.Equatable {
    let countsByGroup: [Inspector2ClientTypes.Counts]?
    let totalCounts: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCoverageStatisticsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countsByGroup
        case nextToken
        case totalCounts
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countsByGroupContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Counts?].self, forKey: .countsByGroup)
        var countsByGroupDecoded0:[Inspector2ClientTypes.Counts]? = nil
        if let countsByGroupContainer = countsByGroupContainer {
            countsByGroupDecoded0 = [Inspector2ClientTypes.Counts]()
            for structure0 in countsByGroupContainer {
                if let structure0 = structure0 {
                    countsByGroupDecoded0?.append(structure0)
                }
            }
        }
        countsByGroup = countsByGroupDecoded0
        let totalCountsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCounts)
        totalCounts = totalCountsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDelegatedAdminAccountsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDelegatedAdminAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delegatedadminaccounts/list"
    }
}

public struct ListDelegatedAdminAccountsInput: Swift.Equatable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDelegatedAdminAccountsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListDelegatedAdminAccountsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDelegatedAdminAccountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDelegatedAdminAccountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDelegatedAdminAccountsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDelegatedAdminAccountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDelegatedAdminAccountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.delegatedAdminAccounts = output.delegatedAdminAccounts
            self.nextToken = output.nextToken
        } else {
            self.delegatedAdminAccounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListDelegatedAdminAccountsOutputResponse: Swift.Equatable {
    /// Details of the Amazon Inspector delegated administrator of your organization.
    public var delegatedAdminAccounts: [Inspector2ClientTypes.DelegatedAdminAccount]?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init (
        delegatedAdminAccounts: [Inspector2ClientTypes.DelegatedAdminAccount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.delegatedAdminAccounts = delegatedAdminAccounts
        self.nextToken = nextToken
    }
}

struct ListDelegatedAdminAccountsOutputResponseBody: Swift.Equatable {
    let delegatedAdminAccounts: [Inspector2ClientTypes.DelegatedAdminAccount]?
    let nextToken: Swift.String?
}

extension ListDelegatedAdminAccountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegatedAdminAccounts
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegatedAdminAccountsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.DelegatedAdminAccount?].self, forKey: .delegatedAdminAccounts)
        var delegatedAdminAccountsDecoded0:[Inspector2ClientTypes.DelegatedAdminAccount]? = nil
        if let delegatedAdminAccountsContainer = delegatedAdminAccountsContainer {
            delegatedAdminAccountsDecoded0 = [Inspector2ClientTypes.DelegatedAdminAccount]()
            for structure0 in delegatedAdminAccountsContainer {
                if let structure0 = structure0 {
                    delegatedAdminAccountsDecoded0?.append(structure0)
                }
            }
        }
        delegatedAdminAccounts = delegatedAdminAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFiltersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case arns
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for filterarnlist0 in arns {
                try arnsContainer.encode(filterarnlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFiltersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/filters/list"
    }
}

public struct ListFiltersInput: Swift.Equatable {
    /// The action the filter applies to matched findings.
    public var action: Inspector2ClientTypes.FilterAction?
    /// The Amazon resource number (ARN) of the filter.
    public var arns: [Swift.String]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init (
        action: Inspector2ClientTypes.FilterAction? = nil,
        arns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.action = action
        self.arns = arns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFiltersInputBody: Swift.Equatable {
    let arns: [Swift.String]?
    let action: Inspector2ClientTypes.FilterAction?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListFiltersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case arns
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
        let actionDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterAction.self, forKey: .action)
        action = actionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFiltersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFiltersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFiltersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFiltersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFiltersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.filters = output.filters
            self.nextToken = output.nextToken
        } else {
            self.filters = nil
            self.nextToken = nil
        }
    }
}

public struct ListFiltersOutputResponse: Swift.Equatable {
    /// Contains details on the filters associated with your account.
    /// This member is required.
    public var filters: [Inspector2ClientTypes.Filter]?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init (
        filters: [Inspector2ClientTypes.Filter]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.nextToken = nextToken
    }
}

struct ListFiltersOutputResponseBody: Swift.Equatable {
    let filters: [Inspector2ClientTypes.Filter]?
    let nextToken: Swift.String?
}

extension ListFiltersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[Inspector2ClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Inspector2ClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFindingAggregationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case aggregationRequest
        case aggregationType
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for stringfilterlist0 in accountIds {
                try accountIdsContainer.encode(stringfilterlist0)
            }
        }
        if let aggregationRequest = aggregationRequest {
            try encodeContainer.encode(aggregationRequest, forKey: .aggregationRequest)
        }
        if let aggregationType = aggregationType {
            try encodeContainer.encode(aggregationType.rawValue, forKey: .aggregationType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFindingAggregationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findings/aggregation/list"
    }
}

public struct ListFindingAggregationsInput: Swift.Equatable {
    /// The Amazon Web Services account IDs to retrieve finding aggregation data for.
    public var accountIds: [Inspector2ClientTypes.StringFilter]?
    /// Details of the aggregation request that is used to filter your aggregation results.
    public var aggregationRequest: Inspector2ClientTypes.AggregationRequest?
    /// The type of the aggregation request.
    /// This member is required.
    public var aggregationType: Inspector2ClientTypes.AggregationType?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init (
        accountIds: [Inspector2ClientTypes.StringFilter]? = nil,
        aggregationRequest: Inspector2ClientTypes.AggregationRequest? = nil,
        aggregationType: Inspector2ClientTypes.AggregationType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.aggregationRequest = aggregationRequest
        self.aggregationType = aggregationType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFindingAggregationsInputBody: Swift.Equatable {
    let aggregationType: Inspector2ClientTypes.AggregationType?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let accountIds: [Inspector2ClientTypes.StringFilter]?
    let aggregationRequest: Inspector2ClientTypes.AggregationRequest?
}

extension ListFindingAggregationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case aggregationRequest
        case aggregationType
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AggregationType.self, forKey: .aggregationType)
        aggregationType = aggregationTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in accountIdsContainer {
                if let structure0 = structure0 {
                    accountIdsDecoded0?.append(structure0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let aggregationRequestDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AggregationRequest.self, forKey: .aggregationRequest)
        aggregationRequest = aggregationRequestDecoded
    }
}

extension ListFindingAggregationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFindingAggregationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFindingAggregationsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFindingAggregationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFindingAggregationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aggregationType = output.aggregationType
            self.nextToken = output.nextToken
            self.responses = output.responses
        } else {
            self.aggregationType = nil
            self.nextToken = nil
            self.responses = nil
        }
    }
}

public struct ListFindingAggregationsOutputResponse: Swift.Equatable {
    /// The type of aggregation to perform.
    /// This member is required.
    public var aggregationType: Inspector2ClientTypes.AggregationType?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// Objects that contain the results of an aggregation operation.
    public var responses: [Inspector2ClientTypes.AggregationResponse]?

    public init (
        aggregationType: Inspector2ClientTypes.AggregationType? = nil,
        nextToken: Swift.String? = nil,
        responses: [Inspector2ClientTypes.AggregationResponse]? = nil
    )
    {
        self.aggregationType = aggregationType
        self.nextToken = nextToken
        self.responses = responses
    }
}

struct ListFindingAggregationsOutputResponseBody: Swift.Equatable {
    let aggregationType: Inspector2ClientTypes.AggregationType?
    let responses: [Inspector2ClientTypes.AggregationResponse]?
    let nextToken: Swift.String?
}

extension ListFindingAggregationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationType
        case nextToken
        case responses
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AggregationType.self, forKey: .aggregationType)
        aggregationType = aggregationTypeDecoded
        let responsesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.AggregationResponse?].self, forKey: .responses)
        var responsesDecoded0:[Inspector2ClientTypes.AggregationResponse]? = nil
        if let responsesContainer = responsesContainer {
            responsesDecoded0 = [Inspector2ClientTypes.AggregationResponse]()
            for union0 in responsesContainer {
                if let union0 = union0 {
                    responsesDecoded0?.append(union0)
                }
            }
        }
        responses = responsesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria
        case maxResults
        case nextToken
        case sortCriteria
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterCriteria = filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

extension ListFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findings/list"
    }
}

public struct ListFindingsInput: Swift.Equatable {
    /// Details on the filters to apply to your finding results.
    public var filterCriteria: Inspector2ClientTypes.FilterCriteria?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// Details on the sort criteria to apply to your finding results.
    public var sortCriteria: Inspector2ClientTypes.SortCriteria?

    public init (
        filterCriteria: Inspector2ClientTypes.FilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: Inspector2ClientTypes.SortCriteria? = nil
    )
    {
        self.filterCriteria = filterCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct ListFindingsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filterCriteria: Inspector2ClientTypes.FilterCriteria?
    let sortCriteria: Inspector2ClientTypes.SortCriteria?
}

extension ListFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria
        case maxResults
        case nextToken
        case sortCriteria
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension ListFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFindingsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findings = output.findings
            self.nextToken = output.nextToken
        } else {
            self.findings = nil
            self.nextToken = nil
        }
    }
}

public struct ListFindingsOutputResponse: Swift.Equatable {
    /// Contains details on the findings in your environment.
    public var findings: [Inspector2ClientTypes.Finding]?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init (
        findings: [Inspector2ClientTypes.Finding]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

struct ListFindingsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let findings: [Inspector2ClientTypes.Finding]?
}

extension ListFindingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findings
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let findingsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Finding?].self, forKey: .findings)
        var findingsDecoded0:[Inspector2ClientTypes.Finding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [Inspector2ClientTypes.Finding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
    }
}

extension ListMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case onlyAssociated
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let onlyAssociated = onlyAssociated {
            try encodeContainer.encode(onlyAssociated, forKey: .onlyAssociated)
        }
    }
}

extension ListMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/members/list"
    }
}

public struct ListMembersInput: Swift.Equatable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// Specifies whether to list only currently associated members if True or to list all members within the organization if False.
    public var onlyAssociated: Swift.Bool?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        onlyAssociated: Swift.Bool? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.onlyAssociated = onlyAssociated
    }
}

struct ListMembersInputBody: Swift.Equatable {
    let onlyAssociated: Swift.Bool?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case onlyAssociated
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onlyAssociatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .onlyAssociated)
        onlyAssociated = onlyAssociatedDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMembersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListMembersOutputResponse: Swift.Equatable {
    /// An object that contains details for each member account.
    public var members: [Inspector2ClientTypes.Member]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init (
        members: [Inspector2ClientTypes.Member]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListMembersOutputResponseBody: Swift.Equatable {
    let members: [Inspector2ClientTypes.Member]?
    let nextToken: Swift.String?
}

extension ListMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Member?].self, forKey: .members)
        var membersDecoded0:[Inspector2ClientTypes.Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [Inspector2ClientTypes.Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon resource number (ARN) of the resource to list tags of.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, mapvalue0) in tagsContainer {
                if let mapvalue0 = mapvalue0 {
                    tagsDecoded0?[key0] = mapvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListUsageTotalsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for usageaccountidlist0 in accountIds {
                try accountIdsContainer.encode(usageaccountidlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListUsageTotalsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/usage/list"
    }
}

public struct ListUsageTotalsInput: Swift.Equatable {
    /// The Amazon Web Services account IDs to retrieve usage totals for.
    public var accountIds: [Swift.String]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUsageTotalsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let accountIds: [Swift.String]?
}

extension ListUsageTotalsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension ListUsageTotalsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsageTotalsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsageTotalsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsageTotalsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUsageTotalsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.totals = output.totals
        } else {
            self.nextToken = nil
            self.totals = nil
        }
    }
}

public struct ListUsageTotalsOutputResponse: Swift.Equatable {
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?
    /// An object with details on the total usage for the requested account.
    public var totals: [Inspector2ClientTypes.UsageTotal]?

    public init (
        nextToken: Swift.String? = nil,
        totals: [Inspector2ClientTypes.UsageTotal]? = nil
    )
    {
        self.nextToken = nextToken
        self.totals = totals
    }
}

struct ListUsageTotalsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let totals: [Inspector2ClientTypes.UsageTotal]?
}

extension ListUsageTotalsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case totals
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.UsageTotal?].self, forKey: .totals)
        var totalsDecoded0:[Inspector2ClientTypes.UsageTotal]? = nil
        if let totalsContainer = totalsContainer {
            totalsDecoded0 = [Inspector2ClientTypes.UsageTotal]()
            for structure0 in totalsContainer {
                if let structure0 = structure0 {
                    totalsDecoded0?.append(structure0)
                }
            }
        }
        totals = totalsDecoded0
    }
}

extension Inspector2ClientTypes {
    public enum MapComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [MapComparison] {
            return [
                .equals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MapComparison(rawValue: rawValue) ?? MapComparison.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.MapFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparison
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = comparison {
            try encodeContainer.encode(comparison.rawValue, forKey: .comparison)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.MapComparison.self, forKey: .comparison)
        comparison = comparisonDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that describes details of a map filter.
    public struct MapFilter: Swift.Equatable {
        /// The operator to use when comparing values in the filter.
        /// This member is required.
        public var comparison: Inspector2ClientTypes.MapComparison?
        /// The tag key used in the filter.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value used in the filter.
        public var value: Swift.String?

        public init (
            comparison: Inspector2ClientTypes.MapComparison? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.key = key
            self.value = value
        }
    }

}

extension Inspector2ClientTypes.Member: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case delegatedAdminAccountId
        case relationshipStatus
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let delegatedAdminAccountId = delegatedAdminAccountId {
            try encodeContainer.encode(delegatedAdminAccountId, forKey: .delegatedAdminAccountId)
        }
        if let relationshipStatus = relationshipStatus {
            try encodeContainer.encode(relationshipStatus.rawValue, forKey: .relationshipStatus)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.RelationshipStatus.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let delegatedAdminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delegatedAdminAccountId)
        delegatedAdminAccountId = delegatedAdminAccountIdDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details on a member account in your organization.
    public struct Member: Swift.Equatable {
        /// The Amazon Web Services account ID of the member account.
        public var accountId: Swift.String?
        /// The Amazon Web Services account ID of the Amazon Inspector delegated administrator for this member account.
        public var delegatedAdminAccountId: Swift.String?
        /// The status of the member account.
        public var relationshipStatus: Inspector2ClientTypes.RelationshipStatus?
        /// A timestamp showing when the status of this member was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init (
            accountId: Swift.String? = nil,
            delegatedAdminAccountId: Swift.String? = nil,
            relationshipStatus: Inspector2ClientTypes.RelationshipStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.accountId = accountId
            self.delegatedAdminAccountId = delegatedAdminAccountId
            self.relationshipStatus = relationshipStatus
            self.updatedAt = updatedAt
        }
    }

}

extension Inspector2ClientTypes.NetworkPath: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case steps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for steplist0 in steps {
                try stepsContainer.encode(steplist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Step?].self, forKey: .steps)
        var stepsDecoded0:[Inspector2ClientTypes.Step]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [Inspector2ClientTypes.Step]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension Inspector2ClientTypes {
    /// Information on the network path associated with a finding.
    public struct NetworkPath: Swift.Equatable {
        /// The details on the steps in the network path.
        public var steps: [Inspector2ClientTypes.Step]?

        public init (
            steps: [Inspector2ClientTypes.Step]? = nil
        )
        {
            self.steps = steps
        }
    }

}

extension Inspector2ClientTypes {
    public enum NetworkProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkProtocol] {
            return [
                .tcp,
                .udp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkProtocol(rawValue: rawValue) ?? NetworkProtocol.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.NetworkReachabilityDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkPath
        case openPortRange
        case `protocol` = "protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkPath = networkPath {
            try encodeContainer.encode(networkPath, forKey: .networkPath)
        }
        if let openPortRange = openPortRange {
            try encodeContainer.encode(openPortRange, forKey: .openPortRange)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let openPortRangeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.PortRange.self, forKey: .openPortRange)
        openPortRange = openPortRangeDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.NetworkProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let networkPathDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.NetworkPath.self, forKey: .networkPath)
        networkPath = networkPathDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains the details of a network reachability finding.
    public struct NetworkReachabilityDetails: Swift.Equatable {
        /// An object that contains details about a network path associated with a finding.
        /// This member is required.
        public var networkPath: Inspector2ClientTypes.NetworkPath?
        /// An object that contains details about the open port range associated with a finding.
        /// This member is required.
        public var openPortRange: Inspector2ClientTypes.PortRange?
        /// The protocol associated with a finding.
        /// This member is required.
        public var `protocol`: Inspector2ClientTypes.NetworkProtocol?

        public init (
            networkPath: Inspector2ClientTypes.NetworkPath? = nil,
            openPortRange: Inspector2ClientTypes.PortRange? = nil,
            `protocol`: Inspector2ClientTypes.NetworkProtocol? = nil
        )
        {
            self.networkPath = networkPath
            self.openPortRange = openPortRange
            self.`protocol` = `protocol`
        }
    }

}

extension Inspector2ClientTypes.NumberFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lowerInclusive
        case upperInclusive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lowerInclusive = lowerInclusive {
            try encodeContainer.encode(lowerInclusive, forKey: .lowerInclusive)
        }
        if let upperInclusive = upperInclusive {
            try encodeContainer.encode(upperInclusive, forKey: .upperInclusive)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let upperInclusiveDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .upperInclusive)
        upperInclusive = upperInclusiveDecoded
        let lowerInclusiveDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lowerInclusive)
        lowerInclusive = lowerInclusiveDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that describes the details of a number filter.
    public struct NumberFilter: Swift.Equatable {
        /// The lowest number to be included in the filter.
        public var lowerInclusive: Swift.Double?
        /// The highest number to be included in the filter.
        public var upperInclusive: Swift.Double?

        public init (
            lowerInclusive: Swift.Double? = nil,
            upperInclusive: Swift.Double? = nil
        )
        {
            self.lowerInclusive = lowerInclusive
            self.upperInclusive = upperInclusive
        }
    }

}

extension Inspector2ClientTypes {
    public enum Operation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disableRepository
        case disableScanning
        case enableRepository
        case enableScanning
        case sdkUnknown(Swift.String)

        public static var allCases: [Operation] {
            return [
                .disableRepository,
                .disableScanning,
                .enableRepository,
                .enableScanning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disableRepository: return "DISABLE_REPOSITORY"
            case .disableScanning: return "DISABLE_SCANNING"
            case .enableRepository: return "ENABLE_REPOSITORY"
            case .enableScanning: return "ENABLE_SCANNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operation(rawValue: rawValue) ?? Operation.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.PackageAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageNames
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let packageNames = packageNames {
            var packageNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .packageNames)
            for stringfilterlist0 in packageNames {
                try packageNamesContainer.encode(stringfilterlist0)
            }
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNamesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .packageNames)
        var packageNamesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let packageNamesContainer = packageNamesContainer {
            packageNamesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in packageNamesContainer {
                if let structure0 = structure0 {
                    packageNamesDecoded0?.append(structure0)
                }
            }
        }
        packageNames = packageNamesDecoded0
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.PackageSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on operating system package type.
    public struct PackageAggregation: Swift.Equatable {
        /// The names of packages to aggregate findings on.
        public var packageNames: [Inspector2ClientTypes.StringFilter]?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.PackageSortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init (
            packageNames: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.PackageSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.packageNames = packageNames
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes.PackageAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case packageName
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let packageName = packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let severityCounts = severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
    }
}

extension Inspector2ClientTypes {
    /// A response that contains the results of a finding aggregation by image layer.
    public struct PackageAggregationResponse: Swift.Equatable {
        /// The ID of the Amazon Web Services account associated with the findings.
        public var accountId: Swift.String?
        /// The name of the operating system package.
        /// This member is required.
        public var packageName: Swift.String?
        /// An object that contains the count of matched findings per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init (
            accountId: Swift.String? = nil,
            packageName: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.packageName = packageName
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes.PackageFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case epoch
        case name
        case release
        case sourceLayerHash
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = architecture {
            try encodeContainer.encode(architecture, forKey: .architecture)
        }
        if let epoch = epoch {
            try encodeContainer.encode(epoch, forKey: .epoch)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let release = release {
            try encodeContainer.encode(release, forKey: .release)
        }
        if let sourceLayerHash = sourceLayerHash {
            try encodeContainer.encode(sourceLayerHash, forKey: .sourceLayerHash)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.StringFilter.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.StringFilter.self, forKey: .version)
        version = versionDecoded
        let epochDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.NumberFilter.self, forKey: .epoch)
        epoch = epochDecoded
        let releaseDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.StringFilter.self, forKey: .release)
        release = releaseDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.StringFilter.self, forKey: .architecture)
        architecture = architectureDecoded
        let sourceLayerHashDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.StringFilter.self, forKey: .sourceLayerHash)
        sourceLayerHash = sourceLayerHashDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains information on the details of a package filter.
    public struct PackageFilter: Swift.Equatable {
        /// An object that contains details on the package architecture type to filter on.
        public var architecture: Inspector2ClientTypes.StringFilter?
        /// An object that contains details on the package epoch to filter on.
        public var epoch: Inspector2ClientTypes.NumberFilter?
        /// An object that contains details on the name of the package to filter on.
        public var name: Inspector2ClientTypes.StringFilter?
        /// An object that contains details on the package release to filter on.
        public var release: Inspector2ClientTypes.StringFilter?
        /// An object that contains details on the source layer hash to filter on.
        public var sourceLayerHash: Inspector2ClientTypes.StringFilter?
        /// The package version to filter on.
        public var version: Inspector2ClientTypes.StringFilter?

        public init (
            architecture: Inspector2ClientTypes.StringFilter? = nil,
            epoch: Inspector2ClientTypes.NumberFilter? = nil,
            name: Inspector2ClientTypes.StringFilter? = nil,
            release: Inspector2ClientTypes.StringFilter? = nil,
            sourceLayerHash: Inspector2ClientTypes.StringFilter? = nil,
            version: Inspector2ClientTypes.StringFilter? = nil
        )
        {
            self.architecture = architecture
            self.epoch = epoch
            self.name = name
            self.release = release
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }
    }

}

extension Inspector2ClientTypes {
    public enum PackageManager: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bundler
        case cargo
        case composer
        case gobinary
        case gomod
        case jar
        case npm
        case nuget
        case os
        case pipenv
        case poetry
        case yarn
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageManager] {
            return [
                .bundler,
                .cargo,
                .composer,
                .gobinary,
                .gomod,
                .jar,
                .npm,
                .nuget,
                .os,
                .pipenv,
                .poetry,
                .yarn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bundler: return "BUNDLER"
            case .cargo: return "CARGO"
            case .composer: return "COMPOSER"
            case .gobinary: return "GOBINARY"
            case .gomod: return "GOMOD"
            case .jar: return "JAR"
            case .npm: return "NPM"
            case .nuget: return "NUGET"
            case .os: return "OS"
            case .pipenv: return "PIPENV"
            case .poetry: return "POETRY"
            case .yarn: return "YARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageManager(rawValue: rawValue) ?? PackageManager.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum PackageSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageSortBy] {
            return [
                .all,
                .critical,
                .high,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageSortBy(rawValue: rawValue) ?? PackageSortBy.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.PackageVulnerabilityDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cvss
        case referenceUrls
        case relatedVulnerabilities
        case source
        case sourceUrl
        case vendorCreatedAt
        case vendorSeverity
        case vendorUpdatedAt
        case vulnerabilityId
        case vulnerablePackages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cvss = cvss {
            var cvssContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cvss)
            for cvssscorelist0 in cvss {
                try cvssContainer.encode(cvssscorelist0)
            }
        }
        if let referenceUrls = referenceUrls {
            var referenceUrlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceUrls)
            for nonemptystringlist0 in referenceUrls {
                try referenceUrlsContainer.encode(nonemptystringlist0)
            }
        }
        if let relatedVulnerabilities = relatedVulnerabilities {
            var relatedVulnerabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedVulnerabilities)
            for vulnerabilityidlist0 in relatedVulnerabilities {
                try relatedVulnerabilitiesContainer.encode(vulnerabilityidlist0)
            }
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceUrl = sourceUrl {
            try encodeContainer.encode(sourceUrl, forKey: .sourceUrl)
        }
        if let vendorCreatedAt = vendorCreatedAt {
            try encodeContainer.encode(vendorCreatedAt.timeIntervalSince1970, forKey: .vendorCreatedAt)
        }
        if let vendorSeverity = vendorSeverity {
            try encodeContainer.encode(vendorSeverity, forKey: .vendorSeverity)
        }
        if let vendorUpdatedAt = vendorUpdatedAt {
            try encodeContainer.encode(vendorUpdatedAt.timeIntervalSince1970, forKey: .vendorUpdatedAt)
        }
        if let vulnerabilityId = vulnerabilityId {
            try encodeContainer.encode(vulnerabilityId, forKey: .vulnerabilityId)
        }
        if let vulnerablePackages = vulnerablePackages {
            var vulnerablePackagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerablePackages)
            for vulnerablepackagelist0 in vulnerablePackages {
                try vulnerablePackagesContainer.encode(vulnerablepackagelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vulnerabilityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vulnerabilityId)
        vulnerabilityId = vulnerabilityIdDecoded
        let vulnerablePackagesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.VulnerablePackage?].self, forKey: .vulnerablePackages)
        var vulnerablePackagesDecoded0:[Inspector2ClientTypes.VulnerablePackage]? = nil
        if let vulnerablePackagesContainer = vulnerablePackagesContainer {
            vulnerablePackagesDecoded0 = [Inspector2ClientTypes.VulnerablePackage]()
            for structure0 in vulnerablePackagesContainer {
                if let structure0 = structure0 {
                    vulnerablePackagesDecoded0?.append(structure0)
                }
            }
        }
        vulnerablePackages = vulnerablePackagesDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let cvssContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.CvssScore?].self, forKey: .cvss)
        var cvssDecoded0:[Inspector2ClientTypes.CvssScore]? = nil
        if let cvssContainer = cvssContainer {
            cvssDecoded0 = [Inspector2ClientTypes.CvssScore]()
            for structure0 in cvssContainer {
                if let structure0 = structure0 {
                    cvssDecoded0?.append(structure0)
                }
            }
        }
        cvss = cvssDecoded0
        let relatedVulnerabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .relatedVulnerabilities)
        var relatedVulnerabilitiesDecoded0:[Swift.String]? = nil
        if let relatedVulnerabilitiesContainer = relatedVulnerabilitiesContainer {
            relatedVulnerabilitiesDecoded0 = [Swift.String]()
            for string0 in relatedVulnerabilitiesContainer {
                if let string0 = string0 {
                    relatedVulnerabilitiesDecoded0?.append(string0)
                }
            }
        }
        relatedVulnerabilities = relatedVulnerabilitiesDecoded0
        let sourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceUrl)
        sourceUrl = sourceUrlDecoded
        let vendorSeverityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorSeverity)
        vendorSeverity = vendorSeverityDecoded
        let vendorCreatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .vendorCreatedAt)
        vendorCreatedAt = vendorCreatedAtDecoded
        let vendorUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .vendorUpdatedAt)
        vendorUpdatedAt = vendorUpdatedAtDecoded
        let referenceUrlsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .referenceUrls)
        var referenceUrlsDecoded0:[Swift.String]? = nil
        if let referenceUrlsContainer = referenceUrlsContainer {
            referenceUrlsDecoded0 = [Swift.String]()
            for string0 in referenceUrlsContainer {
                if let string0 = string0 {
                    referenceUrlsDecoded0?.append(string0)
                }
            }
        }
        referenceUrls = referenceUrlsDecoded0
    }
}

extension Inspector2ClientTypes {
    /// Information about a package vulnerability finding.
    public struct PackageVulnerabilityDetails: Swift.Equatable {
        /// An object that contains details about the CVSS score of a finding.
        public var cvss: [Inspector2ClientTypes.CvssScore]?
        /// One or more URLs that contain details about this vulnerability type.
        public var referenceUrls: [Swift.String]?
        /// One or more vulnerabilities related to the one identified in this finding.
        public var relatedVulnerabilities: [Swift.String]?
        /// The source of the vulnerability information.
        /// This member is required.
        public var source: Swift.String?
        /// A URL to the source of the vulnerability information.
        public var sourceUrl: Swift.String?
        /// The date and time that this vulnerability was first added to the vendor's database.
        public var vendorCreatedAt: ClientRuntime.Date?
        /// The severity the vendor has given to this vulnerability type.
        public var vendorSeverity: Swift.String?
        /// The date and time the vendor last updated this vulnerability in their database.
        public var vendorUpdatedAt: ClientRuntime.Date?
        /// The ID given to this vulnerability.
        /// This member is required.
        public var vulnerabilityId: Swift.String?
        /// The packages impacted by this vulnerability.
        /// This member is required.
        public var vulnerablePackages: [Inspector2ClientTypes.VulnerablePackage]?

        public init (
            cvss: [Inspector2ClientTypes.CvssScore]? = nil,
            referenceUrls: [Swift.String]? = nil,
            relatedVulnerabilities: [Swift.String]? = nil,
            source: Swift.String? = nil,
            sourceUrl: Swift.String? = nil,
            vendorCreatedAt: ClientRuntime.Date? = nil,
            vendorSeverity: Swift.String? = nil,
            vendorUpdatedAt: ClientRuntime.Date? = nil,
            vulnerabilityId: Swift.String? = nil,
            vulnerablePackages: [Inspector2ClientTypes.VulnerablePackage]? = nil
        )
        {
            self.cvss = cvss
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
            self.source = source
            self.sourceUrl = sourceUrl
            self.vendorCreatedAt = vendorCreatedAt
            self.vendorSeverity = vendorSeverity
            self.vendorUpdatedAt = vendorUpdatedAt
            self.vulnerabilityId = vulnerabilityId
            self.vulnerablePackages = vulnerablePackages
        }
    }

}

extension Inspector2ClientTypes.Permission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operation
        case service
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operation = operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
        if let service = service {
            try encodeContainer.encode(service.rawValue, forKey: .service)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Operation.self, forKey: .operation)
        operation = operationDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains information on the permissions an account has within Amazon Inspector.
    public struct Permission: Swift.Equatable {
        /// The operations that can be performed with the given permissions.
        /// This member is required.
        public var operation: Inspector2ClientTypes.Operation?
        /// The services that the permissions allow an account to perform the given operations for.
        /// This member is required.
        public var service: Inspector2ClientTypes.Service?

        public init (
            operation: Inspector2ClientTypes.Operation? = nil,
            service: Inspector2ClientTypes.Service? = nil
        )
        {
            self.operation = operation
            self.service = service
        }
    }

}

extension Inspector2ClientTypes.PortRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case begin
        case end
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let begin = begin {
            try encodeContainer.encode(begin, forKey: .begin)
        }
        if let end = end {
            try encodeContainer.encode(end, forKey: .end)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .begin)
        begin = beginDecoded
        let endDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .end)
        end = endDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details about the port range associated with a finding.
    public struct PortRange: Swift.Equatable {
        /// The beginning port in a port range.
        /// This member is required.
        public var begin: Swift.Int?
        /// The ending port in a port range.
        /// This member is required.
        public var end: Swift.Int?

        public init (
            begin: Swift.Int? = nil,
            end: Swift.Int? = nil
        )
        {
            self.begin = begin
            self.end = end
        }
    }

}

extension Inspector2ClientTypes.PortRangeFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginInclusive
        case endInclusive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginInclusive = beginInclusive {
            try encodeContainer.encode(beginInclusive, forKey: .beginInclusive)
        }
        if let endInclusive = endInclusive {
            try encodeContainer.encode(endInclusive, forKey: .endInclusive)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginInclusiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginInclusive)
        beginInclusive = beginInclusiveDecoded
        let endInclusiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endInclusive)
        endInclusive = endInclusiveDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that describes the details of a port range filter.
    public struct PortRangeFilter: Swift.Equatable {
        /// The port number the port range begins at.
        public var beginInclusive: Swift.Int?
        /// The port number the port range ends at.
        public var endInclusive: Swift.Int?

        public init (
            beginInclusive: Swift.Int? = nil,
            endInclusive: Swift.Int? = nil
        )
        {
            self.beginInclusive = beginInclusive
            self.endInclusive = endInclusive
        }
    }

}

extension Inspector2ClientTypes.Recommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case url = "Url"
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details about the recommended course of action to remediate the finding.
    public struct Recommendation: Swift.Equatable {
        /// The recommended course of action to remediate the finding.
        public var text: Swift.String?
        /// The URL address to the CVE remediation recommendations.
        public var url: Swift.String?

        public init (
            text: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.text = text
            self.url = url
        }
    }

}

extension Inspector2ClientTypes {
    public enum RelationshipStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountSuspended
        case cannotCreateDetectorInOrgMaster
        case created
        case deleted
        case disabled
        case emailVerificationFailed
        case emailVerificationInProgress
        case enabled
        case invited
        case regionDisabled
        case removed
        case resigned
        case sdkUnknown(Swift.String)

        public static var allCases: [RelationshipStatus] {
            return [
                .accountSuspended,
                .cannotCreateDetectorInOrgMaster,
                .created,
                .deleted,
                .disabled,
                .emailVerificationFailed,
                .emailVerificationInProgress,
                .enabled,
                .invited,
                .regionDisabled,
                .removed,
                .resigned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountSuspended: return "ACCOUNT_SUSPENDED"
            case .cannotCreateDetectorInOrgMaster: return "CANNOT_CREATE_DETECTOR_IN_ORG_MASTER"
            case .created: return "CREATED"
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .emailVerificationFailed: return "EMAIL_VERIFICATION_FAILED"
            case .emailVerificationInProgress: return "EMAIL_VERIFICATION_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case .invited: return "INVITED"
            case .regionDisabled: return "REGION_DISABLED"
            case .removed: return "REMOVED"
            case .resigned: return "RESIGNED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelationshipStatus(rawValue: rawValue) ?? RelationshipStatus.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.Remediation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommendation = recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Recommendation.self, forKey: .recommendation)
        recommendation = recommendationDecoded
    }
}

extension Inspector2ClientTypes {
    /// Information on how to remediate a finding.
    public struct Remediation: Swift.Equatable {
        /// An object that contains information about the recommended course of action to remediate the finding.
        public var recommendation: Inspector2ClientTypes.Recommendation?

        public init (
            recommendation: Inspector2ClientTypes.Recommendation? = nil
        )
        {
            self.recommendation = recommendation
        }
    }

}

extension Inspector2ClientTypes {
    public enum ReportFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFormat] {
            return [
                .csv,
                .json,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .json: return "JSON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportFormat(rawValue: rawValue) ?? ReportFormat.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum ReportingErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalError
        case invalidPermissions
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportingErrorCode] {
            return [
                .internalError,
                .invalidPermissions,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "INTERNAL_ERROR"
            case .invalidPermissions: return "INVALID_PERMISSIONS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportingErrorCode(rawValue: rawValue) ?? ReportingErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.RepositoryAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositories
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositories = repositories {
            var repositoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositories)
            for stringfilterlist0 in repositories {
                try repositoriesContainer.encode(stringfilterlist0)
            }
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .repositories)
        var repositoriesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.RepositorySortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on repository.
    public struct RepositoryAggregation: Swift.Equatable {
        /// The names of repositories to aggregate findings on.
        public var repositories: [Inspector2ClientTypes.StringFilter]?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.RepositorySortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init (
            repositories: [Inspector2ClientTypes.StringFilter]? = nil,
            sortBy: Inspector2ClientTypes.RepositorySortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.repositories = repositories
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes.RepositoryAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case affectedImages
        case repository
        case severityCounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let affectedImages = affectedImages {
            try encodeContainer.encode(affectedImages, forKey: .affectedImages)
        }
        if let repository = repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
        if let severityCounts = severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repository)
        repository = repositoryDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
        let affectedImagesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .affectedImages)
        affectedImages = affectedImagesDecoded
    }
}

extension Inspector2ClientTypes {
    /// A response that contains details on the results of a finding aggregation by repository.
    public struct RepositoryAggregationResponse: Swift.Equatable {
        /// The ID of the Amazon Web Services account associated with the findings.
        public var accountId: Swift.String?
        /// The number of container images impacted by the findings.
        public var affectedImages: Swift.Int?
        /// The name of the repository associated with the findings.
        /// This member is required.
        public var repository: Swift.String?
        /// An object that represent the count of matched findings per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?

        public init (
            accountId: Swift.String? = nil,
            affectedImages: Swift.Int? = nil,
            repository: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil
        )
        {
            self.accountId = accountId
            self.affectedImages = affectedImages
            self.repository = repository
            self.severityCounts = severityCounts
        }
    }

}

extension Inspector2ClientTypes {
    public enum RepositorySortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case affectedImages
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [RepositorySortBy] {
            return [
                .affectedImages,
                .all,
                .critical,
                .high,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .affectedImages: return "AFFECTED_IMAGES"
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RepositorySortBy(rawValue: rawValue) ?? RepositorySortBy.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
        case id
        case partition
        case region
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let partition = partition {
            try encodeContainer.encode(partition, forKey: .partition)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ResourceType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let partitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partition)
        partition = partitionDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, mapvalue0) in tagsContainer {
                if let mapvalue0 = mapvalue0 {
                    tagsDecoded0?[key0] = mapvalue0
                }
            }
        }
        tags = tagsDecoded0
        let detailsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ResourceDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details about the resource involved in a finding.
    public struct Resource: Swift.Equatable {
        /// An object that contains details about the resource involved in a finding.
        public var details: Inspector2ClientTypes.ResourceDetails?
        /// The ID of the resource.
        /// This member is required.
        public var id: Swift.String?
        /// The partition of the resource.
        public var partition: Swift.String?
        /// The Amazon Web Services Region the impacted resource is located in.
        public var region: Swift.String?
        /// The tags attached to the resource.
        public var tags: [Swift.String:Swift.String]?
        /// The type of resource.
        /// This member is required.
        public var type: Inspector2ClientTypes.ResourceType?

        public init (
            details: Inspector2ClientTypes.ResourceDetails? = nil,
            id: Swift.String? = nil,
            partition: Swift.String? = nil,
            region: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: Inspector2ClientTypes.ResourceType? = nil
        )
        {
            self.details = details
            self.id = id
            self.partition = partition
            self.region = region
            self.tags = tags
            self.type = type
        }
    }

}

extension Inspector2ClientTypes.ResourceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsEc2Instance
        case awsEcrContainerImage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsEc2Instance = awsEc2Instance {
            try encodeContainer.encode(awsEc2Instance, forKey: .awsEc2Instance)
        }
        if let awsEcrContainerImage = awsEcrContainerImage {
            try encodeContainer.encode(awsEcrContainerImage, forKey: .awsEcrContainerImage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsEc2InstanceDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AwsEc2InstanceDetails.self, forKey: .awsEc2Instance)
        awsEc2Instance = awsEc2InstanceDecoded
        let awsEcrContainerImageDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AwsEcrContainerImageDetails.self, forKey: .awsEcrContainerImage)
        awsEcrContainerImage = awsEcrContainerImageDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains details about the resource involved in the finding.
    public struct ResourceDetails: Swift.Equatable {
        /// An object that contains details about the Amazon EC2 instance involved in the finding.
        public var awsEc2Instance: Inspector2ClientTypes.AwsEc2InstanceDetails?
        /// An object that contains details about the Amazon ECR container image involved in the finding.
        public var awsEcrContainerImage: Inspector2ClientTypes.AwsEcrContainerImageDetails?

        public init (
            awsEc2Instance: Inspector2ClientTypes.AwsEc2InstanceDetails? = nil,
            awsEcrContainerImage: Inspector2ClientTypes.AwsEcrContainerImageDetails? = nil
        )
        {
            self.awsEc2Instance = awsEc2Instance
            self.awsEcrContainerImage = awsEcrContainerImage
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation tried to access an invalid resource. Make sure the resource is specified correctly.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Inspector2ClientTypes.ResourceScanMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2
        case ecrImage
        case ecrRepository
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2 = ec2 {
            try encodeContainer.encode(ec2, forKey: .ec2)
        }
        if let ecrImage = ecrImage {
            try encodeContainer.encode(ecrImage, forKey: .ecrImage)
        }
        if let ecrRepository = ecrRepository {
            try encodeContainer.encode(ecrRepository, forKey: .ecrRepository)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecrRepositoryDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.EcrRepositoryMetadata.self, forKey: .ecrRepository)
        ecrRepository = ecrRepositoryDecoded
        let ecrImageDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.EcrContainerImageMetadata.self, forKey: .ecrImage)
        ecrImage = ecrImageDecoded
        let ec2Decoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Ec2Metadata.self, forKey: .ec2)
        ec2 = ec2Decoded
    }
}

extension Inspector2ClientTypes {
    /// An object that contains details about the metadata for an Amazon ECR resource.
    public struct ResourceScanMetadata: Swift.Equatable {
        /// An object that contains metadata details for an Amazon EC2 instance.
        public var ec2: Inspector2ClientTypes.Ec2Metadata?
        /// An object that contains details about the container metadata for an Amazon ECR image.
        public var ecrImage: Inspector2ClientTypes.EcrContainerImageMetadata?
        /// An object that contains details about the repository an Amazon ECR image resides in.
        public var ecrRepository: Inspector2ClientTypes.EcrRepositoryMetadata?

        public init (
            ec2: Inspector2ClientTypes.Ec2Metadata? = nil,
            ecrImage: Inspector2ClientTypes.EcrContainerImageMetadata? = nil,
            ecrRepository: Inspector2ClientTypes.EcrRepositoryMetadata? = nil
        )
        {
            self.ec2 = ec2
            self.ecrImage = ecrImage
            self.ecrRepository = ecrRepository
        }
    }

}

extension Inspector2ClientTypes {
    public enum ResourceScanType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2
        case ecr
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceScanType] {
            return [
                .ec2,
                .ecr,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2: return "EC2"
            case .ecr: return "ECR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceScanType(rawValue: rawValue) ?? ResourceScanType.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.ResourceState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2
        case ecr
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2 = ec2 {
            try encodeContainer.encode(ec2, forKey: .ec2)
        }
        if let ecr = ecr {
            try encodeContainer.encode(ecr, forKey: .ecr)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2Decoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.State.self, forKey: .ec2)
        ec2 = ec2Decoded
        let ecrDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.State.self, forKey: .ecr)
        ecr = ecrDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details the state of Amazon Inspector for each resource type Amazon Inspector scans.
    public struct ResourceState: Swift.Equatable {
        /// An object detailing the state of Amazon Inspector scanning for Amazon EC2 resources.
        /// This member is required.
        public var ec2: Inspector2ClientTypes.State?
        /// An object detailing the state of Amazon Inspector scanning for Amazon ECR resources.
        /// This member is required.
        public var ecr: Inspector2ClientTypes.State?

        public init (
            ec2: Inspector2ClientTypes.State? = nil,
            ecr: Inspector2ClientTypes.State? = nil
        )
        {
            self.ec2 = ec2
            self.ecr = ecr
        }
    }

}

extension Inspector2ClientTypes.ResourceStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2
        case ecr
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2 = ec2 {
            try encodeContainer.encode(ec2.rawValue, forKey: .ec2)
        }
        if let ecr = ecr {
            try encodeContainer.encode(ecr.rawValue, forKey: .ecr)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2Decoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Status.self, forKey: .ec2)
        ec2 = ec2Decoded
        let ecrDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Status.self, forKey: .ecr)
        ecr = ecrDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details the status of Amazon Inspector for each resource type Amazon Inspector scans.
    public struct ResourceStatus: Swift.Equatable {
        /// The status of Amazon Inspector scanning for Amazon EC2 resources.
        /// This member is required.
        public var ec2: Inspector2ClientTypes.Status?
        /// The status of Amazon Inspector scanning for Amazon ECR resources.
        /// This member is required.
        public var ecr: Inspector2ClientTypes.Status?

        public init (
            ec2: Inspector2ClientTypes.Status? = nil,
            ecr: Inspector2ClientTypes.Status? = nil
        )
        {
            self.ec2 = ec2
            self.ecr = ecr
        }
    }

}

extension Inspector2ClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsEc2Instance
        case awsEcrContainerImage
        case awsEcrRepository
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .awsEc2Instance,
                .awsEcrContainerImage,
                .awsEcrRepository,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsEc2Instance: return "AWS_EC2_INSTANCE"
            case .awsEcrContainerImage: return "AWS_ECR_CONTAINER_IMAGE"
            case .awsEcrRepository: return "AWS_ECR_REPOSITORY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.ScanStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ScanStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ScanStatusReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension Inspector2ClientTypes {
    /// The status of the scan.
    public struct ScanStatus: Swift.Equatable {
        /// The reason for the scan.
        /// This member is required.
        public var reason: Inspector2ClientTypes.ScanStatusReason?
        /// The status code of the scan.
        /// This member is required.
        public var statusCode: Inspector2ClientTypes.ScanStatusCode?

        public init (
            reason: Inspector2ClientTypes.ScanStatusReason? = nil,
            statusCode: Inspector2ClientTypes.ScanStatusCode? = nil
        )
        {
            self.reason = reason
            self.statusCode = statusCode
        }
    }

}

extension Inspector2ClientTypes {
    public enum ScanStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanStatusCode] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanStatusCode(rawValue: rawValue) ?? ScanStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum ScanStatusReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case ec2InstanceStopped
        case imageSizeExceeded
        case internalError
        case noResourcesFound
        case pendingInitialScan
        case resourceTerminated
        case scanEligibilityExpired
        case scanFrequencyManual
        case scanFrequencyScanOnPush
        case successful
        case unmanagedEc2Instance
        case unsupportedOs
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanStatusReason] {
            return [
                .accessDenied,
                .ec2InstanceStopped,
                .imageSizeExceeded,
                .internalError,
                .noResourcesFound,
                .pendingInitialScan,
                .resourceTerminated,
                .scanEligibilityExpired,
                .scanFrequencyManual,
                .scanFrequencyScanOnPush,
                .successful,
                .unmanagedEc2Instance,
                .unsupportedOs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .ec2InstanceStopped: return "EC2_INSTANCE_STOPPED"
            case .imageSizeExceeded: return "IMAGE_SIZE_EXCEEDED"
            case .internalError: return "INTERNAL_ERROR"
            case .noResourcesFound: return "NO_RESOURCES_FOUND"
            case .pendingInitialScan: return "PENDING_INITIAL_SCAN"
            case .resourceTerminated: return "RESOURCE_TERMINATED"
            case .scanEligibilityExpired: return "SCAN_ELIGIBILITY_EXPIRED"
            case .scanFrequencyManual: return "SCAN_FREQUENCY_MANUAL"
            case .scanFrequencyScanOnPush: return "SCAN_FREQUENCY_SCAN_ON_PUSH"
            case .successful: return "SUCCESSFUL"
            case .unmanagedEc2Instance: return "UNMANAGED_EC2_INSTANCE"
            case .unsupportedOs: return "UNSUPPORTED_OS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanStatusReason(rawValue: rawValue) ?? ScanStatusReason.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum ScanType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case network
        case package
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanType] {
            return [
                .network,
                .package,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .network: return "NETWORK"
            case .package: return "PACKAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanType(rawValue: rawValue) ?? ScanType.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum Service: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2
        case ecr
        case sdkUnknown(Swift.String)

        public static var allCases: [Service] {
            return [
                .ec2,
                .ecr,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2: return "EC2"
            case .ecr: return "ECR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Service(rawValue: rawValue) ?? Service.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use Service Quotas to request a service quota increase.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource that exceeds a service quota.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension Inspector2ClientTypes {
    public enum Severity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case high
        case informational
        case low
        case medium
        case untriaged
        case sdkUnknown(Swift.String)

        public static var allCases: [Severity] {
            return [
                .critical,
                .high,
                .informational,
                .low,
                .medium,
                .untriaged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .informational: return "INFORMATIONAL"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .untriaged: return "UNTRIAGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Severity(rawValue: rawValue) ?? Severity.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.SeverityCounts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case all
        case critical
        case high
        case medium
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let all = all {
            try encodeContainer.encode(all, forKey: .all)
        }
        if let critical = critical {
            try encodeContainer.encode(critical, forKey: .critical)
        }
        if let high = high {
            try encodeContainer.encode(high, forKey: .high)
        }
        if let medium = medium {
            try encodeContainer.encode(medium, forKey: .medium)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .all)
        all = allDecoded
        let mediumDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .medium)
        medium = mediumDecoded
        let highDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .high)
        high = highDecoded
        let criticalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .critical)
        critical = criticalDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that contains the counts of aggregated finding per severity.
    public struct SeverityCounts: Swift.Equatable {
        /// The total count of findings from all severities.
        public var all: Swift.Int?
        /// The total count of critical severity findings.
        public var critical: Swift.Int?
        /// The total count of high severity findings.
        public var high: Swift.Int?
        /// The total count of medium severity findings.
        public var medium: Swift.Int?

        public init (
            all: Swift.Int? = nil,
            critical: Swift.Int? = nil,
            high: Swift.Int? = nil,
            medium: Swift.Int? = nil
        )
        {
            self.all = all
            self.critical = critical
            self.high = high
            self.medium = medium
        }
    }

}

extension Inspector2ClientTypes.SortCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case field
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let field = field {
            try encodeContainer.encode(field.rawValue, forKey: .field)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortField.self, forKey: .field)
        field = fieldDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details about the criteria used to sort finding results.
    public struct SortCriteria: Swift.Equatable {
        /// The finding detail field by which results are sorted.
        /// This member is required.
        public var field: Inspector2ClientTypes.SortField?
        /// The order by which findings are sorted.
        /// This member is required.
        public var sortOrder: Inspector2ClientTypes.SortOrder?

        public init (
            field: Inspector2ClientTypes.SortField? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil
        )
        {
            self.field = field
            self.sortOrder = sortOrder
        }
    }

}

extension Inspector2ClientTypes {
    public enum SortField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsAccountId
        case componentType
        case ecrImagePushedAt
        case ecrImageRegistry
        case ecrImageRepositoryName
        case findingStatus
        case findingType
        case firstObservedAt
        case inspectorScore
        case lastObservedAt
        case networkProtocol
        case resourceType
        case severity
        case vendorSeverity
        case vulnerabilityId
        case vulnerabilitySource
        case sdkUnknown(Swift.String)

        public static var allCases: [SortField] {
            return [
                .awsAccountId,
                .componentType,
                .ecrImagePushedAt,
                .ecrImageRegistry,
                .ecrImageRepositoryName,
                .findingStatus,
                .findingType,
                .firstObservedAt,
                .inspectorScore,
                .lastObservedAt,
                .networkProtocol,
                .resourceType,
                .severity,
                .vendorSeverity,
                .vulnerabilityId,
                .vulnerabilitySource,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsAccountId: return "AWS_ACCOUNT_ID"
            case .componentType: return "COMPONENT_TYPE"
            case .ecrImagePushedAt: return "ECR_IMAGE_PUSHED_AT"
            case .ecrImageRegistry: return "ECR_IMAGE_REGISTRY"
            case .ecrImageRepositoryName: return "ECR_IMAGE_REPOSITORY_NAME"
            case .findingStatus: return "FINDING_STATUS"
            case .findingType: return "FINDING_TYPE"
            case .firstObservedAt: return "FIRST_OBSERVED_AT"
            case .inspectorScore: return "INSPECTOR_SCORE"
            case .lastObservedAt: return "LAST_OBSERVED_AT"
            case .networkProtocol: return "NETWORK_PROTOCOL"
            case .resourceType: return "RESOURCE_TYPE"
            case .severity: return "SEVERITY"
            case .vendorSeverity: return "VENDOR_SEVERITY"
            case .vulnerabilityId: return "VULNERABILITY_ID"
            case .vulnerabilitySource: return "VULNERABILITY_SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortField(rawValue: rawValue) ?? SortField.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.State: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that described the state of Amazon Inspector scans for an account.
    public struct State: Swift.Equatable {
        /// The error code explaining why the account failed to enable Amazon Inspector.
        /// This member is required.
        public var errorCode: Inspector2ClientTypes.ErrorCode?
        /// The error message received when the account failed to enable Amazon Inspector.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The status of Amazon Inspector for the account.
        /// This member is required.
        public var status: Inspector2ClientTypes.Status?

        public init (
            errorCode: Inspector2ClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            status: Inspector2ClientTypes.Status? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.status = status
        }
    }

}

extension Inspector2ClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case suspended
        case suspending
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling,
                .suspended,
                .suspending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case .suspended: return "SUSPENDED"
            case .suspending: return "SUSPENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.Step: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentId
        case componentType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentId = componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let componentType = componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
    }
}

extension Inspector2ClientTypes {
    /// Details about the step associated with a finding.
    public struct Step: Swift.Equatable {
        /// The component ID.
        /// This member is required.
        public var componentId: Swift.String?
        /// The component type.
        /// This member is required.
        public var componentType: Swift.String?

        public init (
            componentId: Swift.String? = nil,
            componentType: Swift.String? = nil
        )
        {
            self.componentId = componentId
            self.componentType = componentType
        }
    }

}

extension Inspector2ClientTypes {
    public enum StringComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case notEquals
        case `prefix`
        case sdkUnknown(Swift.String)

        public static var allCases: [StringComparison] {
            return [
                .equals,
                .notEquals,
                .prefix,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case .prefix: return "PREFIX"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StringComparison(rawValue: rawValue) ?? StringComparison.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.StringFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparison
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = comparison {
            try encodeContainer.encode(comparison.rawValue, forKey: .comparison)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.StringComparison.self, forKey: .comparison)
        comparison = comparisonDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that describes the details of a string filter.
    public struct StringFilter: Swift.Equatable {
        /// The operator to use when comparing values in the filter
        /// This member is required.
        public var comparison: Inspector2ClientTypes.StringComparison?
        /// The value to filter on.
        /// This member is required.
        public var value: Swift.String?

        public init (
            comparison: Inspector2ClientTypes.StringComparison? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to apply a tag to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be added to a resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, mapvalue0) in tagsContainer {
                if let mapvalue0 = mapvalue0 {
                    tagsDecoded0?[key0] = mapvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The limit on the number of requests per second was exceeded.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Inspector2ClientTypes.TitleAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceType
        case sortBy
        case sortOrder
        case titles
        case vulnerabilityIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
        if let titles = titles {
            var titlesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .titles)
            for stringfilterlist0 in titles {
                try titlesContainer.encode(stringfilterlist0)
            }
        }
        if let vulnerabilityIds = vulnerabilityIds {
            var vulnerabilityIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerabilityIds)
            for stringfilterlist0 in vulnerabilityIds {
                try vulnerabilityIdsContainer.encode(stringfilterlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titlesContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .titles)
        var titlesDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let titlesContainer = titlesContainer {
            titlesDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in titlesContainer {
                if let structure0 = structure0 {
                    titlesDecoded0?.append(structure0)
                }
            }
        }
        titles = titlesDecoded0
        let vulnerabilityIdsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.StringFilter?].self, forKey: .vulnerabilityIds)
        var vulnerabilityIdsDecoded0:[Inspector2ClientTypes.StringFilter]? = nil
        if let vulnerabilityIdsContainer = vulnerabilityIdsContainer {
            vulnerabilityIdsDecoded0 = [Inspector2ClientTypes.StringFilter]()
            for structure0 in vulnerabilityIdsContainer {
                if let structure0 = structure0 {
                    vulnerabilityIdsDecoded0?.append(structure0)
                }
            }
        }
        vulnerabilityIds = vulnerabilityIdsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AggregationResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.TitleSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension Inspector2ClientTypes {
    /// The details that define an aggregation based on finding title.
    public struct TitleAggregation: Swift.Equatable {
        /// The resource type to aggregate on.
        public var resourceType: Inspector2ClientTypes.AggregationResourceType?
        /// The value to sort results by.
        public var sortBy: Inspector2ClientTypes.TitleSortBy?
        /// The order to sort results by.
        public var sortOrder: Inspector2ClientTypes.SortOrder?
        /// The finding titles to aggregate on.
        public var titles: [Inspector2ClientTypes.StringFilter]?
        /// The vulnerability IDs of the findings.
        public var vulnerabilityIds: [Inspector2ClientTypes.StringFilter]?

        public init (
            resourceType: Inspector2ClientTypes.AggregationResourceType? = nil,
            sortBy: Inspector2ClientTypes.TitleSortBy? = nil,
            sortOrder: Inspector2ClientTypes.SortOrder? = nil,
            titles: [Inspector2ClientTypes.StringFilter]? = nil,
            vulnerabilityIds: [Inspector2ClientTypes.StringFilter]? = nil
        )
        {
            self.resourceType = resourceType
            self.sortBy = sortBy
            self.sortOrder = sortOrder
            self.titles = titles
            self.vulnerabilityIds = vulnerabilityIds
        }
    }

}

extension Inspector2ClientTypes.TitleAggregationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case severityCounts
        case title
        case vulnerabilityId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let severityCounts = severityCounts {
            try encodeContainer.encode(severityCounts, forKey: .severityCounts)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let vulnerabilityId = vulnerabilityId {
            try encodeContainer.encode(vulnerabilityId, forKey: .vulnerabilityId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let vulnerabilityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vulnerabilityId)
        vulnerabilityId = vulnerabilityIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let severityCountsDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.SeverityCounts.self, forKey: .severityCounts)
        severityCounts = severityCountsDecoded
    }
}

extension Inspector2ClientTypes {
    /// A response that contains details on the results of a finding aggregation by title.
    public struct TitleAggregationResponse: Swift.Equatable {
        /// The ID of the Amazon Web Services account associated with the findings.
        public var accountId: Swift.String?
        /// An object that represent the count of matched findings per severity.
        public var severityCounts: Inspector2ClientTypes.SeverityCounts?
        /// The title that the findings were aggregated on.
        /// This member is required.
        public var title: Swift.String?
        /// The vulnerability ID of the finding.
        public var vulnerabilityId: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            severityCounts: Inspector2ClientTypes.SeverityCounts? = nil,
            title: Swift.String? = nil,
            vulnerabilityId: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.severityCounts = severityCounts
            self.title = title
            self.vulnerabilityId = vulnerabilityId
        }
    }

}

extension Inspector2ClientTypes {
    public enum TitleSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case critical
        case high
        case sdkUnknown(Swift.String)

        public static var allCases: [TitleSortBy] {
            return [
                .all,
                .critical,
                .high,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TitleSortBy(rawValue: rawValue) ?? TitleSortBy.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case description
        case filterArn
        case filterCriteria
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let filterArn = filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let filterCriteria = filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/filters/update"
    }
}

public struct UpdateFilterInput: Swift.Equatable {
    /// Specifies the action that is to be applied to the findings that match the filter.
    public var action: Inspector2ClientTypes.FilterAction?
    /// A description of the filter.
    public var description: Swift.String?
    /// The Amazon Resource Number (ARN) of the filter to update.
    /// This member is required.
    public var filterArn: Swift.String?
    /// Defines the criteria to be update in the filter.
    public var filterCriteria: Inspector2ClientTypes.FilterCriteria?
    /// The name of the filter.
    public var name: Swift.String?

    public init (
        action: Inspector2ClientTypes.FilterAction? = nil,
        description: Swift.String? = nil,
        filterArn: Swift.String? = nil,
        filterCriteria: Inspector2ClientTypes.FilterCriteria? = nil,
        name: Swift.String? = nil
    )
    {
        self.action = action
        self.description = description
        self.filterArn = filterArn
        self.filterCriteria = filterCriteria
        self.name = name
    }
}

struct UpdateFilterInputBody: Swift.Equatable {
    let action: Inspector2ClientTypes.FilterAction?
    let description: Swift.String?
    let filterCriteria: Inspector2ClientTypes.FilterCriteria?
    let name: Swift.String?
    let filterArn: Swift.String?
}

extension UpdateFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case description
        case filterArn
        case filterCriteria
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterAction.self, forKey: .action)
        action = actionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
    }
}

extension UpdateFilterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFilterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFilterOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFilterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFilterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct UpdateFilterOutputResponse: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the successfully updated filter.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct UpdateFilterOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension UpdateFilterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension UpdateOrganizationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoEnable = autoEnable {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }
}

extension UpdateOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organizationconfiguration/update"
    }
}

public struct UpdateOrganizationConfigurationInput: Swift.Equatable {
    /// Defines which scan types are enabled automatically for new members of your Amazon Inspector organization.
    /// This member is required.
    public var autoEnable: Inspector2ClientTypes.AutoEnable?

    public init (
        autoEnable: Inspector2ClientTypes.AutoEnable? = nil
    )
    {
        self.autoEnable = autoEnable
    }
}

struct UpdateOrganizationConfigurationInputBody: Swift.Equatable {
    let autoEnable: Inspector2ClientTypes.AutoEnable?
}

extension UpdateOrganizationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AutoEnable.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
    }
}

extension UpdateOrganizationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateOrganizationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOrganizationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOrganizationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateOrganizationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoEnable = output.autoEnable
        } else {
            self.autoEnable = nil
        }
    }
}

public struct UpdateOrganizationConfigurationOutputResponse: Swift.Equatable {
    /// The updated status of scan types automatically enabled for new members of your Amazon Inspector organization.
    /// This member is required.
    public var autoEnable: Inspector2ClientTypes.AutoEnable?

    public init (
        autoEnable: Inspector2ClientTypes.AutoEnable? = nil
    )
    {
        self.autoEnable = autoEnable
    }
}

struct UpdateOrganizationConfigurationOutputResponseBody: Swift.Equatable {
    let autoEnable: Inspector2ClientTypes.AutoEnable?
}

extension UpdateOrganizationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.AutoEnable.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
    }
}

extension Inspector2ClientTypes.Usage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currency
        case estimatedMonthlyCost
        case total
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currency = currency {
            try encodeContainer.encode(currency.rawValue, forKey: .currency)
        }
        if estimatedMonthlyCost != 0.0 {
            try encodeContainer.encode(estimatedMonthlyCost, forKey: .estimatedMonthlyCost)
        }
        if total != 0.0 {
            try encodeContainer.encode(total, forKey: .total)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.UsageType.self, forKey: .type)
        type = typeDecoded
        let totalDecoded = try containerValues.decode(Swift.Double.self, forKey: .total)
        total = totalDecoded
        let estimatedMonthlyCostDecoded = try containerValues.decode(Swift.Double.self, forKey: .estimatedMonthlyCost)
        estimatedMonthlyCost = estimatedMonthlyCostDecoded
        let currencyDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.Currency.self, forKey: .currency)
        currency = currencyDecoded
    }
}

extension Inspector2ClientTypes {
    /// Contains usage information about the cost of Amazon Inspector operation.
    public struct Usage: Swift.Equatable {
        /// The currency type used when calculating usage data.
        public var currency: Inspector2ClientTypes.Currency?
        /// The estimated monthly cost of Amazon Inspector.
        public var estimatedMonthlyCost: Swift.Double
        /// The total of usage.
        public var total: Swift.Double
        /// The type scan.
        public var type: Inspector2ClientTypes.UsageType?

        public init (
            currency: Inspector2ClientTypes.Currency? = nil,
            estimatedMonthlyCost: Swift.Double = 0.0,
            total: Swift.Double = 0.0,
            type: Inspector2ClientTypes.UsageType? = nil
        )
        {
            self.currency = currency
            self.estimatedMonthlyCost = estimatedMonthlyCost
            self.total = total
            self.type = type
        }
    }

}

extension Inspector2ClientTypes.UsageTotal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case usage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let usage = usage {
            var usageContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usage)
            for usagelist0 in usage {
                try usageContainer.encode(usagelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let usageContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.Usage?].self, forKey: .usage)
        var usageDecoded0:[Inspector2ClientTypes.Usage]? = nil
        if let usageContainer = usageContainer {
            usageDecoded0 = [Inspector2ClientTypes.Usage]()
            for structure0 in usageContainer {
                if let structure0 = structure0 {
                    usageDecoded0?.append(structure0)
                }
            }
        }
        usage = usageDecoded0
    }
}

extension Inspector2ClientTypes {
    /// The total of usage for an account ID.
    public struct UsageTotal: Swift.Equatable {
        /// The account ID of the account that usage data was retrieved for.
        public var accountId: Swift.String?
        /// An object representing the total usage for an account.
        public var usage: [Inspector2ClientTypes.Usage]?

        public init (
            accountId: Swift.String? = nil,
            usage: [Inspector2ClientTypes.Usage]? = nil
        )
        {
            self.accountId = accountId
            self.usage = usage
        }
    }

}

extension Inspector2ClientTypes {
    public enum UsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2InstanceHours
        case ecrInitialScan
        case ecrRescan
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageType] {
            return [
                .ec2InstanceHours,
                .ecrInitialScan,
                .ecrRescan,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2InstanceHours: return "EC2_INSTANCE_HOURS"
            case .ecrInitialScan: return "ECR_INITIAL_SCAN"
            case .ecrRescan: return "ECR_RESCAN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageType(rawValue: rawValue) ?? UsageType.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request has failed validation due to missing required fields or having invalid inputs.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The fields that failed validation.
    public var fields: [Inspector2ClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// The reason for the validation failure.
    /// This member is required.
    public var reason: Inspector2ClientTypes.ValidationExceptionReason?

    public init (
        fields: [Inspector2ClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: Inspector2ClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: Inspector2ClientTypes.ValidationExceptionReason?
    let fields: [Inspector2ClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Inspector2ClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[Inspector2ClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Inspector2ClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension Inspector2ClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Inspector2ClientTypes {
    /// An object that describes a validation exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The validation exception message.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the validation exception.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension Inspector2ClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension Inspector2ClientTypes.VulnerablePackage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arch
        case epoch
        case filePath
        case fixedInVersion
        case name
        case packageManager
        case release
        case sourceLayerHash
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arch = arch {
            try encodeContainer.encode(arch, forKey: .arch)
        }
        if epoch != 0 {
            try encodeContainer.encode(epoch, forKey: .epoch)
        }
        if let filePath = filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let fixedInVersion = fixedInVersion {
            try encodeContainer.encode(fixedInVersion, forKey: .fixedInVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packageManager = packageManager {
            try encodeContainer.encode(packageManager.rawValue, forKey: .packageManager)
        }
        if let release = release {
            try encodeContainer.encode(release, forKey: .release)
        }
        if let sourceLayerHash = sourceLayerHash {
            try encodeContainer.encode(sourceLayerHash, forKey: .sourceLayerHash)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let sourceLayerHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLayerHash)
        sourceLayerHash = sourceLayerHashDecoded
        let epochDecoded = try containerValues.decode(Swift.Int.self, forKey: .epoch)
        epoch = epochDecoded
        let releaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .release)
        release = releaseDecoded
        let archDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arch)
        arch = archDecoded
        let packageManagerDecoded = try containerValues.decodeIfPresent(Inspector2ClientTypes.PackageManager.self, forKey: .packageManager)
        packageManager = packageManagerDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fixedInVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fixedInVersion)
        fixedInVersion = fixedInVersionDecoded
    }
}

extension Inspector2ClientTypes {
    /// Information on the vulnerable package identified by a finding.
    public struct VulnerablePackage: Swift.Equatable {
        /// The architecture of the vulnerable package.
        public var arch: Swift.String?
        /// The epoch of the vulnerable package.
        public var epoch: Swift.Int
        /// The file path of the vulnerable package.
        public var filePath: Swift.String?
        /// The version of the package that contains the vulnerability fix.
        public var fixedInVersion: Swift.String?
        /// The name of the vulnerable package.
        /// This member is required.
        public var name: Swift.String?
        /// The package manager of the vulnerable package.
        public var packageManager: Inspector2ClientTypes.PackageManager?
        /// The release of the vulnerable package.
        public var release: Swift.String?
        /// The source layer hash of the vulnerable package.
        public var sourceLayerHash: Swift.String?
        /// The version of the vulnerable package.
        /// This member is required.
        public var version: Swift.String?

        public init (
            arch: Swift.String? = nil,
            epoch: Swift.Int = 0,
            filePath: Swift.String? = nil,
            fixedInVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            packageManager: Inspector2ClientTypes.PackageManager? = nil,
            release: Swift.String? = nil,
            sourceLayerHash: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arch = arch
            self.epoch = epoch
            self.filePath = filePath
            self.fixedInVersion = fixedInVersion
            self.name = name
            self.packageManager = packageManager
            self.release = release
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }
    }

}
