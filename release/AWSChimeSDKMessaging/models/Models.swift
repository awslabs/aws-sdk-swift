// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ChimeSDKMessagingClientTypes {
    public enum AllowNotifications: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case filtered
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AllowNotifications] {
            return [
                .all,
                .filtered,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .filtered: return "FILTERED"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AllowNotifications(rawValue: rawValue) ?? AllowNotifications.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMessagingClientTypes.AppInstanceUserMembershipSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readMarkerTimestamp = "ReadMarkerTimestamp"
        case subChannelId = "SubChannelId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readMarkerTimestamp = self.readMarkerTimestamp {
            try encodeContainer.encodeTimestamp(readMarkerTimestamp, format: .epochSeconds, forKey: .readMarkerTimestamp)
        }
        if let subChannelId = self.subChannelId {
            try encodeContainer.encode(subChannelId, forKey: .subChannelId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let readMarkerTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .readMarkerTimestamp)
        readMarkerTimestamp = readMarkerTimestampDecoded
        let subChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subChannelId)
        subChannelId = subChannelIdDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// Summary of the membership details of an AppInstanceUser.
    public struct AppInstanceUserMembershipSummary: Swift.Equatable {
        /// The time at which an AppInstanceUser last marked a channel as read.
        public var readMarkerTimestamp: ClientRuntime.Date?
        /// The ID of the SubChannel that the AppInstanceUser is a member of.
        public var subChannelId: Swift.String?
        /// The type of ChannelMembership.
        public var type: ChimeSDKMessagingClientTypes.ChannelMembershipType?

        public init (
            readMarkerTimestamp: ClientRuntime.Date? = nil,
            subChannelId: Swift.String? = nil,
            type: ChimeSDKMessagingClientTypes.ChannelMembershipType? = nil
        )
        {
            self.readMarkerTimestamp = readMarkerTimestamp
            self.subChannelId = subChannelId
            self.type = type
        }
    }

}

extension AssociateChannelFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelFlowArn = "ChannelFlowArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelFlowArn = self.channelFlowArn {
            try encodeContainer.encode(channelFlowArn, forKey: .channelFlowArn)
        }
    }
}

extension AssociateChannelFlowInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension AssociateChannelFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/channel-flow"
    }
}

public struct AssociateChannelFlowInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the channel flow.
    /// This member is required.
    public var channelFlowArn: Swift.String?
    /// The AppInstanceUserArn of the user making the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelFlowArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelFlowArn = channelFlowArn
        self.chimeBearer = chimeBearer
    }
}

struct AssociateChannelFlowInputBody: Swift.Equatable {
    let channelFlowArn: Swift.String?
}

extension AssociateChannelFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelFlowArn = "ChannelFlowArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelFlowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelFlowArn)
        channelFlowArn = channelFlowArnDecoded
    }
}

extension AssociateChannelFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateChannelFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateChannelFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateChannelFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateChannelFlowOutputResponse: Swift.Equatable {

    public init () { }
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let code: ChimeSDKMessagingClientTypes.ErrorCode?
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKMessagingClientTypes.BatchChannelMemberships: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case invitedBy = "InvitedBy"
        case members = "Members"
        case subChannelId = "SubChannelId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let invitedBy = self.invitedBy {
            try encodeContainer.encode(invitedBy, forKey: .invitedBy)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for identity0 in members {
                try membersContainer.encode(identity0)
            }
        }
        if let subChannelId = self.subChannelId {
            try encodeContainer.encode(subChannelId, forKey: .subChannelId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitedByDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Identity.self, forKey: .invitedBy)
        invitedBy = invitedByDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let membersContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.Identity?].self, forKey: .members)
        var membersDecoded0:[ChimeSDKMessagingClientTypes.Identity]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [ChimeSDKMessagingClientTypes.Identity]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let subChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subChannelId)
        subChannelId = subChannelIdDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// The membership information, including member ARNs, the channel ARN, and membership types.
    public struct BatchChannelMemberships: Swift.Equatable {
        /// The ARN of the channel to which you're adding users.
        public var channelArn: Swift.String?
        /// The identifier of the member who invited another member.
        public var invitedBy: ChimeSDKMessagingClientTypes.Identity?
        /// The users successfully added to the request.
        public var members: [ChimeSDKMessagingClientTypes.Identity]?
        /// The ID of the SubChannel.
        public var subChannelId: Swift.String?
        /// The membership types set for the channel users.
        public var type: ChimeSDKMessagingClientTypes.ChannelMembershipType?

        public init (
            channelArn: Swift.String? = nil,
            invitedBy: ChimeSDKMessagingClientTypes.Identity? = nil,
            members: [ChimeSDKMessagingClientTypes.Identity]? = nil,
            subChannelId: Swift.String? = nil,
            type: ChimeSDKMessagingClientTypes.ChannelMembershipType? = nil
        )
        {
            self.channelArn = channelArn
            self.invitedBy = invitedBy
            self.members = members
            self.subChannelId = subChannelId
            self.type = type
        }
    }

}

extension ChimeSDKMessagingClientTypes.BatchCreateChannelMembershipError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case memberArn = "MemberArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let memberArn = self.memberArn {
            try encodeContainer.encode(memberArn, forKey: .memberArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberArn)
        memberArn = memberArnDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// A list of failed member ARNs, error codes, and error messages.
    public struct BatchCreateChannelMembershipError: Swift.Equatable {
        /// The error code.
        public var errorCode: ChimeSDKMessagingClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The AppInstanceUserArn of the member that the service couldn't add.
        public var memberArn: Swift.String?

        public init (
            errorCode: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            memberArn: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.memberArn = memberArn
        }
    }

}

extension BatchCreateChannelMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArns = "MemberArns"
        case subChannelId = "SubChannelId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberArns = memberArns {
            var memberArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .memberArns)
            for chimearn0 in memberArns {
                try memberArnsContainer.encode(chimearn0)
            }
        }
        if let subChannelId = self.subChannelId {
            try encodeContainer.encode(subChannelId, forKey: .subChannelId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension BatchCreateChannelMembershipInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension BatchCreateChannelMembershipInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "batch-create"))
            return items
        }
    }
}

extension BatchCreateChannelMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships"
    }
}

public struct BatchCreateChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel to which you're adding users.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The AppInstanceUserArns of the members you want to add to the channel.
    /// This member is required.
    public var memberArns: [Swift.String]?
    /// The ID of the SubChannel in the request. Only required when creating membership in a SubChannel for a moderator in an elastic channel.
    public var subChannelId: Swift.String?
    /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned. This is only supported by moderators.
    public var type: ChimeSDKMessagingClientTypes.ChannelMembershipType?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArns: [Swift.String]? = nil,
        subChannelId: Swift.String? = nil,
        type: ChimeSDKMessagingClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArns = memberArns
        self.subChannelId = subChannelId
        self.type = type
    }
}

struct BatchCreateChannelMembershipInputBody: Swift.Equatable {
    let type: ChimeSDKMessagingClientTypes.ChannelMembershipType?
    let memberArns: [Swift.String]?
    let subChannelId: Swift.String?
}

extension BatchCreateChannelMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArns = "MemberArns"
        case subChannelId = "SubChannelId"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let memberArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .memberArns)
        var memberArnsDecoded0:[Swift.String]? = nil
        if let memberArnsContainer = memberArnsContainer {
            memberArnsDecoded0 = [Swift.String]()
            for string0 in memberArnsContainer {
                if let string0 = string0 {
                    memberArnsDecoded0?.append(string0)
                }
            }
        }
        memberArns = memberArnsDecoded0
        let subChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subChannelId)
        subChannelId = subChannelIdDecoded
    }
}

extension BatchCreateChannelMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCreateChannelMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchCreateChannelMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCreateChannelMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchCreateChannelMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.batchChannelMemberships = output.batchChannelMemberships
            self.errors = output.errors
        } else {
            self.batchChannelMemberships = nil
            self.errors = nil
        }
    }
}

public struct BatchCreateChannelMembershipOutputResponse: Swift.Equatable {
    /// The list of channel memberships in the response.
    public var batchChannelMemberships: ChimeSDKMessagingClientTypes.BatchChannelMemberships?
    /// If the action fails for one or more of the memberships in the request, a list of the memberships is returned, along with error codes and error messages.
    public var errors: [ChimeSDKMessagingClientTypes.BatchCreateChannelMembershipError]?

    public init (
        batchChannelMemberships: ChimeSDKMessagingClientTypes.BatchChannelMemberships? = nil,
        errors: [ChimeSDKMessagingClientTypes.BatchCreateChannelMembershipError]? = nil
    )
    {
        self.batchChannelMemberships = batchChannelMemberships
        self.errors = errors
    }
}

struct BatchCreateChannelMembershipOutputResponseBody: Swift.Equatable {
    let batchChannelMemberships: ChimeSDKMessagingClientTypes.BatchChannelMemberships?
    let errors: [ChimeSDKMessagingClientTypes.BatchCreateChannelMembershipError]?
}

extension BatchCreateChannelMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchChannelMemberships = "BatchChannelMemberships"
        case errors = "Errors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchChannelMembershipsDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.BatchChannelMemberships.self, forKey: .batchChannelMemberships)
        batchChannelMemberships = batchChannelMembershipsDecoded
        let errorsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.BatchCreateChannelMembershipError?].self, forKey: .errors)
        var errorsDecoded0:[ChimeSDKMessagingClientTypes.BatchCreateChannelMembershipError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ChimeSDKMessagingClientTypes.BatchCreateChannelMembershipError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension ChimeSDKMessagingClientTypes.Channel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelFlowArn = "ChannelFlowArn"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case elasticChannelConfiguration = "ElasticChannelConfiguration"
        case lastMessageTimestamp = "LastMessageTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let channelFlowArn = self.channelFlowArn {
            try encodeContainer.encode(channelFlowArn, forKey: .channelFlowArn)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let elasticChannelConfiguration = self.elasticChannelConfiguration {
            try encodeContainer.encode(elasticChannelConfiguration, forKey: .elasticChannelConfiguration)
        }
        if let lastMessageTimestamp = self.lastMessageTimestamp {
            try encodeContainer.encodeTimestamp(lastMessageTimestamp, format: .epochSeconds, forKey: .lastMessageTimestamp)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let privacy = self.privacy {
            try encodeContainer.encode(privacy.rawValue, forKey: .privacy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let privacyDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelPrivacy.self, forKey: .privacy)
        privacy = privacyDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Identity.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastMessageTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastMessageTimestamp)
        lastMessageTimestamp = lastMessageTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let channelFlowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelFlowArn)
        channelFlowArn = channelFlowArnDecoded
        let elasticChannelConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ElasticChannelConfiguration.self, forKey: .elasticChannelConfiguration)
        elasticChannelConfiguration = elasticChannelConfigurationDecoded
    }
}

extension ChimeSDKMessagingClientTypes.Channel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Channel(channelArn: \(Swift.String(describing: channelArn)), channelFlowArn: \(Swift.String(describing: channelFlowArn)), createdBy: \(Swift.String(describing: createdBy)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), elasticChannelConfiguration: \(Swift.String(describing: elasticChannelConfiguration)), lastMessageTimestamp: \(Swift.String(describing: lastMessageTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), mode: \(Swift.String(describing: mode)), privacy: \(Swift.String(describing: privacy)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {
    /// The details of a channel.
    public struct Channel: Swift.Equatable {
        /// The ARN of a channel.
        public var channelArn: Swift.String?
        /// The ARN of the channel flow.
        public var channelFlowArn: Swift.String?
        /// The AppInstanceUser who created the channel.
        public var createdBy: ChimeSDKMessagingClientTypes.Identity?
        /// The time at which the AppInstanceUser created the channel.
        public var createdTimestamp: ClientRuntime.Date?
        /// The attributes required to configure and create an elastic channel. An elastic channel can support a maximum of 1-million members.
        public var elasticChannelConfiguration: ChimeSDKMessagingClientTypes.ElasticChannelConfiguration?
        /// The time at which a member sent the last message in the channel.
        public var lastMessageTimestamp: ClientRuntime.Date?
        /// The time at which a channel was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The channel's metadata.
        public var metadata: Swift.String?
        /// The mode of the channel.
        public var mode: ChimeSDKMessagingClientTypes.ChannelMode?
        /// The name of a channel.
        public var name: Swift.String?
        /// The channel's privacy setting.
        public var privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy?

        public init (
            channelArn: Swift.String? = nil,
            channelFlowArn: Swift.String? = nil,
            createdBy: ChimeSDKMessagingClientTypes.Identity? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            elasticChannelConfiguration: ChimeSDKMessagingClientTypes.ElasticChannelConfiguration? = nil,
            lastMessageTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            mode: ChimeSDKMessagingClientTypes.ChannelMode? = nil,
            name: Swift.String? = nil,
            privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy? = nil
        )
        {
            self.channelArn = channelArn
            self.channelFlowArn = channelFlowArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.elasticChannelConfiguration = elasticChannelConfiguration
            self.lastMessageTimestamp = lastMessageTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }
    }

}

extension ChimeSDKMessagingClientTypes.ChannelAssociatedWithFlowSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let privacy = self.privacy {
            try encodeContainer.encode(privacy.rawValue, forKey: .privacy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let privacyDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelPrivacy.self, forKey: .privacy)
        privacy = privacyDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ChimeSDKMessagingClientTypes.ChannelAssociatedWithFlowSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelAssociatedWithFlowSummary(channelArn: \(Swift.String(describing: channelArn)), mode: \(Swift.String(describing: mode)), privacy: \(Swift.String(describing: privacy)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {
    /// Summary of details of a channel associated with channel flow.
    public struct ChannelAssociatedWithFlowSummary: Swift.Equatable {
        /// The ARN of the channel.
        public var channelArn: Swift.String?
        /// The channel's metadata.
        public var metadata: Swift.String?
        /// The mode of the channel.
        public var mode: ChimeSDKMessagingClientTypes.ChannelMode?
        /// The name of the channel flow.
        public var name: Swift.String?
        /// The channel's privacy setting.
        public var privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy?

        public init (
            channelArn: Swift.String? = nil,
            metadata: Swift.String? = nil,
            mode: ChimeSDKMessagingClientTypes.ChannelMode? = nil,
            name: Swift.String? = nil,
            privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy? = nil
        )
        {
            self.channelArn = channelArn
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }
    }

}

extension ChimeSDKMessagingClientTypes.ChannelBan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case member = "Member"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let member = self.member {
            try encodeContainer.encode(member, forKey: .member)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Identity.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// The details of a channel ban.
    public struct ChannelBan: Swift.Equatable {
        /// The ARN of the channel from which a member is being banned.
        public var channelArn: Swift.String?
        /// The AppInstanceUser who created the ban.
        public var createdBy: ChimeSDKMessagingClientTypes.Identity?
        /// The time at which the ban was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The member being banned from the channel.
        public var member: ChimeSDKMessagingClientTypes.Identity?

        public init (
            channelArn: Swift.String? = nil,
            createdBy: ChimeSDKMessagingClientTypes.Identity? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            member: ChimeSDKMessagingClientTypes.Identity? = nil
        )
        {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.member = member
        }
    }

}

extension ChimeSDKMessagingClientTypes.ChannelBanSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member = "Member"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let member = self.member {
            try encodeContainer.encode(member, forKey: .member)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// Summary of the details of a ChannelBan.
    public struct ChannelBanSummary: Swift.Equatable {
        /// The member being banned from a channel.
        public var member: ChimeSDKMessagingClientTypes.Identity?

        public init (
            member: ChimeSDKMessagingClientTypes.Identity? = nil
        )
        {
            self.member = member
        }
    }

}

extension ChimeSDKMessagingClientTypes.ChannelFlow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelFlowArn = "ChannelFlowArn"
        case createdTimestamp = "CreatedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case name = "Name"
        case processors = "Processors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelFlowArn = self.channelFlowArn {
            try encodeContainer.encode(channelFlowArn, forKey: .channelFlowArn)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let processors = processors {
            var processorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processors)
            for processor0 in processors {
                try processorsContainer.encode(processor0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelFlowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelFlowArn)
        channelFlowArn = channelFlowArnDecoded
        let processorsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.Processor?].self, forKey: .processors)
        var processorsDecoded0:[ChimeSDKMessagingClientTypes.Processor]? = nil
        if let processorsContainer = processorsContainer {
            processorsDecoded0 = [ChimeSDKMessagingClientTypes.Processor]()
            for structure0 in processorsContainer {
                if let structure0 = structure0 {
                    processorsDecoded0?.append(structure0)
                }
            }
        }
        processors = processorsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension ChimeSDKMessagingClientTypes.ChannelFlow: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelFlow(channelFlowArn: \(Swift.String(describing: channelFlowArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), processors: \(Swift.String(describing: processors)), name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {
    /// The details of a channel flow.
    public struct ChannelFlow: Swift.Equatable {
        /// The ARN of the channel flow.
        public var channelFlowArn: Swift.String?
        /// The time at which the channel flow was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which a channel flow was updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The name of the channel flow.
        public var name: Swift.String?
        /// Information about the processor Lambda functions.
        public var processors: [ChimeSDKMessagingClientTypes.Processor]?

        public init (
            channelFlowArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            processors: [ChimeSDKMessagingClientTypes.Processor]? = nil
        )
        {
            self.channelFlowArn = channelFlowArn
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.name = name
            self.processors = processors
        }
    }

}

extension ChannelFlowCallbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callbackId = "CallbackId"
        case channelMessage = "ChannelMessage"
        case deleteResource = "DeleteResource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callbackId = self.callbackId {
            try encodeContainer.encode(callbackId, forKey: .callbackId)
        }
        if let channelMessage = self.channelMessage {
            try encodeContainer.encode(channelMessage, forKey: .channelMessage)
        }
        if deleteResource != false {
            try encodeContainer.encode(deleteResource, forKey: .deleteResource)
        }
    }
}

extension ChannelFlowCallbackInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "channel-flow-callback"))
            return items
        }
    }
}

extension ChannelFlowCallbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

public struct ChannelFlowCallbackInput: Swift.Equatable {
    /// The identifier passed to the processor by the service when invoked. Use the identifier to call back the service.
    /// This member is required.
    public var callbackId: Swift.String?
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// Stores information about the processed message.
    /// This member is required.
    public var channelMessage: ChimeSDKMessagingClientTypes.ChannelMessageCallback?
    /// When a processor determines that a message needs to be DENIED, pass this parameter with a value of true.
    public var deleteResource: Swift.Bool

    public init (
        callbackId: Swift.String? = nil,
        channelArn: Swift.String? = nil,
        channelMessage: ChimeSDKMessagingClientTypes.ChannelMessageCallback? = nil,
        deleteResource: Swift.Bool = false
    )
    {
        self.callbackId = callbackId
        self.channelArn = channelArn
        self.channelMessage = channelMessage
        self.deleteResource = deleteResource
    }
}

struct ChannelFlowCallbackInputBody: Swift.Equatable {
    let callbackId: Swift.String?
    let deleteResource: Swift.Bool
    let channelMessage: ChimeSDKMessagingClientTypes.ChannelMessageCallback?
}

extension ChannelFlowCallbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callbackId = "CallbackId"
        case channelMessage = "ChannelMessage"
        case deleteResource = "DeleteResource"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callbackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callbackId)
        callbackId = callbackIdDecoded
        let deleteResourceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteResource) ?? false
        deleteResource = deleteResourceDecoded
        let channelMessageDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMessageCallback.self, forKey: .channelMessage)
        channelMessage = channelMessageDecoded
    }
}

extension ChannelFlowCallbackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ChannelFlowCallbackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ChannelFlowCallbackOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ChannelFlowCallbackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ChannelFlowCallbackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.callbackId = output.callbackId
            self.channelArn = output.channelArn
        } else {
            self.callbackId = nil
            self.channelArn = nil
        }
    }
}

public struct ChannelFlowCallbackOutputResponse: Swift.Equatable {
    /// The call back ID passed in the request.
    public var callbackId: Swift.String?
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init (
        callbackId: Swift.String? = nil,
        channelArn: Swift.String? = nil
    )
    {
        self.callbackId = callbackId
        self.channelArn = channelArn
    }
}

struct ChannelFlowCallbackOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let callbackId: Swift.String?
}

extension ChannelFlowCallbackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callbackId = "CallbackId"
        case channelArn = "ChannelArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let callbackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callbackId)
        callbackId = callbackIdDecoded
    }
}

extension ChimeSDKMessagingClientTypes.ChannelFlowSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelFlowArn = "ChannelFlowArn"
        case name = "Name"
        case processors = "Processors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelFlowArn = self.channelFlowArn {
            try encodeContainer.encode(channelFlowArn, forKey: .channelFlowArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let processors = processors {
            var processorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processors)
            for processor0 in processors {
                try processorsContainer.encode(processor0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelFlowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelFlowArn)
        channelFlowArn = channelFlowArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let processorsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.Processor?].self, forKey: .processors)
        var processorsDecoded0:[ChimeSDKMessagingClientTypes.Processor]? = nil
        if let processorsContainer = processorsContainer {
            processorsDecoded0 = [ChimeSDKMessagingClientTypes.Processor]()
            for structure0 in processorsContainer {
                if let structure0 = structure0 {
                    processorsDecoded0?.append(structure0)
                }
            }
        }
        processors = processorsDecoded0
    }
}

extension ChimeSDKMessagingClientTypes.ChannelFlowSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelFlowSummary(channelFlowArn: \(Swift.String(describing: channelFlowArn)), processors: \(Swift.String(describing: processors)), name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {
    /// Summary of details of a channel flow.
    public struct ChannelFlowSummary: Swift.Equatable {
        /// The ARN of the channel flow.
        public var channelFlowArn: Swift.String?
        /// The name of the channel flow.
        public var name: Swift.String?
        /// Information about the processor Lambda functions.
        public var processors: [ChimeSDKMessagingClientTypes.Processor]?

        public init (
            channelFlowArn: Swift.String? = nil,
            name: Swift.String? = nil,
            processors: [ChimeSDKMessagingClientTypes.Processor]? = nil
        )
        {
            self.channelFlowArn = channelFlowArn
            self.name = name
            self.processors = processors
        }
    }

}

extension ChimeSDKMessagingClientTypes.ChannelMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case createdTimestamp = "CreatedTimestamp"
        case invitedBy = "InvitedBy"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case member = "Member"
        case subChannelId = "SubChannelId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let invitedBy = self.invitedBy {
            try encodeContainer.encode(invitedBy, forKey: .invitedBy)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let member = self.member {
            try encodeContainer.encode(member, forKey: .member)
        }
        if let subChannelId = self.subChannelId {
            try encodeContainer.encode(subChannelId, forKey: .subChannelId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitedByDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Identity.self, forKey: .invitedBy)
        invitedBy = invitedByDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let subChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subChannelId)
        subChannelId = subChannelIdDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// The details of a channel member.
    public struct ChannelMembership: Swift.Equatable {
        /// The ARN of the member's channel.
        public var channelArn: Swift.String?
        /// The time at which the channel membership was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The identifier of the member who invited another member.
        public var invitedBy: ChimeSDKMessagingClientTypes.Identity?
        /// The time at which a channel membership was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The data of the channel member.
        public var member: ChimeSDKMessagingClientTypes.Identity?
        /// The ID of the SubChannel that a user belongs to.
        public var subChannelId: Swift.String?
        /// The membership type set for the channel member.
        public var type: ChimeSDKMessagingClientTypes.ChannelMembershipType?

        public init (
            channelArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            invitedBy: ChimeSDKMessagingClientTypes.Identity? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            member: ChimeSDKMessagingClientTypes.Identity? = nil,
            subChannelId: Swift.String? = nil,
            type: ChimeSDKMessagingClientTypes.ChannelMembershipType? = nil
        )
        {
            self.channelArn = channelArn
            self.createdTimestamp = createdTimestamp
            self.invitedBy = invitedBy
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.member = member
            self.subChannelId = subChannelId
            self.type = type
        }
    }

}

extension ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserMembershipSummary = "AppInstanceUserMembershipSummary"
        case channelSummary = "ChannelSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceUserMembershipSummary = self.appInstanceUserMembershipSummary {
            try encodeContainer.encode(appInstanceUserMembershipSummary, forKey: .appInstanceUserMembershipSummary)
        }
        if let channelSummary = self.channelSummary {
            try encodeContainer.encode(channelSummary, forKey: .channelSummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelSummaryDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelSummary.self, forKey: .channelSummary)
        channelSummary = channelSummaryDecoded
        let appInstanceUserMembershipSummaryDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.AppInstanceUserMembershipSummary.self, forKey: .appInstanceUserMembershipSummary)
        appInstanceUserMembershipSummary = appInstanceUserMembershipSummaryDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// Summary of the channel membership details of an AppInstanceUser.
    public struct ChannelMembershipForAppInstanceUserSummary: Swift.Equatable {
        /// Returns the channel membership data for an AppInstance.
        public var appInstanceUserMembershipSummary: ChimeSDKMessagingClientTypes.AppInstanceUserMembershipSummary?
        /// Returns the channel data for an AppInstance.
        public var channelSummary: ChimeSDKMessagingClientTypes.ChannelSummary?

        public init (
            appInstanceUserMembershipSummary: ChimeSDKMessagingClientTypes.AppInstanceUserMembershipSummary? = nil,
            channelSummary: ChimeSDKMessagingClientTypes.ChannelSummary? = nil
        )
        {
            self.appInstanceUserMembershipSummary = appInstanceUserMembershipSummary
            self.channelSummary = channelSummary
        }
    }

}

extension ChimeSDKMessagingClientTypes.ChannelMembershipPreferences: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pushNotifications = "PushNotifications"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pushNotifications = self.pushNotifications {
            try encodeContainer.encode(pushNotifications, forKey: .pushNotifications)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pushNotificationsDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.PushNotificationPreferences.self, forKey: .pushNotifications)
        pushNotifications = pushNotificationsDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// The channel membership preferences for an AppInstanceUser.
    public struct ChannelMembershipPreferences: Swift.Equatable {
        /// The push notification configuration of a message.
        public var pushNotifications: ChimeSDKMessagingClientTypes.PushNotificationPreferences?

        public init (
            pushNotifications: ChimeSDKMessagingClientTypes.PushNotificationPreferences? = nil
        )
        {
            self.pushNotifications = pushNotifications
        }
    }

}

extension ChimeSDKMessagingClientTypes.ChannelMembershipSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member = "Member"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let member = self.member {
            try encodeContainer.encode(member, forKey: .member)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// Summary of the details of a ChannelMembership.
    public struct ChannelMembershipSummary: Swift.Equatable {
        /// A member's summary data.
        public var member: ChimeSDKMessagingClientTypes.Identity?

        public init (
            member: ChimeSDKMessagingClientTypes.Identity? = nil
        )
        {
            self.member = member
        }
    }

}

extension ChimeSDKMessagingClientTypes {
    public enum ChannelMembershipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case hidden
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMembershipType] {
            return [
                .default,
                .hidden,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .hidden: return "HIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMembershipType(rawValue: rawValue) ?? ChannelMembershipType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMessagingClientTypes.ChannelMessage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case content = "Content"
        case createdTimestamp = "CreatedTimestamp"
        case lastEditedTimestamp = "LastEditedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case messageAttributes = "MessageAttributes"
        case messageId = "MessageId"
        case metadata = "Metadata"
        case persistence = "Persistence"
        case redacted = "Redacted"
        case sender = "Sender"
        case status = "Status"
        case subChannelId = "SubChannelId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let lastEditedTimestamp = self.lastEditedTimestamp {
            try encodeContainer.encodeTimestamp(lastEditedTimestamp, format: .epochSeconds, forKey: .lastEditedTimestamp)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let messageAttributes = messageAttributes {
            var messageAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .messageAttributes)
            for (dictKey0, messageAttributeMap0) in messageAttributes {
                try messageAttributesContainer.encode(messageAttributeMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let persistence = self.persistence {
            try encodeContainer.encode(persistence.rawValue, forKey: .persistence)
        }
        if redacted != false {
            try encodeContainer.encode(redacted, forKey: .redacted)
        }
        if let sender = self.sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subChannelId = self.subChannelId {
            try encodeContainer.encode(subChannelId, forKey: .subChannelId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMessageType.self, forKey: .type)
        type = typeDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastEditedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastEditedTimestamp)
        lastEditedTimestamp = lastEditedTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let senderDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Identity.self, forKey: .sender)
        sender = senderDecoded
        let redactedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .redacted) ?? false
        redacted = redactedDecoded
        let persistenceDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMessagePersistenceType.self, forKey: .persistence)
        persistence = persistenceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure.self, forKey: .status)
        status = statusDecoded
        let messageAttributesContainer = try containerValues.decodeIfPresent([Swift.String: ChimeSDKMessagingClientTypes.MessageAttributeValue?].self, forKey: .messageAttributes)
        var messageAttributesDecoded0: [Swift.String:ChimeSDKMessagingClientTypes.MessageAttributeValue]? = nil
        if let messageAttributesContainer = messageAttributesContainer {
            messageAttributesDecoded0 = [Swift.String:ChimeSDKMessagingClientTypes.MessageAttributeValue]()
            for (key0, messageattributevalue0) in messageAttributesContainer {
                if let messageattributevalue0 = messageattributevalue0 {
                    messageAttributesDecoded0?[key0] = messageattributevalue0
                }
            }
        }
        messageAttributes = messageAttributesDecoded0
        let subChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subChannelId)
        subChannelId = subChannelIdDecoded
    }
}

extension ChimeSDKMessagingClientTypes.ChannelMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMessage(channelArn: \(Swift.String(describing: channelArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastEditedTimestamp: \(Swift.String(describing: lastEditedTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), messageAttributes: \(Swift.String(describing: messageAttributes)), messageId: \(Swift.String(describing: messageId)), persistence: \(Swift.String(describing: persistence)), redacted: \(Swift.String(describing: redacted)), sender: \(Swift.String(describing: sender)), status: \(Swift.String(describing: status)), subChannelId: \(Swift.String(describing: subChannelId)), type: \(Swift.String(describing: type)), content: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {
    /// The details of a message in a channel.
    public struct ChannelMessage: Swift.Equatable {
        /// The ARN of the channel.
        public var channelArn: Swift.String?
        /// The message content.
        public var content: Swift.String?
        /// The time at which the message was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which a message was edited.
        public var lastEditedTimestamp: ClientRuntime.Date?
        /// The time at which a message was updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The attributes for the message, used for message filtering along with a FilterRule defined in the PushNotificationPreferences.
        public var messageAttributes: [Swift.String:ChimeSDKMessagingClientTypes.MessageAttributeValue]?
        /// The ID of a message.
        public var messageId: Swift.String?
        /// The message metadata.
        public var metadata: Swift.String?
        /// The persistence setting for a channel message.
        public var persistence: ChimeSDKMessagingClientTypes.ChannelMessagePersistenceType?
        /// Hides the content of a message.
        public var redacted: Swift.Bool
        /// The message sender.
        public var sender: ChimeSDKMessagingClientTypes.Identity?
        /// The status of the channel message.
        public var status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure?
        /// The ID of the SubChannel.
        public var subChannelId: Swift.String?
        /// The message type.
        public var type: ChimeSDKMessagingClientTypes.ChannelMessageType?

        public init (
            channelArn: Swift.String? = nil,
            content: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastEditedTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            messageAttributes: [Swift.String:ChimeSDKMessagingClientTypes.MessageAttributeValue]? = nil,
            messageId: Swift.String? = nil,
            metadata: Swift.String? = nil,
            persistence: ChimeSDKMessagingClientTypes.ChannelMessagePersistenceType? = nil,
            redacted: Swift.Bool = false,
            sender: ChimeSDKMessagingClientTypes.Identity? = nil,
            status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure? = nil,
            subChannelId: Swift.String? = nil,
            type: ChimeSDKMessagingClientTypes.ChannelMessageType? = nil
        )
        {
            self.channelArn = channelArn
            self.content = content
            self.createdTimestamp = createdTimestamp
            self.lastEditedTimestamp = lastEditedTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.messageAttributes = messageAttributes
            self.messageId = messageId
            self.metadata = metadata
            self.persistence = persistence
            self.redacted = redacted
            self.sender = sender
            self.status = status
            self.subChannelId = subChannelId
            self.type = type
        }
    }

}

extension ChimeSDKMessagingClientTypes.ChannelMessageCallback: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case messageAttributes = "MessageAttributes"
        case messageId = "MessageId"
        case metadata = "Metadata"
        case pushNotification = "PushNotification"
        case subChannelId = "SubChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let messageAttributes = messageAttributes {
            var messageAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .messageAttributes)
            for (dictKey0, messageAttributeMap0) in messageAttributes {
                try messageAttributesContainer.encode(messageAttributeMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let pushNotification = self.pushNotification {
            try encodeContainer.encode(pushNotification, forKey: .pushNotification)
        }
        if let subChannelId = self.subChannelId {
            try encodeContainer.encode(subChannelId, forKey: .subChannelId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let pushNotificationDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.PushNotificationConfiguration.self, forKey: .pushNotification)
        pushNotification = pushNotificationDecoded
        let messageAttributesContainer = try containerValues.decodeIfPresent([Swift.String: ChimeSDKMessagingClientTypes.MessageAttributeValue?].self, forKey: .messageAttributes)
        var messageAttributesDecoded0: [Swift.String:ChimeSDKMessagingClientTypes.MessageAttributeValue]? = nil
        if let messageAttributesContainer = messageAttributesContainer {
            messageAttributesDecoded0 = [Swift.String:ChimeSDKMessagingClientTypes.MessageAttributeValue]()
            for (key0, messageattributevalue0) in messageAttributesContainer {
                if let messageattributevalue0 = messageattributevalue0 {
                    messageAttributesDecoded0?[key0] = messageattributevalue0
                }
            }
        }
        messageAttributes = messageAttributesDecoded0
        let subChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subChannelId)
        subChannelId = subChannelIdDecoded
    }
}

extension ChimeSDKMessagingClientTypes.ChannelMessageCallback: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMessageCallback(messageAttributes: \(Swift.String(describing: messageAttributes)), messageId: \(Swift.String(describing: messageId)), pushNotification: \(Swift.String(describing: pushNotification)), subChannelId: \(Swift.String(describing: subChannelId)), content: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {
    /// Stores information about a callback.
    public struct ChannelMessageCallback: Swift.Equatable {
        /// The message content.
        public var content: Swift.String?
        /// The attributes for the message, used for message filtering along with a FilterRule defined in the PushNotificationPreferences.
        public var messageAttributes: [Swift.String:ChimeSDKMessagingClientTypes.MessageAttributeValue]?
        /// The message ID.
        /// This member is required.
        public var messageId: Swift.String?
        /// The message metadata.
        public var metadata: Swift.String?
        /// The push notification configuration of the message.
        public var pushNotification: ChimeSDKMessagingClientTypes.PushNotificationConfiguration?
        /// The ID of the SubChannel.
        public var subChannelId: Swift.String?

        public init (
            content: Swift.String? = nil,
            messageAttributes: [Swift.String:ChimeSDKMessagingClientTypes.MessageAttributeValue]? = nil,
            messageId: Swift.String? = nil,
            metadata: Swift.String? = nil,
            pushNotification: ChimeSDKMessagingClientTypes.PushNotificationConfiguration? = nil,
            subChannelId: Swift.String? = nil
        )
        {
            self.content = content
            self.messageAttributes = messageAttributes
            self.messageId = messageId
            self.metadata = metadata
            self.pushNotification = pushNotification
            self.subChannelId = subChannelId
        }
    }

}

extension ChimeSDKMessagingClientTypes {
    public enum ChannelMessagePersistenceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nonPersistent
        case persistent
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMessagePersistenceType] {
            return [
                .nonPersistent,
                .persistent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nonPersistent: return "NON_PERSISTENT"
            case .persistent: return "PERSISTENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMessagePersistenceType(rawValue: rawValue) ?? ChannelMessagePersistenceType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMessagingClientTypes {
    public enum ChannelMessageStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case denied
        case failed
        case pending
        case sent
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMessageStatus] {
            return [
                .denied,
                .failed,
                .pending,
                .sent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .denied: return "DENIED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .sent: return "SENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMessageStatus(rawValue: rawValue) ?? ChannelMessageStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detail = "Detail"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detail = self.detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
        if let value = self.value {
            try encodeContainer.encode(value.rawValue, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMessageStatus.self, forKey: .value)
        value = valueDecoded
        let detailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detail)
        detail = detailDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// Stores information about a message status.
    public struct ChannelMessageStatusStructure: Swift.Equatable {
        /// Contains more details about the messasge status.
        public var detail: Swift.String?
        /// The message status value.
        public var value: ChimeSDKMessagingClientTypes.ChannelMessageStatus?

        public init (
            detail: Swift.String? = nil,
            value: ChimeSDKMessagingClientTypes.ChannelMessageStatus? = nil
        )
        {
            self.detail = detail
            self.value = value
        }
    }

}

extension ChimeSDKMessagingClientTypes.ChannelMessageSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case createdTimestamp = "CreatedTimestamp"
        case lastEditedTimestamp = "LastEditedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case messageAttributes = "MessageAttributes"
        case messageId = "MessageId"
        case metadata = "Metadata"
        case redacted = "Redacted"
        case sender = "Sender"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let lastEditedTimestamp = self.lastEditedTimestamp {
            try encodeContainer.encodeTimestamp(lastEditedTimestamp, format: .epochSeconds, forKey: .lastEditedTimestamp)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let messageAttributes = messageAttributes {
            var messageAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .messageAttributes)
            for (dictKey0, messageAttributeMap0) in messageAttributes {
                try messageAttributesContainer.encode(messageAttributeMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if redacted != false {
            try encodeContainer.encode(redacted, forKey: .redacted)
        }
        if let sender = self.sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMessageType.self, forKey: .type)
        type = typeDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let lastEditedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastEditedTimestamp)
        lastEditedTimestamp = lastEditedTimestampDecoded
        let senderDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Identity.self, forKey: .sender)
        sender = senderDecoded
        let redactedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .redacted) ?? false
        redacted = redactedDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure.self, forKey: .status)
        status = statusDecoded
        let messageAttributesContainer = try containerValues.decodeIfPresent([Swift.String: ChimeSDKMessagingClientTypes.MessageAttributeValue?].self, forKey: .messageAttributes)
        var messageAttributesDecoded0: [Swift.String:ChimeSDKMessagingClientTypes.MessageAttributeValue]? = nil
        if let messageAttributesContainer = messageAttributesContainer {
            messageAttributesDecoded0 = [Swift.String:ChimeSDKMessagingClientTypes.MessageAttributeValue]()
            for (key0, messageattributevalue0) in messageAttributesContainer {
                if let messageattributevalue0 = messageattributevalue0 {
                    messageAttributesDecoded0?[key0] = messageattributevalue0
                }
            }
        }
        messageAttributes = messageAttributesDecoded0
    }
}

extension ChimeSDKMessagingClientTypes.ChannelMessageSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMessageSummary(createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastEditedTimestamp: \(Swift.String(describing: lastEditedTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), messageAttributes: \(Swift.String(describing: messageAttributes)), messageId: \(Swift.String(describing: messageId)), redacted: \(Swift.String(describing: redacted)), sender: \(Swift.String(describing: sender)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), content: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {
    /// Summary of the messages in a Channel.
    public struct ChannelMessageSummary: Swift.Equatable {
        /// The content of the message.
        public var content: Swift.String?
        /// The time at which the message summary was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which a message was last edited.
        public var lastEditedTimestamp: ClientRuntime.Date?
        /// The time at which a message was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The message attribues listed in a the summary of a channel message.
        public var messageAttributes: [Swift.String:ChimeSDKMessagingClientTypes.MessageAttributeValue]?
        /// The ID of the message.
        public var messageId: Swift.String?
        /// The metadata of the message.
        public var metadata: Swift.String?
        /// Indicates whether a message was redacted.
        public var redacted: Swift.Bool
        /// The message sender.
        public var sender: ChimeSDKMessagingClientTypes.Identity?
        /// The message status. The status value is SENT for messages sent to a channel without a channel flow. For channels associated with channel flow, the value determines the processing stage.
        public var status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure?
        /// The type of message.
        public var type: ChimeSDKMessagingClientTypes.ChannelMessageType?

        public init (
            content: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastEditedTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            messageAttributes: [Swift.String:ChimeSDKMessagingClientTypes.MessageAttributeValue]? = nil,
            messageId: Swift.String? = nil,
            metadata: Swift.String? = nil,
            redacted: Swift.Bool = false,
            sender: ChimeSDKMessagingClientTypes.Identity? = nil,
            status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure? = nil,
            type: ChimeSDKMessagingClientTypes.ChannelMessageType? = nil
        )
        {
            self.content = content
            self.createdTimestamp = createdTimestamp
            self.lastEditedTimestamp = lastEditedTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.messageAttributes = messageAttributes
            self.messageId = messageId
            self.metadata = metadata
            self.redacted = redacted
            self.sender = sender
            self.status = status
            self.type = type
        }
    }

}

extension ChimeSDKMessagingClientTypes {
    public enum ChannelMessageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case control
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMessageType] {
            return [
                .control,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .control: return "CONTROL"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMessageType(rawValue: rawValue) ?? ChannelMessageType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMessagingClientTypes {
    public enum ChannelMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case restricted
        case unrestricted
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMode] {
            return [
                .restricted,
                .unrestricted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .restricted: return "RESTRICTED"
            case .unrestricted: return "UNRESTRICTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelMode(rawValue: rawValue) ?? ChannelMode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelSummary = "ChannelSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelSummary = self.channelSummary {
            try encodeContainer.encode(channelSummary, forKey: .channelSummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelSummaryDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelSummary.self, forKey: .channelSummary)
        channelSummary = channelSummaryDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// Summary of the details of a moderated channel.
    public struct ChannelModeratedByAppInstanceUserSummary: Swift.Equatable {
        /// Summary of the details of a Channel.
        public var channelSummary: ChimeSDKMessagingClientTypes.ChannelSummary?

        public init (
            channelSummary: ChimeSDKMessagingClientTypes.ChannelSummary? = nil
        )
        {
            self.channelSummary = channelSummary
        }
    }

}

extension ChimeSDKMessagingClientTypes.ChannelModerator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case createdBy = "CreatedBy"
        case createdTimestamp = "CreatedTimestamp"
        case moderator = "Moderator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let moderator = self.moderator {
            try encodeContainer.encode(moderator, forKey: .moderator)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moderatorDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Identity.self, forKey: .moderator)
        moderator = moderatorDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Identity.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// The details of a channel moderator.
    public struct ChannelModerator: Swift.Equatable {
        /// The ARN of the moderator's channel.
        public var channelArn: Swift.String?
        /// The AppInstanceUser who created the moderator.
        public var createdBy: ChimeSDKMessagingClientTypes.Identity?
        /// The time at which the moderator was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The moderator's data.
        public var moderator: ChimeSDKMessagingClientTypes.Identity?

        public init (
            channelArn: Swift.String? = nil,
            createdBy: ChimeSDKMessagingClientTypes.Identity? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            moderator: ChimeSDKMessagingClientTypes.Identity? = nil
        )
        {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.moderator = moderator
        }
    }

}

extension ChimeSDKMessagingClientTypes.ChannelModeratorSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case moderator = "Moderator"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let moderator = self.moderator {
            try encodeContainer.encode(moderator, forKey: .moderator)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moderatorDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Identity.self, forKey: .moderator)
        moderator = moderatorDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// Summary of the details of a ChannelModerator.
    public struct ChannelModeratorSummary: Swift.Equatable {
        /// The data for a moderator.
        public var moderator: ChimeSDKMessagingClientTypes.Identity?

        public init (
            moderator: ChimeSDKMessagingClientTypes.Identity? = nil
        )
        {
            self.moderator = moderator
        }
    }

}

extension ChimeSDKMessagingClientTypes {
    public enum ChannelPrivacy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelPrivacy] {
            return [
                .private,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelPrivacy(rawValue: rawValue) ?? ChannelPrivacy.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMessagingClientTypes.ChannelSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case lastMessageTimestamp = "LastMessageTimestamp"
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
        case privacy = "Privacy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let lastMessageTimestamp = self.lastMessageTimestamp {
            try encodeContainer.encodeTimestamp(lastMessageTimestamp, format: .epochSeconds, forKey: .lastMessageTimestamp)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let privacy = self.privacy {
            try encodeContainer.encode(privacy.rawValue, forKey: .privacy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let privacyDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelPrivacy.self, forKey: .privacy)
        privacy = privacyDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let lastMessageTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastMessageTimestamp)
        lastMessageTimestamp = lastMessageTimestampDecoded
    }
}

extension ChimeSDKMessagingClientTypes.ChannelSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelSummary(channelArn: \(Swift.String(describing: channelArn)), lastMessageTimestamp: \(Swift.String(describing: lastMessageTimestamp)), mode: \(Swift.String(describing: mode)), privacy: \(Swift.String(describing: privacy)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {
    /// Summary of the details of a Channel.
    public struct ChannelSummary: Swift.Equatable {
        /// The ARN of the channel.
        public var channelArn: Swift.String?
        /// The time at which the last persistent message in a channel was sent.
        public var lastMessageTimestamp: ClientRuntime.Date?
        /// The metadata of the channel.
        public var metadata: Swift.String?
        /// The mode of the channel.
        public var mode: ChimeSDKMessagingClientTypes.ChannelMode?
        /// The name of the channel.
        public var name: Swift.String?
        /// The privacy setting of the channel.
        public var privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy?

        public init (
            channelArn: Swift.String? = nil,
            lastMessageTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            mode: ChimeSDKMessagingClientTypes.ChannelMode? = nil,
            name: Swift.String? = nil,
            privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy? = nil
        )
        {
            self.channelArn = channelArn
            self.lastMessageTimestamp = lastMessageTimestamp
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let code: ChimeSDKMessagingClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateChannelBanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberArn = self.memberArn {
            try encodeContainer.encode(memberArn, forKey: .memberArn)
        }
    }
}

extension CreateChannelBanInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateChannelBanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans"
    }
}

public struct CreateChannelBanInput: Swift.Equatable {
    /// The ARN of the ban request.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member being banned.
    /// This member is required.
    public var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct CreateChannelBanInputBody: Swift.Equatable {
    let memberArn: Swift.String?
}

extension CreateChannelBanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberArn)
        memberArn = memberArnDecoded
    }
}

extension CreateChannelBanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelBanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateChannelBanOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelBanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateChannelBanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.member = output.member
        } else {
            self.channelArn = nil
            self.member = nil
        }
    }
}

public struct CreateChannelBanOutputResponse: Swift.Equatable {
    /// The ARN of the response to the ban request.
    public var channelArn: Swift.String?
    /// The ChannelArn and BannedIdentity of the member in the ban response.
    public var member: ChimeSDKMessagingClientTypes.Identity?

    public init (
        channelArn: Swift.String? = nil,
        member: ChimeSDKMessagingClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
    }
}

struct CreateChannelBanOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let member: ChimeSDKMessagingClientTypes.Identity?
}

extension CreateChannelBanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case member = "Member"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
    }
}

extension CreateChannelFlowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelFlowInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), processors: \(Swift.String(describing: processors)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateChannelFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case processors = "Processors"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = self.appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let processors = processors {
            var processorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processors)
            for processor0 in processors {
                try processorsContainer.encode(processor0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateChannelFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channel-flows"
    }
}

public struct CreateChannelFlowInput: Swift.Equatable {
    /// The ARN of the channel flow request.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The client token for the request. An Idempotency token.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The name of the channel flow.
    /// This member is required.
    public var name: Swift.String?
    /// Information about the processor Lambda functions.
    /// This member is required.
    public var processors: [ChimeSDKMessagingClientTypes.Processor]?
    /// The tags for the creation request.
    public var tags: [ChimeSDKMessagingClientTypes.Tag]?

    public init (
        appInstanceArn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        processors: [ChimeSDKMessagingClientTypes.Processor]? = nil,
        tags: [ChimeSDKMessagingClientTypes.Tag]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.processors = processors
        self.tags = tags
    }
}

struct CreateChannelFlowInputBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
    let processors: [ChimeSDKMessagingClientTypes.Processor]?
    let name: Swift.String?
    let tags: [ChimeSDKMessagingClientTypes.Tag]?
    let clientRequestToken: Swift.String?
}

extension CreateChannelFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case processors = "Processors"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let processorsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.Processor?].self, forKey: .processors)
        var processorsDecoded0:[ChimeSDKMessagingClientTypes.Processor]? = nil
        if let processorsContainer = processorsContainer {
            processorsDecoded0 = [ChimeSDKMessagingClientTypes.Processor]()
            for structure0 in processorsContainer {
                if let structure0 = structure0 {
                    processorsDecoded0?.append(structure0)
                }
            }
        }
        processors = processorsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMessagingClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMessagingClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateChannelFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateChannelFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateChannelFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelFlowArn = output.channelFlowArn
        } else {
            self.channelFlowArn = nil
        }
    }
}

public struct CreateChannelFlowOutputResponse: Swift.Equatable {
    /// The ARN of the channel flow.
    public var channelFlowArn: Swift.String?

    public init (
        channelFlowArn: Swift.String? = nil
    )
    {
        self.channelFlowArn = channelFlowArn
    }
}

struct CreateChannelFlowOutputResponseBody: Swift.Equatable {
    let channelFlowArn: Swift.String?
}

extension CreateChannelFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelFlowArn = "ChannelFlowArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelFlowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelFlowArn)
        channelFlowArn = channelFlowArnDecoded
    }
}

extension CreateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), elasticChannelConfiguration: \(Swift.String(describing: elasticChannelConfiguration)), memberArns: \(Swift.String(describing: memberArns)), mode: \(Swift.String(describing: mode)), moderatorArns: \(Swift.String(describing: moderatorArns)), privacy: \(Swift.String(describing: privacy)), tags: \(Swift.String(describing: tags)), channelId: \"CONTENT_REDACTED\", clientRequestToken: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case channelId = "ChannelId"
        case clientRequestToken = "ClientRequestToken"
        case elasticChannelConfiguration = "ElasticChannelConfiguration"
        case memberArns = "MemberArns"
        case metadata = "Metadata"
        case mode = "Mode"
        case moderatorArns = "ModeratorArns"
        case name = "Name"
        case privacy = "Privacy"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = self.appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let channelId = self.channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let elasticChannelConfiguration = self.elasticChannelConfiguration {
            try encodeContainer.encode(elasticChannelConfiguration, forKey: .elasticChannelConfiguration)
        }
        if let memberArns = memberArns {
            var memberArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .memberArns)
            for chimearn0 in memberArns {
                try memberArnsContainer.encode(chimearn0)
            }
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let moderatorArns = moderatorArns {
            var moderatorArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .moderatorArns)
            for chimearn0 in moderatorArns {
                try moderatorArnsContainer.encode(chimearn0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let privacy = self.privacy {
            try encodeContainer.encode(privacy.rawValue, forKey: .privacy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateChannelInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct CreateChannelInput: Swift.Equatable {
    /// The ARN of the channel request.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The ID of the channel in the request.
    public var channelId: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The client token for the request. An Idempotency token.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The attributes required to configure and create an elastic channel. An elastic channel can support a maximum of 1-million users, excluding moderators.
    public var elasticChannelConfiguration: ChimeSDKMessagingClientTypes.ElasticChannelConfiguration?
    /// The ARNs of the channel members in the request.
    public var memberArns: [Swift.String]?
    /// The metadata of the creation request. Limited to 1KB and UTF-8.
    public var metadata: Swift.String?
    /// The channel mode: UNRESTRICTED or RESTRICTED. Administrators, moderators, and channel members can add themselves and other members to unrestricted channels. Only administrators and moderators can add members to restricted channels.
    public var mode: ChimeSDKMessagingClientTypes.ChannelMode?
    /// The ARNs of the channel moderators in the request.
    public var moderatorArns: [Swift.String]?
    /// The name of the channel.
    /// This member is required.
    public var name: Swift.String?
    /// The channel's privacy level: PUBLIC or PRIVATE. Private channels aren't discoverable by users outside the channel. Public channels are discoverable by anyone in the AppInstance.
    public var privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy?
    /// The tags for the creation request.
    public var tags: [ChimeSDKMessagingClientTypes.Tag]?

    public init (
        appInstanceArn: Swift.String? = nil,
        channelId: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        elasticChannelConfiguration: ChimeSDKMessagingClientTypes.ElasticChannelConfiguration? = nil,
        memberArns: [Swift.String]? = nil,
        metadata: Swift.String? = nil,
        mode: ChimeSDKMessagingClientTypes.ChannelMode? = nil,
        moderatorArns: [Swift.String]? = nil,
        name: Swift.String? = nil,
        privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy? = nil,
        tags: [ChimeSDKMessagingClientTypes.Tag]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.channelId = channelId
        self.chimeBearer = chimeBearer
        self.clientRequestToken = clientRequestToken
        self.elasticChannelConfiguration = elasticChannelConfiguration
        self.memberArns = memberArns
        self.metadata = metadata
        self.mode = mode
        self.moderatorArns = moderatorArns
        self.name = name
        self.privacy = privacy
        self.tags = tags
    }
}

struct CreateChannelInputBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
    let name: Swift.String?
    let mode: ChimeSDKMessagingClientTypes.ChannelMode?
    let privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy?
    let metadata: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [ChimeSDKMessagingClientTypes.Tag]?
    let channelId: Swift.String?
    let memberArns: [Swift.String]?
    let moderatorArns: [Swift.String]?
    let elasticChannelConfiguration: ChimeSDKMessagingClientTypes.ElasticChannelConfiguration?
}

extension CreateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case channelId = "ChannelId"
        case clientRequestToken = "ClientRequestToken"
        case elasticChannelConfiguration = "ElasticChannelConfiguration"
        case memberArns = "MemberArns"
        case metadata = "Metadata"
        case mode = "Mode"
        case moderatorArns = "ModeratorArns"
        case name = "Name"
        case privacy = "Privacy"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let privacyDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelPrivacy.self, forKey: .privacy)
        privacy = privacyDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMessagingClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMessagingClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let memberArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .memberArns)
        var memberArnsDecoded0:[Swift.String]? = nil
        if let memberArnsContainer = memberArnsContainer {
            memberArnsDecoded0 = [Swift.String]()
            for string0 in memberArnsContainer {
                if let string0 = string0 {
                    memberArnsDecoded0?.append(string0)
                }
            }
        }
        memberArns = memberArnsDecoded0
        let moderatorArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .moderatorArns)
        var moderatorArnsDecoded0:[Swift.String]? = nil
        if let moderatorArnsContainer = moderatorArnsContainer {
            moderatorArnsDecoded0 = [Swift.String]()
            for string0 in moderatorArnsContainer {
                if let string0 = string0 {
                    moderatorArnsDecoded0?.append(string0)
                }
            }
        }
        moderatorArns = moderatorArnsDecoded0
        let elasticChannelConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ElasticChannelConfiguration.self, forKey: .elasticChannelConfiguration)
        elasticChannelConfiguration = elasticChannelConfigurationDecoded
    }
}

extension CreateChannelMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
        case subChannelId = "SubChannelId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberArn = self.memberArn {
            try encodeContainer.encode(memberArn, forKey: .memberArn)
        }
        if let subChannelId = self.subChannelId {
            try encodeContainer.encode(subChannelId, forKey: .subChannelId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateChannelMembershipInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateChannelMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships"
    }
}

public struct CreateChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel to which you're adding users.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member you want to add to the channel.
    /// This member is required.
    public var memberArn: Swift.String?
    /// The ID of the SubChannel in the request. Only required when creating membership in a SubChannel for a moderator in an elastic channel.
    public var subChannelId: Swift.String?
    /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned. This is only supported by moderators.
    /// This member is required.
    public var type: ChimeSDKMessagingClientTypes.ChannelMembershipType?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil,
        subChannelId: Swift.String? = nil,
        type: ChimeSDKMessagingClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
        self.subChannelId = subChannelId
        self.type = type
    }
}

struct CreateChannelMembershipInputBody: Swift.Equatable {
    let memberArn: Swift.String?
    let type: ChimeSDKMessagingClientTypes.ChannelMembershipType?
    let subChannelId: Swift.String?
}

extension CreateChannelMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberArn = "MemberArn"
        case subChannelId = "SubChannelId"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberArn)
        memberArn = memberArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMembershipType.self, forKey: .type)
        type = typeDecoded
        let subChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subChannelId)
        subChannelId = subChannelIdDecoded
    }
}

extension CreateChannelMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateChannelMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateChannelMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.member = output.member
            self.subChannelId = output.subChannelId
        } else {
            self.channelArn = nil
            self.member = nil
            self.subChannelId = nil
        }
    }
}

public struct CreateChannelMembershipOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ARN and metadata of the member being added.
    public var member: ChimeSDKMessagingClientTypes.Identity?
    /// The ID of the SubChannel in the response.
    public var subChannelId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        member: ChimeSDKMessagingClientTypes.Identity? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
        self.subChannelId = subChannelId
    }
}

struct CreateChannelMembershipOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let member: ChimeSDKMessagingClientTypes.Identity?
    let subChannelId: Swift.String?
}

extension CreateChannelMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case member = "Member"
        case subChannelId = "SubChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
        let subChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subChannelId)
        subChannelId = subChannelIdDecoded
    }
}

extension CreateChannelModeratorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelModeratorArn = "ChannelModeratorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelModeratorArn = self.channelModeratorArn {
            try encodeContainer.encode(channelModeratorArn, forKey: .channelModeratorArn)
        }
    }
}

extension CreateChannelModeratorInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateChannelModeratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators"
    }
}

public struct CreateChannelModeratorInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the moderator.
    /// This member is required.
    public var channelModeratorArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

struct CreateChannelModeratorInputBody: Swift.Equatable {
    let channelModeratorArn: Swift.String?
}

extension CreateChannelModeratorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelModeratorArn = "ChannelModeratorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelModeratorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelModeratorArn)
        channelModeratorArn = channelModeratorArnDecoded
    }
}

extension CreateChannelModeratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelModeratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateChannelModeratorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelModeratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateChannelModeratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelModerator = output.channelModerator
        } else {
            self.channelArn = nil
            self.channelModerator = nil
        }
    }
}

public struct CreateChannelModeratorOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ARNs of the channel and the moderator.
    public var channelModerator: ChimeSDKMessagingClientTypes.Identity?

    public init (
        channelArn: Swift.String? = nil,
        channelModerator: ChimeSDKMessagingClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModerator = channelModerator
    }
}

struct CreateChannelModeratorOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let channelModerator: ChimeSDKMessagingClientTypes.Identity?
}

extension CreateChannelModeratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelModerator = "ChannelModerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let channelModeratorDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Identity.self, forKey: .channelModerator)
        channelModerator = channelModeratorDecoded
    }
}

extension CreateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateChannelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
        } else {
            self.channelArn = nil
        }
    }
}

public struct CreateChannelOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct CreateChannelOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
}

extension CreateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

extension DeleteChannelBanInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelBanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let memberArn = memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans/\(memberArn.urlPercentEncoding())"
    }
}

public struct DeleteChannelBanInput: Swift.Equatable {
    /// The ARN of the channel from which the AppInstanceUser was banned.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ARN of the AppInstanceUser that you want to reinstate.
    /// This member is required.
    public var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct DeleteChannelBanInputBody: Swift.Equatable {
}

extension DeleteChannelBanInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelBanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelBanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteChannelBanOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelBanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelBanOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteChannelFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelFlowArn = channelFlowArn else {
            return nil
        }
        return "/channel-flows/\(channelFlowArn.urlPercentEncoding())"
    }
}

public struct DeleteChannelFlowInput: Swift.Equatable {
    /// The ARN of the channel flow.
    /// This member is required.
    public var channelFlowArn: Swift.String?

    public init (
        channelFlowArn: Swift.String? = nil
    )
    {
        self.channelFlowArn = channelFlowArn
    }
}

struct DeleteChannelFlowInputBody: Swift.Equatable {
}

extension DeleteChannelFlowInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteChannelFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelFlowOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteChannelInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let subChannelId = subChannelId {
                let subChannelIdQueryItem = ClientRuntime.URLQueryItem(name: "sub-channel-id".urlPercentEncoding(), value: Swift.String(subChannelId).urlPercentEncoding())
                items.append(subChannelIdQueryItem)
            }
            return items
        }
    }
}

extension DeleteChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

public struct DeleteChannelInput: Swift.Equatable {
    /// The ARN of the channel being deleted.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ID of the SubChannel in the request.
    public var subChannelId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.subChannelId = subChannelId
    }
}

struct DeleteChannelInputBody: Swift.Equatable {
}

extension DeleteChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelMembershipInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelMembershipInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let subChannelId = subChannelId {
                let subChannelIdQueryItem = ClientRuntime.URLQueryItem(name: "sub-channel-id".urlPercentEncoding(), value: Swift.String(subChannelId).urlPercentEncoding())
                items.append(subChannelIdQueryItem)
            }
            return items
        }
    }
}

extension DeleteChannelMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let memberArn = memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())"
    }
}

public struct DeleteChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel from which you want to remove the user.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member that you're removing from the channel.
    /// This member is required.
    public var memberArn: Swift.String?
    /// The ID of the SubChannel in the request. Only for use by moderators.
    public var subChannelId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
        self.subChannelId = subChannelId
    }
}

struct DeleteChannelMembershipInputBody: Swift.Equatable {
}

extension DeleteChannelMembershipInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteChannelMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelMembershipOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteChannelMessageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelMessageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let subChannelId = subChannelId {
                let subChannelIdQueryItem = ClientRuntime.URLQueryItem(name: "sub-channel-id".urlPercentEncoding(), value: Swift.String(subChannelId).urlPercentEncoding())
                items.append(subChannelIdQueryItem)
            }
            return items
        }
    }
}

extension DeleteChannelMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let messageId = messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

public struct DeleteChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ID of the message being deleted.
    /// This member is required.
    public var messageId: Swift.String?
    /// The ID of the SubChannel in the request. Only required when deleting messages in a SubChannel that the user belongs to.
    public var subChannelId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
        self.subChannelId = subChannelId
    }
}

struct DeleteChannelMessageInputBody: Swift.Equatable {
}

extension DeleteChannelMessageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelMessageOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteChannelModeratorInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelModeratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let channelModeratorArn = channelModeratorArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators/\(channelModeratorArn.urlPercentEncoding())"
    }
}

public struct DeleteChannelModeratorInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the moderator being deleted.
    /// This member is required.
    public var channelModeratorArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

struct DeleteChannelModeratorInputBody: Swift.Equatable {
}

extension DeleteChannelModeratorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteChannelModeratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelModeratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteChannelModeratorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelModeratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelModeratorOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteChannelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeChannelBanInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelBanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let memberArn = memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans/\(memberArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelBanInput: Swift.Equatable {
    /// The ARN of the channel from which the user is banned.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member being banned.
    /// This member is required.
    public var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct DescribeChannelBanInputBody: Swift.Equatable {
}

extension DescribeChannelBanInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelBanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelBanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeChannelBanOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelBanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeChannelBanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelBan = output.channelBan
        } else {
            self.channelBan = nil
        }
    }
}

public struct DescribeChannelBanOutputResponse: Swift.Equatable {
    /// The details of the ban.
    public var channelBan: ChimeSDKMessagingClientTypes.ChannelBan?

    public init (
        channelBan: ChimeSDKMessagingClientTypes.ChannelBan? = nil
    )
    {
        self.channelBan = channelBan
    }
}

struct DescribeChannelBanOutputResponseBody: Swift.Equatable {
    let channelBan: ChimeSDKMessagingClientTypes.ChannelBan?
}

extension DescribeChannelBanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelBan = "ChannelBan"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelBanDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelBan.self, forKey: .channelBan)
        channelBan = channelBanDecoded
    }
}

extension DescribeChannelFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelFlowArn = channelFlowArn else {
            return nil
        }
        return "/channel-flows/\(channelFlowArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelFlowInput: Swift.Equatable {
    /// The ARN of the channel flow.
    /// This member is required.
    public var channelFlowArn: Swift.String?

    public init (
        channelFlowArn: Swift.String? = nil
    )
    {
        self.channelFlowArn = channelFlowArn
    }
}

struct DescribeChannelFlowInputBody: Swift.Equatable {
}

extension DescribeChannelFlowInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeChannelFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeChannelFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelFlow = output.channelFlow
        } else {
            self.channelFlow = nil
        }
    }
}

public struct DescribeChannelFlowOutputResponse: Swift.Equatable {
    /// The channel flow details.
    public var channelFlow: ChimeSDKMessagingClientTypes.ChannelFlow?

    public init (
        channelFlow: ChimeSDKMessagingClientTypes.ChannelFlow? = nil
    )
    {
        self.channelFlow = channelFlow
    }
}

struct DescribeChannelFlowOutputResponseBody: Swift.Equatable {
    let channelFlow: ChimeSDKMessagingClientTypes.ChannelFlow?
}

extension DescribeChannelFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelFlow = "ChannelFlow"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelFlowDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelFlow.self, forKey: .channelFlow)
        channelFlow = channelFlowDecoded
    }
}

extension DescribeChannelInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

struct DescribeChannelInputBody: Swift.Equatable {
}

extension DescribeChannelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelMembershipForAppInstanceUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelMembershipForAppInstanceUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-membership"))
            guard let appInstanceUserArn = appInstanceUserArn else {
                let message = "Creating a URL Query Item failed. appInstanceUserArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            items.append(appInstanceUserArnQueryItem)
            return items
        }
    }
}

extension DescribeChannelMembershipForAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelMembershipForAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the user in a channel.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The ARN of the channel to which the user belongs.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

struct DescribeChannelMembershipForAppInstanceUserInputBody: Swift.Equatable {
}

extension DescribeChannelMembershipForAppInstanceUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelMembershipForAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelMembershipForAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeChannelMembershipForAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelMembershipForAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeChannelMembershipForAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelMembership = output.channelMembership
        } else {
            self.channelMembership = nil
        }
    }
}

public struct DescribeChannelMembershipForAppInstanceUserOutputResponse: Swift.Equatable {
    /// The channel to which a user belongs.
    public var channelMembership: ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary?

    public init (
        channelMembership: ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary? = nil
    )
    {
        self.channelMembership = channelMembership
    }
}

struct DescribeChannelMembershipForAppInstanceUserOutputResponseBody: Swift.Equatable {
    let channelMembership: ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary?
}

extension DescribeChannelMembershipForAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMembership = "ChannelMembership"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMembershipDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary.self, forKey: .channelMembership)
        channelMembership = channelMembershipDecoded
    }
}

extension DescribeChannelMembershipInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelMembershipInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let subChannelId = subChannelId {
                let subChannelIdQueryItem = ClientRuntime.URLQueryItem(name: "sub-channel-id".urlPercentEncoding(), value: Swift.String(subChannelId).urlPercentEncoding())
                items.append(subChannelIdQueryItem)
            }
            return items
        }
    }
}

extension DescribeChannelMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let memberArn = memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelMembershipInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member.
    /// This member is required.
    public var memberArn: Swift.String?
    /// The ID of the SubChannel in the request. The response contains an ElasticChannelConfiguration object. Only required to get a user’s SubChannel membership details.
    public var subChannelId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
        self.subChannelId = subChannelId
    }
}

struct DescribeChannelMembershipInputBody: Swift.Equatable {
}

extension DescribeChannelMembershipInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelMembershipOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelMembershipOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeChannelMembershipOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelMembershipOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeChannelMembershipOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelMembership = output.channelMembership
        } else {
            self.channelMembership = nil
        }
    }
}

public struct DescribeChannelMembershipOutputResponse: Swift.Equatable {
    /// The details of the membership.
    public var channelMembership: ChimeSDKMessagingClientTypes.ChannelMembership?

    public init (
        channelMembership: ChimeSDKMessagingClientTypes.ChannelMembership? = nil
    )
    {
        self.channelMembership = channelMembership
    }
}

struct DescribeChannelMembershipOutputResponseBody: Swift.Equatable {
    let channelMembership: ChimeSDKMessagingClientTypes.ChannelMembership?
}

extension DescribeChannelMembershipOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMembership = "ChannelMembership"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMembershipDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMembership.self, forKey: .channelMembership)
        channelMembership = channelMembershipDecoded
    }
}

extension DescribeChannelModeratedByAppInstanceUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelModeratedByAppInstanceUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-moderated-channel"))
            guard let appInstanceUserArn = appInstanceUserArn else {
                let message = "Creating a URL Query Item failed. appInstanceUserArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            items.append(appInstanceUserArnQueryItem)
            return items
        }
    }
}

extension DescribeChannelModeratedByAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelModeratedByAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser in the moderated channel.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The ARN of the moderated channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

struct DescribeChannelModeratedByAppInstanceUserInputBody: Swift.Equatable {
}

extension DescribeChannelModeratedByAppInstanceUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelModeratedByAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelModeratedByAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeChannelModeratedByAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelModeratedByAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeChannelModeratedByAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
        } else {
            self.channel = nil
        }
    }
}

public struct DescribeChannelModeratedByAppInstanceUserOutputResponse: Swift.Equatable {
    /// The moderated channel.
    public var channel: ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary?

    public init (
        channel: ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary? = nil
    )
    {
        self.channel = channel
    }
}

struct DescribeChannelModeratedByAppInstanceUserOutputResponseBody: Swift.Equatable {
    let channel: ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary?
}

extension DescribeChannelModeratedByAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension DescribeChannelModeratorInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelModeratorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let channelModeratorArn = channelModeratorArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators/\(channelModeratorArn.urlPercentEncoding())"
    }
}

public struct DescribeChannelModeratorInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the channel moderator.
    /// This member is required.
    public var channelModeratorArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

struct DescribeChannelModeratorInputBody: Swift.Equatable {
}

extension DescribeChannelModeratorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChannelModeratorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelModeratorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeChannelModeratorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelModeratorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeChannelModeratorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelModerator = output.channelModerator
        } else {
            self.channelModerator = nil
        }
    }
}

public struct DescribeChannelModeratorOutputResponse: Swift.Equatable {
    /// The details of the channel moderator.
    public var channelModerator: ChimeSDKMessagingClientTypes.ChannelModerator?

    public init (
        channelModerator: ChimeSDKMessagingClientTypes.ChannelModerator? = nil
    )
    {
        self.channelModerator = channelModerator
    }
}

struct DescribeChannelModeratorOutputResponseBody: Swift.Equatable {
    let channelModerator: ChimeSDKMessagingClientTypes.ChannelModerator?
}

extension DescribeChannelModeratorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelModerator = "ChannelModerator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelModeratorDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelModerator.self, forKey: .channelModerator)
        channelModerator = channelModeratorDecoded
    }
}

extension DescribeChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeChannelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
        } else {
            self.channel = nil
        }
    }
}

public struct DescribeChannelOutputResponse: Swift.Equatable {
    /// The channel details.
    public var channel: ChimeSDKMessagingClientTypes.Channel?

    public init (
        channel: ChimeSDKMessagingClientTypes.Channel? = nil
    )
    {
        self.channel = channel
    }
}

struct DescribeChannelOutputResponseBody: Swift.Equatable {
    let channel: ChimeSDKMessagingClientTypes.Channel?
}

extension DescribeChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel = "Channel"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension DisassociateChannelFlowInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DisassociateChannelFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let channelFlowArn = channelFlowArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/channel-flow/\(channelFlowArn.urlPercentEncoding())"
    }
}

public struct DisassociateChannelFlowInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the channel flow.
    /// This member is required.
    public var channelFlowArn: Swift.String?
    /// The AppInstanceUserArn of the user making the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelFlowArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelFlowArn = channelFlowArn
        self.chimeBearer = chimeBearer
    }
}

struct DisassociateChannelFlowInputBody: Swift.Equatable {
}

extension DisassociateChannelFlowInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateChannelFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateChannelFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateChannelFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateChannelFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateChannelFlowOutputResponse: Swift.Equatable {

    public init () { }
}

extension ChimeSDKMessagingClientTypes.ElasticChannelConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximumSubChannels = "MaximumSubChannels"
        case minimumMembershipPercentage = "MinimumMembershipPercentage"
        case targetMembershipsPerSubChannel = "TargetMembershipsPerSubChannel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximumSubChannels = self.maximumSubChannels {
            try encodeContainer.encode(maximumSubChannels, forKey: .maximumSubChannels)
        }
        if let minimumMembershipPercentage = self.minimumMembershipPercentage {
            try encodeContainer.encode(minimumMembershipPercentage, forKey: .minimumMembershipPercentage)
        }
        if let targetMembershipsPerSubChannel = self.targetMembershipsPerSubChannel {
            try encodeContainer.encode(targetMembershipsPerSubChannel, forKey: .targetMembershipsPerSubChannel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumSubChannelsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumSubChannels)
        maximumSubChannels = maximumSubChannelsDecoded
        let targetMembershipsPerSubChannelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetMembershipsPerSubChannel)
        targetMembershipsPerSubChannel = targetMembershipsPerSubChannelDecoded
        let minimumMembershipPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumMembershipPercentage)
        minimumMembershipPercentage = minimumMembershipPercentageDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// The attributes required to configure and create an elastic channel. An elastic channel can support a maximum of 1-million members.
    public struct ElasticChannelConfiguration: Swift.Equatable {
        /// The maximum number of SubChannels that you want to allow in the elastic channel.
        /// This member is required.
        public var maximumSubChannels: Swift.Int?
        /// The minimum allowed percentage of TargetMembershipsPerSubChannel users. Ceil of the calculated value is used in balancing members among SubChannels of the elastic channel.
        /// This member is required.
        public var minimumMembershipPercentage: Swift.Int?
        /// The maximum number of members allowed in a SubChannel.
        /// This member is required.
        public var targetMembershipsPerSubChannel: Swift.Int?

        public init (
            maximumSubChannels: Swift.Int? = nil,
            minimumMembershipPercentage: Swift.Int? = nil,
            targetMembershipsPerSubChannel: Swift.Int? = nil
        )
        {
            self.maximumSubChannels = maximumSubChannels
            self.minimumMembershipPercentage = minimumMembershipPercentage
            self.targetMembershipsPerSubChannel = targetMembershipsPerSubChannel
        }
    }

}

extension ChimeSDKMessagingClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdenied
        case badrequest
        case conflict
        case forbidden
        case notfound
        case phonenumberassociationsexist
        case preconditionfailed
        case resourcelimitexceeded
        case servicefailure
        case serviceunavailable
        case throttled
        case throttling
        case unauthorized
        case unprocessable
        case voiceconnectorgroupassociationsexist
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessdenied,
                .badrequest,
                .conflict,
                .forbidden,
                .notfound,
                .phonenumberassociationsexist,
                .preconditionfailed,
                .resourcelimitexceeded,
                .servicefailure,
                .serviceunavailable,
                .throttled,
                .throttling,
                .unauthorized,
                .unprocessable,
                .voiceconnectorgroupassociationsexist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "AccessDenied"
            case .badrequest: return "BadRequest"
            case .conflict: return "Conflict"
            case .forbidden: return "Forbidden"
            case .notfound: return "NotFound"
            case .phonenumberassociationsexist: return "PhoneNumberAssociationsExist"
            case .preconditionfailed: return "PreconditionFailed"
            case .resourcelimitexceeded: return "ResourceLimitExceeded"
            case .servicefailure: return "ServiceFailure"
            case .serviceunavailable: return "ServiceUnavailable"
            case .throttled: return "Throttled"
            case .throttling: return "Throttling"
            case .unauthorized: return "Unauthorized"
            case .unprocessable: return "Unprocessable"
            case .voiceconnectorgroupassociationsexist: return "VoiceConnectorGroupAssociationsExist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMessagingClientTypes {
    public enum FallbackAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case abort
        case `continue`
        case sdkUnknown(Swift.String)

        public static var allCases: [FallbackAction] {
            return [
                .abort,
                .continue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .abort: return "ABORT"
            case .continue: return "CONTINUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FallbackAction(rawValue: rawValue) ?? FallbackAction.sdkUnknown(rawValue)
        }
    }
}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let code: ChimeSDKMessagingClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetChannelMembershipPreferencesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension GetChannelMembershipPreferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let memberArn = memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())/preferences"
    }
}

public struct GetChannelMembershipPreferencesInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserARN of the user making the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member retrieving the preferences.
    /// This member is required.
    public var memberArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

struct GetChannelMembershipPreferencesInputBody: Swift.Equatable {
}

extension GetChannelMembershipPreferencesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetChannelMembershipPreferencesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelMembershipPreferencesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetChannelMembershipPreferencesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelMembershipPreferencesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetChannelMembershipPreferencesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.member = output.member
            self.preferences = output.preferences
        } else {
            self.channelArn = nil
            self.member = nil
            self.preferences = nil
        }
    }
}

public struct GetChannelMembershipPreferencesOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The details of a user.
    public var member: ChimeSDKMessagingClientTypes.Identity?
    /// The channel membership preferences for an AppInstanceUser .
    public var preferences: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences?

    public init (
        channelArn: Swift.String? = nil,
        member: ChimeSDKMessagingClientTypes.Identity? = nil,
        preferences: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
        self.preferences = preferences
    }
}

struct GetChannelMembershipPreferencesOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let member: ChimeSDKMessagingClientTypes.Identity?
    let preferences: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences?
}

extension GetChannelMembershipPreferencesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case member = "Member"
        case preferences = "Preferences"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
        let preferencesDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMembershipPreferences.self, forKey: .preferences)
        preferences = preferencesDecoded
    }
}

extension GetChannelMessageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension GetChannelMessageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let subChannelId = subChannelId {
                let subChannelIdQueryItem = ClientRuntime.URLQueryItem(name: "sub-channel-id".urlPercentEncoding(), value: Swift.String(subChannelId).urlPercentEncoding())
                items.append(subChannelIdQueryItem)
            }
            return items
        }
    }
}

extension GetChannelMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let messageId = messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

public struct GetChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ID of the message.
    /// This member is required.
    public var messageId: Swift.String?
    /// The ID of the SubChannel in the request. Only required when getting messages in a SubChannel that the user belongs to.
    public var subChannelId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
        self.subChannelId = subChannelId
    }
}

struct GetChannelMessageInputBody: Swift.Equatable {
}

extension GetChannelMessageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetChannelMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelMessage = output.channelMessage
        } else {
            self.channelMessage = nil
        }
    }
}

public struct GetChannelMessageOutputResponse: Swift.Equatable {
    /// The details of and content in the message.
    public var channelMessage: ChimeSDKMessagingClientTypes.ChannelMessage?

    public init (
        channelMessage: ChimeSDKMessagingClientTypes.ChannelMessage? = nil
    )
    {
        self.channelMessage = channelMessage
    }
}

struct GetChannelMessageOutputResponseBody: Swift.Equatable {
    let channelMessage: ChimeSDKMessagingClientTypes.ChannelMessage?
}

extension GetChannelMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMessage = "ChannelMessage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMessageDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMessage.self, forKey: .channelMessage)
        channelMessage = channelMessageDecoded
    }
}

extension GetChannelMessageStatusInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension GetChannelMessageStatusInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "scope", value: "message-status"))
            if let subChannelId = subChannelId {
                let subChannelIdQueryItem = ClientRuntime.URLQueryItem(name: "sub-channel-id".urlPercentEncoding(), value: Swift.String(subChannelId).urlPercentEncoding())
                items.append(subChannelIdQueryItem)
            }
            return items
        }
    }
}

extension GetChannelMessageStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let messageId = messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

public struct GetChannelMessageStatusInput: Swift.Equatable {
    /// The ARN of the channel
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user making the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ID of the message.
    /// This member is required.
    public var messageId: Swift.String?
    /// The ID of the SubChannel in the request. Only required when getting message status in a SubChannel that the user belongs to.
    public var subChannelId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
        self.subChannelId = subChannelId
    }
}

struct GetChannelMessageStatusInputBody: Swift.Equatable {
}

extension GetChannelMessageStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetChannelMessageStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelMessageStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetChannelMessageStatusOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelMessageStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetChannelMessageStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct GetChannelMessageStatusOutputResponse: Swift.Equatable {
    /// The message status and details.
    public var status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure?

    public init (
        status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure? = nil
    )
    {
        self.status = status
    }
}

struct GetChannelMessageStatusOutputResponseBody: Swift.Equatable {
    let status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure?
}

extension GetChannelMessageStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetMessagingSessionEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/endpoints/messaging-session"
    }
}

public struct GetMessagingSessionEndpointInput: Swift.Equatable {

    public init () { }
}

struct GetMessagingSessionEndpointInputBody: Swift.Equatable {
}

extension GetMessagingSessionEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMessagingSessionEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMessagingSessionEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMessagingSessionEndpointOutputError: Swift.Error, Swift.Equatable {
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMessagingSessionEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMessagingSessionEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct GetMessagingSessionEndpointOutputResponse: Swift.Equatable {
    /// The endpoint returned in the response.
    public var endpoint: ChimeSDKMessagingClientTypes.MessagingSessionEndpoint?

    public init (
        endpoint: ChimeSDKMessagingClientTypes.MessagingSessionEndpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct GetMessagingSessionEndpointOutputResponseBody: Swift.Equatable {
    let endpoint: ChimeSDKMessagingClientTypes.MessagingSessionEndpoint?
}

extension GetMessagingSessionEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.MessagingSessionEndpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension ChimeSDKMessagingClientTypes.Identity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ChimeSDKMessagingClientTypes.Identity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Identity(arn: \(Swift.String(describing: arn)), name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {
    /// The details of a user.
    public struct Identity: Swift.Equatable {
        /// The ARN in an Identity.
        public var arn: Swift.String?
        /// The name in an Identity.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension ChimeSDKMessagingClientTypes {
    public enum InvocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case async
        case sdkUnknown(Swift.String)

        public static var allCases: [InvocationType] {
            return [
                .async,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .async: return "ASYNC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InvocationType(rawValue: rawValue) ?? InvocationType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMessagingClientTypes.LambdaConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invocationType = "InvocationType"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invocationType = self.invocationType {
            try encodeContainer.encode(invocationType.rawValue, forKey: .invocationType)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let invocationTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.InvocationType.self, forKey: .invocationType)
        invocationType = invocationTypeDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// Stores metadata about a Lambda processor.
    public struct LambdaConfiguration: Swift.Equatable {
        /// Controls how the Lambda function is invoked.
        /// This member is required.
        public var invocationType: ChimeSDKMessagingClientTypes.InvocationType?
        /// The ARN of the Lambda message processing function.
        /// This member is required.
        public var resourceArn: Swift.String?

        public init (
            invocationType: ChimeSDKMessagingClientTypes.InvocationType? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.invocationType = invocationType
            self.resourceArn = resourceArn
        }
    }

}

extension ListChannelBansInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelBansInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelBansInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelBansInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChannelBansInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans"
    }
}

public struct ListChannelBansInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of bans that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested bans are returned.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelBansInputBody: Swift.Equatable {
}

extension ListChannelBansInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelBansOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelBansOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListChannelBansOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelBansOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelBansOutputResponse(channelArn: \(Swift.String(describing: channelArn)), channelBans: \(Swift.String(describing: channelBans)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelBansOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListChannelBansOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelBans = output.channelBans
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelBans = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelBansOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The information for each requested ban.
    public var channelBans: [ChimeSDKMessagingClientTypes.ChannelBanSummary]?
    /// The token passed by previous API calls until all requested bans are returned.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelBans: [ChimeSDKMessagingClientTypes.ChannelBanSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelBans = channelBans
        self.nextToken = nextToken
    }
}

struct ListChannelBansOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let nextToken: Swift.String?
    let channelBans: [ChimeSDKMessagingClientTypes.ChannelBanSummary]?
}

extension ListChannelBansOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelBans = "ChannelBans"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelBansContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.ChannelBanSummary?].self, forKey: .channelBans)
        var channelBansDecoded0:[ChimeSDKMessagingClientTypes.ChannelBanSummary]? = nil
        if let channelBansContainer = channelBansContainer {
            channelBansDecoded0 = [ChimeSDKMessagingClientTypes.ChannelBanSummary]()
            for structure0 in channelBansContainer {
                if let structure0 = structure0 {
                    channelBansDecoded0?.append(structure0)
                }
            }
        }
        channelBans = channelBansDecoded0
    }
}

extension ListChannelFlowsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelFlowsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelFlowsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let appInstanceArn = appInstanceArn else {
                let message = "Creating a URL Query Item failed. appInstanceArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let appInstanceArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-arn".urlPercentEncoding(), value: Swift.String(appInstanceArn).urlPercentEncoding())
            items.append(appInstanceArnQueryItem)
            return items
        }
    }
}

extension ListChannelFlowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channel-flows"
    }
}

public struct ListChannelFlowsInput: Swift.Equatable {
    /// The ARN of the app instance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The maximum number of channel flows that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channel flows are returned.
    public var nextToken: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelFlowsInputBody: Swift.Equatable {
}

extension ListChannelFlowsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelFlowsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelFlowsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListChannelFlowsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelFlowsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelFlowsOutputResponse(channelFlows: \(Swift.String(describing: channelFlows)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelFlowsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListChannelFlowsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelFlows = output.channelFlows
            self.nextToken = output.nextToken
        } else {
            self.channelFlows = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelFlowsOutputResponse: Swift.Equatable {
    /// The information about each channel flow.
    public var channelFlows: [ChimeSDKMessagingClientTypes.ChannelFlowSummary]?
    /// The token passed by previous API calls until all requested channels are returned.
    public var nextToken: Swift.String?

    public init (
        channelFlows: [ChimeSDKMessagingClientTypes.ChannelFlowSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelFlows = channelFlows
        self.nextToken = nextToken
    }
}

struct ListChannelFlowsOutputResponseBody: Swift.Equatable {
    let channelFlows: [ChimeSDKMessagingClientTypes.ChannelFlowSummary]?
    let nextToken: Swift.String?
}

extension ListChannelFlowsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelFlows = "ChannelFlows"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelFlowsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.ChannelFlowSummary?].self, forKey: .channelFlows)
        var channelFlowsDecoded0:[ChimeSDKMessagingClientTypes.ChannelFlowSummary]? = nil
        if let channelFlowsContainer = channelFlowsContainer {
            channelFlowsDecoded0 = [ChimeSDKMessagingClientTypes.ChannelFlowSummary]()
            for structure0 in channelFlowsContainer {
                if let structure0 = structure0 {
                    channelFlowsDecoded0?.append(structure0)
                }
            }
        }
        channelFlows = channelFlowsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelMembershipsForAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsForAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelMembershipsForAppInstanceUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelMembershipsForAppInstanceUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-memberships"))
            if let appInstanceUserArn = appInstanceUserArn {
                let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
                items.append(appInstanceUserArnQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChannelMembershipsForAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct ListChannelMembershipsForAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUsers
    public var appInstanceUserArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of users that you want returned.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of channel memberships is reached.
    public var nextToken: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelMembershipsForAppInstanceUserInputBody: Swift.Equatable {
}

extension ListChannelMembershipsForAppInstanceUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelMembershipsForAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelMembershipsForAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListChannelMembershipsForAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelMembershipsForAppInstanceUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsForAppInstanceUserOutputResponse(channelMemberships: \(Swift.String(describing: channelMemberships)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelMembershipsForAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListChannelMembershipsForAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelMemberships = output.channelMemberships
            self.nextToken = output.nextToken
        } else {
            self.channelMemberships = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelMembershipsForAppInstanceUserOutputResponse: Swift.Equatable {
    /// The information for the requested channel memberships.
    public var channelMemberships: [ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary]?
    /// The token passed by previous API calls until all requested users are returned.
    public var nextToken: Swift.String?

    public init (
        channelMemberships: [ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelMemberships = channelMemberships
        self.nextToken = nextToken
    }
}

struct ListChannelMembershipsForAppInstanceUserOutputResponseBody: Swift.Equatable {
    let channelMemberships: [ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary]?
    let nextToken: Swift.String?
}

extension ListChannelMembershipsForAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelMemberships = "ChannelMemberships"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelMembershipsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary?].self, forKey: .channelMemberships)
        var channelMembershipsDecoded0:[ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary]? = nil
        if let channelMembershipsContainer = channelMembershipsContainer {
            channelMembershipsDecoded0 = [ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary]()
            for structure0 in channelMembershipsContainer {
                if let structure0 = structure0 {
                    channelMembershipsDecoded0?.append(structure0)
                }
            }
        }
        channelMemberships = channelMembershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelMembershipsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), subChannelId: \(Swift.String(describing: subChannelId)), type: \(Swift.String(describing: type)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelMembershipsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelMembershipsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let subChannelId = subChannelId {
                let subChannelIdQueryItem = ClientRuntime.URLQueryItem(name: "sub-channel-id".urlPercentEncoding(), value: Swift.String(subChannelId).urlPercentEncoding())
                items.append(subChannelIdQueryItem)
            }
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChannelMembershipsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships"
    }
}

public struct ListChannelMembershipsInput: Swift.Equatable {
    /// The maximum number of channel memberships that you want returned.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of channel memberships that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channel memberships are returned.
    public var nextToken: Swift.String?
    /// The ID of the SubChannel in the request. Only required when listing a user's memberships in a particular sub-channel of an elastic channel.
    public var subChannelId: Swift.String?
    /// The membership type of a user, DEFAULT or HIDDEN. Default members are returned as part of ListChannelMemberships if no type is specified. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN.
    public var type: ChimeSDKMessagingClientTypes.ChannelMembershipType?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        subChannelId: Swift.String? = nil,
        type: ChimeSDKMessagingClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subChannelId = subChannelId
        self.type = type
    }
}

struct ListChannelMembershipsInputBody: Swift.Equatable {
}

extension ListChannelMembershipsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelMembershipsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelMembershipsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListChannelMembershipsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelMembershipsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsOutputResponse(channelArn: \(Swift.String(describing: channelArn)), channelMemberships: \(Swift.String(describing: channelMemberships)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelMembershipsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListChannelMembershipsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelMemberships = output.channelMemberships
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelMemberships = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelMembershipsOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The information for the requested channel memberships.
    public var channelMemberships: [ChimeSDKMessagingClientTypes.ChannelMembershipSummary]?
    /// The token passed by previous API calls until all requested channel memberships are returned.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelMemberships: [ChimeSDKMessagingClientTypes.ChannelMembershipSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelMemberships = channelMemberships
        self.nextToken = nextToken
    }
}

struct ListChannelMembershipsOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let channelMemberships: [ChimeSDKMessagingClientTypes.ChannelMembershipSummary]?
    let nextToken: Swift.String?
}

extension ListChannelMembershipsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelMemberships = "ChannelMemberships"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let channelMembershipsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.ChannelMembershipSummary?].self, forKey: .channelMemberships)
        var channelMembershipsDecoded0:[ChimeSDKMessagingClientTypes.ChannelMembershipSummary]? = nil
        if let channelMembershipsContainer = channelMembershipsContainer {
            channelMembershipsDecoded0 = [ChimeSDKMessagingClientTypes.ChannelMembershipSummary]()
            for structure0 in channelMembershipsContainer {
                if let structure0 = structure0 {
                    channelMembershipsDecoded0?.append(structure0)
                }
            }
        }
        channelMemberships = channelMembershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelMessagesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMessagesInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), notAfter: \(Swift.String(describing: notAfter)), notBefore: \(Swift.String(describing: notBefore)), sortOrder: \(Swift.String(describing: sortOrder)), subChannelId: \(Swift.String(describing: subChannelId)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelMessagesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelMessagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let subChannelId = subChannelId {
                let subChannelIdQueryItem = ClientRuntime.URLQueryItem(name: "sub-channel-id".urlPercentEncoding(), value: Swift.String(subChannelId).urlPercentEncoding())
                items.append(subChannelIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let sortOrder = sortOrder {
                let sortOrderQueryItem = ClientRuntime.URLQueryItem(name: "sort-order".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
                items.append(sortOrderQueryItem)
            }
            if let notBefore = notBefore {
                let notBeforeQueryItem = ClientRuntime.URLQueryItem(name: "not-before".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: notBefore)).urlPercentEncoding())
                items.append(notBeforeQueryItem)
            }
            if let notAfter = notAfter {
                let notAfterQueryItem = ClientRuntime.URLQueryItem(name: "not-after".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: notAfter)).urlPercentEncoding())
                items.append(notAfterQueryItem)
            }
            return items
        }
    }
}

extension ListChannelMessagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages"
    }
}

public struct ListChannelMessagesInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of messages that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested messages are returned.
    public var nextToken: Swift.String?
    /// The final or ending time stamp for your requested messages.
    public var notAfter: ClientRuntime.Date?
    /// The initial or starting time stamp for your requested messages.
    public var notBefore: ClientRuntime.Date?
    /// The order in which you want messages sorted. Default is Descending, based on time created.
    public var sortOrder: ChimeSDKMessagingClientTypes.SortOrder?
    /// The ID of the SubChannel in the request. Only required when listing the messages in a SubChannel that the user belongs to.
    public var subChannelId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        notAfter: ClientRuntime.Date? = nil,
        notBefore: ClientRuntime.Date? = nil,
        sortOrder: ChimeSDKMessagingClientTypes.SortOrder? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.notAfter = notAfter
        self.notBefore = notBefore
        self.sortOrder = sortOrder
        self.subChannelId = subChannelId
    }
}

struct ListChannelMessagesInputBody: Swift.Equatable {
}

extension ListChannelMessagesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelMessagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelMessagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListChannelMessagesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelMessagesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMessagesOutputResponse(channelArn: \(Swift.String(describing: channelArn)), channelMessages: \(Swift.String(describing: channelMessages)), subChannelId: \(Swift.String(describing: subChannelId)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelMessagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListChannelMessagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelMessages = output.channelMessages
            self.nextToken = output.nextToken
            self.subChannelId = output.subChannelId
        } else {
            self.channelArn = nil
            self.channelMessages = nil
            self.nextToken = nil
            self.subChannelId = nil
        }
    }
}

public struct ListChannelMessagesOutputResponse: Swift.Equatable {
    /// The ARN of the channel containing the requested messages.
    public var channelArn: Swift.String?
    /// The information about, and content of, each requested message.
    public var channelMessages: [ChimeSDKMessagingClientTypes.ChannelMessageSummary]?
    /// The token passed by previous API calls until all requested messages are returned.
    public var nextToken: Swift.String?
    /// The ID of the SubChannel in the response.
    public var subChannelId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelMessages: [ChimeSDKMessagingClientTypes.ChannelMessageSummary]? = nil,
        nextToken: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelMessages = channelMessages
        self.nextToken = nextToken
        self.subChannelId = subChannelId
    }
}

struct ListChannelMessagesOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let nextToken: Swift.String?
    let channelMessages: [ChimeSDKMessagingClientTypes.ChannelMessageSummary]?
    let subChannelId: Swift.String?
}

extension ListChannelMessagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelMessages = "ChannelMessages"
        case nextToken = "NextToken"
        case subChannelId = "SubChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelMessagesContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.ChannelMessageSummary?].self, forKey: .channelMessages)
        var channelMessagesDecoded0:[ChimeSDKMessagingClientTypes.ChannelMessageSummary]? = nil
        if let channelMessagesContainer = channelMessagesContainer {
            channelMessagesDecoded0 = [ChimeSDKMessagingClientTypes.ChannelMessageSummary]()
            for structure0 in channelMessagesContainer {
                if let structure0 = structure0 {
                    channelMessagesDecoded0?.append(structure0)
                }
            }
        }
        channelMessages = channelMessagesDecoded0
        let subChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subChannelId)
        subChannelId = subChannelIdDecoded
    }
}

extension ListChannelModeratorsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelModeratorsInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelModeratorsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelModeratorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChannelModeratorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators"
    }
}

public struct ListChannelModeratorsInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of moderators that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested moderators are returned.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelModeratorsInputBody: Swift.Equatable {
}

extension ListChannelModeratorsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelModeratorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelModeratorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListChannelModeratorsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelModeratorsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelModeratorsOutputResponse(channelArn: \(Swift.String(describing: channelArn)), channelModerators: \(Swift.String(describing: channelModerators)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelModeratorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListChannelModeratorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.channelModerators = output.channelModerators
            self.nextToken = output.nextToken
        } else {
            self.channelArn = nil
            self.channelModerators = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelModeratorsOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The information about and names of each moderator.
    public var channelModerators: [ChimeSDKMessagingClientTypes.ChannelModeratorSummary]?
    /// The token passed by previous API calls until all requested moderators are returned.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        channelModerators: [ChimeSDKMessagingClientTypes.ChannelModeratorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModerators = channelModerators
        self.nextToken = nextToken
    }
}

struct ListChannelModeratorsOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let nextToken: Swift.String?
    let channelModerators: [ChimeSDKMessagingClientTypes.ChannelModeratorSummary]?
}

extension ListChannelModeratorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case channelModerators = "ChannelModerators"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelModeratorsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.ChannelModeratorSummary?].self, forKey: .channelModerators)
        var channelModeratorsDecoded0:[ChimeSDKMessagingClientTypes.ChannelModeratorSummary]? = nil
        if let channelModeratorsContainer = channelModeratorsContainer {
            channelModeratorsDecoded0 = [ChimeSDKMessagingClientTypes.ChannelModeratorSummary]()
            for structure0 in channelModeratorsContainer {
                if let structure0 = structure0 {
                    channelModeratorsDecoded0?.append(structure0)
                }
            }
        }
        channelModerators = channelModeratorsDecoded0
    }
}

extension ListChannelsAssociatedWithChannelFlowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsAssociatedWithChannelFlowInput(channelFlowArn: \(Swift.String(describing: channelFlowArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelsAssociatedWithChannelFlowInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "scope", value: "channel-flow-associations"))
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let channelFlowArn = channelFlowArn else {
                let message = "Creating a URL Query Item failed. channelFlowArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let channelFlowArnQueryItem = ClientRuntime.URLQueryItem(name: "channel-flow-arn".urlPercentEncoding(), value: Swift.String(channelFlowArn).urlPercentEncoding())
            items.append(channelFlowArnQueryItem)
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChannelsAssociatedWithChannelFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct ListChannelsAssociatedWithChannelFlowInput: Swift.Equatable {
    /// The ARN of the channel flow.
    /// This member is required.
    public var channelFlowArn: Swift.String?
    /// The maximum number of channels that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channels are returned.
    public var nextToken: Swift.String?

    public init (
        channelFlowArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelFlowArn = channelFlowArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsAssociatedWithChannelFlowInputBody: Swift.Equatable {
}

extension ListChannelsAssociatedWithChannelFlowInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelsAssociatedWithChannelFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsAssociatedWithChannelFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListChannelsAssociatedWithChannelFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsAssociatedWithChannelFlowOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsAssociatedWithChannelFlowOutputResponse(channels: \(Swift.String(describing: channels)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelsAssociatedWithChannelFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListChannelsAssociatedWithChannelFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsAssociatedWithChannelFlowOutputResponse: Swift.Equatable {
    /// The information about each channel.
    public var channels: [ChimeSDKMessagingClientTypes.ChannelAssociatedWithFlowSummary]?
    /// The token passed by previous API calls until all requested channels are returned.
    public var nextToken: Swift.String?

    public init (
        channels: [ChimeSDKMessagingClientTypes.ChannelAssociatedWithFlowSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsAssociatedWithChannelFlowOutputResponseBody: Swift.Equatable {
    let channels: [ChimeSDKMessagingClientTypes.ChannelAssociatedWithFlowSummary]?
    let nextToken: Swift.String?
}

extension ListChannelsAssociatedWithChannelFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.ChannelAssociatedWithFlowSummary?].self, forKey: .channels)
        var channelsDecoded0:[ChimeSDKMessagingClientTypes.ChannelAssociatedWithFlowSummary]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [ChimeSDKMessagingClientTypes.ChannelAssociatedWithFlowSummary]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), privacy: \(Swift.String(describing: privacy)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let privacy = privacy {
                let privacyQueryItem = ClientRuntime.URLQueryItem(name: "privacy".urlPercentEncoding(), value: Swift.String(privacy.rawValue).urlPercentEncoding())
                items.append(privacyQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let appInstanceArn = appInstanceArn else {
                let message = "Creating a URL Query Item failed. appInstanceArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let appInstanceArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-arn".urlPercentEncoding(), value: Swift.String(appInstanceArn).urlPercentEncoding())
            items.append(appInstanceArnQueryItem)
            return items
        }
    }
}

extension ListChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct ListChannelsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of channels that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channels are returned.
    public var nextToken: Swift.String?
    /// The privacy setting. PUBLIC retrieves all the public channels. PRIVATE retrieves private channels. Only an AppInstanceAdmin can retrieve private channels.
    public var privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy?

    public init (
        appInstanceArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.privacy = privacy
    }
}

struct ListChannelsInputBody: Swift.Equatable {
}

extension ListChannelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelsModeratedByAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsModeratedByAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelsModeratedByAppInstanceUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelsModeratedByAppInstanceUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "scope", value: "app-instance-user-moderated-channels"))
            if let appInstanceUserArn = appInstanceUserArn {
                let appInstanceUserArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
                items.append(appInstanceUserArnQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListChannelsModeratedByAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct ListChannelsModeratedByAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the user in the moderated channel.
    public var appInstanceUserArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of channels in the request.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of channels moderated by the user is reached.
    public var nextToken: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsModeratedByAppInstanceUserInputBody: Swift.Equatable {
}

extension ListChannelsModeratedByAppInstanceUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChannelsModeratedByAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsModeratedByAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListChannelsModeratedByAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsModeratedByAppInstanceUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsModeratedByAppInstanceUserOutputResponse(channels: \(Swift.String(describing: channels)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelsModeratedByAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListChannelsModeratedByAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsModeratedByAppInstanceUserOutputResponse: Swift.Equatable {
    /// The moderated channels in the request.
    public var channels: [ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary]?
    /// The token returned from previous API requests until the number of channels moderated by the user is reached.
    public var nextToken: Swift.String?

    public init (
        channels: [ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsModeratedByAppInstanceUserOutputResponseBody: Swift.Equatable {
    let channels: [ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary]?
    let nextToken: Swift.String?
}

extension ListChannelsModeratedByAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary?].self, forKey: .channels)
        var channelsDecoded0:[ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListChannelsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsOutputResponse(channels: \(Swift.String(describing: channels)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutputResponse: Swift.Equatable {
    /// The information about each channel.
    public var channels: [ChimeSDKMessagingClientTypes.ChannelSummary]?
    /// The token returned from previous API requests until the number of channels is reached.
    public var nextToken: Swift.String?

    public init (
        channels: [ChimeSDKMessagingClientTypes.ChannelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputResponseBody: Swift.Equatable {
    let channels: [ChimeSDKMessagingClientTypes.ChannelSummary]?
    let nextToken: Swift.String?
}

extension ListChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.ChannelSummary?].self, forKey: .channels)
        var channelsDecoded0:[ChimeSDKMessagingClientTypes.ChannelSummary]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [ChimeSDKMessagingClientTypes.ChannelSummary]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSubChannelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSubChannelsInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListSubChannelsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListSubChannelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSubChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/subchannels"
    }
}

public struct ListSubChannelsInput: Swift.Equatable {
    /// The ARN of elastic channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user making the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of sub-channels that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested sub-channels are returned.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSubChannelsInputBody: Swift.Equatable {
}

extension ListSubChannelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSubChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSubChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSubChannelsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSubChannelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSubChannelsOutputResponse(channelArn: \(Swift.String(describing: channelArn)), subChannels: \(Swift.String(describing: subChannels)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListSubChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSubChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.nextToken = output.nextToken
            self.subChannels = output.subChannels
        } else {
            self.channelArn = nil
            self.nextToken = nil
            self.subChannels = nil
        }
    }
}

public struct ListSubChannelsOutputResponse: Swift.Equatable {
    /// The ARN of elastic channel.
    public var channelArn: Swift.String?
    /// The token passed by previous API calls until all requested sub-channels are returned.
    public var nextToken: Swift.String?
    /// The information about each sub-channel.
    public var subChannels: [ChimeSDKMessagingClientTypes.SubChannelSummary]?

    public init (
        channelArn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        subChannels: [ChimeSDKMessagingClientTypes.SubChannelSummary]? = nil
    )
    {
        self.channelArn = channelArn
        self.nextToken = nextToken
        self.subChannels = subChannels
    }
}

struct ListSubChannelsOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let subChannels: [ChimeSDKMessagingClientTypes.SubChannelSummary]?
    let nextToken: Swift.String?
}

extension ListSubChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case nextToken = "NextToken"
        case subChannels = "SubChannels"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let subChannelsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.SubChannelSummary?].self, forKey: .subChannels)
        var subChannelsDecoded0:[ChimeSDKMessagingClientTypes.SubChannelSummary]? = nil
        if let subChannelsContainer = subChannelsContainer {
            subChannelsDecoded0 = [ChimeSDKMessagingClientTypes.SubChannelSummary]()
            for structure0 in subChannelsContainer {
                if let structure0 = structure0 {
                    subChannelsDecoded0?.append(structure0)
                }
            }
        }
        subChannels = subChannelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceARN = resourceARN else {
                let message = "Creating a URL Query Item failed. resourceARN is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceARNQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
            items.append(resourceARNQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tag key-value pairs.
    public var tags: [ChimeSDKMessagingClientTypes.Tag]?

    public init (
        tags: [ChimeSDKMessagingClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [ChimeSDKMessagingClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMessagingClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMessagingClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ChimeSDKMessagingClientTypes.MessageAttributeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stringValues = "StringValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stringValues = stringValues {
            var stringValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stringValues)
            for messageattributestringvalue0 in stringValues {
                try stringValuesContainer.encode(messageattributestringvalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stringValues)
        var stringValuesDecoded0:[Swift.String]? = nil
        if let stringValuesContainer = stringValuesContainer {
            stringValuesDecoded0 = [Swift.String]()
            for string0 in stringValuesContainer {
                if let string0 = string0 {
                    stringValuesDecoded0?.append(string0)
                }
            }
        }
        stringValues = stringValuesDecoded0
    }
}

extension ChimeSDKMessagingClientTypes {
    /// A list of message attribute values.
    public struct MessageAttributeValue: Swift.Equatable {
        /// The strings in a message attribute value.
        public var stringValues: [Swift.String]?

        public init (
            stringValues: [Swift.String]? = nil
        )
        {
            self.stringValues = stringValues
        }
    }

}

extension ChimeSDKMessagingClientTypes.MessagingSessionEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// The websocket endpoint used to connect to Amazon Chime SDK messaging.
    public struct MessagingSessionEndpoint: Swift.Equatable {
        /// The endpoint to which you establish a websocket connection.
        public var url: Swift.String?

        public init (
            url: Swift.String? = nil
        )
        {
            self.url = url
        }
    }

}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the resources in the request does not exist in the system.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let code: ChimeSDKMessagingClientTypes.ErrorCode?
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKMessagingClientTypes.Processor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case executionOrder = "ExecutionOrder"
        case fallbackAction = "FallbackAction"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let executionOrder = self.executionOrder {
            try encodeContainer.encode(executionOrder, forKey: .executionOrder)
        }
        if let fallbackAction = self.fallbackAction {
            try encodeContainer.encode(fallbackAction.rawValue, forKey: .fallbackAction)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ProcessorConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let executionOrderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executionOrder)
        executionOrder = executionOrderDecoded
        let fallbackActionDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.FallbackAction.self, forKey: .fallbackAction)
        fallbackAction = fallbackActionDecoded
    }
}

extension ChimeSDKMessagingClientTypes.Processor: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Processor(configuration: \(Swift.String(describing: configuration)), executionOrder: \(Swift.String(describing: executionOrder)), fallbackAction: \(Swift.String(describing: fallbackAction)), name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {
    /// The information about a processor in a channel flow.
    public struct Processor: Swift.Equatable {
        /// The information about the type of processor and its identifier.
        /// This member is required.
        public var configuration: ChimeSDKMessagingClientTypes.ProcessorConfiguration?
        /// The sequence in which processors run. If you have multiple processors in a channel flow, message processing goes through each processor in the sequence. The value determines the sequence. At this point, we support only 1 processor within a flow.
        /// This member is required.
        public var executionOrder: Swift.Int?
        /// Determines whether to continue with message processing or stop it in cases where communication with a processor fails. If a processor has a fallback action of ABORT and communication with it fails, the processor sets the message status to FAILED and does not send the message to any recipients. Note that if the last processor in the channel flow sequence has a fallback action of CONTINUE and communication with the processor fails, then the message is considered processed and sent to recipients of the channel.
        /// This member is required.
        public var fallbackAction: ChimeSDKMessagingClientTypes.FallbackAction?
        /// The name of the channel flow.
        /// This member is required.
        public var name: Swift.String?

        public init (
            configuration: ChimeSDKMessagingClientTypes.ProcessorConfiguration? = nil,
            executionOrder: Swift.Int? = nil,
            fallbackAction: ChimeSDKMessagingClientTypes.FallbackAction? = nil,
            name: Swift.String? = nil
        )
        {
            self.configuration = configuration
            self.executionOrder = executionOrder
            self.fallbackAction = fallbackAction
            self.name = name
        }
    }

}

extension ChimeSDKMessagingClientTypes.ProcessorConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambda = "Lambda"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambda = self.lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.LambdaConfiguration.self, forKey: .lambda)
        lambda = lambdaDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// A processor's metadata.
    public struct ProcessorConfiguration: Swift.Equatable {
        /// Indicates that the processor is of type Lambda.
        /// This member is required.
        public var lambda: ChimeSDKMessagingClientTypes.LambdaConfiguration?

        public init (
            lambda: ChimeSDKMessagingClientTypes.LambdaConfiguration? = nil
        )
        {
            self.lambda = lambda
        }
    }

}

extension ChimeSDKMessagingClientTypes.PushNotificationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body = "Body"
        case title = "Title"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.PushNotificationType.self, forKey: .type)
        type = typeDecoded
    }
}

extension ChimeSDKMessagingClientTypes.PushNotificationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PushNotificationConfiguration(type: \(Swift.String(describing: type)), body: \"CONTENT_REDACTED\", title: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {
    /// The push notification configuration of the message.
    public struct PushNotificationConfiguration: Swift.Equatable {
        /// The body of the push notification.
        public var body: Swift.String?
        /// The title of the push notification.
        public var title: Swift.String?
        /// Enum value that indicates the type of the push notification for a message. DEFAULT: Normal mobile push notification. VOIP: VOIP mobile push notification.
        public var type: ChimeSDKMessagingClientTypes.PushNotificationType?

        public init (
            body: Swift.String? = nil,
            title: Swift.String? = nil,
            type: ChimeSDKMessagingClientTypes.PushNotificationType? = nil
        )
        {
            self.body = body
            self.title = title
            self.type = type
        }
    }

}

extension ChimeSDKMessagingClientTypes.PushNotificationPreferences: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowNotifications = "AllowNotifications"
        case filterRule = "FilterRule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowNotifications = self.allowNotifications {
            try encodeContainer.encode(allowNotifications.rawValue, forKey: .allowNotifications)
        }
        if let filterRule = self.filterRule {
            try encodeContainer.encode(filterRule, forKey: .filterRule)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowNotificationsDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.AllowNotifications.self, forKey: .allowNotifications)
        allowNotifications = allowNotificationsDecoded
        let filterRuleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterRule)
        filterRule = filterRuleDecoded
    }
}

extension ChimeSDKMessagingClientTypes.PushNotificationPreferences: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PushNotificationPreferences(allowNotifications: \(Swift.String(describing: allowNotifications)), filterRule: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {
    /// The channel membership preferences for push notification.
    public struct PushNotificationPreferences: Swift.Equatable {
        /// Enum value that indicates which push notifications to send to the requested member of a channel. ALL sends all push notifications, NONE sends no push notifications, FILTERED sends only filtered push notifications.
        /// This member is required.
        public var allowNotifications: ChimeSDKMessagingClientTypes.AllowNotifications?
        /// The simple JSON object used to send a subset of a push notification to the requested member.
        public var filterRule: Swift.String?

        public init (
            allowNotifications: ChimeSDKMessagingClientTypes.AllowNotifications? = nil,
            filterRule: Swift.String? = nil
        )
        {
            self.allowNotifications = allowNotifications
            self.filterRule = filterRule
        }
    }

}

extension ChimeSDKMessagingClientTypes {
    public enum PushNotificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case voip
        case sdkUnknown(Swift.String)

        public static var allCases: [PushNotificationType] {
            return [
                .default,
                .voip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .voip: return "VOIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PushNotificationType(rawValue: rawValue) ?? PushNotificationType.sdkUnknown(rawValue)
        }
    }
}

extension PutChannelMembershipPreferencesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preferences = "Preferences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let preferences = self.preferences {
            try encodeContainer.encode(preferences, forKey: .preferences)
        }
    }
}

extension PutChannelMembershipPreferencesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension PutChannelMembershipPreferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let memberArn = memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())/preferences"
    }
}

public struct PutChannelMembershipPreferencesInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserARN of the user making the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member setting the preferences.
    /// This member is required.
    public var memberArn: Swift.String?
    /// The channel membership preferences of an AppInstanceUser .
    /// This member is required.
    public var preferences: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil,
        preferences: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
        self.preferences = preferences
    }
}

struct PutChannelMembershipPreferencesInputBody: Swift.Equatable {
    let preferences: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences?
}

extension PutChannelMembershipPreferencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preferences = "Preferences"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preferencesDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMembershipPreferences.self, forKey: .preferences)
        preferences = preferencesDecoded
    }
}

extension PutChannelMembershipPreferencesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutChannelMembershipPreferencesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutChannelMembershipPreferencesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutChannelMembershipPreferencesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutChannelMembershipPreferencesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.member = output.member
            self.preferences = output.preferences
        } else {
            self.channelArn = nil
            self.member = nil
            self.preferences = nil
        }
    }
}

public struct PutChannelMembershipPreferencesOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The details of a user.
    public var member: ChimeSDKMessagingClientTypes.Identity?
    /// The ARN and metadata of the member being added.
    public var preferences: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences?

    public init (
        channelArn: Swift.String? = nil,
        member: ChimeSDKMessagingClientTypes.Identity? = nil,
        preferences: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
        self.preferences = preferences
    }
}

struct PutChannelMembershipPreferencesOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let member: ChimeSDKMessagingClientTypes.Identity?
    let preferences: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences?
}

extension PutChannelMembershipPreferencesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case member = "Member"
        case preferences = "Preferences"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let memberDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.Identity.self, forKey: .member)
        member = memberDecoded
        let preferencesDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMembershipPreferences.self, forKey: .preferences)
        preferences = preferencesDecoded
    }
}

extension RedactChannelMessageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subChannelId = "SubChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subChannelId = self.subChannelId {
            try encodeContainer.encode(subChannelId, forKey: .subChannelId)
        }
    }
}

extension RedactChannelMessageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension RedactChannelMessageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "redact"))
            return items
        }
    }
}

extension RedactChannelMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let messageId = messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

public struct RedactChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel containing the messages that you want to redact.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ID of the message being redacted.
    /// This member is required.
    public var messageId: Swift.String?
    /// The ID of the SubChannel in the request.
    public var subChannelId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
        self.subChannelId = subChannelId
    }
}

struct RedactChannelMessageInputBody: Swift.Equatable {
    let subChannelId: Swift.String?
}

extension RedactChannelMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subChannelId = "SubChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subChannelId)
        subChannelId = subChannelIdDecoded
    }
}

extension RedactChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RedactChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RedactChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RedactChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RedactChannelMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.messageId = output.messageId
            self.subChannelId = output.subChannelId
        } else {
            self.channelArn = nil
            self.messageId = nil
            self.subChannelId = nil
        }
    }
}

public struct RedactChannelMessageOutputResponse: Swift.Equatable {
    /// The ARN of the channel containing the messages that you want to redact.
    public var channelArn: Swift.String?
    /// The ID of the message being redacted.
    public var messageId: Swift.String?
    /// The ID of the SubChannel in the response. Only required when redacting messages in a SubChannel that the user belongs to.
    public var subChannelId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
        self.subChannelId = subChannelId
    }
}

struct RedactChannelMessageOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let messageId: Swift.String?
    let subChannelId: Swift.String?
}

extension RedactChannelMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case messageId = "MessageId"
        case subChannelId = "SubChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let subChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subChannelId)
        subChannelId = subChannelIdDecoded
    }
}

extension ResourceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeds the resource limit.
public struct ResourceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    let code: ChimeSDKMessagingClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SearchChannelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchChannelsInput(chimeBearer: \(Swift.String(describing: chimeBearer)), fields: \(Swift.String(describing: fields)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension SearchChannelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fields)
            for searchfield0 in fields {
                try fieldsContainer.encode(searchfield0)
            }
        }
    }
}

extension SearchChannelsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension SearchChannelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "search"))
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension SearchChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/channels"
    }
}

public struct SearchChannelsInput: Swift.Equatable {
    /// The AppInstanceUserArn of the user making the API call.
    public var chimeBearer: Swift.String?
    /// A list of the Field objects in the channel being searched.
    /// This member is required.
    public var fields: [ChimeSDKMessagingClientTypes.SearchField]?
    /// The maximum number of channels that you want returned.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of channels is reached.
    public var nextToken: Swift.String?

    public init (
        chimeBearer: Swift.String? = nil,
        fields: [ChimeSDKMessagingClientTypes.SearchField]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.chimeBearer = chimeBearer
        self.fields = fields
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct SearchChannelsInputBody: Swift.Equatable {
    let fields: [ChimeSDKMessagingClientTypes.SearchField]?
}

extension SearchChannelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.SearchField?].self, forKey: .fields)
        var fieldsDecoded0:[ChimeSDKMessagingClientTypes.SearchField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ChimeSDKMessagingClientTypes.SearchField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension SearchChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchChannelsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchChannelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchChannelsOutputResponse(channels: \(Swift.String(describing: channels)), nextToken: \"CONTENT_REDACTED\")"}
}

extension SearchChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct SearchChannelsOutputResponse: Swift.Equatable {
    /// A list of the channels in the request.
    public var channels: [ChimeSDKMessagingClientTypes.ChannelSummary]?
    /// The token returned from previous API responses until the number of channels is reached.
    public var nextToken: Swift.String?

    public init (
        channels: [ChimeSDKMessagingClientTypes.ChannelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct SearchChannelsOutputResponseBody: Swift.Equatable {
    let channels: [ChimeSDKMessagingClientTypes.ChannelSummary]?
    let nextToken: Swift.String?
}

extension SearchChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels = "Channels"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.ChannelSummary?].self, forKey: .channels)
        var channelsDecoded0:[ChimeSDKMessagingClientTypes.ChannelSummary]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [ChimeSDKMessagingClientTypes.ChannelSummary]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ChimeSDKMessagingClientTypes.SearchField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case `operator` = "Operator"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for searchfieldvalue0 in values {
                try valuesContainer.encode(searchfieldvalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.SearchFieldKey.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.SearchFieldOperator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// A Field of the channel that you want to search.
    public struct SearchField: Swift.Equatable {
        /// An enum value that indicates the key to search the channel on. MEMBERS allows you to search channels based on memberships. You can use it with the EQUALS operator to get channels whose memberships are equal to the specified values, and with the INCLUDES operator to get channels whose memberships include the specified values.
        /// This member is required.
        public var key: ChimeSDKMessagingClientTypes.SearchFieldKey?
        /// The operator used to compare field values, currently EQUALS or INCLUDES. Use the EQUALS operator to find channels whose memberships equal the specified values. Use the INCLUDES operator to find channels whose memberships include the specified values.
        /// This member is required.
        public var `operator`: ChimeSDKMessagingClientTypes.SearchFieldOperator?
        /// The values that you want to search for, a list of strings. The values must be AppInstanceUserArns specified as a list of strings. This operation isn't supported for AppInstanceUsers with large number of memberships.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: ChimeSDKMessagingClientTypes.SearchFieldKey? = nil,
            `operator`: ChimeSDKMessagingClientTypes.SearchFieldOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension ChimeSDKMessagingClientTypes {
    public enum SearchFieldKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case members
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchFieldKey] {
            return [
                .members,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .members: return "MEMBERS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SearchFieldKey(rawValue: rawValue) ?? SearchFieldKey.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMessagingClientTypes {
    public enum SearchFieldOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case includes
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchFieldOperator] {
            return [
                .equals,
                .includes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .includes: return "INCLUDES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SearchFieldOperator(rawValue: rawValue) ?? SearchFieldOperator.sdkUnknown(rawValue)
        }
    }
}

extension SendChannelMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendChannelMessageInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), messageAttributes: \(Swift.String(describing: messageAttributes)), persistence: \(Swift.String(describing: persistence)), pushNotification: \(Swift.String(describing: pushNotification)), subChannelId: \(Swift.String(describing: subChannelId)), type: \(Swift.String(describing: type)), clientRequestToken: \"CONTENT_REDACTED\", content: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

extension SendChannelMessageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case content = "Content"
        case messageAttributes = "MessageAttributes"
        case metadata = "Metadata"
        case persistence = "Persistence"
        case pushNotification = "PushNotification"
        case subChannelId = "SubChannelId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let messageAttributes = messageAttributes {
            var messageAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .messageAttributes)
            for (dictKey0, messageAttributeMap0) in messageAttributes {
                try messageAttributesContainer.encode(messageAttributeMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let persistence = self.persistence {
            try encodeContainer.encode(persistence.rawValue, forKey: .persistence)
        }
        if let pushNotification = self.pushNotification {
            try encodeContainer.encode(pushNotification, forKey: .pushNotification)
        }
        if let subChannelId = self.subChannelId {
            try encodeContainer.encode(subChannelId, forKey: .subChannelId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension SendChannelMessageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension SendChannelMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages"
    }
}

public struct SendChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The Idempotency token for each client request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The content of the message.
    /// This member is required.
    public var content: Swift.String?
    /// The attributes for the message, used for message filtering along with a FilterRule defined in the PushNotificationPreferences.
    public var messageAttributes: [Swift.String:ChimeSDKMessagingClientTypes.MessageAttributeValue]?
    /// The optional metadata for each message.
    public var metadata: Swift.String?
    /// Boolean that controls whether the message is persisted on the back end. Required.
    /// This member is required.
    public var persistence: ChimeSDKMessagingClientTypes.ChannelMessagePersistenceType?
    /// The push notification configuration of the message.
    public var pushNotification: ChimeSDKMessagingClientTypes.PushNotificationConfiguration?
    /// The ID of the SubChannel in the request.
    public var subChannelId: Swift.String?
    /// The type of message, STANDARD or CONTROL.
    /// This member is required.
    public var type: ChimeSDKMessagingClientTypes.ChannelMessageType?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        content: Swift.String? = nil,
        messageAttributes: [Swift.String:ChimeSDKMessagingClientTypes.MessageAttributeValue]? = nil,
        metadata: Swift.String? = nil,
        persistence: ChimeSDKMessagingClientTypes.ChannelMessagePersistenceType? = nil,
        pushNotification: ChimeSDKMessagingClientTypes.PushNotificationConfiguration? = nil,
        subChannelId: Swift.String? = nil,
        type: ChimeSDKMessagingClientTypes.ChannelMessageType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.messageAttributes = messageAttributes
        self.metadata = metadata
        self.persistence = persistence
        self.pushNotification = pushNotification
        self.subChannelId = subChannelId
        self.type = type
    }
}

struct SendChannelMessageInputBody: Swift.Equatable {
    let content: Swift.String?
    let type: ChimeSDKMessagingClientTypes.ChannelMessageType?
    let persistence: ChimeSDKMessagingClientTypes.ChannelMessagePersistenceType?
    let metadata: Swift.String?
    let clientRequestToken: Swift.String?
    let pushNotification: ChimeSDKMessagingClientTypes.PushNotificationConfiguration?
    let messageAttributes: [Swift.String:ChimeSDKMessagingClientTypes.MessageAttributeValue]?
    let subChannelId: Swift.String?
}

extension SendChannelMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case content = "Content"
        case messageAttributes = "MessageAttributes"
        case metadata = "Metadata"
        case persistence = "Persistence"
        case pushNotification = "PushNotification"
        case subChannelId = "SubChannelId"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMessageType.self, forKey: .type)
        type = typeDecoded
        let persistenceDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMessagePersistenceType.self, forKey: .persistence)
        persistence = persistenceDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let pushNotificationDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.PushNotificationConfiguration.self, forKey: .pushNotification)
        pushNotification = pushNotificationDecoded
        let messageAttributesContainer = try containerValues.decodeIfPresent([Swift.String: ChimeSDKMessagingClientTypes.MessageAttributeValue?].self, forKey: .messageAttributes)
        var messageAttributesDecoded0: [Swift.String:ChimeSDKMessagingClientTypes.MessageAttributeValue]? = nil
        if let messageAttributesContainer = messageAttributesContainer {
            messageAttributesDecoded0 = [Swift.String:ChimeSDKMessagingClientTypes.MessageAttributeValue]()
            for (key0, messageattributevalue0) in messageAttributesContainer {
                if let messageattributevalue0 = messageattributevalue0 {
                    messageAttributesDecoded0?[key0] = messageattributevalue0
                }
            }
        }
        messageAttributes = messageAttributesDecoded0
        let subChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subChannelId)
        subChannelId = subChannelIdDecoded
    }
}

extension SendChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SendChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SendChannelMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.messageId = output.messageId
            self.status = output.status
            self.subChannelId = output.subChannelId
        } else {
            self.channelArn = nil
            self.messageId = nil
            self.status = nil
            self.subChannelId = nil
        }
    }
}

public struct SendChannelMessageOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ID string assigned to each message.
    public var messageId: Swift.String?
    /// The status of the channel message.
    public var status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure?
    /// The ID of the SubChannel in the response.
    public var subChannelId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil,
        status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
        self.status = status
        self.subChannelId = subChannelId
    }
}

struct SendChannelMessageOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let messageId: Swift.String?
    let status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure?
    let subChannelId: Swift.String?
}

extension SendChannelMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case messageId = "MessageId"
        case status = "Status"
        case subChannelId = "SubChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure.self, forKey: .status)
        status = statusDecoded
        let subChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subChannelId)
        subChannelId = subChannelIdDecoded
    }
}

extension ServiceFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service encountered an unexpected error.
public struct ServiceFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: ChimeSDKMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceFailureExceptionBody: Swift.Equatable {
    let code: ChimeSDKMessagingClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: ChimeSDKMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let code: ChimeSDKMessagingClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKMessagingClientTypes.SubChannelSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case membershipCount = "MembershipCount"
        case subChannelId = "SubChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let membershipCount = self.membershipCount {
            try encodeContainer.encode(membershipCount, forKey: .membershipCount)
        }
        if let subChannelId = self.subChannelId {
            try encodeContainer.encode(subChannelId, forKey: .subChannelId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subChannelId)
        subChannelId = subChannelIdDecoded
        let membershipCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .membershipCount)
        membershipCount = membershipCountDecoded
    }
}

extension ChimeSDKMessagingClientTypes {
    /// Summary of the sub-channels associated with the elastic channel.
    public struct SubChannelSummary: Swift.Equatable {
        /// The number of members in a SubChannel.
        public var membershipCount: Swift.Int?
        /// The unique ID of a SubChannel.
        public var subChannelId: Swift.String?

        public init (
            membershipCount: Swift.Int? = nil,
            subChannelId: Swift.String? = nil
        )
        {
            self.membershipCount = membershipCount
            self.subChannelId = subChannelId
        }
    }

}

extension ChimeSDKMessagingClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ChimeSDKMessagingClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {
    /// A tag object containing a key-value pair.
    public struct Tag: Swift.Equatable {
        /// The key in a tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value in a tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "tag-resource"))
            return items
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [ChimeSDKMessagingClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [ChimeSDKMessagingClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [ChimeSDKMessagingClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKMessagingClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKMessagingClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottledClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottledClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client exceeded its request rate limit.
public struct ThrottledClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ThrottledClientExceptionBody: Swift.Equatable {
    let code: ChimeSDKMessagingClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ThrottledClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnauthorizedClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is not currently authorized to make the request.
public struct UnauthorizedClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKMessagingClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UnauthorizedClientExceptionBody: Swift.Equatable {
    let code: ChimeSDKMessagingClientTypes.ErrorCode?
    let message: Swift.String?
}

extension UnauthorizedClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "untag-resource"))
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateChannelFlowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelFlowInput(channelFlowArn: \(Swift.String(describing: channelFlowArn)), processors: \(Swift.String(describing: processors)), name: \"CONTENT_REDACTED\")"}
}

extension UpdateChannelFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case processors = "Processors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let processors = processors {
            var processorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processors)
            for processor0 in processors {
                try processorsContainer.encode(processor0)
            }
        }
    }
}

extension UpdateChannelFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelFlowArn = channelFlowArn else {
            return nil
        }
        return "/channel-flows/\(channelFlowArn.urlPercentEncoding())"
    }
}

public struct UpdateChannelFlowInput: Swift.Equatable {
    /// The ARN of the channel flow.
    /// This member is required.
    public var channelFlowArn: Swift.String?
    /// The name of the channel flow.
    /// This member is required.
    public var name: Swift.String?
    /// Information about the processor Lambda functions
    /// This member is required.
    public var processors: [ChimeSDKMessagingClientTypes.Processor]?

    public init (
        channelFlowArn: Swift.String? = nil,
        name: Swift.String? = nil,
        processors: [ChimeSDKMessagingClientTypes.Processor]? = nil
    )
    {
        self.channelFlowArn = channelFlowArn
        self.name = name
        self.processors = processors
    }
}

struct UpdateChannelFlowInputBody: Swift.Equatable {
    let processors: [ChimeSDKMessagingClientTypes.Processor]?
    let name: Swift.String?
}

extension UpdateChannelFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case processors = "Processors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let processorsContainer = try containerValues.decodeIfPresent([ChimeSDKMessagingClientTypes.Processor?].self, forKey: .processors)
        var processorsDecoded0:[ChimeSDKMessagingClientTypes.Processor]? = nil
        if let processorsContainer = processorsContainer {
            processorsDecoded0 = [ChimeSDKMessagingClientTypes.Processor]()
            for structure0 in processorsContainer {
                if let structure0 = structure0 {
                    processorsDecoded0?.append(structure0)
                }
            }
        }
        processors = processorsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateChannelFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateChannelFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateChannelFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelFlowArn = output.channelFlowArn
        } else {
            self.channelFlowArn = nil
        }
    }
}

public struct UpdateChannelFlowOutputResponse: Swift.Equatable {
    /// The ARN of the channel flow.
    public var channelFlowArn: Swift.String?

    public init (
        channelFlowArn: Swift.String? = nil
    )
    {
        self.channelFlowArn = channelFlowArn
    }
}

struct UpdateChannelFlowOutputResponseBody: Swift.Equatable {
    let channelFlowArn: Swift.String?
}

extension UpdateChannelFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelFlowArn = "ChannelFlowArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelFlowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelFlowArn)
        channelFlowArn = channelFlowArnDecoded
    }
}

extension UpdateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), mode: \(Swift.String(describing: mode)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateChannelInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension UpdateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

public struct UpdateChannelInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The metadata for the update request.
    public var metadata: Swift.String?
    /// The mode of the update request.
    public var mode: ChimeSDKMessagingClientTypes.ChannelMode?
    /// The name of the channel.
    public var name: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        metadata: Swift.String? = nil,
        mode: ChimeSDKMessagingClientTypes.ChannelMode? = nil,
        name: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.metadata = metadata
        self.mode = mode
        self.name = name
    }
}

struct UpdateChannelInputBody: Swift.Equatable {
    let name: Swift.String?
    let mode: ChimeSDKMessagingClientTypes.ChannelMode?
    let metadata: Swift.String?
}

extension UpdateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case mode = "Mode"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let modeDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMode.self, forKey: .mode)
        mode = modeDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension UpdateChannelMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelMessageInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), messageId: \(Swift.String(describing: messageId)), subChannelId: \(Swift.String(describing: subChannelId)), content: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

extension UpdateChannelMessageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case metadata = "Metadata"
        case subChannelId = "SubChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let subChannelId = self.subChannelId {
            try encodeContainer.encode(subChannelId, forKey: .subChannelId)
        }
    }
}

extension UpdateChannelMessageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension UpdateChannelMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        guard let messageId = messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

public struct UpdateChannelMessageInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The content of the message being updated.
    public var content: Swift.String?
    /// The ID string of the message being updated.
    /// This member is required.
    public var messageId: Swift.String?
    /// The metadata of the message being updated.
    public var metadata: Swift.String?
    /// The ID of the SubChannel in the request. Only required when updating messages in a SubChannel that the user belongs to.
    public var subChannelId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        content: Swift.String? = nil,
        messageId: Swift.String? = nil,
        metadata: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.content = content
        self.messageId = messageId
        self.metadata = metadata
        self.subChannelId = subChannelId
    }
}

struct UpdateChannelMessageInputBody: Swift.Equatable {
    let content: Swift.String?
    let metadata: Swift.String?
    let subChannelId: Swift.String?
}

extension UpdateChannelMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case metadata = "Metadata"
        case subChannelId = "SubChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let subChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subChannelId)
        subChannelId = subChannelIdDecoded
    }
}

extension UpdateChannelMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateChannelMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateChannelMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.messageId = output.messageId
            self.status = output.status
            self.subChannelId = output.subChannelId
        } else {
            self.channelArn = nil
            self.messageId = nil
            self.status = nil
            self.subChannelId = nil
        }
    }
}

public struct UpdateChannelMessageOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ID string of the message being updated.
    public var messageId: Swift.String?
    /// The status of the message update.
    public var status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure?
    /// The ID of the SubChannel in the response.
    public var subChannelId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil,
        status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
        self.status = status
        self.subChannelId = subChannelId
    }
}

struct UpdateChannelMessageOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let messageId: Swift.String?
    let status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure?
    let subChannelId: Swift.String?
}

extension UpdateChannelMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case messageId = "MessageId"
        case status = "Status"
        case subChannelId = "SubChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure.self, forKey: .status)
        status = statusDecoded
        let subChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subChannelId)
        subChannelId = subChannelIdDecoded
    }
}

extension UpdateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateChannelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
        } else {
            self.channelArn = nil
        }
    }
}

public struct UpdateChannelOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct UpdateChannelOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
}

extension UpdateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

extension UpdateChannelReadMarkerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subChannelId = "SubChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subChannelId = self.subChannelId {
            try encodeContainer.encode(subChannelId, forKey: .subChannelId)
        }
    }
}

extension UpdateChannelReadMarkerInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let chimeBearer = chimeBearer {
            items.add(Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension UpdateChannelReadMarkerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let channelArn = channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/readMarker"
    }
}

public struct UpdateChannelReadMarkerInput: Swift.Equatable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ID of the SubChannel in the request.
    public var subChannelId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.subChannelId = subChannelId
    }
}

struct UpdateChannelReadMarkerInputBody: Swift.Equatable {
    let subChannelId: Swift.String?
}

extension UpdateChannelReadMarkerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subChannelId = "SubChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subChannelId)
        subChannelId = subChannelIdDecoded
    }
}

extension UpdateChannelReadMarkerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelReadMarkerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateChannelReadMarkerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelReadMarkerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateChannelReadMarkerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelArn = output.channelArn
            self.subChannelId = output.subChannelId
        } else {
            self.channelArn = nil
            self.subChannelId = nil
        }
    }
}

public struct UpdateChannelReadMarkerOutputResponse: Swift.Equatable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ID of the SubChannel in the response.
    public var subChannelId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.subChannelId = subChannelId
    }
}

struct UpdateChannelReadMarkerOutputResponseBody: Swift.Equatable {
    let channelArn: Swift.String?
    let subChannelId: Swift.String?
}

extension UpdateChannelReadMarkerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn = "ChannelArn"
        case subChannelId = "SubChannelId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let subChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subChannelId)
        subChannelId = subChannelIdDecoded
    }
}
