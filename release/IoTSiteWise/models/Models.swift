// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessPolicySummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case id
        case identity
        case lastUpdateDate
        case permission
        case resource
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let identity = identity {
            try encodeContainer.encode(identity, forKey: .identity)
        }
        if let lastUpdateDate = lastUpdateDate {
            try encodeContainer.encode(lastUpdateDate.timeIntervalSince1970, forKey: .lastUpdateDate)
        }
        if let permission = permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let identityDecoded = try containerValues.decodeIfPresent(Identity.self, forKey: .identity)
        identity = identityDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Resource.self, forKey: .resource)
        resource = resourceDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(Permission.self, forKey: .permission)
        permission = permissionDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension AccessPolicySummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessPolicySummary(creationDate: \(String(describing: creationDate)), id: \(String(describing: id)), identity: \(String(describing: identity)), lastUpdateDate: \(String(describing: lastUpdateDate)), permission: \(String(describing: permission)), resource: \(String(describing: resource)))"}
}

/// <p>Contains an access policy that defines an identity's access to an AWS IoT SiteWise Monitor
///       resource.</p>
public struct AccessPolicySummary: Equatable {
    /// <p>The date the access policy was created, in Unix epoch time.</p>
    public let creationDate: Date?
    /// <p>The ID of the access policy.</p>
    public let id: String?
    /// <p>The identity (an AWS SSO user, an AWS SSO group, or an IAM user).</p>
    public let identity: Identity?
    /// <p>The date the access policy was last updated, in Unix epoch time.</p>
    public let lastUpdateDate: Date?
    /// <p>The permissions for the access policy. Note that a project <code>ADMINISTRATOR</code> is
    ///       also known as a project owner.</p>
    public let permission: Permission?
    /// <p>The AWS IoT SiteWise Monitor resource (a portal or project).</p>
    public let resource: Resource?

    public init (
        creationDate: Date? = nil,
        id: String? = nil,
        identity: Identity? = nil,
        lastUpdateDate: Date? = nil,
        permission: Permission? = nil,
        resource: Resource? = nil
    )
    {
        self.creationDate = creationDate
        self.id = id
        self.identity = identity
        self.lastUpdateDate = lastUpdateDate
        self.permission = permission
        self.resource = resource
    }
}

public enum AggregateType {
    case average
    case count
    case maximum
    case minimum
    case standardDeviation
    case sum
    case sdkUnknown(String)
}

extension AggregateType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AggregateType] {
        return [
            .average,
            .count,
            .maximum,
            .minimum,
            .standardDeviation,
            .sum,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .average: return "AVERAGE"
        case .count: return "COUNT"
        case .maximum: return "MAXIMUM"
        case .minimum: return "MINIMUM"
        case .standardDeviation: return "STANDARD_DEVIATION"
        case .sum: return "SUM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AggregateType(rawValue: rawValue) ?? AggregateType.sdkUnknown(rawValue)
    }
}

extension AggregatedValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case quality
        case timestamp
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quality = quality {
            try encodeContainer.encode(quality.rawValue, forKey: .quality)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let qualityDecoded = try containerValues.decodeIfPresent(Quality.self, forKey: .quality)
        quality = qualityDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Aggregates.self, forKey: .value)
        value = valueDecoded
    }
}

extension AggregatedValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AggregatedValue(quality: \(String(describing: quality)), timestamp: \(String(describing: timestamp)), value: \(String(describing: value)))"}
}

/// <p>Contains aggregated asset property values (for example, average, minimum, and
///       maximum).</p>
public struct AggregatedValue: Equatable {
    /// <p>The quality of the aggregated data.</p>
    public let quality: Quality?
    /// <p>The date the aggregating computations occurred, in Unix epoch time.</p>
    public let timestamp: Date?
    /// <p>The value of the aggregates.</p>
    public let value: Aggregates?

    public init (
        quality: Quality? = nil,
        timestamp: Date? = nil,
        value: Aggregates? = nil
    )
    {
        self.quality = quality
        self.timestamp = timestamp
        self.value = value
    }
}

extension Aggregates: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case average
        case count
        case maximum
        case minimum
        case standardDeviation
        case sum
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let average = average {
            try encodeContainer.encode(average, forKey: .average)
        }
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let maximum = maximum {
            try encodeContainer.encode(maximum, forKey: .maximum)
        }
        if let minimum = minimum {
            try encodeContainer.encode(minimum, forKey: .minimum)
        }
        if let standardDeviation = standardDeviation {
            try encodeContainer.encode(standardDeviation, forKey: .standardDeviation)
        }
        if let sum = sum {
            try encodeContainer.encode(sum, forKey: .sum)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let averageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .average)
        average = averageDecoded
        let countDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .count)
        count = countDecoded
        let maximumDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .maximum)
        maximum = maximumDecoded
        let minimumDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .minimum)
        minimum = minimumDecoded
        let sumDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .sum)
        sum = sumDecoded
        let standardDeviationDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .standardDeviation)
        standardDeviation = standardDeviationDecoded
    }
}

extension Aggregates: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Aggregates(average: \(String(describing: average)), count: \(String(describing: count)), maximum: \(String(describing: maximum)), minimum: \(String(describing: minimum)), standardDeviation: \(String(describing: standardDeviation)), sum: \(String(describing: sum)))"}
}

/// <p>Contains the (pre-calculated) aggregate values for an asset property.</p>
public struct Aggregates: Equatable {
    /// <p>The average (mean) value of the time series over a time interval window.</p>
    public let average: Double?
    /// <p>The count of data points in the time series over a time interval window.</p>
    public let count: Double?
    /// <p>The maximum value of the time series over a time interval window.</p>
    public let maximum: Double?
    /// <p>The minimum value of the time series over a time interval window.</p>
    public let minimum: Double?
    /// <p>The standard deviation of the time series over a time interval window.</p>
    public let standardDeviation: Double?
    /// <p>The sum of the time series over a time interval window.</p>
    public let sum: Double?

    public init (
        average: Double? = nil,
        count: Double? = nil,
        maximum: Double? = nil,
        minimum: Double? = nil,
        standardDeviation: Double? = nil,
        sum: Double? = nil
    )
    {
        self.average = average
        self.count = count
        self.maximum = maximum
        self.minimum = minimum
        self.standardDeviation = standardDeviation
        self.sum = sum
    }
}

extension Alarms: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarmRoleArn
        case notificationLambdaArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmRoleArn = alarmRoleArn {
            try encodeContainer.encode(alarmRoleArn, forKey: .alarmRoleArn)
        }
        if let notificationLambdaArn = notificationLambdaArn {
            try encodeContainer.encode(notificationLambdaArn, forKey: .notificationLambdaArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmRoleArn)
        alarmRoleArn = alarmRoleArnDecoded
        let notificationLambdaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notificationLambdaArn)
        notificationLambdaArn = notificationLambdaArnDecoded
    }
}

extension Alarms: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Alarms(alarmRoleArn: \(String(describing: alarmRoleArn)), notificationLambdaArn: \(String(describing: notificationLambdaArn)))"}
}

/// <p>Contains the configuration information of an alarm created in an AWS IoT SiteWise Monitor portal.
///   You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see .</p>
public struct Alarms: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the IAM role that allows the alarm to perform actions and access AWS resources, including AWS IoT Events.</p>
    public let alarmRoleArn: String?
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the AWS Lambda function that manages alarm notifications. For more information, see <a href="https://docs.aws.amazon.com/">Managing alarm notifications</a>
    ///       in the <i>AWS IoT Events Developer Guide</i>.</p>
    public let notificationLambdaArn: String?

    public init (
        alarmRoleArn: String? = nil,
        notificationLambdaArn: String? = nil
    )
    {
        self.alarmRoleArn = alarmRoleArn
        self.notificationLambdaArn = notificationLambdaArn
    }
}

extension AssetCompositeModel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case name
        case properties
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for assetproperties0 in properties {
                try propertiesContainer.encode(assetproperties0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([AssetProperty?].self, forKey: .properties)
        var propertiesDecoded0:[AssetProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [AssetProperty]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
    }
}

extension AssetCompositeModel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetCompositeModel(description: \(String(describing: description)), name: \(String(describing: name)), properties: \(String(describing: properties)), type: \(String(describing: type)))"}
}

/// <p>Contains information about a composite model in an asset. This object contains the asset's
///       properties that you define in the composite model.</p>
public struct AssetCompositeModel: Equatable {
    /// <p>The description of the composite model.</p>
    public let description: String?
    /// <p>The name of the composite model.</p>
    public let name: String?
    /// <p>The asset properties that this composite model defines.</p>
    public let properties: [AssetProperty]?
    /// <p>The type of the composite model. For alarm composite models, this type is
    ///         <code>AWS/ALARM</code>.</p>
    public let type: String?

    public init (
        description: String? = nil,
        name: String? = nil,
        properties: [AssetProperty]? = nil,
        type: String? = nil
    )
    {
        self.description = description
        self.name = name
        self.properties = properties
        self.type = type
    }
}

public enum AssetErrorCode {
    case internalFailure
    case sdkUnknown(String)
}

extension AssetErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssetErrorCode] {
        return [
            .internalFailure,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .internalFailure: return "INTERNAL_FAILURE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssetErrorCode(rawValue: rawValue) ?? AssetErrorCode.sdkUnknown(rawValue)
    }
}

extension AssetErrorDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetId
        case code
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(AssetErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssetErrorDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetErrorDetails(assetId: \(String(describing: assetId)), code: \(String(describing: code)), message: \(String(describing: message)))"}
}

/// <p>Contains error details for the requested associate project asset action.</p>
public struct AssetErrorDetails: Equatable {
    /// <p>The ID of the asset.</p>
    public let assetId: String?
    /// <p>The error code.</p>
    public let code: AssetErrorCode?
    /// <p>The error message.</p>
    public let message: String?

    public init (
        assetId: String? = nil,
        code: AssetErrorCode? = nil,
        message: String? = nil
    )
    {
        self.assetId = assetId
        self.code = code
        self.message = message
    }
}

extension AssetHierarchy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AssetHierarchy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetHierarchy(id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Describes an asset hierarchy that contains a hierarchy's name and ID.</p>
public struct AssetHierarchy: Equatable {
    /// <p>The ID of the hierarchy. This ID is a <code>hierarchyId</code>.</p>
    public let id: String?
    /// <p>The hierarchy name provided in the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html">CreateAssetModel</a> or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html">UpdateAssetModel</a>
    ///       API operation.</p>
    public let name: String?

    public init (
        id: String? = nil,
        name: String? = nil
    )
    {
        self.id = id
        self.name = name
    }
}

extension AssetHierarchyInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case childAssetId
        case parentAssetId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetId = childAssetId {
            try encodeContainer.encode(childAssetId, forKey: .childAssetId)
        }
        if let parentAssetId = parentAssetId {
            try encodeContainer.encode(parentAssetId, forKey: .parentAssetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentAssetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentAssetId)
        parentAssetId = parentAssetIdDecoded
        let childAssetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .childAssetId)
        childAssetId = childAssetIdDecoded
    }
}

extension AssetHierarchyInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetHierarchyInfo(childAssetId: \(String(describing: childAssetId)), parentAssetId: \(String(describing: parentAssetId)))"}
}

/// <p>Contains information about a parent asset and a child asset that are related through an
///       asset hierarchy.</p>
public struct AssetHierarchyInfo: Equatable {
    /// <p>The ID of the child asset in this asset relationship.</p>
    public let childAssetId: String?
    /// <p>The ID of the parent asset in this asset relationship.</p>
    public let parentAssetId: String?

    public init (
        childAssetId: String? = nil,
        parentAssetId: String? = nil
    )
    {
        self.childAssetId = childAssetId
        self.parentAssetId = parentAssetId
    }
}

extension AssetModelCompositeModel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case name
        case properties
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for assetmodelproperties0 in properties {
                try propertiesContainer.encode(assetmodelproperties0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([AssetModelProperty?].self, forKey: .properties)
        var propertiesDecoded0:[AssetModelProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [AssetModelProperty]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
    }
}

extension AssetModelCompositeModel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetModelCompositeModel(description: \(String(describing: description)), name: \(String(describing: name)), properties: \(String(describing: properties)), type: \(String(describing: type)))"}
}

/// <p>Contains information about a composite model in an asset model. This object contains the
///       asset property definitions that you define in the composite model.</p>
public struct AssetModelCompositeModel: Equatable {
    /// <p>The description of the composite model.</p>
    public let description: String?
    /// <p>The name of the composite model.</p>
    public let name: String?
    /// <p>The asset property definitions for this composite model.</p>
    public let properties: [AssetModelProperty]?
    /// <p>The type of the composite model. For alarm composite models, this type is
    ///       <code>AWS/ALARM</code>.</p>
    public let type: String?

    public init (
        description: String? = nil,
        name: String? = nil,
        properties: [AssetModelProperty]? = nil,
        type: String? = nil
    )
    {
        self.description = description
        self.name = name
        self.properties = properties
        self.type = type
    }
}

extension AssetModelCompositeModelDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case name
        case properties
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for assetmodelpropertydefinitions0 in properties {
                try propertiesContainer.encode(assetmodelpropertydefinitions0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([AssetModelPropertyDefinition?].self, forKey: .properties)
        var propertiesDecoded0:[AssetModelPropertyDefinition]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [AssetModelPropertyDefinition]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
    }
}

extension AssetModelCompositeModelDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetModelCompositeModelDefinition(description: \(String(describing: description)), name: \(String(describing: name)), properties: \(String(describing: properties)), type: \(String(describing: type)))"}
}

/// <p>Contains a composite model definition in an asset model. This composite model definition
///       is applied to all assets created from the asset model.</p>
public struct AssetModelCompositeModelDefinition: Equatable {
    /// <p>The description of the composite model.</p>
    public let description: String?
    /// <p>The name of the composite model.</p>
    public let name: String?
    /// <p>The asset property definitions for this composite model.</p>
    public let properties: [AssetModelPropertyDefinition]?
    /// <p>The type of the composite model. For alarm composite models, this type is
    ///       <code>AWS/ALARM</code>.</p>
    public let type: String?

    public init (
        description: String? = nil,
        name: String? = nil,
        properties: [AssetModelPropertyDefinition]? = nil,
        type: String? = nil
    )
    {
        self.description = description
        self.name = name
        self.properties = properties
        self.type = type
    }
}

extension AssetModelHierarchy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case childAssetModelId
        case id
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetModelId = childAssetModelId {
            try encodeContainer.encode(childAssetModelId, forKey: .childAssetModelId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let childAssetModelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .childAssetModelId)
        childAssetModelId = childAssetModelIdDecoded
    }
}

extension AssetModelHierarchy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetModelHierarchy(childAssetModelId: \(String(describing: childAssetModelId)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Describes an asset hierarchy that contains a hierarchy's name, ID, and child asset model
///       ID that specifies the type of asset that can be in this hierarchy.</p>
public struct AssetModelHierarchy: Equatable {
    /// <p>The ID of the asset model. All assets in this hierarchy must be instances of the
    ///         <code>childAssetModelId</code> asset model.</p>
    public let childAssetModelId: String?
    /// <p>The ID of the asset model hierarchy. This ID is a <code>hierarchyId</code>.</p>
    public let id: String?
    /// <p>The name of the asset model hierarchy that you specify by using the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html">CreateAssetModel</a> or
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html">UpdateAssetModel</a> API operation.</p>
    public let name: String?

    public init (
        childAssetModelId: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.childAssetModelId = childAssetModelId
        self.id = id
        self.name = name
    }
}

extension AssetModelHierarchyDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case childAssetModelId
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetModelId = childAssetModelId {
            try encodeContainer.encode(childAssetModelId, forKey: .childAssetModelId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let childAssetModelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .childAssetModelId)
        childAssetModelId = childAssetModelIdDecoded
    }
}

extension AssetModelHierarchyDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetModelHierarchyDefinition(childAssetModelId: \(String(describing: childAssetModelId)), name: \(String(describing: name)))"}
}

/// <p>Contains an asset model hierarchy used in asset model creation. An asset model hierarchy
///       determines the kind (or type) of asset that can belong to a hierarchy.</p>
public struct AssetModelHierarchyDefinition: Equatable {
    /// <p>The ID of an asset model for this hierarchy.</p>
    public let childAssetModelId: String?
    /// <p>The name of the asset model hierarchy definition (as specified in the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html">CreateAssetModel</a> or
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html">UpdateAssetModel</a> API operation).</p>
    public let name: String?

    public init (
        childAssetModelId: String? = nil,
        name: String? = nil
    )
    {
        self.childAssetModelId = childAssetModelId
        self.name = name
    }
}

extension AssetModelProperty: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataType
        case dataTypeSpec
        case id
        case name
        case type
        case unit
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let dataTypeSpec = dataTypeSpec {
            try encodeContainer.encode(dataTypeSpec, forKey: .dataTypeSpec)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeSpecDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataTypeSpec)
        dataTypeSpec = dataTypeSpecDecoded
        let unitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unit)
        unit = unitDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PropertyType.self, forKey: .type)
        type = typeDecoded
    }
}

extension AssetModelProperty: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetModelProperty(dataType: \(String(describing: dataType)), dataTypeSpec: \(String(describing: dataTypeSpec)), id: \(String(describing: id)), name: \(String(describing: name)), type: \(String(describing: type)), unit: \(String(describing: unit)))"}
}

/// <p>Contains information about an asset model property.</p>
public struct AssetModelProperty: Equatable {
    /// <p>The data type of the asset model property.</p>
    public let dataType: PropertyDataType?
    /// <p>The data type of the structure for this property. This parameter exists on properties that
    ///       have the <code>STRUCT</code> data type.</p>
    public let dataTypeSpec: String?
    /// <p>The ID of the asset model property.</p>
    public let id: String?
    /// <p>The name of the asset model property.</p>
    public let name: String?
    /// <p>The property type (see <code>PropertyType</code>).</p>
    public let type: PropertyType?
    /// <p>The unit of the asset model property, such as <code>Newtons</code> or
    ///       <code>RPM</code>.</p>
    public let unit: String?

    public init (
        dataType: PropertyDataType? = nil,
        dataTypeSpec: String? = nil,
        id: String? = nil,
        name: String? = nil,
        type: PropertyType? = nil,
        unit: String? = nil
    )
    {
        self.dataType = dataType
        self.dataTypeSpec = dataTypeSpec
        self.id = id
        self.name = name
        self.type = type
        self.unit = unit
    }
}

extension AssetModelPropertyDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataType
        case dataTypeSpec
        case name
        case type
        case unit
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let dataTypeSpec = dataTypeSpec {
            try encodeContainer.encode(dataTypeSpec, forKey: .dataTypeSpec)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeSpecDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataTypeSpec)
        dataTypeSpec = dataTypeSpecDecoded
        let unitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unit)
        unit = unitDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PropertyType.self, forKey: .type)
        type = typeDecoded
    }
}

extension AssetModelPropertyDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetModelPropertyDefinition(dataType: \(String(describing: dataType)), dataTypeSpec: \(String(describing: dataTypeSpec)), name: \(String(describing: name)), type: \(String(describing: type)), unit: \(String(describing: unit)))"}
}

/// <p>Contains an asset model property definition. This property definition is applied to all
///       assets created from the asset model.</p>
public struct AssetModelPropertyDefinition: Equatable {
    /// <p>The data type of the property definition.</p>
    ///          <p>If you specify <code>STRUCT</code>, you must also specify <code>dataTypeSpec</code> to
    ///       identify the type of the structure for this property.</p>
    public let dataType: PropertyDataType?
    /// <p>The data type of the structure for this property. This parameter is required on properties
    ///       that have the <code>STRUCT</code> data type.</p>
    ///          <p>The options for this parameter depend on the type of the composite model in which you
    ///       define this property. Use <code>AWS/ALARM_STATE</code> for alarm state in alarm composite
    ///       models.</p>
    public let dataTypeSpec: String?
    /// <p>The name of the property definition.</p>
    public let name: String?
    /// <p>The property definition type (see <code>PropertyType</code>). You can only specify one
    ///       type in a property definition.</p>
    public let type: PropertyType?
    /// <p>The unit of the property definition, such as <code>Newtons</code> or
    ///       <code>RPM</code>.</p>
    public let unit: String?

    public init (
        dataType: PropertyDataType? = nil,
        dataTypeSpec: String? = nil,
        name: String? = nil,
        type: PropertyType? = nil,
        unit: String? = nil
    )
    {
        self.dataType = dataType
        self.dataTypeSpec = dataTypeSpec
        self.name = name
        self.type = type
        self.unit = unit
    }
}

public enum AssetModelState {
    case active
    case creating
    case deleting
    case failed
    case propagating
    case updating
    case sdkUnknown(String)
}

extension AssetModelState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssetModelState] {
        return [
            .active,
            .creating,
            .deleting,
            .failed,
            .propagating,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .propagating: return "PROPAGATING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssetModelState(rawValue: rawValue) ?? AssetModelState.sdkUnknown(rawValue)
    }
}

extension AssetModelStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(AssetModelState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension AssetModelStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetModelStatus(error: \(String(describing: error)), state: \(String(describing: state)))"}
}

/// <p>Contains current status information for an asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-and-model-states.html">Asset and model
///         states</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
public struct AssetModelStatus: Equatable {
    /// <p>Contains associated error information, if any.</p>
    public let error: ErrorDetails?
    /// <p>The current state of the asset model.</p>
    public let state: AssetModelState?

    public init (
        error: ErrorDetails? = nil,
        state: AssetModelState? = nil
    )
    {
        self.error = error
        self.state = state
    }
}

extension AssetModelSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case creationDate
        case description
        case id
        case lastUpdateDate
        case name
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = lastUpdateDate {
            try encodeContainer.encode(lastUpdateDate.timeIntervalSince1970, forKey: .lastUpdateDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AssetModelStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AssetModelSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetModelSummary(arn: \(String(describing: arn)), creationDate: \(String(describing: creationDate)), description: \(String(describing: description)), id: \(String(describing: id)), lastUpdateDate: \(String(describing: lastUpdateDate)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>Contains a summary of an asset model.</p>
public struct AssetModelSummary: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset model, which has the following format.</p>
    ///         <p>
    ///             <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}</code>
    ///          </p>
    public let arn: String?
    /// <p>The date the asset model was created, in Unix epoch time.</p>
    public let creationDate: Date?
    /// <p>The asset model description.</p>
    public let description: String?
    /// <p>The ID of the asset model (used with AWS IoT SiteWise APIs).</p>
    public let id: String?
    /// <p>The date the asset model was last updated, in Unix epoch time.</p>
    public let lastUpdateDate: Date?
    /// <p>The name of the asset model.</p>
    public let name: String?
    /// <p>The current status of the asset model.</p>
    public let status: AssetModelStatus?

    public init (
        arn: String? = nil,
        creationDate: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        lastUpdateDate: Date? = nil,
        name: String? = nil,
        status: AssetModelStatus? = nil
    )
    {
        self.arn = arn
        self.creationDate = creationDate
        self.description = description
        self.id = id
        self.lastUpdateDate = lastUpdateDate
        self.name = name
        self.status = status
    }
}

extension AssetProperty: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alias
        case dataType
        case dataTypeSpec
        case id
        case name
        case notification
        case unit
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let dataTypeSpec = dataTypeSpec {
            try encodeContainer.encode(dataTypeSpec, forKey: .dataTypeSpec)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(PropertyNotification.self, forKey: .notification)
        notification = notificationDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeSpecDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataTypeSpec)
        dataTypeSpec = dataTypeSpecDecoded
        let unitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension AssetProperty: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetProperty(alias: \(String(describing: alias)), dataType: \(String(describing: dataType)), dataTypeSpec: \(String(describing: dataTypeSpec)), id: \(String(describing: id)), name: \(String(describing: name)), notification: \(String(describing: notification)), unit: \(String(describing: unit)))"}
}

/// <p>Contains asset property information.</p>
public struct AssetProperty: Equatable {
    /// <p>The property alias that identifies the property, such as an OPC-UA server data stream path
    ///         (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the
    ///         <i>AWS IoT SiteWise User Guide</i>.</p>
    public let alias: String?
    /// <p>The data type of the asset property.</p>
    public let dataType: PropertyDataType?
    /// <p>The data type of the structure for this property. This parameter exists on properties that
    ///       have the <code>STRUCT</code> data type.</p>
    public let dataTypeSpec: String?
    /// <p>The ID of the asset property.</p>
    public let id: String?
    /// <p>The name of the property.</p>
    public let name: String?
    /// <p>The asset property's notification topic and state. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html">UpdateAssetProperty</a>.</p>
    public let notification: PropertyNotification?
    /// <p>The unit (such as <code>Newtons</code> or <code>RPM</code>) of the asset property.</p>
    public let unit: String?

    public init (
        alias: String? = nil,
        dataType: PropertyDataType? = nil,
        dataTypeSpec: String? = nil,
        id: String? = nil,
        name: String? = nil,
        notification: PropertyNotification? = nil,
        unit: String? = nil
    )
    {
        self.alias = alias
        self.dataType = dataType
        self.dataTypeSpec = dataTypeSpec
        self.id = id
        self.name = name
        self.notification = notification
        self.unit = unit
    }
}

extension AssetPropertyValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case quality
        case timestamp
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quality = quality {
            try encodeContainer.encode(quality.rawValue, forKey: .quality)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Variant.self, forKey: .value)
        value = valueDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(TimeInNanos.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let qualityDecoded = try containerValues.decodeIfPresent(Quality.self, forKey: .quality)
        quality = qualityDecoded
    }
}

extension AssetPropertyValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetPropertyValue(quality: \(String(describing: quality)), timestamp: \(String(describing: timestamp)), value: \(String(describing: value)))"}
}

/// <p>Contains asset property value information.</p>
public struct AssetPropertyValue: Equatable {
    /// <p>The quality of the asset property value.</p>
    public let quality: Quality?
    /// <p>The timestamp of the asset property value.</p>
    public let timestamp: TimeInNanos?
    /// <p>The value of the asset property (see <code>Variant</code>).</p>
    public let value: Variant?

    public init (
        quality: Quality? = nil,
        timestamp: TimeInNanos? = nil,
        value: Variant? = nil
    )
    {
        self.quality = quality
        self.timestamp = timestamp
        self.value = value
    }
}

extension AssetRelationshipSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hierarchyInfo
        case relationshipType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hierarchyInfo = hierarchyInfo {
            try encodeContainer.encode(hierarchyInfo, forKey: .hierarchyInfo)
        }
        if let relationshipType = relationshipType {
            try encodeContainer.encode(relationshipType.rawValue, forKey: .relationshipType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyInfoDecoded = try containerValues.decodeIfPresent(AssetHierarchyInfo.self, forKey: .hierarchyInfo)
        hierarchyInfo = hierarchyInfoDecoded
        let relationshipTypeDecoded = try containerValues.decodeIfPresent(AssetRelationshipType.self, forKey: .relationshipType)
        relationshipType = relationshipTypeDecoded
    }
}

extension AssetRelationshipSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetRelationshipSummary(hierarchyInfo: \(String(describing: hierarchyInfo)), relationshipType: \(String(describing: relationshipType)))"}
}

/// <p>Contains information about assets that are related to one another.</p>
public struct AssetRelationshipSummary: Equatable {
    /// <p>The assets that are related through an asset hierarchy.</p>
    ///          <p>This object is present if the <code>relationshipType</code> is
    ///       <code>HIERARCHY</code>.</p>
    public let hierarchyInfo: AssetHierarchyInfo?
    /// <p>The relationship type of the assets in this relationship. This value is one of the
    ///       following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>HIERARCHY</code> – The assets are related through an asset hierarchy. If
    ///           you specify this relationship type, this asset relationship includes the
    ///             <code>hierarchyInfo</code> object.</p>
    ///             </li>
    ///          </ul>
    public let relationshipType: AssetRelationshipType?

    public init (
        hierarchyInfo: AssetHierarchyInfo? = nil,
        relationshipType: AssetRelationshipType? = nil
    )
    {
        self.hierarchyInfo = hierarchyInfo
        self.relationshipType = relationshipType
    }
}

public enum AssetRelationshipType {
    case hierarchy
    case sdkUnknown(String)
}

extension AssetRelationshipType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssetRelationshipType] {
        return [
            .hierarchy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .hierarchy: return "HIERARCHY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssetRelationshipType(rawValue: rawValue) ?? AssetRelationshipType.sdkUnknown(rawValue)
    }
}

public enum AssetState {
    case active
    case creating
    case deleting
    case failed
    case updating
    case sdkUnknown(String)
}

extension AssetState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssetState] {
        return [
            .active,
            .creating,
            .deleting,
            .failed,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssetState(rawValue: rawValue) ?? AssetState.sdkUnknown(rawValue)
    }
}

extension AssetStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(AssetState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension AssetStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetStatus(error: \(String(describing: error)), state: \(String(describing: state)))"}
}

/// <p>Contains information about the current status of an asset. For more information, see
///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-and-model-states.html">Asset and model
///         states</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
public struct AssetStatus: Equatable {
    /// <p>Contains associated error information, if any.</p>
    public let error: ErrorDetails?
    /// <p>The current status of the asset.</p>
    public let state: AssetState?

    public init (
        error: ErrorDetails? = nil,
        state: AssetState? = nil
    )
    {
        self.error = error
        self.state = state
    }
}

extension AssetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case assetModelId
        case creationDate
        case hierarchies
        case id
        case lastUpdateDate
        case name
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assetModelId = assetModelId {
            try encodeContainer.encode(assetModelId, forKey: .assetModelId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let hierarchies = hierarchies {
            var hierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hierarchies)
            for assethierarchies0 in hierarchies {
                try hierarchiesContainer.encode(assethierarchies0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = lastUpdateDate {
            try encodeContainer.encode(lastUpdateDate.timeIntervalSince1970, forKey: .lastUpdateDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AssetStatus.self, forKey: .status)
        status = statusDecoded
        let hierarchiesContainer = try containerValues.decodeIfPresent([AssetHierarchy?].self, forKey: .hierarchies)
        var hierarchiesDecoded0:[AssetHierarchy]? = nil
        if let hierarchiesContainer = hierarchiesContainer {
            hierarchiesDecoded0 = [AssetHierarchy]()
            for structure0 in hierarchiesContainer {
                if let structure0 = structure0 {
                    hierarchiesDecoded0?.append(structure0)
                }
            }
        }
        hierarchies = hierarchiesDecoded0
    }
}

extension AssetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetSummary(arn: \(String(describing: arn)), assetModelId: \(String(describing: assetModelId)), creationDate: \(String(describing: creationDate)), hierarchies: \(String(describing: hierarchies)), id: \(String(describing: id)), lastUpdateDate: \(String(describing: lastUpdateDate)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>Contains a summary of an asset.</p>
public struct AssetSummary: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset, which has the following format.</p>
    ///         <p>
    ///             <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}</code>
    ///          </p>
    public let arn: String?
    /// <p>The ID of the asset model used to create this asset.</p>
    public let assetModelId: String?
    /// <p>The date the asset was created, in Unix epoch time.</p>
    public let creationDate: Date?
    /// <p>A list of asset hierarchies that each contain a <code>hierarchyId</code>. A hierarchy specifies allowed parent/child asset relationships.</p>
    public let hierarchies: [AssetHierarchy]?
    /// <p>The ID of the asset.</p>
    public let id: String?
    /// <p>The date the asset was last updated, in Unix epoch time.</p>
    public let lastUpdateDate: Date?
    /// <p>The name of the asset.</p>
    public let name: String?
    /// <p>The current status of the asset.</p>
    public let status: AssetStatus?

    public init (
        arn: String? = nil,
        assetModelId: String? = nil,
        creationDate: Date? = nil,
        hierarchies: [AssetHierarchy]? = nil,
        id: String? = nil,
        lastUpdateDate: Date? = nil,
        name: String? = nil,
        status: AssetStatus? = nil
    )
    {
        self.arn = arn
        self.assetModelId = assetModelId
        self.creationDate = creationDate
        self.hierarchies = hierarchies
        self.id = id
        self.lastUpdateDate = lastUpdateDate
        self.name = name
        self.status = status
    }
}

public struct AssociateAssetsInputBodyMiddleware: Middleware {
    public let id: String = "AssociateAssetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateAssetsInput>
    public typealias MOutput = OperationOutput<AssociateAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateAssetsOutputError>
}

extension AssociateAssetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateAssetsInput(assetId: \(String(describing: assetId)), childAssetId: \(String(describing: childAssetId)), clientToken: \(String(describing: clientToken)), hierarchyId: \(String(describing: hierarchyId)))"}
}

extension AssociateAssetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case childAssetId
        case clientToken
        case hierarchyId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetId = childAssetId {
            try encodeContainer.encode(childAssetId, forKey: .childAssetId)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let hierarchyId = hierarchyId {
            try encodeContainer.encode(hierarchyId, forKey: .hierarchyId)
        }
    }
}

public struct AssociateAssetsInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateAssetsInput>
    public typealias MOutput = OperationOutput<AssociateAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateAssetsOutputError>
}

public struct AssociateAssetsInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateAssetsInput>
    public typealias MOutput = OperationOutput<AssociateAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateAssetsOutputError>
}

public struct AssociateAssetsInput: Equatable {
    /// <p>The ID of the parent asset.</p>
    public let assetId: String?
    /// <p>The ID of the child asset to be associated.</p>
    public let childAssetId: String?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?
    /// <p>The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings
    ///       of assets to be formed that all come from the same asset model. For more information, see
    ///       <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let hierarchyId: String?

    public init (
        assetId: String? = nil,
        childAssetId: String? = nil,
        clientToken: String? = nil,
        hierarchyId: String? = nil
    )
    {
        self.assetId = assetId
        self.childAssetId = childAssetId
        self.clientToken = clientToken
        self.hierarchyId = hierarchyId
    }
}

struct AssociateAssetsInputBody: Equatable {
    public let hierarchyId: String?
    public let childAssetId: String?
    public let clientToken: String?
}

extension AssociateAssetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case childAssetId
        case clientToken
        case hierarchyId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hierarchyId)
        hierarchyId = hierarchyIdDecoded
        let childAssetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .childAssetId)
        childAssetId = childAssetIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateAssetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateAssetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateAssetsOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateAssetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateAssetsOutputResponse()"}
}

extension AssociateAssetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateAssetsOutputResponse: Equatable {

    public init() {}
}

struct AssociateAssetsOutputResponseBody: Equatable {
}

extension AssociateAssetsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AssociatedAssetsSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case assetModelId
        case creationDate
        case hierarchies
        case id
        case lastUpdateDate
        case name
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assetModelId = assetModelId {
            try encodeContainer.encode(assetModelId, forKey: .assetModelId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let hierarchies = hierarchies {
            var hierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hierarchies)
            for assethierarchies0 in hierarchies {
                try hierarchiesContainer.encode(assethierarchies0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = lastUpdateDate {
            try encodeContainer.encode(lastUpdateDate.timeIntervalSince1970, forKey: .lastUpdateDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AssetStatus.self, forKey: .status)
        status = statusDecoded
        let hierarchiesContainer = try containerValues.decodeIfPresent([AssetHierarchy?].self, forKey: .hierarchies)
        var hierarchiesDecoded0:[AssetHierarchy]? = nil
        if let hierarchiesContainer = hierarchiesContainer {
            hierarchiesDecoded0 = [AssetHierarchy]()
            for structure0 in hierarchiesContainer {
                if let structure0 = structure0 {
                    hierarchiesDecoded0?.append(structure0)
                }
            }
        }
        hierarchies = hierarchiesDecoded0
    }
}

extension AssociatedAssetsSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociatedAssetsSummary(arn: \(String(describing: arn)), assetModelId: \(String(describing: assetModelId)), creationDate: \(String(describing: creationDate)), hierarchies: \(String(describing: hierarchies)), id: \(String(describing: id)), lastUpdateDate: \(String(describing: lastUpdateDate)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>Contains a summary of an associated asset.</p>
public struct AssociatedAssetsSummary: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset, which has the following format.</p>
    ///         <p>
    ///             <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}</code>
    ///          </p>
    public let arn: String?
    /// <p>The ID of the asset model used to create the asset.</p>
    public let assetModelId: String?
    /// <p>The date the asset was created, in Unix epoch time.</p>
    public let creationDate: Date?
    /// <p>A list of asset hierarchies that each contain a <code>hierarchyId</code>. A hierarchy specifies allowed parent/child asset relationships.</p>
    public let hierarchies: [AssetHierarchy]?
    /// <p>The ID of the asset.</p>
    public let id: String?
    /// <p>The date the asset was last updated, in Unix epoch time.</p>
    public let lastUpdateDate: Date?
    /// <p>The name of the asset.</p>
    public let name: String?
    /// <p>The current status of the asset.</p>
    public let status: AssetStatus?

    public init (
        arn: String? = nil,
        assetModelId: String? = nil,
        creationDate: Date? = nil,
        hierarchies: [AssetHierarchy]? = nil,
        id: String? = nil,
        lastUpdateDate: Date? = nil,
        name: String? = nil,
        status: AssetStatus? = nil
    )
    {
        self.arn = arn
        self.assetModelId = assetModelId
        self.creationDate = creationDate
        self.hierarchies = hierarchies
        self.id = id
        self.lastUpdateDate = lastUpdateDate
        self.name = name
        self.status = status
    }
}

extension Attribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension Attribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Attribute(defaultValue: \(String(describing: defaultValue)))"}
}

/// <p>Contains an asset attribute property. For more information, see
///       <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#attributes">Attributes</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
public struct Attribute: Equatable {
    /// <p>The default value of the asset model property attribute. All assets that you create from
    ///       the asset model contain this attribute value. You can update an attribute's value after you
    ///       create an asset. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/update-attribute-values.html">Updating attribute values</a> in the
    ///         <i>AWS IoT SiteWise User Guide</i>.</p>
    public let defaultValue: String?

    public init (
        defaultValue: String? = nil
    )
    {
        self.defaultValue = defaultValue
    }
}

public enum AuthMode {
    case iam
    case sso
    case sdkUnknown(String)
}

extension AuthMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthMode] {
        return [
            .iam,
            .sso,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .iam: return "IAM"
        case .sso: return "SSO"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthMode(rawValue: rawValue) ?? AuthMode.sdkUnknown(rawValue)
    }
}

public struct BatchAssociateProjectAssetsInputBodyMiddleware: Middleware {
    public let id: String = "BatchAssociateProjectAssetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAssociateProjectAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAssociateProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAssociateProjectAssetsInput>
    public typealias MOutput = OperationOutput<BatchAssociateProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAssociateProjectAssetsOutputError>
}

extension BatchAssociateProjectAssetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAssociateProjectAssetsInput(assetIds: \(String(describing: assetIds)), clientToken: \(String(describing: clientToken)), projectId: \(String(describing: projectId)))"}
}

extension BatchAssociateProjectAssetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetIds
        case clientToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetIds = assetIds {
            var assetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetIds)
            for ids0 in assetIds {
                try assetIdsContainer.encode(ids0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct BatchAssociateProjectAssetsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchAssociateProjectAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAssociateProjectAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAssociateProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAssociateProjectAssetsInput>
    public typealias MOutput = OperationOutput<BatchAssociateProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAssociateProjectAssetsOutputError>
}

public struct BatchAssociateProjectAssetsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchAssociateProjectAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAssociateProjectAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAssociateProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAssociateProjectAssetsInput>
    public typealias MOutput = OperationOutput<BatchAssociateProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAssociateProjectAssetsOutputError>
}

public struct BatchAssociateProjectAssetsInput: Equatable {
    /// <p>The IDs of the assets to be associated to the project.</p>
    public let assetIds: [String]?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?
    /// <p>The ID of the project to which to associate the assets.</p>
    public let projectId: String?

    public init (
        assetIds: [String]? = nil,
        clientToken: String? = nil,
        projectId: String? = nil
    )
    {
        self.assetIds = assetIds
        self.clientToken = clientToken
        self.projectId = projectId
    }
}

struct BatchAssociateProjectAssetsInputBody: Equatable {
    public let assetIds: [String]?
    public let clientToken: String?
}

extension BatchAssociateProjectAssetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetIds
        case clientToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .assetIds)
        var assetIdsDecoded0:[String]? = nil
        if let assetIdsContainer = assetIdsContainer {
            assetIdsDecoded0 = [String]()
            for string0 in assetIdsContainer {
                if let string0 = string0 {
                    assetIdsDecoded0?.append(string0)
                }
            }
        }
        assetIds = assetIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension BatchAssociateProjectAssetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAssociateProjectAssetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchAssociateProjectAssetsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAssociateProjectAssetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAssociateProjectAssetsOutputResponse(errors: \(String(describing: errors)))"}
}

extension BatchAssociateProjectAssetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchAssociateProjectAssetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchAssociateProjectAssetsOutputResponse: Equatable {
    /// <p>A list of associated error information, if any.</p>
    public let errors: [AssetErrorDetails]?

    public init (
        errors: [AssetErrorDetails]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchAssociateProjectAssetsOutputResponseBody: Equatable {
    public let errors: [AssetErrorDetails]?
}

extension BatchAssociateProjectAssetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([AssetErrorDetails?].self, forKey: .errors)
        var errorsDecoded0:[AssetErrorDetails]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AssetErrorDetails]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct BatchDisassociateProjectAssetsInputBodyMiddleware: Middleware {
    public let id: String = "BatchDisassociateProjectAssetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisassociateProjectAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisassociateProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisassociateProjectAssetsInput>
    public typealias MOutput = OperationOutput<BatchDisassociateProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisassociateProjectAssetsOutputError>
}

extension BatchDisassociateProjectAssetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDisassociateProjectAssetsInput(assetIds: \(String(describing: assetIds)), clientToken: \(String(describing: clientToken)), projectId: \(String(describing: projectId)))"}
}

extension BatchDisassociateProjectAssetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetIds
        case clientToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetIds = assetIds {
            var assetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetIds)
            for ids0 in assetIds {
                try assetIdsContainer.encode(ids0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct BatchDisassociateProjectAssetsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDisassociateProjectAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisassociateProjectAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisassociateProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisassociateProjectAssetsInput>
    public typealias MOutput = OperationOutput<BatchDisassociateProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisassociateProjectAssetsOutputError>
}

public struct BatchDisassociateProjectAssetsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDisassociateProjectAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisassociateProjectAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisassociateProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisassociateProjectAssetsInput>
    public typealias MOutput = OperationOutput<BatchDisassociateProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisassociateProjectAssetsOutputError>
}

public struct BatchDisassociateProjectAssetsInput: Equatable {
    /// <p>The IDs of the assets to be disassociated from the project.</p>
    public let assetIds: [String]?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?
    /// <p>The ID of the project from which to disassociate the assets.</p>
    public let projectId: String?

    public init (
        assetIds: [String]? = nil,
        clientToken: String? = nil,
        projectId: String? = nil
    )
    {
        self.assetIds = assetIds
        self.clientToken = clientToken
        self.projectId = projectId
    }
}

struct BatchDisassociateProjectAssetsInputBody: Equatable {
    public let assetIds: [String]?
    public let clientToken: String?
}

extension BatchDisassociateProjectAssetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetIds
        case clientToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .assetIds)
        var assetIdsDecoded0:[String]? = nil
        if let assetIdsContainer = assetIdsContainer {
            assetIdsDecoded0 = [String]()
            for string0 in assetIdsContainer {
                if let string0 = string0 {
                    assetIdsDecoded0?.append(string0)
                }
            }
        }
        assetIds = assetIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension BatchDisassociateProjectAssetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisassociateProjectAssetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDisassociateProjectAssetsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisassociateProjectAssetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDisassociateProjectAssetsOutputResponse(errors: \(String(describing: errors)))"}
}

extension BatchDisassociateProjectAssetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDisassociateProjectAssetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDisassociateProjectAssetsOutputResponse: Equatable {
    /// <p>A list of associated error information, if any.</p>
    public let errors: [AssetErrorDetails]?

    public init (
        errors: [AssetErrorDetails]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDisassociateProjectAssetsOutputResponseBody: Equatable {
    public let errors: [AssetErrorDetails]?
}

extension BatchDisassociateProjectAssetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([AssetErrorDetails?].self, forKey: .errors)
        var errorsDecoded0:[AssetErrorDetails]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AssetErrorDetails]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension BatchPutAssetPropertyError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case errorMessage
        case timestamps
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let timestamps = timestamps {
            var timestampsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timestamps)
            for timestamps0 in timestamps {
                try timestampsContainer.encode(timestamps0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(BatchPutAssetPropertyValueErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let timestampsContainer = try containerValues.decodeIfPresent([TimeInNanos?].self, forKey: .timestamps)
        var timestampsDecoded0:[TimeInNanos]? = nil
        if let timestampsContainer = timestampsContainer {
            timestampsDecoded0 = [TimeInNanos]()
            for structure0 in timestampsContainer {
                if let structure0 = structure0 {
                    timestampsDecoded0?.append(structure0)
                }
            }
        }
        timestamps = timestampsDecoded0
    }
}

extension BatchPutAssetPropertyError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchPutAssetPropertyError(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), timestamps: \(String(describing: timestamps)))"}
}

/// <p>Contains error information from updating a batch of asset property values.</p>
public struct BatchPutAssetPropertyError: Equatable {
    /// <p>The error code.</p>
    public let errorCode: BatchPutAssetPropertyValueErrorCode?
    /// <p>The associated error message.</p>
    public let errorMessage: String?
    /// <p>A list of timestamps for each  error, if any.</p>
    public let timestamps: [TimeInNanos]?

    public init (
        errorCode: BatchPutAssetPropertyValueErrorCode? = nil,
        errorMessage: String? = nil,
        timestamps: [TimeInNanos]? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.timestamps = timestamps
    }
}

extension BatchPutAssetPropertyErrorEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entryId
        case errors
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryId = entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for batchputassetpropertyerrors0 in errors {
                try errorsContainer.encode(batchputassetpropertyerrors0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let errorsContainer = try containerValues.decodeIfPresent([BatchPutAssetPropertyError?].self, forKey: .errors)
        var errorsDecoded0:[BatchPutAssetPropertyError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [BatchPutAssetPropertyError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension BatchPutAssetPropertyErrorEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchPutAssetPropertyErrorEntry(entryId: \(String(describing: entryId)), errors: \(String(describing: errors)))"}
}

/// <p>Contains error information for asset property value entries that are associated with the
///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchPutAssetPropertyValue.html">BatchPutAssetPropertyValue</a> API.</p>
public struct BatchPutAssetPropertyErrorEntry: Equatable {
    /// <p>The ID of the failed entry.</p>
    public let entryId: String?
    /// <p>The list of update property value errors.</p>
    public let errors: [BatchPutAssetPropertyError]?

    public init (
        entryId: String? = nil,
        errors: [BatchPutAssetPropertyError]? = nil
    )
    {
        self.entryId = entryId
        self.errors = errors
    }
}

public enum BatchPutAssetPropertyValueErrorCode {
    case accessdeniedexception
    case conflictingoperationexception
    case internalfailureexception
    case invalidrequestexception
    case limitexceededexception
    case resourcenotfoundexception
    case serviceunavailableexception
    case throttlingexception
    case timestampoutofrangeexception
    case sdkUnknown(String)
}

extension BatchPutAssetPropertyValueErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BatchPutAssetPropertyValueErrorCode] {
        return [
            .accessdeniedexception,
            .conflictingoperationexception,
            .internalfailureexception,
            .invalidrequestexception,
            .limitexceededexception,
            .resourcenotfoundexception,
            .serviceunavailableexception,
            .throttlingexception,
            .timestampoutofrangeexception,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessdeniedexception: return "AccessDeniedException"
        case .conflictingoperationexception: return "ConflictingOperationException"
        case .internalfailureexception: return "InternalFailureException"
        case .invalidrequestexception: return "InvalidRequestException"
        case .limitexceededexception: return "LimitExceededException"
        case .resourcenotfoundexception: return "ResourceNotFoundException"
        case .serviceunavailableexception: return "ServiceUnavailableException"
        case .throttlingexception: return "ThrottlingException"
        case .timestampoutofrangeexception: return "TimestampOutOfRangeException"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BatchPutAssetPropertyValueErrorCode(rawValue: rawValue) ?? BatchPutAssetPropertyValueErrorCode.sdkUnknown(rawValue)
    }
}

public struct BatchPutAssetPropertyValueInputBodyMiddleware: Middleware {
    public let id: String = "BatchPutAssetPropertyValueInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchPutAssetPropertyValueInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchPutAssetPropertyValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchPutAssetPropertyValueInput>
    public typealias MOutput = OperationOutput<BatchPutAssetPropertyValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchPutAssetPropertyValueOutputError>
}

extension BatchPutAssetPropertyValueInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchPutAssetPropertyValueInput(entries: \(String(describing: entries)))"}
}

extension BatchPutAssetPropertyValueInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entries
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for putassetpropertyvalueentries0 in entries {
                try entriesContainer.encode(putassetpropertyvalueentries0)
            }
        }
    }
}

public struct BatchPutAssetPropertyValueInputHeadersMiddleware: Middleware {
    public let id: String = "BatchPutAssetPropertyValueInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchPutAssetPropertyValueInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchPutAssetPropertyValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchPutAssetPropertyValueInput>
    public typealias MOutput = OperationOutput<BatchPutAssetPropertyValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchPutAssetPropertyValueOutputError>
}

public struct BatchPutAssetPropertyValueInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchPutAssetPropertyValueInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchPutAssetPropertyValueInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchPutAssetPropertyValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchPutAssetPropertyValueInput>
    public typealias MOutput = OperationOutput<BatchPutAssetPropertyValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchPutAssetPropertyValueOutputError>
}

public struct BatchPutAssetPropertyValueInput: Equatable {
    /// <p>The list of asset property value entries for the batch put request. You can specify up to
    ///       10 entries per request.</p>
    public let entries: [PutAssetPropertyValueEntry]?

    public init (
        entries: [PutAssetPropertyValueEntry]? = nil
    )
    {
        self.entries = entries
    }
}

struct BatchPutAssetPropertyValueInputBody: Equatable {
    public let entries: [PutAssetPropertyValueEntry]?
}

extension BatchPutAssetPropertyValueInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([PutAssetPropertyValueEntry?].self, forKey: .entries)
        var entriesDecoded0:[PutAssetPropertyValueEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [PutAssetPropertyValueEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchPutAssetPropertyValueOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchPutAssetPropertyValueOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchPutAssetPropertyValueOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchPutAssetPropertyValueOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchPutAssetPropertyValueOutputResponse(errorEntries: \(String(describing: errorEntries)))"}
}

extension BatchPutAssetPropertyValueOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchPutAssetPropertyValueOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchPutAssetPropertyValueOutputResponse: Equatable {
    /// <p>A list of the errors (if any) associated with the batch put request. Each error entry
    ///       contains the <code>entryId</code> of the entry that failed.</p>
    public let errorEntries: [BatchPutAssetPropertyErrorEntry]?

    public init (
        errorEntries: [BatchPutAssetPropertyErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchPutAssetPropertyValueOutputResponseBody: Equatable {
    public let errorEntries: [BatchPutAssetPropertyErrorEntry]?
}

extension BatchPutAssetPropertyValueOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorEntries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([BatchPutAssetPropertyErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[BatchPutAssetPropertyErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [BatchPutAssetPropertyErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

public enum CapabilitySyncStatus {
    case inSync
    case outOfSync
    case syncFailed
    case sdkUnknown(String)
}

extension CapabilitySyncStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CapabilitySyncStatus] {
        return [
            .inSync,
            .outOfSync,
            .syncFailed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .inSync: return "IN_SYNC"
        case .outOfSync: return "OUT_OF_SYNC"
        case .syncFailed: return "SYNC_FAILED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CapabilitySyncStatus(rawValue: rawValue) ?? CapabilitySyncStatus.sdkUnknown(rawValue)
    }
}

extension CompositeModelProperty: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetProperty
        case name
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetProperty = assetProperty {
            try encodeContainer.encode(assetProperty, forKey: .assetProperty)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let assetPropertyDecoded = try containerValues.decodeIfPresent(Property.self, forKey: .assetProperty)
        assetProperty = assetPropertyDecoded
    }
}

extension CompositeModelProperty: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompositeModelProperty(assetProperty: \(String(describing: assetProperty)), name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>Contains information about a composite model property on an asset.</p>
public struct CompositeModelProperty: Equatable {
    /// <p>Contains asset property information.</p>
    public let assetProperty: Property?
    /// <p>The name of the property.</p>
    public let name: String?
    /// <p>The type of the composite model that defines this property.</p>
    public let type: String?

    public init (
        assetProperty: Property? = nil,
        name: String? = nil,
        type: String? = nil
    )
    {
        self.assetProperty = assetProperty
        self.name = name
        self.type = type
    }
}

extension ConfigurationErrorDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConfigurationErrorDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationErrorDetails(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

/// <p>Contains the details of an AWS IoT SiteWise configuration error.</p>
public struct ConfigurationErrorDetails: Equatable {
    /// <p>The error code.</p>
    public let code: ErrorCode?
    /// <p>The error message.</p>
    public let message: String?

    public init (
        code: ErrorCode? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

public enum ConfigurationState {
    case active
    case updateFailed
    case updateInProgress
    case sdkUnknown(String)
}

extension ConfigurationState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfigurationState] {
        return [
            .active,
            .updateFailed,
            .updateInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .updateFailed: return "UPDATE_FAILED"
        case .updateInProgress: return "UPDATE_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfigurationState(rawValue: rawValue) ?? ConfigurationState.sdkUnknown(rawValue)
    }
}

extension ConfigurationStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ConfigurationState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(ConfigurationErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension ConfigurationStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationStatus(error: \(String(describing: error)), state: \(String(describing: state)))"}
}

/// <p>Contains current status information for the configuration.</p>
public struct ConfigurationStatus: Equatable {
    /// <p>Contains associated error information, if any.</p>
    public let error: ConfigurationErrorDetails?
    /// <p>The current state of the configuration.</p>
    public let state: ConfigurationState?

    public init (
        error: ConfigurationErrorDetails? = nil,
        state: ConfigurationState? = nil
    )
    {
        self.error = error
        self.state = state
    }
}

extension ConflictingOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictingOperationException(message: \(String(describing: message)), resourceArn: \(String(describing: resourceArn)), resourceId: \(String(describing: resourceId)))"}
}

extension ConflictingOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictingOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceArn = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request has conflicting operations. This can occur if you're trying to perform more
///       than one operation on the same resource at the same time.</p>
public struct ConflictingOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The ARN of the resource that conflicts with this operation.</p>
    public var resourceArn: String?
    /// <p>The ID of the resource that conflicts with this operation.</p>
    public var resourceId: String?

    public init (
        message: String? = nil,
        resourceArn: String? = nil,
        resourceId: String? = nil
    )
    {
        self.message = message
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

struct ConflictingOperationExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceArn: String?
}

extension ConflictingOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceArn
        case resourceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

public struct CreateAccessPolicyInputBodyMiddleware: Middleware {
    public let id: String = "CreateAccessPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessPolicyInput>
    public typealias MOutput = OperationOutput<CreateAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessPolicyOutputError>
}

extension CreateAccessPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccessPolicyInput(accessPolicyIdentity: \(String(describing: accessPolicyIdentity)), accessPolicyPermission: \(String(describing: accessPolicyPermission)), accessPolicyResource: \(String(describing: accessPolicyResource)), clientToken: \(String(describing: clientToken)), tags: \(String(describing: tags)))"}
}

extension CreateAccessPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessPolicyIdentity
        case accessPolicyPermission
        case accessPolicyResource
        case clientToken
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPolicyIdentity = accessPolicyIdentity {
            try encodeContainer.encode(accessPolicyIdentity, forKey: .accessPolicyIdentity)
        }
        if let accessPolicyPermission = accessPolicyPermission {
            try encodeContainer.encode(accessPolicyPermission.rawValue, forKey: .accessPolicyPermission)
        }
        if let accessPolicyResource = accessPolicyResource {
            try encodeContainer.encode(accessPolicyResource, forKey: .accessPolicyResource)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAccessPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessPolicyInput>
    public typealias MOutput = OperationOutput<CreateAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessPolicyOutputError>
}

public struct CreateAccessPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessPolicyInput>
    public typealias MOutput = OperationOutput<CreateAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessPolicyOutputError>
}

public struct CreateAccessPolicyInput: Equatable {
    /// <p>The identity for this access policy. Choose an AWS SSO user, an AWS SSO group, or an IAM user.</p>
    public let accessPolicyIdentity: Identity?
    /// <p>The permission level for this access policy. Note that a project <code>ADMINISTRATOR</code> is also known as a project owner.</p>
    public let accessPolicyPermission: Permission?
    /// <p>The AWS IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.</p>
    public let accessPolicyResource: Resource?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?
    /// <p>A list of key-value pairs that contain metadata for the access policy. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your
    ///         AWS IoT SiteWise resources</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let tags: [String:String]?

    public init (
        accessPolicyIdentity: Identity? = nil,
        accessPolicyPermission: Permission? = nil,
        accessPolicyResource: Resource? = nil,
        clientToken: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.accessPolicyIdentity = accessPolicyIdentity
        self.accessPolicyPermission = accessPolicyPermission
        self.accessPolicyResource = accessPolicyResource
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateAccessPolicyInputBody: Equatable {
    public let accessPolicyIdentity: Identity?
    public let accessPolicyResource: Resource?
    public let accessPolicyPermission: Permission?
    public let clientToken: String?
    public let tags: [String:String]?
}

extension CreateAccessPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessPolicyIdentity
        case accessPolicyPermission
        case accessPolicyResource
        case clientToken
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyIdentityDecoded = try containerValues.decodeIfPresent(Identity.self, forKey: .accessPolicyIdentity)
        accessPolicyIdentity = accessPolicyIdentityDecoded
        let accessPolicyResourceDecoded = try containerValues.decodeIfPresent(Resource.self, forKey: .accessPolicyResource)
        accessPolicyResource = accessPolicyResourceDecoded
        let accessPolicyPermissionDecoded = try containerValues.decodeIfPresent(Permission.self, forKey: .accessPolicyPermission)
        accessPolicyPermission = accessPolicyPermissionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAccessPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccessPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAccessPolicyOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccessPolicyOutputResponse(accessPolicyArn: \(String(describing: accessPolicyArn)), accessPolicyId: \(String(describing: accessPolicyId)))"}
}

extension CreateAccessPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAccessPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessPolicyArn = output.accessPolicyArn
            self.accessPolicyId = output.accessPolicyId
        } else {
            self.accessPolicyArn = nil
            self.accessPolicyId = nil
        }
    }
}

public struct CreateAccessPolicyOutputResponse: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the access policy, which has the following format.</p>
    ///         <p>
    ///             <code>arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId}</code>
    ///          </p>
    public let accessPolicyArn: String?
    /// <p>The ID of the access policy.</p>
    public let accessPolicyId: String?

    public init (
        accessPolicyArn: String? = nil,
        accessPolicyId: String? = nil
    )
    {
        self.accessPolicyArn = accessPolicyArn
        self.accessPolicyId = accessPolicyId
    }
}

struct CreateAccessPolicyOutputResponseBody: Equatable {
    public let accessPolicyId: String?
    public let accessPolicyArn: String?
}

extension CreateAccessPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessPolicyArn
        case accessPolicyId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessPolicyId)
        accessPolicyId = accessPolicyIdDecoded
        let accessPolicyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessPolicyArn)
        accessPolicyArn = accessPolicyArnDecoded
    }
}

public struct CreateAssetInputBodyMiddleware: Middleware {
    public let id: String = "CreateAssetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssetInput>
    public typealias MOutput = OperationOutput<CreateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssetOutputError>
}

extension CreateAssetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssetInput(assetModelId: \(String(describing: assetModelId)), assetName: \(String(describing: assetName)), clientToken: \(String(describing: clientToken)), tags: \(String(describing: tags)))"}
}

extension CreateAssetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetModelId
        case assetName
        case clientToken
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetModelId = assetModelId {
            try encodeContainer.encode(assetModelId, forKey: .assetModelId)
        }
        if let assetName = assetName {
            try encodeContainer.encode(assetName, forKey: .assetName)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAssetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssetInput>
    public typealias MOutput = OperationOutput<CreateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssetOutputError>
}

public struct CreateAssetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssetInput>
    public typealias MOutput = OperationOutput<CreateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssetOutputError>
}

public struct CreateAssetInput: Equatable {
    /// <p>The ID of the asset model from which to create the asset.</p>
    public let assetModelId: String?
    /// <p>A unique, friendly name for the asset.</p>
    public let assetName: String?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?
    /// <p>A list of key-value pairs that contain metadata for the asset. For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your AWS IoT SiteWise
    ///         resources</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let tags: [String:String]?

    public init (
        assetModelId: String? = nil,
        assetName: String? = nil,
        clientToken: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.assetModelId = assetModelId
        self.assetName = assetName
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateAssetInputBody: Equatable {
    public let assetName: String?
    public let assetModelId: String?
    public let clientToken: String?
    public let tags: [String:String]?
}

extension CreateAssetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetModelId
        case assetName
        case clientToken
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateAssetModelInputBodyMiddleware: Middleware {
    public let id: String = "CreateAssetModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssetModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssetModelInput>
    public typealias MOutput = OperationOutput<CreateAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssetModelOutputError>
}

extension CreateAssetModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssetModelInput(assetModelCompositeModels: \(String(describing: assetModelCompositeModels)), assetModelDescription: \(String(describing: assetModelDescription)), assetModelHierarchies: \(String(describing: assetModelHierarchies)), assetModelName: \(String(describing: assetModelName)), assetModelProperties: \(String(describing: assetModelProperties)), clientToken: \(String(describing: clientToken)), tags: \(String(describing: tags)))"}
}

extension CreateAssetModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetModelCompositeModels
        case assetModelDescription
        case assetModelHierarchies
        case assetModelName
        case assetModelProperties
        case clientToken
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetModelCompositeModels = assetModelCompositeModels {
            var assetModelCompositeModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelCompositeModels)
            for assetmodelcompositemodeldefinitions0 in assetModelCompositeModels {
                try assetModelCompositeModelsContainer.encode(assetmodelcompositemodeldefinitions0)
            }
        }
        if let assetModelDescription = assetModelDescription {
            try encodeContainer.encode(assetModelDescription, forKey: .assetModelDescription)
        }
        if let assetModelHierarchies = assetModelHierarchies {
            var assetModelHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelHierarchies)
            for assetmodelhierarchydefinitions0 in assetModelHierarchies {
                try assetModelHierarchiesContainer.encode(assetmodelhierarchydefinitions0)
            }
        }
        if let assetModelName = assetModelName {
            try encodeContainer.encode(assetModelName, forKey: .assetModelName)
        }
        if let assetModelProperties = assetModelProperties {
            var assetModelPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelProperties)
            for assetmodelpropertydefinitions0 in assetModelProperties {
                try assetModelPropertiesContainer.encode(assetmodelpropertydefinitions0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAssetModelInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAssetModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssetModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssetModelInput>
    public typealias MOutput = OperationOutput<CreateAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssetModelOutputError>
}

public struct CreateAssetModelInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAssetModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssetModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssetModelInput>
    public typealias MOutput = OperationOutput<CreateAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssetModelOutputError>
}

public struct CreateAssetModelInput: Equatable {
    /// <p>The composite asset models that are part of this asset model.
    ///       Composite asset models are asset models that contain specific properties. Each composite model
    ///       has a type that defines the properties that the composite model supports. Use composite asset
    ///       models to define alarms on this asset model.</p>
    public let assetModelCompositeModels: [AssetModelCompositeModelDefinition]?
    /// <p>A description for the asset model.</p>
    public let assetModelDescription: String?
    /// <p>The hierarchy definitions of the asset model. Each hierarchy specifies an asset model
    ///       whose assets can be children of any other assets created from this asset model. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    ///          <p>You can specify up to 10 hierarchies per asset model. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let assetModelHierarchies: [AssetModelHierarchyDefinition]?
    /// <p>A unique, friendly name for the asset model.</p>
    public let assetModelName: String?
    /// <p>The property definitions of the asset model. For more information, see
    ///       <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html">Asset properties</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    ///          <p>You can specify up to 200 properties per asset model. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let assetModelProperties: [AssetModelPropertyDefinition]?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?
    /// <p>A list of key-value pairs that contain metadata for the asset model. For more information,
    ///       see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your AWS IoT SiteWise
    ///         resources</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let tags: [String:String]?

    public init (
        assetModelCompositeModels: [AssetModelCompositeModelDefinition]? = nil,
        assetModelDescription: String? = nil,
        assetModelHierarchies: [AssetModelHierarchyDefinition]? = nil,
        assetModelName: String? = nil,
        assetModelProperties: [AssetModelPropertyDefinition]? = nil,
        clientToken: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.assetModelCompositeModels = assetModelCompositeModels
        self.assetModelDescription = assetModelDescription
        self.assetModelHierarchies = assetModelHierarchies
        self.assetModelName = assetModelName
        self.assetModelProperties = assetModelProperties
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateAssetModelInputBody: Equatable {
    public let assetModelName: String?
    public let assetModelDescription: String?
    public let assetModelProperties: [AssetModelPropertyDefinition]?
    public let assetModelHierarchies: [AssetModelHierarchyDefinition]?
    public let assetModelCompositeModels: [AssetModelCompositeModelDefinition]?
    public let clientToken: String?
    public let tags: [String:String]?
}

extension CreateAssetModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetModelCompositeModels
        case assetModelDescription
        case assetModelHierarchies
        case assetModelName
        case assetModelProperties
        case clientToken
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetModelName)
        assetModelName = assetModelNameDecoded
        let assetModelDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetModelDescription)
        assetModelDescription = assetModelDescriptionDecoded
        let assetModelPropertiesContainer = try containerValues.decodeIfPresent([AssetModelPropertyDefinition?].self, forKey: .assetModelProperties)
        var assetModelPropertiesDecoded0:[AssetModelPropertyDefinition]? = nil
        if let assetModelPropertiesContainer = assetModelPropertiesContainer {
            assetModelPropertiesDecoded0 = [AssetModelPropertyDefinition]()
            for structure0 in assetModelPropertiesContainer {
                if let structure0 = structure0 {
                    assetModelPropertiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelProperties = assetModelPropertiesDecoded0
        let assetModelHierarchiesContainer = try containerValues.decodeIfPresent([AssetModelHierarchyDefinition?].self, forKey: .assetModelHierarchies)
        var assetModelHierarchiesDecoded0:[AssetModelHierarchyDefinition]? = nil
        if let assetModelHierarchiesContainer = assetModelHierarchiesContainer {
            assetModelHierarchiesDecoded0 = [AssetModelHierarchyDefinition]()
            for structure0 in assetModelHierarchiesContainer {
                if let structure0 = structure0 {
                    assetModelHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelHierarchies = assetModelHierarchiesDecoded0
        let assetModelCompositeModelsContainer = try containerValues.decodeIfPresent([AssetModelCompositeModelDefinition?].self, forKey: .assetModelCompositeModels)
        var assetModelCompositeModelsDecoded0:[AssetModelCompositeModelDefinition]? = nil
        if let assetModelCompositeModelsContainer = assetModelCompositeModelsContainer {
            assetModelCompositeModelsDecoded0 = [AssetModelCompositeModelDefinition]()
            for structure0 in assetModelCompositeModelsContainer {
                if let structure0 = structure0 {
                    assetModelCompositeModelsDecoded0?.append(structure0)
                }
            }
        }
        assetModelCompositeModels = assetModelCompositeModelsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAssetModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssetModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssetModelOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssetModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssetModelOutputResponse(assetModelArn: \(String(describing: assetModelArn)), assetModelId: \(String(describing: assetModelId)), assetModelStatus: \(String(describing: assetModelStatus)))"}
}

extension CreateAssetModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAssetModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assetModelArn = output.assetModelArn
            self.assetModelId = output.assetModelId
            self.assetModelStatus = output.assetModelStatus
        } else {
            self.assetModelArn = nil
            self.assetModelId = nil
            self.assetModelStatus = nil
        }
    }
}

public struct CreateAssetModelOutputResponse: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset model, which has the following format.</p>
    ///         <p>
    ///             <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}</code>
    ///          </p>
    public let assetModelArn: String?
    /// <p>The ID of the asset model. You can use this ID when you call other AWS IoT SiteWise APIs.</p>
    public let assetModelId: String?
    /// <p>The status of the asset model, which contains a state (<code>CREATING</code> after
    ///       successfully calling this operation) and any error message.</p>
    public let assetModelStatus: AssetModelStatus?

    public init (
        assetModelArn: String? = nil,
        assetModelId: String? = nil,
        assetModelStatus: AssetModelStatus? = nil
    )
    {
        self.assetModelArn = assetModelArn
        self.assetModelId = assetModelId
        self.assetModelStatus = assetModelStatus
    }
}

struct CreateAssetModelOutputResponseBody: Equatable {
    public let assetModelId: String?
    public let assetModelArn: String?
    public let assetModelStatus: AssetModelStatus?
}

extension CreateAssetModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetModelArn
        case assetModelId
        case assetModelStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let assetModelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetModelArn)
        assetModelArn = assetModelArnDecoded
        let assetModelStatusDecoded = try containerValues.decodeIfPresent(AssetModelStatus.self, forKey: .assetModelStatus)
        assetModelStatus = assetModelStatusDecoded
    }
}

extension CreateAssetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssetOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssetOutputResponse(assetArn: \(String(describing: assetArn)), assetId: \(String(describing: assetId)), assetStatus: \(String(describing: assetStatus)))"}
}

extension CreateAssetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAssetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assetArn = output.assetArn
            self.assetId = output.assetId
            self.assetStatus = output.assetStatus
        } else {
            self.assetArn = nil
            self.assetId = nil
            self.assetStatus = nil
        }
    }
}

public struct CreateAssetOutputResponse: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset, which has the following format.</p>
    ///         <p>
    ///             <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}</code>
    ///          </p>
    public let assetArn: String?
    /// <p>The ID of the asset. This ID uniquely identifies the asset within AWS IoT SiteWise and can be used with other
    ///       AWS IoT SiteWise APIs.</p>
    public let assetId: String?
    /// <p>The status of the asset, which contains a state (<code>CREATING</code> after successfully
    ///       calling this operation) and any error message.</p>
    public let assetStatus: AssetStatus?

    public init (
        assetArn: String? = nil,
        assetId: String? = nil,
        assetStatus: AssetStatus? = nil
    )
    {
        self.assetArn = assetArn
        self.assetId = assetId
        self.assetStatus = assetStatus
    }
}

struct CreateAssetOutputResponseBody: Equatable {
    public let assetId: String?
    public let assetArn: String?
    public let assetStatus: AssetStatus?
}

extension CreateAssetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetArn
        case assetId
        case assetStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let assetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetArn)
        assetArn = assetArnDecoded
        let assetStatusDecoded = try containerValues.decodeIfPresent(AssetStatus.self, forKey: .assetStatus)
        assetStatus = assetStatusDecoded
    }
}

public struct CreateDashboardInputBodyMiddleware: Middleware {
    public let id: String = "CreateDashboardInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDashboardInput>
    public typealias MOutput = OperationOutput<CreateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDashboardOutputError>
}

extension CreateDashboardInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDashboardInput(clientToken: \(String(describing: clientToken)), dashboardDefinition: \(String(describing: dashboardDefinition)), dashboardDescription: \(String(describing: dashboardDescription)), dashboardName: \(String(describing: dashboardName)), projectId: \(String(describing: projectId)), tags: \(String(describing: tags)))"}
}

extension CreateDashboardInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case dashboardDefinition
        case dashboardDescription
        case dashboardName
        case projectId
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dashboardDefinition = dashboardDefinition {
            try encodeContainer.encode(dashboardDefinition, forKey: .dashboardDefinition)
        }
        if let dashboardDescription = dashboardDescription {
            try encodeContainer.encode(dashboardDescription, forKey: .dashboardDescription)
        }
        if let dashboardName = dashboardName {
            try encodeContainer.encode(dashboardName, forKey: .dashboardName)
        }
        if let projectId = projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDashboardInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDashboardInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDashboardInput>
    public typealias MOutput = OperationOutput<CreateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDashboardOutputError>
}

public struct CreateDashboardInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDashboardInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDashboardInput>
    public typealias MOutput = OperationOutput<CreateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDashboardOutputError>
}

public struct CreateDashboardInput: Equatable {
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?
    /// <p>The dashboard definition specified in a JSON literal. For detailed information, see
    ///       <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html">Creating dashboards (CLI)</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let dashboardDefinition: String?
    /// <p>A description for the dashboard.</p>
    public let dashboardDescription: String?
    /// <p>A friendly name for the dashboard.</p>
    public let dashboardName: String?
    /// <p>The ID of the project in which to create the dashboard.</p>
    public let projectId: String?
    /// <p>A list of key-value pairs that contain metadata for the dashboard. For more information,
    ///       see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your AWS IoT SiteWise
    ///         resources</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let tags: [String:String]?

    public init (
        clientToken: String? = nil,
        dashboardDefinition: String? = nil,
        dashboardDescription: String? = nil,
        dashboardName: String? = nil,
        projectId: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientToken = clientToken
        self.dashboardDefinition = dashboardDefinition
        self.dashboardDescription = dashboardDescription
        self.dashboardName = dashboardName
        self.projectId = projectId
        self.tags = tags
    }
}

struct CreateDashboardInputBody: Equatable {
    public let projectId: String?
    public let dashboardName: String?
    public let dashboardDescription: String?
    public let dashboardDefinition: String?
    public let clientToken: String?
    public let tags: [String:String]?
}

extension CreateDashboardInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case dashboardDefinition
        case dashboardDescription
        case dashboardName
        case projectId
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let dashboardNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardName)
        dashboardName = dashboardNameDecoded
        let dashboardDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardDescription)
        dashboardDescription = dashboardDescriptionDecoded
        let dashboardDefinitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardDefinition)
        dashboardDefinition = dashboardDefinitionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDashboardOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDashboardOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDashboardOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDashboardOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDashboardOutputResponse(dashboardArn: \(String(describing: dashboardArn)), dashboardId: \(String(describing: dashboardId)))"}
}

extension CreateDashboardOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDashboardOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dashboardArn = output.dashboardArn
            self.dashboardId = output.dashboardId
        } else {
            self.dashboardArn = nil
            self.dashboardId = nil
        }
    }
}

public struct CreateDashboardOutputResponse: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the dashboard, which has the following format.</p>
    ///         <p>
    ///             <code>arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId}</code>
    ///          </p>
    public let dashboardArn: String?
    /// <p>The ID of the dashboard.</p>
    public let dashboardId: String?

    public init (
        dashboardArn: String? = nil,
        dashboardId: String? = nil
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardId = dashboardId
    }
}

struct CreateDashboardOutputResponseBody: Equatable {
    public let dashboardId: String?
    public let dashboardArn: String?
}

extension CreateDashboardOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dashboardArn
        case dashboardId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let dashboardArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardArn)
        dashboardArn = dashboardArnDecoded
    }
}

public struct CreateGatewayInputBodyMiddleware: Middleware {
    public let id: String = "CreateGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGatewayInput>
    public typealias MOutput = OperationOutput<CreateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGatewayOutputError>
}

extension CreateGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGatewayInput(gatewayName: \(String(describing: gatewayName)), gatewayPlatform: \(String(describing: gatewayPlatform)), tags: \(String(describing: tags)))"}
}

extension CreateGatewayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayName
        case gatewayPlatform
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayName = gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
        if let gatewayPlatform = gatewayPlatform {
            try encodeContainer.encode(gatewayPlatform, forKey: .gatewayPlatform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGatewayInput>
    public typealias MOutput = OperationOutput<CreateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGatewayOutputError>
}

public struct CreateGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGatewayInput>
    public typealias MOutput = OperationOutput<CreateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGatewayOutputError>
}

public struct CreateGatewayInput: Equatable {
    /// <p>A unique, friendly name for the gateway.</p>
    public let gatewayName: String?
    /// <p>The gateway's platform. You can only specify one platform in a gateway.</p>
    public let gatewayPlatform: GatewayPlatform?
    /// <p>A list of key-value pairs that contain metadata for the gateway. For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your AWS IoT SiteWise
    ///         resources</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let tags: [String:String]?

    public init (
        gatewayName: String? = nil,
        gatewayPlatform: GatewayPlatform? = nil,
        tags: [String:String]? = nil
    )
    {
        self.gatewayName = gatewayName
        self.gatewayPlatform = gatewayPlatform
        self.tags = tags
    }
}

struct CreateGatewayInputBody: Equatable {
    public let gatewayName: String?
    public let gatewayPlatform: GatewayPlatform?
    public let tags: [String:String]?
}

extension CreateGatewayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayName
        case gatewayPlatform
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayPlatformDecoded = try containerValues.decodeIfPresent(GatewayPlatform.self, forKey: .gatewayPlatform)
        gatewayPlatform = gatewayPlatformDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGatewayOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGatewayOutputResponse(gatewayArn: \(String(describing: gatewayArn)), gatewayId: \(String(describing: gatewayId)))"}
}

extension CreateGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGatewayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayArn = output.gatewayArn
            self.gatewayId = output.gatewayId
        } else {
            self.gatewayArn = nil
            self.gatewayId = nil
        }
    }
}

public struct CreateGatewayOutputResponse: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the gateway, which has the following format.</p>
    ///         <p>
    ///             <code>arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId}</code>
    ///          </p>
    public let gatewayArn: String?
    /// <p>The ID of the gateway device. You can use this ID when you call other AWS IoT SiteWise APIs.</p>
    public let gatewayId: String?

    public init (
        gatewayArn: String? = nil,
        gatewayId: String? = nil
    )
    {
        self.gatewayArn = gatewayArn
        self.gatewayId = gatewayId
    }
}

struct CreateGatewayOutputResponseBody: Equatable {
    public let gatewayId: String?
    public let gatewayArn: String?
}

extension CreateGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayArn
        case gatewayId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let gatewayArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

public struct CreatePortalInputBodyMiddleware: Middleware {
    public let id: String = "CreatePortalInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePortalInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePortalInput>
    public typealias MOutput = OperationOutput<CreatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePortalOutputError>
}

extension CreatePortalInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePortalInput(alarms: \(String(describing: alarms)), clientToken: \(String(describing: clientToken)), notificationSenderEmail: \(String(describing: notificationSenderEmail)), portalAuthMode: \(String(describing: portalAuthMode)), portalContactEmail: \(String(describing: portalContactEmail)), portalDescription: \(String(describing: portalDescription)), portalLogoImageFile: \(String(describing: portalLogoImageFile)), portalName: \(String(describing: portalName)), roleArn: \(String(describing: roleArn)), tags: \(String(describing: tags)))"}
}

extension CreatePortalInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarms
        case clientToken
        case notificationSenderEmail
        case portalAuthMode
        case portalContactEmail
        case portalDescription
        case portalLogoImageFile
        case portalName
        case roleArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarms = alarms {
            try encodeContainer.encode(alarms, forKey: .alarms)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let notificationSenderEmail = notificationSenderEmail {
            try encodeContainer.encode(notificationSenderEmail, forKey: .notificationSenderEmail)
        }
        if let portalAuthMode = portalAuthMode {
            try encodeContainer.encode(portalAuthMode.rawValue, forKey: .portalAuthMode)
        }
        if let portalContactEmail = portalContactEmail {
            try encodeContainer.encode(portalContactEmail, forKey: .portalContactEmail)
        }
        if let portalDescription = portalDescription {
            try encodeContainer.encode(portalDescription, forKey: .portalDescription)
        }
        if let portalLogoImageFile = portalLogoImageFile {
            try encodeContainer.encode(portalLogoImageFile, forKey: .portalLogoImageFile)
        }
        if let portalName = portalName {
            try encodeContainer.encode(portalName, forKey: .portalName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreatePortalInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePortalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePortalInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePortalInput>
    public typealias MOutput = OperationOutput<CreatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePortalOutputError>
}

public struct CreatePortalInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePortalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePortalInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePortalInput>
    public typealias MOutput = OperationOutput<CreatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePortalOutputError>
}

public struct CreatePortalInput: Equatable {
    /// <p>Contains the configuration information of an alarm created in an AWS IoT SiteWise Monitor portal.
    ///   You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see .</p>
    public let alarms: Alarms?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?
    /// <p>The email address that sends alarm notifications.</p>
    ///          <important>
    ///             <p>If you use the AWS IoT Events managed AWS Lambda function to manage your emails, you must
    ///         <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html">verify the sender email address in Amazon SES</a>.</p>
    ///          </important>
    public let notificationSenderEmail: String?
    /// <p>The service to use to authenticate users to the portal. Choose from the following
    ///       options:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SSO</code> – The portal uses AWS Single Sign-On to authenticate users and manage
    ///           user permissions. Before you can create a portal that uses AWS SSO, you must enable AWS SSO.
    ///           For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-get-started.html#mon-gs-sso">Enabling AWS SSO</a> in the
    ///             <i>AWS IoT SiteWise User Guide</i>. This option is only available in AWS Regions other than
    ///           the China Regions.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IAM</code> – The portal uses AWS Identity and Access Management (IAM) to authenticate users and manage
    ///           user permissions. This option is only available in the China Regions.</p>
    ///             </li>
    ///          </ul>
    ///          <p>You can't change this value after you create a portal.</p>
    ///          <p>Default: <code>SSO</code>
    ///          </p>
    public let portalAuthMode: AuthMode?
    /// <p>The AWS administrator's contact email address.</p>
    public let portalContactEmail: String?
    /// <p>A description for the portal.</p>
    public let portalDescription: String?
    /// <p>A logo image to display in the portal. Upload a square, high-resolution image. The
    ///       image is displayed on a dark background.</p>
    public let portalLogoImageFile: ImageFile?
    /// <p>A friendly name for the portal.</p>
    public let portalName: String?
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of a service role that allows the portal's users to access your AWS IoT SiteWise
    ///       resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for AWS IoT SiteWise Monitor</a> in the
    ///         <i>AWS IoT SiteWise User Guide</i>.</p>
    public let roleArn: String?
    /// <p>A list of key-value pairs that contain metadata for the portal. For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your AWS IoT SiteWise
    ///         resources</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let tags: [String:String]?

    public init (
        alarms: Alarms? = nil,
        clientToken: String? = nil,
        notificationSenderEmail: String? = nil,
        portalAuthMode: AuthMode? = nil,
        portalContactEmail: String? = nil,
        portalDescription: String? = nil,
        portalLogoImageFile: ImageFile? = nil,
        portalName: String? = nil,
        roleArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.alarms = alarms
        self.clientToken = clientToken
        self.notificationSenderEmail = notificationSenderEmail
        self.portalAuthMode = portalAuthMode
        self.portalContactEmail = portalContactEmail
        self.portalDescription = portalDescription
        self.portalLogoImageFile = portalLogoImageFile
        self.portalName = portalName
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreatePortalInputBody: Equatable {
    public let portalName: String?
    public let portalDescription: String?
    public let portalContactEmail: String?
    public let clientToken: String?
    public let portalLogoImageFile: ImageFile?
    public let roleArn: String?
    public let tags: [String:String]?
    public let portalAuthMode: AuthMode?
    public let notificationSenderEmail: String?
    public let alarms: Alarms?
}

extension CreatePortalInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alarms
        case clientToken
        case notificationSenderEmail
        case portalAuthMode
        case portalContactEmail
        case portalDescription
        case portalLogoImageFile
        case portalName
        case roleArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portalName)
        portalName = portalNameDecoded
        let portalDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portalDescription)
        portalDescription = portalDescriptionDecoded
        let portalContactEmailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portalContactEmail)
        portalContactEmail = portalContactEmailDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let portalLogoImageFileDecoded = try containerValues.decodeIfPresent(ImageFile.self, forKey: .portalLogoImageFile)
        portalLogoImageFile = portalLogoImageFileDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let portalAuthModeDecoded = try containerValues.decodeIfPresent(AuthMode.self, forKey: .portalAuthMode)
        portalAuthMode = portalAuthModeDecoded
        let notificationSenderEmailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notificationSenderEmail)
        notificationSenderEmail = notificationSenderEmailDecoded
        let alarmsDecoded = try containerValues.decodeIfPresent(Alarms.self, forKey: .alarms)
        alarms = alarmsDecoded
    }
}

extension CreatePortalOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePortalOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePortalOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePortalOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePortalOutputResponse(portalArn: \(String(describing: portalArn)), portalId: \(String(describing: portalId)), portalStartUrl: \(String(describing: portalStartUrl)), portalStatus: \(String(describing: portalStatus)), ssoApplicationId: \(String(describing: ssoApplicationId)))"}
}

extension CreatePortalOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePortalOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.portalArn = output.portalArn
            self.portalId = output.portalId
            self.portalStartUrl = output.portalStartUrl
            self.portalStatus = output.portalStatus
            self.ssoApplicationId = output.ssoApplicationId
        } else {
            self.portalArn = nil
            self.portalId = nil
            self.portalStartUrl = nil
            self.portalStatus = nil
            self.ssoApplicationId = nil
        }
    }
}

public struct CreatePortalOutputResponse: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the portal, which has the following format.</p>
    ///         <p>
    ///             <code>arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId}</code>
    ///          </p>
    public let portalArn: String?
    /// <p>The ID of the created portal.</p>
    public let portalId: String?
    /// <p>The URL for the AWS IoT SiteWise Monitor portal. You can use this URL to access portals that
    ///       use AWS SSO for authentication. For portals that use IAM for authentication, you must use the
    ///       AWS IoT SiteWise console to get a URL that you can use to access the portal.</p>
    public let portalStartUrl: String?
    /// <p>The status of the portal, which contains a state (<code>CREATING</code> after successfully
    ///       calling this operation) and any error message.</p>
    public let portalStatus: PortalStatus?
    /// <p>The associated AWS SSO application ID, if the portal uses AWS SSO.</p>
    public let ssoApplicationId: String?

    public init (
        portalArn: String? = nil,
        portalId: String? = nil,
        portalStartUrl: String? = nil,
        portalStatus: PortalStatus? = nil,
        ssoApplicationId: String? = nil
    )
    {
        self.portalArn = portalArn
        self.portalId = portalId
        self.portalStartUrl = portalStartUrl
        self.portalStatus = portalStatus
        self.ssoApplicationId = ssoApplicationId
    }
}

struct CreatePortalOutputResponseBody: Equatable {
    public let portalId: String?
    public let portalArn: String?
    public let portalStartUrl: String?
    public let portalStatus: PortalStatus?
    public let ssoApplicationId: String?
}

extension CreatePortalOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case portalArn
        case portalId
        case portalStartUrl
        case portalStatus
        case ssoApplicationId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portalId)
        portalId = portalIdDecoded
        let portalArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let portalStartUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portalStartUrl)
        portalStartUrl = portalStartUrlDecoded
        let portalStatusDecoded = try containerValues.decodeIfPresent(PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
        let ssoApplicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ssoApplicationId)
        ssoApplicationId = ssoApplicationIdDecoded
    }
}

public struct CreateProjectInputBodyMiddleware: Middleware {
    public let id: String = "CreateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

extension CreateProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProjectInput(clientToken: \(String(describing: clientToken)), portalId: \(String(describing: portalId)), projectDescription: \(String(describing: projectDescription)), projectName: \(String(describing: projectName)), tags: \(String(describing: tags)))"}
}

extension CreateProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case portalId
        case projectDescription
        case projectName
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let portalId = portalId {
            try encodeContainer.encode(portalId, forKey: .portalId)
        }
        if let projectDescription = projectDescription {
            try encodeContainer.encode(projectDescription, forKey: .projectDescription)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateProjectInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

public struct CreateProjectInput: Equatable {
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?
    /// <p>The ID of the portal in which to create the project.</p>
    public let portalId: String?
    /// <p>A description for the project.</p>
    public let projectDescription: String?
    /// <p>A friendly name for the project.</p>
    public let projectName: String?
    /// <p>A list of key-value pairs that contain metadata for the project. For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your AWS IoT SiteWise
    ///         resources</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let tags: [String:String]?

    public init (
        clientToken: String? = nil,
        portalId: String? = nil,
        projectDescription: String? = nil,
        projectName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientToken = clientToken
        self.portalId = portalId
        self.projectDescription = projectDescription
        self.projectName = projectName
        self.tags = tags
    }
}

struct CreateProjectInputBody: Equatable {
    public let portalId: String?
    public let projectName: String?
    public let projectDescription: String?
    public let clientToken: String?
    public let tags: [String:String]?
}

extension CreateProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case portalId
        case projectDescription
        case projectName
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portalId)
        portalId = portalIdDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let projectDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectDescription)
        projectDescription = projectDescriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProjectOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProjectOutputResponse(projectArn: \(String(describing: projectArn)), projectId: \(String(describing: projectId)))"}
}

extension CreateProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.projectArn = output.projectArn
            self.projectId = output.projectId
        } else {
            self.projectArn = nil
            self.projectId = nil
        }
    }
}

public struct CreateProjectOutputResponse: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the project, which has the following format.</p>
    ///         <p>
    ///             <code>arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId}</code>
    ///          </p>
    public let projectArn: String?
    /// <p>The ID of the project.</p>
    public let projectId: String?

    public init (
        projectArn: String? = nil,
        projectId: String? = nil
    )
    {
        self.projectArn = projectArn
        self.projectId = projectId
    }
}

struct CreateProjectOutputResponseBody: Equatable {
    public let projectId: String?
    public let projectArn: String?
}

extension CreateProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case projectArn
        case projectId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let projectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

extension DashboardSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case description
        case id
        case lastUpdateDate
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = lastUpdateDate {
            try encodeContainer.encode(lastUpdateDate.timeIntervalSince1970, forKey: .lastUpdateDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension DashboardSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DashboardSummary(creationDate: \(String(describing: creationDate)), description: \(String(describing: description)), id: \(String(describing: id)), lastUpdateDate: \(String(describing: lastUpdateDate)), name: \(String(describing: name)))"}
}

/// <p>Contains a dashboard summary.</p>
public struct DashboardSummary: Equatable {
    /// <p>The date the dashboard was created, in Unix epoch time.</p>
    public let creationDate: Date?
    /// <p>The dashboard's description.</p>
    public let description: String?
    /// <p>The ID of the dashboard.</p>
    public let id: String?
    /// <p>The date the dashboard was last updated, in Unix epoch time.</p>
    public let lastUpdateDate: Date?
    /// <p>The name of the dashboard</p>
    public let name: String?

    public init (
        creationDate: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        lastUpdateDate: Date? = nil,
        name: String? = nil
    )
    {
        self.creationDate = creationDate
        self.description = description
        self.id = id
        self.lastUpdateDate = lastUpdateDate
        self.name = name
    }
}

extension DeleteAccessPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessPolicyInput(accessPolicyId: \(String(describing: accessPolicyId)), clientToken: \(String(describing: clientToken)))"}
}

extension DeleteAccessPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAccessPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessPolicyInput>
    public typealias MOutput = OperationOutput<DeleteAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessPolicyOutputError>
}

public struct DeleteAccessPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = URLQueryItem(name: "clientToken".urlPercentEncoding(), value: String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessPolicyInput>
    public typealias MOutput = OperationOutput<DeleteAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessPolicyOutputError>
}

public struct DeleteAccessPolicyInput: Equatable {
    /// <p>The ID of the access policy to be deleted.</p>
    public let accessPolicyId: String?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?

    public init (
        accessPolicyId: String? = nil,
        clientToken: String? = nil
    )
    {
        self.accessPolicyId = accessPolicyId
        self.clientToken = clientToken
    }
}

struct DeleteAccessPolicyInputBody: Equatable {
}

extension DeleteAccessPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAccessPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccessPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccessPolicyOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessPolicyOutputResponse()"}
}

extension DeleteAccessPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteAccessPolicyOutputResponseBody: Equatable {
}

extension DeleteAccessPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAssetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssetInput(assetId: \(String(describing: assetId)), clientToken: \(String(describing: clientToken)))"}
}

extension DeleteAssetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAssetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssetInput>
    public typealias MOutput = OperationOutput<DeleteAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssetOutputError>
}

public struct DeleteAssetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = URLQueryItem(name: "clientToken".urlPercentEncoding(), value: String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssetInput>
    public typealias MOutput = OperationOutput<DeleteAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssetOutputError>
}

public struct DeleteAssetInput: Equatable {
    /// <p>The ID of the asset to delete.</p>
    public let assetId: String?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?

    public init (
        assetId: String? = nil,
        clientToken: String? = nil
    )
    {
        self.assetId = assetId
        self.clientToken = clientToken
    }
}

struct DeleteAssetInputBody: Equatable {
}

extension DeleteAssetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAssetModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssetModelInput(assetModelId: \(String(describing: assetModelId)), clientToken: \(String(describing: clientToken)))"}
}

extension DeleteAssetModelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAssetModelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAssetModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssetModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssetModelInput>
    public typealias MOutput = OperationOutput<DeleteAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssetModelOutputError>
}

public struct DeleteAssetModelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAssetModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssetModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = URLQueryItem(name: "clientToken".urlPercentEncoding(), value: String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssetModelInput>
    public typealias MOutput = OperationOutput<DeleteAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssetModelOutputError>
}

public struct DeleteAssetModelInput: Equatable {
    /// <p>The ID of the asset model to delete.</p>
    public let assetModelId: String?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?

    public init (
        assetModelId: String? = nil,
        clientToken: String? = nil
    )
    {
        self.assetModelId = assetModelId
        self.clientToken = clientToken
    }
}

struct DeleteAssetModelInputBody: Equatable {
}

extension DeleteAssetModelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAssetModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssetModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssetModelOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssetModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssetModelOutputResponse(assetModelStatus: \(String(describing: assetModelStatus)))"}
}

extension DeleteAssetModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteAssetModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assetModelStatus = output.assetModelStatus
        } else {
            self.assetModelStatus = nil
        }
    }
}

public struct DeleteAssetModelOutputResponse: Equatable {
    /// <p>The status of the asset model, which contains a state (<code>DELETING</code> after
    ///       successfully calling this operation) and any error message.</p>
    public let assetModelStatus: AssetModelStatus?

    public init (
        assetModelStatus: AssetModelStatus? = nil
    )
    {
        self.assetModelStatus = assetModelStatus
    }
}

struct DeleteAssetModelOutputResponseBody: Equatable {
    public let assetModelStatus: AssetModelStatus?
}

extension DeleteAssetModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetModelStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelStatusDecoded = try containerValues.decodeIfPresent(AssetModelStatus.self, forKey: .assetModelStatus)
        assetModelStatus = assetModelStatusDecoded
    }
}

extension DeleteAssetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssetOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssetOutputResponse(assetStatus: \(String(describing: assetStatus)))"}
}

extension DeleteAssetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteAssetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assetStatus = output.assetStatus
        } else {
            self.assetStatus = nil
        }
    }
}

public struct DeleteAssetOutputResponse: Equatable {
    /// <p>The status of the asset, which contains a state (<code>DELETING</code> after successfully
    ///       calling this operation) and any error message.</p>
    public let assetStatus: AssetStatus?

    public init (
        assetStatus: AssetStatus? = nil
    )
    {
        self.assetStatus = assetStatus
    }
}

struct DeleteAssetOutputResponseBody: Equatable {
    public let assetStatus: AssetStatus?
}

extension DeleteAssetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetStatusDecoded = try containerValues.decodeIfPresent(AssetStatus.self, forKey: .assetStatus)
        assetStatus = assetStatusDecoded
    }
}

extension DeleteDashboardInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDashboardInput(clientToken: \(String(describing: clientToken)), dashboardId: \(String(describing: dashboardId)))"}
}

extension DeleteDashboardInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDashboardInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDashboardInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDashboardInput>
    public typealias MOutput = OperationOutput<DeleteDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDashboardOutputError>
}

public struct DeleteDashboardInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDashboardInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = URLQueryItem(name: "clientToken".urlPercentEncoding(), value: String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDashboardInput>
    public typealias MOutput = OperationOutput<DeleteDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDashboardOutputError>
}

public struct DeleteDashboardInput: Equatable {
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?
    /// <p>The ID of the dashboard to delete.</p>
    public let dashboardId: String?

    public init (
        clientToken: String? = nil,
        dashboardId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.dashboardId = dashboardId
    }
}

struct DeleteDashboardInputBody: Equatable {
}

extension DeleteDashboardInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDashboardOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDashboardOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDashboardOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDashboardOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDashboardOutputResponse()"}
}

extension DeleteDashboardOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDashboardOutputResponse: Equatable {

    public init() {}
}

struct DeleteDashboardOutputResponseBody: Equatable {
}

extension DeleteDashboardOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGatewayInput(gatewayId: \(String(describing: gatewayId)))"}
}

extension DeleteGatewayInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGatewayInput>
    public typealias MOutput = OperationOutput<DeleteGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGatewayOutputError>
}

public struct DeleteGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGatewayInput>
    public typealias MOutput = OperationOutput<DeleteGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGatewayOutputError>
}

public struct DeleteGatewayInput: Equatable {
    /// <p>The ID of the gateway to delete.</p>
    public let gatewayId: String?

    public init (
        gatewayId: String? = nil
    )
    {
        self.gatewayId = gatewayId
    }
}

struct DeleteGatewayInputBody: Equatable {
}

extension DeleteGatewayInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGatewayOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGatewayOutputResponse()"}
}

extension DeleteGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGatewayOutputResponse: Equatable {

    public init() {}
}

struct DeleteGatewayOutputResponseBody: Equatable {
}

extension DeleteGatewayOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePortalInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePortalInput(clientToken: \(String(describing: clientToken)), portalId: \(String(describing: portalId)))"}
}

extension DeletePortalInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeletePortalInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePortalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePortalInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePortalInput>
    public typealias MOutput = OperationOutput<DeletePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePortalOutputError>
}

public struct DeletePortalInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePortalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePortalInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = URLQueryItem(name: "clientToken".urlPercentEncoding(), value: String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePortalInput>
    public typealias MOutput = OperationOutput<DeletePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePortalOutputError>
}

public struct DeletePortalInput: Equatable {
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?
    /// <p>The ID of the portal to delete.</p>
    public let portalId: String?

    public init (
        clientToken: String? = nil,
        portalId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.portalId = portalId
    }
}

struct DeletePortalInputBody: Equatable {
}

extension DeletePortalInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePortalOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePortalOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePortalOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePortalOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePortalOutputResponse(portalStatus: \(String(describing: portalStatus)))"}
}

extension DeletePortalOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeletePortalOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.portalStatus = output.portalStatus
        } else {
            self.portalStatus = nil
        }
    }
}

public struct DeletePortalOutputResponse: Equatable {
    /// <p>The status of the portal, which contains a state (<code>DELETING</code> after successfully
    ///       calling this operation) and any error message.</p>
    public let portalStatus: PortalStatus?

    public init (
        portalStatus: PortalStatus? = nil
    )
    {
        self.portalStatus = portalStatus
    }
}

struct DeletePortalOutputResponseBody: Equatable {
    public let portalStatus: PortalStatus?
}

extension DeletePortalOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case portalStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalStatusDecoded = try containerValues.decodeIfPresent(PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
    }
}

extension DeleteProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProjectInput(clientToken: \(String(describing: clientToken)), projectId: \(String(describing: projectId)))"}
}

extension DeleteProjectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteProjectInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = URLQueryItem(name: "clientToken".urlPercentEncoding(), value: String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInput: Equatable {
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?
    /// <p>The ID of the project.</p>
    public let projectId: String?

    public init (
        clientToken: String? = nil,
        projectId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectId = projectId
    }
}

struct DeleteProjectInputBody: Equatable {
}

extension DeleteProjectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProjectOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProjectOutputResponse()"}
}

extension DeleteProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProjectOutputResponse: Equatable {

    public init() {}
}

struct DeleteProjectOutputResponseBody: Equatable {
}

extension DeleteProjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAccessPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccessPolicyInput(accessPolicyId: \(String(describing: accessPolicyId)))"}
}

extension DescribeAccessPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAccessPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccessPolicyInput>
    public typealias MOutput = OperationOutput<DescribeAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccessPolicyOutputError>
}

public struct DescribeAccessPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccessPolicyInput>
    public typealias MOutput = OperationOutput<DescribeAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccessPolicyOutputError>
}

public struct DescribeAccessPolicyInput: Equatable {
    /// <p>The ID of the access policy.</p>
    public let accessPolicyId: String?

    public init (
        accessPolicyId: String? = nil
    )
    {
        self.accessPolicyId = accessPolicyId
    }
}

struct DescribeAccessPolicyInputBody: Equatable {
}

extension DescribeAccessPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAccessPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccessPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccessPolicyOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccessPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccessPolicyOutputResponse(accessPolicyArn: \(String(describing: accessPolicyArn)), accessPolicyCreationDate: \(String(describing: accessPolicyCreationDate)), accessPolicyId: \(String(describing: accessPolicyId)), accessPolicyIdentity: \(String(describing: accessPolicyIdentity)), accessPolicyLastUpdateDate: \(String(describing: accessPolicyLastUpdateDate)), accessPolicyPermission: \(String(describing: accessPolicyPermission)), accessPolicyResource: \(String(describing: accessPolicyResource)))"}
}

extension DescribeAccessPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccessPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessPolicyArn = output.accessPolicyArn
            self.accessPolicyCreationDate = output.accessPolicyCreationDate
            self.accessPolicyId = output.accessPolicyId
            self.accessPolicyIdentity = output.accessPolicyIdentity
            self.accessPolicyLastUpdateDate = output.accessPolicyLastUpdateDate
            self.accessPolicyPermission = output.accessPolicyPermission
            self.accessPolicyResource = output.accessPolicyResource
        } else {
            self.accessPolicyArn = nil
            self.accessPolicyCreationDate = nil
            self.accessPolicyId = nil
            self.accessPolicyIdentity = nil
            self.accessPolicyLastUpdateDate = nil
            self.accessPolicyPermission = nil
            self.accessPolicyResource = nil
        }
    }
}

public struct DescribeAccessPolicyOutputResponse: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the access policy, which has the following format.</p>
    ///         <p>
    ///             <code>arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId}</code>
    ///          </p>
    public let accessPolicyArn: String?
    /// <p>The date the access policy was created, in Unix epoch time.</p>
    public let accessPolicyCreationDate: Date?
    /// <p>The ID of the access policy.</p>
    public let accessPolicyId: String?
    /// <p>The identity (AWS SSO user, AWS SSO group, or IAM user) to which this access policy
    ///       applies.</p>
    public let accessPolicyIdentity: Identity?
    /// <p>The date the access policy was last updated, in Unix epoch time.</p>
    public let accessPolicyLastUpdateDate: Date?
    /// <p>The access policy permission. Note that a project <code>ADMINISTRATOR</code> is also known
    ///       as a project owner.</p>
    public let accessPolicyPermission: Permission?
    /// <p>The AWS IoT SiteWise Monitor resource (portal or project) to which this access policy provides
    ///       access.</p>
    public let accessPolicyResource: Resource?

    public init (
        accessPolicyArn: String? = nil,
        accessPolicyCreationDate: Date? = nil,
        accessPolicyId: String? = nil,
        accessPolicyIdentity: Identity? = nil,
        accessPolicyLastUpdateDate: Date? = nil,
        accessPolicyPermission: Permission? = nil,
        accessPolicyResource: Resource? = nil
    )
    {
        self.accessPolicyArn = accessPolicyArn
        self.accessPolicyCreationDate = accessPolicyCreationDate
        self.accessPolicyId = accessPolicyId
        self.accessPolicyIdentity = accessPolicyIdentity
        self.accessPolicyLastUpdateDate = accessPolicyLastUpdateDate
        self.accessPolicyPermission = accessPolicyPermission
        self.accessPolicyResource = accessPolicyResource
    }
}

struct DescribeAccessPolicyOutputResponseBody: Equatable {
    public let accessPolicyId: String?
    public let accessPolicyArn: String?
    public let accessPolicyIdentity: Identity?
    public let accessPolicyResource: Resource?
    public let accessPolicyPermission: Permission?
    public let accessPolicyCreationDate: Date?
    public let accessPolicyLastUpdateDate: Date?
}

extension DescribeAccessPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessPolicyArn
        case accessPolicyCreationDate
        case accessPolicyId
        case accessPolicyIdentity
        case accessPolicyLastUpdateDate
        case accessPolicyPermission
        case accessPolicyResource
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessPolicyId)
        accessPolicyId = accessPolicyIdDecoded
        let accessPolicyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessPolicyArn)
        accessPolicyArn = accessPolicyArnDecoded
        let accessPolicyIdentityDecoded = try containerValues.decodeIfPresent(Identity.self, forKey: .accessPolicyIdentity)
        accessPolicyIdentity = accessPolicyIdentityDecoded
        let accessPolicyResourceDecoded = try containerValues.decodeIfPresent(Resource.self, forKey: .accessPolicyResource)
        accessPolicyResource = accessPolicyResourceDecoded
        let accessPolicyPermissionDecoded = try containerValues.decodeIfPresent(Permission.self, forKey: .accessPolicyPermission)
        accessPolicyPermission = accessPolicyPermissionDecoded
        let accessPolicyCreationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .accessPolicyCreationDate)
        accessPolicyCreationDate = accessPolicyCreationDateDecoded
        let accessPolicyLastUpdateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .accessPolicyLastUpdateDate)
        accessPolicyLastUpdateDate = accessPolicyLastUpdateDateDecoded
    }
}

extension DescribeAssetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssetInput(assetId: \(String(describing: assetId)))"}
}

extension DescribeAssetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAssetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssetInput>
    public typealias MOutput = OperationOutput<DescribeAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssetOutputError>
}

public struct DescribeAssetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssetInput>
    public typealias MOutput = OperationOutput<DescribeAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssetOutputError>
}

public struct DescribeAssetInput: Equatable {
    /// <p>The ID of the asset.</p>
    public let assetId: String?

    public init (
        assetId: String? = nil
    )
    {
        self.assetId = assetId
    }
}

struct DescribeAssetInputBody: Equatable {
}

extension DescribeAssetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAssetModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssetModelInput(assetModelId: \(String(describing: assetModelId)))"}
}

extension DescribeAssetModelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAssetModelInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAssetModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssetModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssetModelInput>
    public typealias MOutput = OperationOutput<DescribeAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssetModelOutputError>
}

public struct DescribeAssetModelInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAssetModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssetModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssetModelInput>
    public typealias MOutput = OperationOutput<DescribeAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssetModelOutputError>
}

public struct DescribeAssetModelInput: Equatable {
    /// <p>The ID of the asset model.</p>
    public let assetModelId: String?

    public init (
        assetModelId: String? = nil
    )
    {
        self.assetModelId = assetModelId
    }
}

struct DescribeAssetModelInputBody: Equatable {
}

extension DescribeAssetModelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAssetModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssetModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssetModelOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssetModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssetModelOutputResponse(assetModelArn: \(String(describing: assetModelArn)), assetModelCompositeModels: \(String(describing: assetModelCompositeModels)), assetModelCreationDate: \(String(describing: assetModelCreationDate)), assetModelDescription: \(String(describing: assetModelDescription)), assetModelHierarchies: \(String(describing: assetModelHierarchies)), assetModelId: \(String(describing: assetModelId)), assetModelLastUpdateDate: \(String(describing: assetModelLastUpdateDate)), assetModelName: \(String(describing: assetModelName)), assetModelProperties: \(String(describing: assetModelProperties)), assetModelStatus: \(String(describing: assetModelStatus)))"}
}

extension DescribeAssetModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAssetModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assetModelArn = output.assetModelArn
            self.assetModelCompositeModels = output.assetModelCompositeModels
            self.assetModelCreationDate = output.assetModelCreationDate
            self.assetModelDescription = output.assetModelDescription
            self.assetModelHierarchies = output.assetModelHierarchies
            self.assetModelId = output.assetModelId
            self.assetModelLastUpdateDate = output.assetModelLastUpdateDate
            self.assetModelName = output.assetModelName
            self.assetModelProperties = output.assetModelProperties
            self.assetModelStatus = output.assetModelStatus
        } else {
            self.assetModelArn = nil
            self.assetModelCompositeModels = nil
            self.assetModelCreationDate = nil
            self.assetModelDescription = nil
            self.assetModelHierarchies = nil
            self.assetModelId = nil
            self.assetModelLastUpdateDate = nil
            self.assetModelName = nil
            self.assetModelProperties = nil
            self.assetModelStatus = nil
        }
    }
}

public struct DescribeAssetModelOutputResponse: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset model, which has the following format.</p>
    ///         <p>
    ///             <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}</code>
    ///          </p>
    public let assetModelArn: String?
    /// <p>The list of composite asset models for the asset model.</p>
    public let assetModelCompositeModels: [AssetModelCompositeModel]?
    /// <p>The date the asset model was created, in Unix epoch time.</p>
    public let assetModelCreationDate: Date?
    /// <p>The asset model's description.</p>
    public let assetModelDescription: String?
    /// <p>A list of asset model hierarchies that each contain a <code>childAssetModelId</code> and a
    ///         <code>hierarchyId</code> (named <code>id</code>). A hierarchy specifies allowed parent/child
    ///       asset relationships for an asset model.</p>
    public let assetModelHierarchies: [AssetModelHierarchy]?
    /// <p>The ID of the asset model.</p>
    public let assetModelId: String?
    /// <p>The date the asset model was last updated, in Unix epoch time.</p>
    public let assetModelLastUpdateDate: Date?
    /// <p>The name of the asset model.</p>
    public let assetModelName: String?
    /// <p>The list of asset properties for the asset model.</p>
    ///          <p>This object doesn't include properties that you define in composite models. You can find
    ///       composite model properties in the <code>assetModelCompositeModels</code> object.</p>
    public let assetModelProperties: [AssetModelProperty]?
    /// <p>The current status of the asset model, which contains a state and any error
    ///       message.</p>
    public let assetModelStatus: AssetModelStatus?

    public init (
        assetModelArn: String? = nil,
        assetModelCompositeModels: [AssetModelCompositeModel]? = nil,
        assetModelCreationDate: Date? = nil,
        assetModelDescription: String? = nil,
        assetModelHierarchies: [AssetModelHierarchy]? = nil,
        assetModelId: String? = nil,
        assetModelLastUpdateDate: Date? = nil,
        assetModelName: String? = nil,
        assetModelProperties: [AssetModelProperty]? = nil,
        assetModelStatus: AssetModelStatus? = nil
    )
    {
        self.assetModelArn = assetModelArn
        self.assetModelCompositeModels = assetModelCompositeModels
        self.assetModelCreationDate = assetModelCreationDate
        self.assetModelDescription = assetModelDescription
        self.assetModelHierarchies = assetModelHierarchies
        self.assetModelId = assetModelId
        self.assetModelLastUpdateDate = assetModelLastUpdateDate
        self.assetModelName = assetModelName
        self.assetModelProperties = assetModelProperties
        self.assetModelStatus = assetModelStatus
    }
}

struct DescribeAssetModelOutputResponseBody: Equatable {
    public let assetModelId: String?
    public let assetModelArn: String?
    public let assetModelName: String?
    public let assetModelDescription: String?
    public let assetModelProperties: [AssetModelProperty]?
    public let assetModelHierarchies: [AssetModelHierarchy]?
    public let assetModelCompositeModels: [AssetModelCompositeModel]?
    public let assetModelCreationDate: Date?
    public let assetModelLastUpdateDate: Date?
    public let assetModelStatus: AssetModelStatus?
}

extension DescribeAssetModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetModelArn
        case assetModelCompositeModels
        case assetModelCreationDate
        case assetModelDescription
        case assetModelHierarchies
        case assetModelId
        case assetModelLastUpdateDate
        case assetModelName
        case assetModelProperties
        case assetModelStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let assetModelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetModelArn)
        assetModelArn = assetModelArnDecoded
        let assetModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetModelName)
        assetModelName = assetModelNameDecoded
        let assetModelDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetModelDescription)
        assetModelDescription = assetModelDescriptionDecoded
        let assetModelPropertiesContainer = try containerValues.decodeIfPresent([AssetModelProperty?].self, forKey: .assetModelProperties)
        var assetModelPropertiesDecoded0:[AssetModelProperty]? = nil
        if let assetModelPropertiesContainer = assetModelPropertiesContainer {
            assetModelPropertiesDecoded0 = [AssetModelProperty]()
            for structure0 in assetModelPropertiesContainer {
                if let structure0 = structure0 {
                    assetModelPropertiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelProperties = assetModelPropertiesDecoded0
        let assetModelHierarchiesContainer = try containerValues.decodeIfPresent([AssetModelHierarchy?].self, forKey: .assetModelHierarchies)
        var assetModelHierarchiesDecoded0:[AssetModelHierarchy]? = nil
        if let assetModelHierarchiesContainer = assetModelHierarchiesContainer {
            assetModelHierarchiesDecoded0 = [AssetModelHierarchy]()
            for structure0 in assetModelHierarchiesContainer {
                if let structure0 = structure0 {
                    assetModelHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelHierarchies = assetModelHierarchiesDecoded0
        let assetModelCompositeModelsContainer = try containerValues.decodeIfPresent([AssetModelCompositeModel?].self, forKey: .assetModelCompositeModels)
        var assetModelCompositeModelsDecoded0:[AssetModelCompositeModel]? = nil
        if let assetModelCompositeModelsContainer = assetModelCompositeModelsContainer {
            assetModelCompositeModelsDecoded0 = [AssetModelCompositeModel]()
            for structure0 in assetModelCompositeModelsContainer {
                if let structure0 = structure0 {
                    assetModelCompositeModelsDecoded0?.append(structure0)
                }
            }
        }
        assetModelCompositeModels = assetModelCompositeModelsDecoded0
        let assetModelCreationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .assetModelCreationDate)
        assetModelCreationDate = assetModelCreationDateDecoded
        let assetModelLastUpdateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .assetModelLastUpdateDate)
        assetModelLastUpdateDate = assetModelLastUpdateDateDecoded
        let assetModelStatusDecoded = try containerValues.decodeIfPresent(AssetModelStatus.self, forKey: .assetModelStatus)
        assetModelStatus = assetModelStatusDecoded
    }
}

extension DescribeAssetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssetOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssetOutputResponse(assetArn: \(String(describing: assetArn)), assetCompositeModels: \(String(describing: assetCompositeModels)), assetCreationDate: \(String(describing: assetCreationDate)), assetHierarchies: \(String(describing: assetHierarchies)), assetId: \(String(describing: assetId)), assetLastUpdateDate: \(String(describing: assetLastUpdateDate)), assetModelId: \(String(describing: assetModelId)), assetName: \(String(describing: assetName)), assetProperties: \(String(describing: assetProperties)), assetStatus: \(String(describing: assetStatus)))"}
}

extension DescribeAssetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAssetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assetArn = output.assetArn
            self.assetCompositeModels = output.assetCompositeModels
            self.assetCreationDate = output.assetCreationDate
            self.assetHierarchies = output.assetHierarchies
            self.assetId = output.assetId
            self.assetLastUpdateDate = output.assetLastUpdateDate
            self.assetModelId = output.assetModelId
            self.assetName = output.assetName
            self.assetProperties = output.assetProperties
            self.assetStatus = output.assetStatus
        } else {
            self.assetArn = nil
            self.assetCompositeModels = nil
            self.assetCreationDate = nil
            self.assetHierarchies = nil
            self.assetId = nil
            self.assetLastUpdateDate = nil
            self.assetModelId = nil
            self.assetName = nil
            self.assetProperties = nil
            self.assetStatus = nil
        }
    }
}

public struct DescribeAssetOutputResponse: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the asset, which has the following format.</p>
    ///         <p>
    ///             <code>arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}</code>
    ///          </p>
    public let assetArn: String?
    /// <p>The composite models for the asset.</p>
    public let assetCompositeModels: [AssetCompositeModel]?
    /// <p>The date the asset was created, in Unix epoch time.</p>
    public let assetCreationDate: Date?
    /// <p>A list of asset hierarchies that each contain a <code>hierarchyId</code>. A hierarchy specifies allowed parent/child asset relationships.</p>
    public let assetHierarchies: [AssetHierarchy]?
    /// <p>The ID of the asset.</p>
    public let assetId: String?
    /// <p>The date the asset was last updated, in Unix epoch time.</p>
    public let assetLastUpdateDate: Date?
    /// <p>The ID of the asset model that was used to create the asset.</p>
    public let assetModelId: String?
    /// <p>The name of the asset.</p>
    public let assetName: String?
    /// <p>The list of asset properties for the asset.</p>
    ///          <p>This object doesn't include properties that you define in composite models. You can find
    ///       composite model properties in the <code>assetCompositeModels</code> object.</p>
    public let assetProperties: [AssetProperty]?
    /// <p>The current status of the asset, which contains a state and any error message.</p>
    public let assetStatus: AssetStatus?

    public init (
        assetArn: String? = nil,
        assetCompositeModels: [AssetCompositeModel]? = nil,
        assetCreationDate: Date? = nil,
        assetHierarchies: [AssetHierarchy]? = nil,
        assetId: String? = nil,
        assetLastUpdateDate: Date? = nil,
        assetModelId: String? = nil,
        assetName: String? = nil,
        assetProperties: [AssetProperty]? = nil,
        assetStatus: AssetStatus? = nil
    )
    {
        self.assetArn = assetArn
        self.assetCompositeModels = assetCompositeModels
        self.assetCreationDate = assetCreationDate
        self.assetHierarchies = assetHierarchies
        self.assetId = assetId
        self.assetLastUpdateDate = assetLastUpdateDate
        self.assetModelId = assetModelId
        self.assetName = assetName
        self.assetProperties = assetProperties
        self.assetStatus = assetStatus
    }
}

struct DescribeAssetOutputResponseBody: Equatable {
    public let assetId: String?
    public let assetArn: String?
    public let assetName: String?
    public let assetModelId: String?
    public let assetProperties: [AssetProperty]?
    public let assetHierarchies: [AssetHierarchy]?
    public let assetCompositeModels: [AssetCompositeModel]?
    public let assetCreationDate: Date?
    public let assetLastUpdateDate: Date?
    public let assetStatus: AssetStatus?
}

extension DescribeAssetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetArn
        case assetCompositeModels
        case assetCreationDate
        case assetHierarchies
        case assetId
        case assetLastUpdateDate
        case assetModelId
        case assetName
        case assetProperties
        case assetStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let assetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetArn)
        assetArn = assetArnDecoded
        let assetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let assetPropertiesContainer = try containerValues.decodeIfPresent([AssetProperty?].self, forKey: .assetProperties)
        var assetPropertiesDecoded0:[AssetProperty]? = nil
        if let assetPropertiesContainer = assetPropertiesContainer {
            assetPropertiesDecoded0 = [AssetProperty]()
            for structure0 in assetPropertiesContainer {
                if let structure0 = structure0 {
                    assetPropertiesDecoded0?.append(structure0)
                }
            }
        }
        assetProperties = assetPropertiesDecoded0
        let assetHierarchiesContainer = try containerValues.decodeIfPresent([AssetHierarchy?].self, forKey: .assetHierarchies)
        var assetHierarchiesDecoded0:[AssetHierarchy]? = nil
        if let assetHierarchiesContainer = assetHierarchiesContainer {
            assetHierarchiesDecoded0 = [AssetHierarchy]()
            for structure0 in assetHierarchiesContainer {
                if let structure0 = structure0 {
                    assetHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        assetHierarchies = assetHierarchiesDecoded0
        let assetCompositeModelsContainer = try containerValues.decodeIfPresent([AssetCompositeModel?].self, forKey: .assetCompositeModels)
        var assetCompositeModelsDecoded0:[AssetCompositeModel]? = nil
        if let assetCompositeModelsContainer = assetCompositeModelsContainer {
            assetCompositeModelsDecoded0 = [AssetCompositeModel]()
            for structure0 in assetCompositeModelsContainer {
                if let structure0 = structure0 {
                    assetCompositeModelsDecoded0?.append(structure0)
                }
            }
        }
        assetCompositeModels = assetCompositeModelsDecoded0
        let assetCreationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .assetCreationDate)
        assetCreationDate = assetCreationDateDecoded
        let assetLastUpdateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .assetLastUpdateDate)
        assetLastUpdateDate = assetLastUpdateDateDecoded
        let assetStatusDecoded = try containerValues.decodeIfPresent(AssetStatus.self, forKey: .assetStatus)
        assetStatus = assetStatusDecoded
    }
}

extension DescribeAssetPropertyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssetPropertyInput(assetId: \(String(describing: assetId)), propertyId: \(String(describing: propertyId)))"}
}

extension DescribeAssetPropertyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAssetPropertyInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAssetPropertyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssetPropertyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssetPropertyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssetPropertyInput>
    public typealias MOutput = OperationOutput<DescribeAssetPropertyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssetPropertyOutputError>
}

public struct DescribeAssetPropertyInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAssetPropertyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssetPropertyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssetPropertyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssetPropertyInput>
    public typealias MOutput = OperationOutput<DescribeAssetPropertyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssetPropertyOutputError>
}

public struct DescribeAssetPropertyInput: Equatable {
    /// <p>The ID of the asset.</p>
    public let assetId: String?
    /// <p>The ID of the asset property.</p>
    public let propertyId: String?

    public init (
        assetId: String? = nil,
        propertyId: String? = nil
    )
    {
        self.assetId = assetId
        self.propertyId = propertyId
    }
}

struct DescribeAssetPropertyInputBody: Equatable {
}

extension DescribeAssetPropertyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAssetPropertyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssetPropertyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssetPropertyOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssetPropertyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssetPropertyOutputResponse(assetId: \(String(describing: assetId)), assetModelId: \(String(describing: assetModelId)), assetName: \(String(describing: assetName)), assetProperty: \(String(describing: assetProperty)), compositeModel: \(String(describing: compositeModel)))"}
}

extension DescribeAssetPropertyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAssetPropertyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assetId = output.assetId
            self.assetModelId = output.assetModelId
            self.assetName = output.assetName
            self.assetProperty = output.assetProperty
            self.compositeModel = output.compositeModel
        } else {
            self.assetId = nil
            self.assetModelId = nil
            self.assetName = nil
            self.assetProperty = nil
            self.compositeModel = nil
        }
    }
}

public struct DescribeAssetPropertyOutputResponse: Equatable {
    /// <p>The ID of the asset.</p>
    public let assetId: String?
    /// <p>The ID of the asset model.</p>
    public let assetModelId: String?
    /// <p>The name of the asset.</p>
    public let assetName: String?
    /// <p>The asset property's definition, alias, and notification state.</p>
    ///          <p>This response includes this object for normal asset properties. If you describe an asset
    ///       property in a composite model, this response includes the asset property information in
    ///         <code>compositeModel</code>.</p>
    public let assetProperty: Property?
    /// <p>The composite asset model that declares this asset property, if this asset property exists
    ///       in a composite model.</p>
    public let compositeModel: CompositeModelProperty?

    public init (
        assetId: String? = nil,
        assetModelId: String? = nil,
        assetName: String? = nil,
        assetProperty: Property? = nil,
        compositeModel: CompositeModelProperty? = nil
    )
    {
        self.assetId = assetId
        self.assetModelId = assetModelId
        self.assetName = assetName
        self.assetProperty = assetProperty
        self.compositeModel = compositeModel
    }
}

struct DescribeAssetPropertyOutputResponseBody: Equatable {
    public let assetId: String?
    public let assetName: String?
    public let assetModelId: String?
    public let assetProperty: Property?
    public let compositeModel: CompositeModelProperty?
}

extension DescribeAssetPropertyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetId
        case assetModelId
        case assetName
        case assetProperty
        case compositeModel
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let assetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let assetPropertyDecoded = try containerValues.decodeIfPresent(Property.self, forKey: .assetProperty)
        assetProperty = assetPropertyDecoded
        let compositeModelDecoded = try containerValues.decodeIfPresent(CompositeModelProperty.self, forKey: .compositeModel)
        compositeModel = compositeModelDecoded
    }
}

extension DescribeDashboardInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDashboardInput(dashboardId: \(String(describing: dashboardId)))"}
}

extension DescribeDashboardInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDashboardInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDashboardInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDashboardInput>
    public typealias MOutput = OperationOutput<DescribeDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDashboardOutputError>
}

public struct DescribeDashboardInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDashboardInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDashboardInput>
    public typealias MOutput = OperationOutput<DescribeDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDashboardOutputError>
}

public struct DescribeDashboardInput: Equatable {
    /// <p>The ID of the dashboard.</p>
    public let dashboardId: String?

    public init (
        dashboardId: String? = nil
    )
    {
        self.dashboardId = dashboardId
    }
}

struct DescribeDashboardInputBody: Equatable {
}

extension DescribeDashboardInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDashboardOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDashboardOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDashboardOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDashboardOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDashboardOutputResponse(dashboardArn: \(String(describing: dashboardArn)), dashboardCreationDate: \(String(describing: dashboardCreationDate)), dashboardDefinition: \(String(describing: dashboardDefinition)), dashboardDescription: \(String(describing: dashboardDescription)), dashboardId: \(String(describing: dashboardId)), dashboardLastUpdateDate: \(String(describing: dashboardLastUpdateDate)), dashboardName: \(String(describing: dashboardName)), projectId: \(String(describing: projectId)))"}
}

extension DescribeDashboardOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDashboardOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dashboardArn = output.dashboardArn
            self.dashboardCreationDate = output.dashboardCreationDate
            self.dashboardDefinition = output.dashboardDefinition
            self.dashboardDescription = output.dashboardDescription
            self.dashboardId = output.dashboardId
            self.dashboardLastUpdateDate = output.dashboardLastUpdateDate
            self.dashboardName = output.dashboardName
            self.projectId = output.projectId
        } else {
            self.dashboardArn = nil
            self.dashboardCreationDate = nil
            self.dashboardDefinition = nil
            self.dashboardDescription = nil
            self.dashboardId = nil
            self.dashboardLastUpdateDate = nil
            self.dashboardName = nil
            self.projectId = nil
        }
    }
}

public struct DescribeDashboardOutputResponse: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the dashboard, which has the following format.</p>
    ///         <p>
    ///             <code>arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId}</code>
    ///          </p>
    public let dashboardArn: String?
    /// <p>The date the dashboard was created, in Unix epoch time.</p>
    public let dashboardCreationDate: Date?
    /// <p>The dashboard's definition JSON literal. For detailed information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html">Creating
    ///         dashboards (CLI)</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let dashboardDefinition: String?
    /// <p>The dashboard's description.</p>
    public let dashboardDescription: String?
    /// <p>The ID of the dashboard.</p>
    public let dashboardId: String?
    /// <p>The date the dashboard was last updated, in Unix epoch time.</p>
    public let dashboardLastUpdateDate: Date?
    /// <p>The name of the dashboard.</p>
    public let dashboardName: String?
    /// <p>The ID of the project that the dashboard is in.</p>
    public let projectId: String?

    public init (
        dashboardArn: String? = nil,
        dashboardCreationDate: Date? = nil,
        dashboardDefinition: String? = nil,
        dashboardDescription: String? = nil,
        dashboardId: String? = nil,
        dashboardLastUpdateDate: Date? = nil,
        dashboardName: String? = nil,
        projectId: String? = nil
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardCreationDate = dashboardCreationDate
        self.dashboardDefinition = dashboardDefinition
        self.dashboardDescription = dashboardDescription
        self.dashboardId = dashboardId
        self.dashboardLastUpdateDate = dashboardLastUpdateDate
        self.dashboardName = dashboardName
        self.projectId = projectId
    }
}

struct DescribeDashboardOutputResponseBody: Equatable {
    public let dashboardId: String?
    public let dashboardArn: String?
    public let dashboardName: String?
    public let projectId: String?
    public let dashboardDescription: String?
    public let dashboardDefinition: String?
    public let dashboardCreationDate: Date?
    public let dashboardLastUpdateDate: Date?
}

extension DescribeDashboardOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dashboardArn
        case dashboardCreationDate
        case dashboardDefinition
        case dashboardDescription
        case dashboardId
        case dashboardLastUpdateDate
        case dashboardName
        case projectId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let dashboardArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardArn)
        dashboardArn = dashboardArnDecoded
        let dashboardNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardName)
        dashboardName = dashboardNameDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let dashboardDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardDescription)
        dashboardDescription = dashboardDescriptionDecoded
        let dashboardDefinitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardDefinition)
        dashboardDefinition = dashboardDefinitionDecoded
        let dashboardCreationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .dashboardCreationDate)
        dashboardCreationDate = dashboardCreationDateDecoded
        let dashboardLastUpdateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .dashboardLastUpdateDate)
        dashboardLastUpdateDate = dashboardLastUpdateDateDecoded
    }
}

extension DescribeDefaultEncryptionConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDefaultEncryptionConfigurationInput()"}
}

extension DescribeDefaultEncryptionConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDefaultEncryptionConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDefaultEncryptionConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDefaultEncryptionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDefaultEncryptionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDefaultEncryptionConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeDefaultEncryptionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDefaultEncryptionConfigurationOutputError>
}

public struct DescribeDefaultEncryptionConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDefaultEncryptionConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDefaultEncryptionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDefaultEncryptionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDefaultEncryptionConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeDefaultEncryptionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDefaultEncryptionConfigurationOutputError>
}

public struct DescribeDefaultEncryptionConfigurationInput: Equatable {

    public init() {}
}

struct DescribeDefaultEncryptionConfigurationInputBody: Equatable {
}

extension DescribeDefaultEncryptionConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDefaultEncryptionConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDefaultEncryptionConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDefaultEncryptionConfigurationOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDefaultEncryptionConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDefaultEncryptionConfigurationOutputResponse(configurationStatus: \(String(describing: configurationStatus)), encryptionType: \(String(describing: encryptionType)), kmsKeyArn: \(String(describing: kmsKeyArn)))"}
}

extension DescribeDefaultEncryptionConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDefaultEncryptionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationStatus = output.configurationStatus
            self.encryptionType = output.encryptionType
            self.kmsKeyArn = output.kmsKeyArn
        } else {
            self.configurationStatus = nil
            self.encryptionType = nil
            self.kmsKeyArn = nil
        }
    }
}

public struct DescribeDefaultEncryptionConfigurationOutputResponse: Equatable {
    /// <p>The status of the account configuration. This contains the
    ///       <code>ConfigurationState</code>. If
    ///       there's an error, it also contains the <code>ErrorDetails</code>.</p>
    public let configurationStatus: ConfigurationStatus?
    /// <p>The type of encryption used for the encryption configuration.</p>
    public let encryptionType: EncryptionType?
    /// <p>The key ARN of the customer managed customer master key (CMK) used for AWS KMS encryption
    ///       if you use <code>KMS_BASED_ENCRYPTION</code>.</p>
    public let kmsKeyArn: String?

    public init (
        configurationStatus: ConfigurationStatus? = nil,
        encryptionType: EncryptionType? = nil,
        kmsKeyArn: String? = nil
    )
    {
        self.configurationStatus = configurationStatus
        self.encryptionType = encryptionType
        self.kmsKeyArn = kmsKeyArn
    }
}

struct DescribeDefaultEncryptionConfigurationOutputResponseBody: Equatable {
    public let encryptionType: EncryptionType?
    public let kmsKeyArn: String?
    public let configurationStatus: ConfigurationStatus?
}

extension DescribeDefaultEncryptionConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationStatus
        case encryptionType
        case kmsKeyArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let configurationStatusDecoded = try containerValues.decodeIfPresent(ConfigurationStatus.self, forKey: .configurationStatus)
        configurationStatus = configurationStatusDecoded
    }
}

extension DescribeGatewayCapabilityConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGatewayCapabilityConfigurationInput(capabilityNamespace: \(String(describing: capabilityNamespace)), gatewayId: \(String(describing: gatewayId)))"}
}

extension DescribeGatewayCapabilityConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeGatewayCapabilityConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeGatewayCapabilityConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGatewayCapabilityConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGatewayCapabilityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGatewayCapabilityConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeGatewayCapabilityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGatewayCapabilityConfigurationOutputError>
}

public struct DescribeGatewayCapabilityConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeGatewayCapabilityConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGatewayCapabilityConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGatewayCapabilityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGatewayCapabilityConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeGatewayCapabilityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGatewayCapabilityConfigurationOutputError>
}

public struct DescribeGatewayCapabilityConfigurationInput: Equatable {
    /// <p>The namespace of the capability configuration.
    ///       For example, if you configure OPC-UA
    ///       sources from the AWS IoT SiteWise console, your OPC-UA capability configuration has the namespace
    ///         <code>iotsitewise:opcuacollector:version</code>, where <code>version</code> is a number such as
    ///         <code>1</code>.</p>
    public let capabilityNamespace: String?
    /// <p>The ID of the gateway that defines the capability configuration.</p>
    public let gatewayId: String?

    public init (
        capabilityNamespace: String? = nil,
        gatewayId: String? = nil
    )
    {
        self.capabilityNamespace = capabilityNamespace
        self.gatewayId = gatewayId
    }
}

struct DescribeGatewayCapabilityConfigurationInputBody: Equatable {
}

extension DescribeGatewayCapabilityConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeGatewayCapabilityConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGatewayCapabilityConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGatewayCapabilityConfigurationOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGatewayCapabilityConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGatewayCapabilityConfigurationOutputResponse(capabilityConfiguration: \(String(describing: capabilityConfiguration)), capabilityNamespace: \(String(describing: capabilityNamespace)), capabilitySyncStatus: \(String(describing: capabilitySyncStatus)), gatewayId: \(String(describing: gatewayId)))"}
}

extension DescribeGatewayCapabilityConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeGatewayCapabilityConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.capabilityConfiguration = output.capabilityConfiguration
            self.capabilityNamespace = output.capabilityNamespace
            self.capabilitySyncStatus = output.capabilitySyncStatus
            self.gatewayId = output.gatewayId
        } else {
            self.capabilityConfiguration = nil
            self.capabilityNamespace = nil
            self.capabilitySyncStatus = nil
            self.gatewayId = nil
        }
    }
}

public struct DescribeGatewayCapabilityConfigurationOutputResponse: Equatable {
    /// <p>The JSON document that defines the gateway capability's configuration. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/configure-sources.html#configure-source-cli">Configuring data sources (CLI)</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let capabilityConfiguration: String?
    /// <p>The namespace of the gateway capability.</p>
    public let capabilityNamespace: String?
    /// <p>The synchronization status of the capability configuration. The sync status can be one of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>IN_SYNC</code> – The gateway is running the capability configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OUT_OF_SYNC</code> – The gateway hasn't received the capability configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SYNC_FAILED</code> – The gateway rejected the capability configuration.</p>
    ///             </li>
    ///          </ul>
    public let capabilitySyncStatus: CapabilitySyncStatus?
    /// <p>The ID of the gateway that defines the capability configuration.</p>
    public let gatewayId: String?

    public init (
        capabilityConfiguration: String? = nil,
        capabilityNamespace: String? = nil,
        capabilitySyncStatus: CapabilitySyncStatus? = nil,
        gatewayId: String? = nil
    )
    {
        self.capabilityConfiguration = capabilityConfiguration
        self.capabilityNamespace = capabilityNamespace
        self.capabilitySyncStatus = capabilitySyncStatus
        self.gatewayId = gatewayId
    }
}

struct DescribeGatewayCapabilityConfigurationOutputResponseBody: Equatable {
    public let gatewayId: String?
    public let capabilityNamespace: String?
    public let capabilityConfiguration: String?
    public let capabilitySyncStatus: CapabilitySyncStatus?
}

extension DescribeGatewayCapabilityConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case capabilityConfiguration
        case capabilityNamespace
        case capabilitySyncStatus
        case gatewayId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let capabilityNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .capabilityNamespace)
        capabilityNamespace = capabilityNamespaceDecoded
        let capabilityConfigurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .capabilityConfiguration)
        capabilityConfiguration = capabilityConfigurationDecoded
        let capabilitySyncStatusDecoded = try containerValues.decodeIfPresent(CapabilitySyncStatus.self, forKey: .capabilitySyncStatus)
        capabilitySyncStatus = capabilitySyncStatusDecoded
    }
}

extension DescribeGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGatewayInput(gatewayId: \(String(describing: gatewayId)))"}
}

extension DescribeGatewayInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGatewayInput>
    public typealias MOutput = OperationOutput<DescribeGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGatewayOutputError>
}

public struct DescribeGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGatewayInput>
    public typealias MOutput = OperationOutput<DescribeGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGatewayOutputError>
}

public struct DescribeGatewayInput: Equatable {
    /// <p>The ID of the gateway device.</p>
    public let gatewayId: String?

    public init (
        gatewayId: String? = nil
    )
    {
        self.gatewayId = gatewayId
    }
}

struct DescribeGatewayInputBody: Equatable {
}

extension DescribeGatewayInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGatewayOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGatewayOutputResponse(creationDate: \(String(describing: creationDate)), gatewayArn: \(String(describing: gatewayArn)), gatewayCapabilitySummaries: \(String(describing: gatewayCapabilitySummaries)), gatewayId: \(String(describing: gatewayId)), gatewayName: \(String(describing: gatewayName)), gatewayPlatform: \(String(describing: gatewayPlatform)), lastUpdateDate: \(String(describing: lastUpdateDate)))"}
}

extension DescribeGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeGatewayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDate = output.creationDate
            self.gatewayArn = output.gatewayArn
            self.gatewayCapabilitySummaries = output.gatewayCapabilitySummaries
            self.gatewayId = output.gatewayId
            self.gatewayName = output.gatewayName
            self.gatewayPlatform = output.gatewayPlatform
            self.lastUpdateDate = output.lastUpdateDate
        } else {
            self.creationDate = nil
            self.gatewayArn = nil
            self.gatewayCapabilitySummaries = nil
            self.gatewayId = nil
            self.gatewayName = nil
            self.gatewayPlatform = nil
            self.lastUpdateDate = nil
        }
    }
}

public struct DescribeGatewayOutputResponse: Equatable {
    /// <p>The date the gateway was created, in Unix epoch time.</p>
    public let creationDate: Date?
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the gateway, which has the following format.</p>
    ///         <p>
    ///             <code>arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId}</code>
    ///          </p>
    public let gatewayArn: String?
    /// <p>A list of gateway capability summaries that each contain a namespace and status. Each
    ///       gateway capability defines data sources for the gateway. To retrieve a capability
    ///       configuration's definition, use <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeGatewayCapabilityConfiguration.html">DescribeGatewayCapabilityConfiguration</a>.</p>
    public let gatewayCapabilitySummaries: [GatewayCapabilitySummary]?
    /// <p>The ID of the gateway device.</p>
    public let gatewayId: String?
    /// <p>The name of the gateway.</p>
    public let gatewayName: String?
    /// <p>The gateway's platform.</p>
    public let gatewayPlatform: GatewayPlatform?
    /// <p>The date the gateway was last updated, in Unix epoch time.</p>
    public let lastUpdateDate: Date?

    public init (
        creationDate: Date? = nil,
        gatewayArn: String? = nil,
        gatewayCapabilitySummaries: [GatewayCapabilitySummary]? = nil,
        gatewayId: String? = nil,
        gatewayName: String? = nil,
        gatewayPlatform: GatewayPlatform? = nil,
        lastUpdateDate: Date? = nil
    )
    {
        self.creationDate = creationDate
        self.gatewayArn = gatewayArn
        self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
        self.gatewayId = gatewayId
        self.gatewayName = gatewayName
        self.gatewayPlatform = gatewayPlatform
        self.lastUpdateDate = lastUpdateDate
    }
}

struct DescribeGatewayOutputResponseBody: Equatable {
    public let gatewayId: String?
    public let gatewayName: String?
    public let gatewayArn: String?
    public let gatewayPlatform: GatewayPlatform?
    public let gatewayCapabilitySummaries: [GatewayCapabilitySummary]?
    public let creationDate: Date?
    public let lastUpdateDate: Date?
}

extension DescribeGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case gatewayArn
        case gatewayCapabilitySummaries
        case gatewayId
        case gatewayName
        case gatewayPlatform
        case lastUpdateDate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let gatewayPlatformDecoded = try containerValues.decodeIfPresent(GatewayPlatform.self, forKey: .gatewayPlatform)
        gatewayPlatform = gatewayPlatformDecoded
        let gatewayCapabilitySummariesContainer = try containerValues.decodeIfPresent([GatewayCapabilitySummary?].self, forKey: .gatewayCapabilitySummaries)
        var gatewayCapabilitySummariesDecoded0:[GatewayCapabilitySummary]? = nil
        if let gatewayCapabilitySummariesContainer = gatewayCapabilitySummariesContainer {
            gatewayCapabilitySummariesDecoded0 = [GatewayCapabilitySummary]()
            for structure0 in gatewayCapabilitySummariesContainer {
                if let structure0 = structure0 {
                    gatewayCapabilitySummariesDecoded0?.append(structure0)
                }
            }
        }
        gatewayCapabilitySummaries = gatewayCapabilitySummariesDecoded0
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension DescribeLoggingOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoggingOptionsInput()"}
}

extension DescribeLoggingOptionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeLoggingOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLoggingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoggingOptionsInput>
    public typealias MOutput = OperationOutput<DescribeLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoggingOptionsOutputError>
}

public struct DescribeLoggingOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLoggingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoggingOptionsInput>
    public typealias MOutput = OperationOutput<DescribeLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoggingOptionsOutputError>
}

public struct DescribeLoggingOptionsInput: Equatable {

    public init() {}
}

struct DescribeLoggingOptionsInputBody: Equatable {
}

extension DescribeLoggingOptionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeLoggingOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLoggingOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoggingOptionsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoggingOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoggingOptionsOutputResponse(loggingOptions: \(String(describing: loggingOptions)))"}
}

extension DescribeLoggingOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeLoggingOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loggingOptions = output.loggingOptions
        } else {
            self.loggingOptions = nil
        }
    }
}

public struct DescribeLoggingOptionsOutputResponse: Equatable {
    /// <p>The current logging options.</p>
    public let loggingOptions: LoggingOptions?

    public init (
        loggingOptions: LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

struct DescribeLoggingOptionsOutputResponseBody: Equatable {
    public let loggingOptions: LoggingOptions?
}

extension DescribeLoggingOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loggingOptions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsDecoded = try containerValues.decodeIfPresent(LoggingOptions.self, forKey: .loggingOptions)
        loggingOptions = loggingOptionsDecoded
    }
}

extension DescribePortalInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePortalInput(portalId: \(String(describing: portalId)))"}
}

extension DescribePortalInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribePortalInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePortalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePortalInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePortalInput>
    public typealias MOutput = OperationOutput<DescribePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePortalOutputError>
}

public struct DescribePortalInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePortalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePortalInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePortalInput>
    public typealias MOutput = OperationOutput<DescribePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePortalOutputError>
}

public struct DescribePortalInput: Equatable {
    /// <p>The ID of the portal.</p>
    public let portalId: String?

    public init (
        portalId: String? = nil
    )
    {
        self.portalId = portalId
    }
}

struct DescribePortalInputBody: Equatable {
}

extension DescribePortalInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribePortalOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePortalOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePortalOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePortalOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePortalOutputResponse(alarms: \(String(describing: alarms)), notificationSenderEmail: \(String(describing: notificationSenderEmail)), portalArn: \(String(describing: portalArn)), portalAuthMode: \(String(describing: portalAuthMode)), portalClientId: \(String(describing: portalClientId)), portalContactEmail: \(String(describing: portalContactEmail)), portalCreationDate: \(String(describing: portalCreationDate)), portalDescription: \(String(describing: portalDescription)), portalId: \(String(describing: portalId)), portalLastUpdateDate: \(String(describing: portalLastUpdateDate)), portalLogoImageLocation: \(String(describing: portalLogoImageLocation)), portalName: \(String(describing: portalName)), portalStartUrl: \(String(describing: portalStartUrl)), portalStatus: \(String(describing: portalStatus)), roleArn: \(String(describing: roleArn)))"}
}

extension DescribePortalOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePortalOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.alarms = output.alarms
            self.notificationSenderEmail = output.notificationSenderEmail
            self.portalArn = output.portalArn
            self.portalAuthMode = output.portalAuthMode
            self.portalClientId = output.portalClientId
            self.portalContactEmail = output.portalContactEmail
            self.portalCreationDate = output.portalCreationDate
            self.portalDescription = output.portalDescription
            self.portalId = output.portalId
            self.portalLastUpdateDate = output.portalLastUpdateDate
            self.portalLogoImageLocation = output.portalLogoImageLocation
            self.portalName = output.portalName
            self.portalStartUrl = output.portalStartUrl
            self.portalStatus = output.portalStatus
            self.roleArn = output.roleArn
        } else {
            self.alarms = nil
            self.notificationSenderEmail = nil
            self.portalArn = nil
            self.portalAuthMode = nil
            self.portalClientId = nil
            self.portalContactEmail = nil
            self.portalCreationDate = nil
            self.portalDescription = nil
            self.portalId = nil
            self.portalLastUpdateDate = nil
            self.portalLogoImageLocation = nil
            self.portalName = nil
            self.portalStartUrl = nil
            self.portalStatus = nil
            self.roleArn = nil
        }
    }
}

public struct DescribePortalOutputResponse: Equatable {
    /// <p>Contains the configuration information of an alarm created in a AWS IoT SiteWise Monitor portal.</p>
    public let alarms: Alarms?
    /// <p>The email address that sends alarm notifications.</p>
    public let notificationSenderEmail: String?
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the portal, which has the following format.</p>
    ///         <p>
    ///             <code>arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId}</code>
    ///          </p>
    public let portalArn: String?
    /// <p>The service to use to authenticate users to the portal.</p>
    public let portalAuthMode: AuthMode?
    /// <p>The AWS SSO application generated client ID (used with AWS SSO APIs). AWS IoT SiteWise includes
    ///         <code>portalClientId</code> for only portals that use AWS SSO to authenticate users.</p>
    public let portalClientId: String?
    /// <p>The AWS administrator's contact email address.</p>
    public let portalContactEmail: String?
    /// <p>The date the portal was created, in Unix epoch time.</p>
    public let portalCreationDate: Date?
    /// <p>The portal's description.</p>
    public let portalDescription: String?
    /// <p>The ID of the portal.</p>
    public let portalId: String?
    /// <p>The date the portal was last updated, in Unix epoch time.</p>
    public let portalLastUpdateDate: Date?
    /// <p>The portal's logo image, which is available at a URL.</p>
    public let portalLogoImageLocation: ImageLocation?
    /// <p>The name of the portal.</p>
    public let portalName: String?
    /// <p>The URL for the AWS IoT SiteWise Monitor portal. You can use this URL to access portals that
    ///       use AWS SSO for authentication. For portals that use IAM for authentication, you must use the
    ///       AWS IoT SiteWise console to get a URL that you can use to access the portal.</p>
    public let portalStartUrl: String?
    /// <p>The current status of the portal, which contains a state and any error message.</p>
    public let portalStatus: PortalStatus?
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the service role that allows the portal's users to access your AWS IoT SiteWise
    ///       resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for AWS IoT SiteWise Monitor</a> in the
    ///         <i>AWS IoT SiteWise User Guide</i>.</p>
    public let roleArn: String?

    public init (
        alarms: Alarms? = nil,
        notificationSenderEmail: String? = nil,
        portalArn: String? = nil,
        portalAuthMode: AuthMode? = nil,
        portalClientId: String? = nil,
        portalContactEmail: String? = nil,
        portalCreationDate: Date? = nil,
        portalDescription: String? = nil,
        portalId: String? = nil,
        portalLastUpdateDate: Date? = nil,
        portalLogoImageLocation: ImageLocation? = nil,
        portalName: String? = nil,
        portalStartUrl: String? = nil,
        portalStatus: PortalStatus? = nil,
        roleArn: String? = nil
    )
    {
        self.alarms = alarms
        self.notificationSenderEmail = notificationSenderEmail
        self.portalArn = portalArn
        self.portalAuthMode = portalAuthMode
        self.portalClientId = portalClientId
        self.portalContactEmail = portalContactEmail
        self.portalCreationDate = portalCreationDate
        self.portalDescription = portalDescription
        self.portalId = portalId
        self.portalLastUpdateDate = portalLastUpdateDate
        self.portalLogoImageLocation = portalLogoImageLocation
        self.portalName = portalName
        self.portalStartUrl = portalStartUrl
        self.portalStatus = portalStatus
        self.roleArn = roleArn
    }
}

struct DescribePortalOutputResponseBody: Equatable {
    public let portalId: String?
    public let portalArn: String?
    public let portalName: String?
    public let portalDescription: String?
    public let portalClientId: String?
    public let portalStartUrl: String?
    public let portalContactEmail: String?
    public let portalStatus: PortalStatus?
    public let portalCreationDate: Date?
    public let portalLastUpdateDate: Date?
    public let portalLogoImageLocation: ImageLocation?
    public let roleArn: String?
    public let portalAuthMode: AuthMode?
    public let notificationSenderEmail: String?
    public let alarms: Alarms?
}

extension DescribePortalOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alarms
        case notificationSenderEmail
        case portalArn
        case portalAuthMode
        case portalClientId
        case portalContactEmail
        case portalCreationDate
        case portalDescription
        case portalId
        case portalLastUpdateDate
        case portalLogoImageLocation
        case portalName
        case portalStartUrl
        case portalStatus
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portalId)
        portalId = portalIdDecoded
        let portalArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let portalNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portalName)
        portalName = portalNameDecoded
        let portalDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portalDescription)
        portalDescription = portalDescriptionDecoded
        let portalClientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portalClientId)
        portalClientId = portalClientIdDecoded
        let portalStartUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portalStartUrl)
        portalStartUrl = portalStartUrlDecoded
        let portalContactEmailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portalContactEmail)
        portalContactEmail = portalContactEmailDecoded
        let portalStatusDecoded = try containerValues.decodeIfPresent(PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
        let portalCreationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .portalCreationDate)
        portalCreationDate = portalCreationDateDecoded
        let portalLastUpdateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .portalLastUpdateDate)
        portalLastUpdateDate = portalLastUpdateDateDecoded
        let portalLogoImageLocationDecoded = try containerValues.decodeIfPresent(ImageLocation.self, forKey: .portalLogoImageLocation)
        portalLogoImageLocation = portalLogoImageLocationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let portalAuthModeDecoded = try containerValues.decodeIfPresent(AuthMode.self, forKey: .portalAuthMode)
        portalAuthMode = portalAuthModeDecoded
        let notificationSenderEmailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notificationSenderEmail)
        notificationSenderEmail = notificationSenderEmailDecoded
        let alarmsDecoded = try containerValues.decodeIfPresent(Alarms.self, forKey: .alarms)
        alarms = alarmsDecoded
    }
}

extension DescribeProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProjectInput(projectId: \(String(describing: projectId)))"}
}

extension DescribeProjectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeProjectInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInput: Equatable {
    /// <p>The ID of the project.</p>
    public let projectId: String?

    public init (
        projectId: String? = nil
    )
    {
        self.projectId = projectId
    }
}

struct DescribeProjectInputBody: Equatable {
}

extension DescribeProjectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProjectOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProjectOutputResponse(portalId: \(String(describing: portalId)), projectArn: \(String(describing: projectArn)), projectCreationDate: \(String(describing: projectCreationDate)), projectDescription: \(String(describing: projectDescription)), projectId: \(String(describing: projectId)), projectLastUpdateDate: \(String(describing: projectLastUpdateDate)), projectName: \(String(describing: projectName)))"}
}

extension DescribeProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.portalId = output.portalId
            self.projectArn = output.projectArn
            self.projectCreationDate = output.projectCreationDate
            self.projectDescription = output.projectDescription
            self.projectId = output.projectId
            self.projectLastUpdateDate = output.projectLastUpdateDate
            self.projectName = output.projectName
        } else {
            self.portalId = nil
            self.projectArn = nil
            self.projectCreationDate = nil
            self.projectDescription = nil
            self.projectId = nil
            self.projectLastUpdateDate = nil
            self.projectName = nil
        }
    }
}

public struct DescribeProjectOutputResponse: Equatable {
    /// <p>The ID of the portal that the project is in.</p>
    public let portalId: String?
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the project, which has the following format.</p>
    ///         <p>
    ///             <code>arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId}</code>
    ///          </p>
    public let projectArn: String?
    /// <p>The date the project was created, in Unix epoch time.</p>
    public let projectCreationDate: Date?
    /// <p>The project's description.</p>
    public let projectDescription: String?
    /// <p>The ID of the project.</p>
    public let projectId: String?
    /// <p>The date the project was last updated, in Unix epoch time.</p>
    public let projectLastUpdateDate: Date?
    /// <p>The name of the project.</p>
    public let projectName: String?

    public init (
        portalId: String? = nil,
        projectArn: String? = nil,
        projectCreationDate: Date? = nil,
        projectDescription: String? = nil,
        projectId: String? = nil,
        projectLastUpdateDate: Date? = nil,
        projectName: String? = nil
    )
    {
        self.portalId = portalId
        self.projectArn = projectArn
        self.projectCreationDate = projectCreationDate
        self.projectDescription = projectDescription
        self.projectId = projectId
        self.projectLastUpdateDate = projectLastUpdateDate
        self.projectName = projectName
    }
}

struct DescribeProjectOutputResponseBody: Equatable {
    public let projectId: String?
    public let projectArn: String?
    public let projectName: String?
    public let portalId: String?
    public let projectDescription: String?
    public let projectCreationDate: Date?
    public let projectLastUpdateDate: Date?
}

extension DescribeProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case portalId
        case projectArn
        case projectCreationDate
        case projectDescription
        case projectId
        case projectLastUpdateDate
        case projectName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let projectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let portalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portalId)
        portalId = portalIdDecoded
        let projectDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectDescription)
        projectDescription = projectDescriptionDecoded
        let projectCreationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .projectCreationDate)
        projectCreationDate = projectCreationDateDecoded
        let projectLastUpdateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .projectLastUpdateDate)
        projectLastUpdateDate = projectLastUpdateDateDecoded
    }
}

public struct DisassociateAssetsInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateAssetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateAssetsInput>
    public typealias MOutput = OperationOutput<DisassociateAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateAssetsOutputError>
}

extension DisassociateAssetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateAssetsInput(assetId: \(String(describing: assetId)), childAssetId: \(String(describing: childAssetId)), clientToken: \(String(describing: clientToken)), hierarchyId: \(String(describing: hierarchyId)))"}
}

extension DisassociateAssetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case childAssetId
        case clientToken
        case hierarchyId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetId = childAssetId {
            try encodeContainer.encode(childAssetId, forKey: .childAssetId)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let hierarchyId = hierarchyId {
            try encodeContainer.encode(hierarchyId, forKey: .hierarchyId)
        }
    }
}

public struct DisassociateAssetsInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateAssetsInput>
    public typealias MOutput = OperationOutput<DisassociateAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateAssetsOutputError>
}

public struct DisassociateAssetsInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateAssetsInput>
    public typealias MOutput = OperationOutput<DisassociateAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateAssetsOutputError>
}

public struct DisassociateAssetsInput: Equatable {
    /// <p>The ID of the parent asset from which to disassociate the child asset.</p>
    public let assetId: String?
    /// <p>The ID of the child asset to disassociate.</p>
    public let childAssetId: String?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?
    /// <p>The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings
    ///       of assets to be formed that all come from the same asset model. You can use the hierarchy ID
    ///       to identify the correct asset to disassociate. For more information, see
    ///       <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let hierarchyId: String?

    public init (
        assetId: String? = nil,
        childAssetId: String? = nil,
        clientToken: String? = nil,
        hierarchyId: String? = nil
    )
    {
        self.assetId = assetId
        self.childAssetId = childAssetId
        self.clientToken = clientToken
        self.hierarchyId = hierarchyId
    }
}

struct DisassociateAssetsInputBody: Equatable {
    public let hierarchyId: String?
    public let childAssetId: String?
    public let clientToken: String?
}

extension DisassociateAssetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case childAssetId
        case clientToken
        case hierarchyId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hierarchyId)
        hierarchyId = hierarchyIdDecoded
        let childAssetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .childAssetId)
        childAssetId = childAssetIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateAssetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateAssetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateAssetsOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateAssetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateAssetsOutputResponse()"}
}

extension DisassociateAssetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateAssetsOutputResponse: Equatable {

    public init() {}
}

struct DisassociateAssetsOutputResponseBody: Equatable {
}

extension DisassociateAssetsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum EncryptionType {
    case kmsBasedEncryption
    case sitewiseDefaultEncryption
    case sdkUnknown(String)
}

extension EncryptionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncryptionType] {
        return [
            .kmsBasedEncryption,
            .sitewiseDefaultEncryption,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .kmsBasedEncryption: return "KMS_BASED_ENCRYPTION"
        case .sitewiseDefaultEncryption: return "SITEWISE_DEFAULT_ENCRYPTION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
    }
}

public enum ErrorCode {
    case internalFailure
    case validationError
    case sdkUnknown(String)
}

extension ErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ErrorCode] {
        return [
            .internalFailure,
            .validationError,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .internalFailure: return "INTERNAL_FAILURE"
        case .validationError: return "VALIDATION_ERROR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
    }
}

extension ErrorDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ErrorDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorDetails(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

/// <p>Contains the details of an AWS IoT SiteWise error.</p>
public struct ErrorDetails: Equatable {
    /// <p>The error code.</p>
    public let code: ErrorCode?
    /// <p>The error message.</p>
    public let message: String?

    public init (
        code: ErrorCode? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

extension ExpressionVariable: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(VariableValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension ExpressionVariable: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExpressionVariable(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Contains expression variable information.</p>
public struct ExpressionVariable: Equatable {
    /// <p>The friendly name of the variable to be used in the expression.</p>
    public let name: String?
    /// <p>The variable that identifies an asset property from which to use values.</p>
    public let value: VariableValue?

    public init (
        name: String? = nil,
        value: VariableValue? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension GatewayCapabilitySummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case capabilityNamespace
        case capabilitySyncStatus
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilityNamespace = capabilityNamespace {
            try encodeContainer.encode(capabilityNamespace, forKey: .capabilityNamespace)
        }
        if let capabilitySyncStatus = capabilitySyncStatus {
            try encodeContainer.encode(capabilitySyncStatus.rawValue, forKey: .capabilitySyncStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilityNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .capabilityNamespace)
        capabilityNamespace = capabilityNamespaceDecoded
        let capabilitySyncStatusDecoded = try containerValues.decodeIfPresent(CapabilitySyncStatus.self, forKey: .capabilitySyncStatus)
        capabilitySyncStatus = capabilitySyncStatusDecoded
    }
}

extension GatewayCapabilitySummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GatewayCapabilitySummary(capabilityNamespace: \(String(describing: capabilityNamespace)), capabilitySyncStatus: \(String(describing: capabilitySyncStatus)))"}
}

/// <p>Contains a summary of a gateway capability configuration.</p>
public struct GatewayCapabilitySummary: Equatable {
    /// <p>The namespace of the capability configuration.
    ///       For example, if you configure OPC-UA
    ///       sources from the AWS IoT SiteWise console, your OPC-UA capability configuration has the namespace
    ///         <code>iotsitewise:opcuacollector:version</code>, where <code>version</code> is a number such as
    ///         <code>1</code>.</p>
    public let capabilityNamespace: String?
    /// <p>The synchronization status of the capability configuration. The sync status can be one of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>IN_SYNC</code> – The gateway is running the capability configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OUT_OF_SYNC</code> – The gateway hasn't received the capability configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SYNC_FAILED</code> – The gateway rejected the capability configuration.</p>
    ///             </li>
    ///          </ul>
    public let capabilitySyncStatus: CapabilitySyncStatus?

    public init (
        capabilityNamespace: String? = nil,
        capabilitySyncStatus: CapabilitySyncStatus? = nil
    )
    {
        self.capabilityNamespace = capabilityNamespace
        self.capabilitySyncStatus = capabilitySyncStatus
    }
}

extension GatewayPlatform: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case greengrass
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let greengrass = greengrass {
            try encodeContainer.encode(greengrass, forKey: .greengrass)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let greengrassDecoded = try containerValues.decodeIfPresent(Greengrass.self, forKey: .greengrass)
        greengrass = greengrassDecoded
    }
}

extension GatewayPlatform: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GatewayPlatform(greengrass: \(String(describing: greengrass)))"}
}

/// <p>Contains a gateway's platform information.</p>
public struct GatewayPlatform: Equatable {
    /// <p>A gateway that runs on AWS IoT Greengrass.</p>
    public let greengrass: Greengrass?

    public init (
        greengrass: Greengrass? = nil
    )
    {
        self.greengrass = greengrass
    }
}

extension GatewaySummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case gatewayCapabilitySummaries
        case gatewayId
        case gatewayName
        case lastUpdateDate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let gatewayCapabilitySummaries = gatewayCapabilitySummaries {
            var gatewayCapabilitySummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .gatewayCapabilitySummaries)
            for gatewaycapabilitysummaries0 in gatewayCapabilitySummaries {
                try gatewayCapabilitySummariesContainer.encode(gatewaycapabilitysummaries0)
            }
        }
        if let gatewayId = gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let gatewayName = gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
        if let lastUpdateDate = lastUpdateDate {
            try encodeContainer.encode(lastUpdateDate.timeIntervalSince1970, forKey: .lastUpdateDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayCapabilitySummariesContainer = try containerValues.decodeIfPresent([GatewayCapabilitySummary?].self, forKey: .gatewayCapabilitySummaries)
        var gatewayCapabilitySummariesDecoded0:[GatewayCapabilitySummary]? = nil
        if let gatewayCapabilitySummariesContainer = gatewayCapabilitySummariesContainer {
            gatewayCapabilitySummariesDecoded0 = [GatewayCapabilitySummary]()
            for structure0 in gatewayCapabilitySummariesContainer {
                if let structure0 = structure0 {
                    gatewayCapabilitySummariesDecoded0?.append(structure0)
                }
            }
        }
        gatewayCapabilitySummaries = gatewayCapabilitySummariesDecoded0
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension GatewaySummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GatewaySummary(creationDate: \(String(describing: creationDate)), gatewayCapabilitySummaries: \(String(describing: gatewayCapabilitySummaries)), gatewayId: \(String(describing: gatewayId)), gatewayName: \(String(describing: gatewayName)), lastUpdateDate: \(String(describing: lastUpdateDate)))"}
}

/// <p>Contains a summary of a gateway.</p>
public struct GatewaySummary: Equatable {
    /// <p>The date the gateway was created, in Unix epoch time.</p>
    public let creationDate: Date?
    /// <p>A list of gateway capability summaries that each contain a namespace and status. Each
    ///       gateway capability defines data sources for the gateway. To retrieve a capability
    ///       configuration's definition, use <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeGatewayCapabilityConfiguration.html">DescribeGatewayCapabilityConfiguration</a>.</p>
    public let gatewayCapabilitySummaries: [GatewayCapabilitySummary]?
    /// <p>The ID of the gateway device.</p>
    public let gatewayId: String?
    /// <p>The name of the asset.</p>
    public let gatewayName: String?
    /// <p>The date the gateway was last updated, in Unix epoch time.</p>
    public let lastUpdateDate: Date?

    public init (
        creationDate: Date? = nil,
        gatewayCapabilitySummaries: [GatewayCapabilitySummary]? = nil,
        gatewayId: String? = nil,
        gatewayName: String? = nil,
        lastUpdateDate: Date? = nil
    )
    {
        self.creationDate = creationDate
        self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
        self.gatewayId = gatewayId
        self.gatewayName = gatewayName
        self.lastUpdateDate = lastUpdateDate
    }
}

extension GetAssetPropertyAggregatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssetPropertyAggregatesInput(aggregateTypes: \(String(describing: aggregateTypes)), assetId: \(String(describing: assetId)), endDate: \(String(describing: endDate)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), propertyAlias: \(String(describing: propertyAlias)), propertyId: \(String(describing: propertyId)), qualities: \(String(describing: qualities)), resolution: \(String(describing: resolution)), startDate: \(String(describing: startDate)), timeOrdering: \(String(describing: timeOrdering)))"}
}

extension GetAssetPropertyAggregatesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAssetPropertyAggregatesInputHeadersMiddleware: Middleware {
    public let id: String = "GetAssetPropertyAggregatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssetPropertyAggregatesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssetPropertyAggregatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssetPropertyAggregatesInput>
    public typealias MOutput = OperationOutput<GetAssetPropertyAggregatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssetPropertyAggregatesOutputError>
}

public struct GetAssetPropertyAggregatesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAssetPropertyAggregatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssetPropertyAggregatesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssetPropertyAggregatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let aggregateTypes = input.operationInput.aggregateTypes {
            aggregateTypes.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "aggregateTypes".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let endDate = input.operationInput.endDate {
            let endDateQueryItem = URLQueryItem(name: "endDate".urlPercentEncoding(), value: String(endDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endDateQueryItem)
        }
        if let assetId = input.operationInput.assetId {
            let assetIdQueryItem = URLQueryItem(name: "assetId".urlPercentEncoding(), value: String(assetId).urlPercentEncoding())
            input.builder.withQueryItem(assetIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let propertyAlias = input.operationInput.propertyAlias {
            let propertyAliasQueryItem = URLQueryItem(name: "propertyAlias".urlPercentEncoding(), value: String(propertyAlias).urlPercentEncoding())
            input.builder.withQueryItem(propertyAliasQueryItem)
        }
        if let qualities = input.operationInput.qualities {
            qualities.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "qualities".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let timeOrdering = input.operationInput.timeOrdering {
            let timeOrderingQueryItem = URLQueryItem(name: "timeOrdering".urlPercentEncoding(), value: String(timeOrdering.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(timeOrderingQueryItem)
        }
        if let propertyId = input.operationInput.propertyId {
            let propertyIdQueryItem = URLQueryItem(name: "propertyId".urlPercentEncoding(), value: String(propertyId).urlPercentEncoding())
            input.builder.withQueryItem(propertyIdQueryItem)
        }
        if let resolution = input.operationInput.resolution {
            let resolutionQueryItem = URLQueryItem(name: "resolution".urlPercentEncoding(), value: String(resolution).urlPercentEncoding())
            input.builder.withQueryItem(resolutionQueryItem)
        }
        if let startDate = input.operationInput.startDate {
            let startDateQueryItem = URLQueryItem(name: "startDate".urlPercentEncoding(), value: String(startDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startDateQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssetPropertyAggregatesInput>
    public typealias MOutput = OperationOutput<GetAssetPropertyAggregatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssetPropertyAggregatesOutputError>
}

public struct GetAssetPropertyAggregatesInput: Equatable {
    /// <p>The data aggregating function.</p>
    public let aggregateTypes: [AggregateType]?
    /// <p>The ID of the asset.</p>
    public let assetId: String?
    /// <p>The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    public let endDate: Date?
    /// <p>The maximum number of results to be returned per paginated request.</p>
    ///          <p>Default: 100</p>
    public let maxResults: Int?
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?
    /// <p>The property alias that identifies the property, such as an OPC-UA server data stream path
    ///         (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the
    ///         <i>AWS IoT SiteWise User Guide</i>.</p>
    public let propertyAlias: String?
    /// <p>The ID of the asset property.</p>
    public let propertyId: String?
    /// <p>The quality by which to filter asset data.</p>
    public let qualities: [Quality]?
    /// <p>The time interval over which to aggregate data.</p>
    public let resolution: String?
    /// <p>The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    public let startDate: Date?
    /// <p>The chronological sorting order of the requested information.</p>
    ///          <p>Default: <code>ASCENDING</code>
    ///          </p>
    public let timeOrdering: TimeOrdering?

    public init (
        aggregateTypes: [AggregateType]? = nil,
        assetId: String? = nil,
        endDate: Date? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        propertyAlias: String? = nil,
        propertyId: String? = nil,
        qualities: [Quality]? = nil,
        resolution: String? = nil,
        startDate: Date? = nil,
        timeOrdering: TimeOrdering? = nil
    )
    {
        self.aggregateTypes = aggregateTypes
        self.assetId = assetId
        self.endDate = endDate
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.qualities = qualities
        self.resolution = resolution
        self.startDate = startDate
        self.timeOrdering = timeOrdering
    }
}

struct GetAssetPropertyAggregatesInputBody: Equatable {
}

extension GetAssetPropertyAggregatesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAssetPropertyAggregatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssetPropertyAggregatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssetPropertyAggregatesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssetPropertyAggregatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssetPropertyAggregatesOutputResponse(aggregatedValues: \(String(describing: aggregatedValues)), nextToken: \(String(describing: nextToken)))"}
}

extension GetAssetPropertyAggregatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAssetPropertyAggregatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aggregatedValues = output.aggregatedValues
            self.nextToken = output.nextToken
        } else {
            self.aggregatedValues = nil
            self.nextToken = nil
        }
    }
}

public struct GetAssetPropertyAggregatesOutputResponse: Equatable {
    /// <p>The requested aggregated values.</p>
    public let aggregatedValues: [AggregatedValue]?
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?

    public init (
        aggregatedValues: [AggregatedValue]? = nil,
        nextToken: String? = nil
    )
    {
        self.aggregatedValues = aggregatedValues
        self.nextToken = nextToken
    }
}

struct GetAssetPropertyAggregatesOutputResponseBody: Equatable {
    public let aggregatedValues: [AggregatedValue]?
    public let nextToken: String?
}

extension GetAssetPropertyAggregatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aggregatedValues
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregatedValuesContainer = try containerValues.decodeIfPresent([AggregatedValue?].self, forKey: .aggregatedValues)
        var aggregatedValuesDecoded0:[AggregatedValue]? = nil
        if let aggregatedValuesContainer = aggregatedValuesContainer {
            aggregatedValuesDecoded0 = [AggregatedValue]()
            for structure0 in aggregatedValuesContainer {
                if let structure0 = structure0 {
                    aggregatedValuesDecoded0?.append(structure0)
                }
            }
        }
        aggregatedValues = aggregatedValuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAssetPropertyValueHistoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssetPropertyValueHistoryInput(assetId: \(String(describing: assetId)), endDate: \(String(describing: endDate)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), propertyAlias: \(String(describing: propertyAlias)), propertyId: \(String(describing: propertyId)), qualities: \(String(describing: qualities)), startDate: \(String(describing: startDate)), timeOrdering: \(String(describing: timeOrdering)))"}
}

extension GetAssetPropertyValueHistoryInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAssetPropertyValueHistoryInputHeadersMiddleware: Middleware {
    public let id: String = "GetAssetPropertyValueHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssetPropertyValueHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssetPropertyValueHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssetPropertyValueHistoryInput>
    public typealias MOutput = OperationOutput<GetAssetPropertyValueHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssetPropertyValueHistoryOutputError>
}

public struct GetAssetPropertyValueHistoryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAssetPropertyValueHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssetPropertyValueHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssetPropertyValueHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let endDate = input.operationInput.endDate {
            let endDateQueryItem = URLQueryItem(name: "endDate".urlPercentEncoding(), value: String(endDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endDateQueryItem)
        }
        if let assetId = input.operationInput.assetId {
            let assetIdQueryItem = URLQueryItem(name: "assetId".urlPercentEncoding(), value: String(assetId).urlPercentEncoding())
            input.builder.withQueryItem(assetIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let propertyAlias = input.operationInput.propertyAlias {
            let propertyAliasQueryItem = URLQueryItem(name: "propertyAlias".urlPercentEncoding(), value: String(propertyAlias).urlPercentEncoding())
            input.builder.withQueryItem(propertyAliasQueryItem)
        }
        if let qualities = input.operationInput.qualities {
            qualities.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "qualities".urlPercentEncoding(), value: String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let timeOrdering = input.operationInput.timeOrdering {
            let timeOrderingQueryItem = URLQueryItem(name: "timeOrdering".urlPercentEncoding(), value: String(timeOrdering.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(timeOrderingQueryItem)
        }
        if let propertyId = input.operationInput.propertyId {
            let propertyIdQueryItem = URLQueryItem(name: "propertyId".urlPercentEncoding(), value: String(propertyId).urlPercentEncoding())
            input.builder.withQueryItem(propertyIdQueryItem)
        }
        if let startDate = input.operationInput.startDate {
            let startDateQueryItem = URLQueryItem(name: "startDate".urlPercentEncoding(), value: String(startDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startDateQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssetPropertyValueHistoryInput>
    public typealias MOutput = OperationOutput<GetAssetPropertyValueHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssetPropertyValueHistoryOutputError>
}

public struct GetAssetPropertyValueHistoryInput: Equatable {
    /// <p>The ID of the asset.</p>
    public let assetId: String?
    /// <p>The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    public let endDate: Date?
    /// <p>The maximum number of results to be returned per paginated request.</p>
    ///          <p>Default: 100</p>
    public let maxResults: Int?
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?
    /// <p>The property alias that identifies the property, such as an OPC-UA server data stream path
    ///         (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the
    ///         <i>AWS IoT SiteWise User Guide</i>.</p>
    public let propertyAlias: String?
    /// <p>The ID of the asset property.</p>
    public let propertyId: String?
    /// <p>The quality by which to filter asset data.</p>
    public let qualities: [Quality]?
    /// <p>The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.</p>
    public let startDate: Date?
    /// <p>The chronological sorting order of the requested information.</p>
    ///          <p>Default: <code>ASCENDING</code>
    ///          </p>
    public let timeOrdering: TimeOrdering?

    public init (
        assetId: String? = nil,
        endDate: Date? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        propertyAlias: String? = nil,
        propertyId: String? = nil,
        qualities: [Quality]? = nil,
        startDate: Date? = nil,
        timeOrdering: TimeOrdering? = nil
    )
    {
        self.assetId = assetId
        self.endDate = endDate
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.qualities = qualities
        self.startDate = startDate
        self.timeOrdering = timeOrdering
    }
}

struct GetAssetPropertyValueHistoryInputBody: Equatable {
}

extension GetAssetPropertyValueHistoryInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAssetPropertyValueHistoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssetPropertyValueHistoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssetPropertyValueHistoryOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssetPropertyValueHistoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssetPropertyValueHistoryOutputResponse(assetPropertyValueHistory: \(String(describing: assetPropertyValueHistory)), nextToken: \(String(describing: nextToken)))"}
}

extension GetAssetPropertyValueHistoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAssetPropertyValueHistoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assetPropertyValueHistory = output.assetPropertyValueHistory
            self.nextToken = output.nextToken
        } else {
            self.assetPropertyValueHistory = nil
            self.nextToken = nil
        }
    }
}

public struct GetAssetPropertyValueHistoryOutputResponse: Equatable {
    /// <p>The asset property's value history.</p>
    public let assetPropertyValueHistory: [AssetPropertyValue]?
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?

    public init (
        assetPropertyValueHistory: [AssetPropertyValue]? = nil,
        nextToken: String? = nil
    )
    {
        self.assetPropertyValueHistory = assetPropertyValueHistory
        self.nextToken = nextToken
    }
}

struct GetAssetPropertyValueHistoryOutputResponseBody: Equatable {
    public let assetPropertyValueHistory: [AssetPropertyValue]?
    public let nextToken: String?
}

extension GetAssetPropertyValueHistoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetPropertyValueHistory
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetPropertyValueHistoryContainer = try containerValues.decodeIfPresent([AssetPropertyValue?].self, forKey: .assetPropertyValueHistory)
        var assetPropertyValueHistoryDecoded0:[AssetPropertyValue]? = nil
        if let assetPropertyValueHistoryContainer = assetPropertyValueHistoryContainer {
            assetPropertyValueHistoryDecoded0 = [AssetPropertyValue]()
            for structure0 in assetPropertyValueHistoryContainer {
                if let structure0 = structure0 {
                    assetPropertyValueHistoryDecoded0?.append(structure0)
                }
            }
        }
        assetPropertyValueHistory = assetPropertyValueHistoryDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAssetPropertyValueInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssetPropertyValueInput(assetId: \(String(describing: assetId)), propertyAlias: \(String(describing: propertyAlias)), propertyId: \(String(describing: propertyId)))"}
}

extension GetAssetPropertyValueInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAssetPropertyValueInputHeadersMiddleware: Middleware {
    public let id: String = "GetAssetPropertyValueInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssetPropertyValueInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssetPropertyValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssetPropertyValueInput>
    public typealias MOutput = OperationOutput<GetAssetPropertyValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssetPropertyValueOutputError>
}

public struct GetAssetPropertyValueInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAssetPropertyValueInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssetPropertyValueInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssetPropertyValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let assetId = input.operationInput.assetId {
            let assetIdQueryItem = URLQueryItem(name: "assetId".urlPercentEncoding(), value: String(assetId).urlPercentEncoding())
            input.builder.withQueryItem(assetIdQueryItem)
        }
        if let propertyAlias = input.operationInput.propertyAlias {
            let propertyAliasQueryItem = URLQueryItem(name: "propertyAlias".urlPercentEncoding(), value: String(propertyAlias).urlPercentEncoding())
            input.builder.withQueryItem(propertyAliasQueryItem)
        }
        if let propertyId = input.operationInput.propertyId {
            let propertyIdQueryItem = URLQueryItem(name: "propertyId".urlPercentEncoding(), value: String(propertyId).urlPercentEncoding())
            input.builder.withQueryItem(propertyIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssetPropertyValueInput>
    public typealias MOutput = OperationOutput<GetAssetPropertyValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssetPropertyValueOutputError>
}

public struct GetAssetPropertyValueInput: Equatable {
    /// <p>The ID of the asset.</p>
    public let assetId: String?
    /// <p>The property alias that identifies the property, such as an OPC-UA server data stream path
    ///         (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the
    ///         <i>AWS IoT SiteWise User Guide</i>.</p>
    public let propertyAlias: String?
    /// <p>The ID of the asset property.</p>
    public let propertyId: String?

    public init (
        assetId: String? = nil,
        propertyAlias: String? = nil,
        propertyId: String? = nil
    )
    {
        self.assetId = assetId
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
    }
}

struct GetAssetPropertyValueInputBody: Equatable {
}

extension GetAssetPropertyValueInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAssetPropertyValueOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssetPropertyValueOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssetPropertyValueOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssetPropertyValueOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssetPropertyValueOutputResponse(propertyValue: \(String(describing: propertyValue)))"}
}

extension GetAssetPropertyValueOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAssetPropertyValueOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.propertyValue = output.propertyValue
        } else {
            self.propertyValue = nil
        }
    }
}

public struct GetAssetPropertyValueOutputResponse: Equatable {
    /// <p>The current asset property value.</p>
    public let propertyValue: AssetPropertyValue?

    public init (
        propertyValue: AssetPropertyValue? = nil
    )
    {
        self.propertyValue = propertyValue
    }
}

struct GetAssetPropertyValueOutputResponseBody: Equatable {
    public let propertyValue: AssetPropertyValue?
}

extension GetAssetPropertyValueOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case propertyValue
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyValueDecoded = try containerValues.decodeIfPresent(AssetPropertyValue.self, forKey: .propertyValue)
        propertyValue = propertyValueDecoded
    }
}

extension GetInterpolatedAssetPropertyValuesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInterpolatedAssetPropertyValuesInput(assetId: \(String(describing: assetId)), endTimeInSeconds: \(String(describing: endTimeInSeconds)), endTimeOffsetInNanos: \(String(describing: endTimeOffsetInNanos)), intervalInSeconds: \(String(describing: intervalInSeconds)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), propertyAlias: \(String(describing: propertyAlias)), propertyId: \(String(describing: propertyId)), quality: \(String(describing: quality)), startTimeInSeconds: \(String(describing: startTimeInSeconds)), startTimeOffsetInNanos: \(String(describing: startTimeOffsetInNanos)), type: \(String(describing: type)))"}
}

extension GetInterpolatedAssetPropertyValuesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetInterpolatedAssetPropertyValuesInputHeadersMiddleware: Middleware {
    public let id: String = "GetInterpolatedAssetPropertyValuesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInterpolatedAssetPropertyValuesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInterpolatedAssetPropertyValuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInterpolatedAssetPropertyValuesInput>
    public typealias MOutput = OperationOutput<GetInterpolatedAssetPropertyValuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInterpolatedAssetPropertyValuesOutputError>
}

public struct GetInterpolatedAssetPropertyValuesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInterpolatedAssetPropertyValuesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInterpolatedAssetPropertyValuesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInterpolatedAssetPropertyValuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let startTimeInSeconds = input.operationInput.startTimeInSeconds {
            let startTimeInSecondsQueryItem = URLQueryItem(name: "startTimeInSeconds".urlPercentEncoding(), value: String(startTimeInSeconds).urlPercentEncoding())
            input.builder.withQueryItem(startTimeInSecondsQueryItem)
        }
        if let startTimeOffsetInNanos = input.operationInput.startTimeOffsetInNanos {
            let startTimeOffsetInNanosQueryItem = URLQueryItem(name: "startTimeOffsetInNanos".urlPercentEncoding(), value: String(startTimeOffsetInNanos).urlPercentEncoding())
            input.builder.withQueryItem(startTimeOffsetInNanosQueryItem)
        }
        if let endTimeInSeconds = input.operationInput.endTimeInSeconds {
            let endTimeInSecondsQueryItem = URLQueryItem(name: "endTimeInSeconds".urlPercentEncoding(), value: String(endTimeInSeconds).urlPercentEncoding())
            input.builder.withQueryItem(endTimeInSecondsQueryItem)
        }
        if let endTimeOffsetInNanos = input.operationInput.endTimeOffsetInNanos {
            let endTimeOffsetInNanosQueryItem = URLQueryItem(name: "endTimeOffsetInNanos".urlPercentEncoding(), value: String(endTimeOffsetInNanos).urlPercentEncoding())
            input.builder.withQueryItem(endTimeOffsetInNanosQueryItem)
        }
        if let assetId = input.operationInput.assetId {
            let assetIdQueryItem = URLQueryItem(name: "assetId".urlPercentEncoding(), value: String(assetId).urlPercentEncoding())
            input.builder.withQueryItem(assetIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let propertyAlias = input.operationInput.propertyAlias {
            let propertyAliasQueryItem = URLQueryItem(name: "propertyAlias".urlPercentEncoding(), value: String(propertyAlias).urlPercentEncoding())
            input.builder.withQueryItem(propertyAliasQueryItem)
        }
        if let intervalInSeconds = input.operationInput.intervalInSeconds {
            let intervalInSecondsQueryItem = URLQueryItem(name: "intervalInSeconds".urlPercentEncoding(), value: String(intervalInSeconds).urlPercentEncoding())
            input.builder.withQueryItem(intervalInSecondsQueryItem)
        }
        if let type = input.operationInput.type {
            let typeQueryItem = URLQueryItem(name: "type".urlPercentEncoding(), value: String(type).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        if let propertyId = input.operationInput.propertyId {
            let propertyIdQueryItem = URLQueryItem(name: "propertyId".urlPercentEncoding(), value: String(propertyId).urlPercentEncoding())
            input.builder.withQueryItem(propertyIdQueryItem)
        }
        if let quality = input.operationInput.quality {
            let qualityQueryItem = URLQueryItem(name: "quality".urlPercentEncoding(), value: String(quality.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(qualityQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInterpolatedAssetPropertyValuesInput>
    public typealias MOutput = OperationOutput<GetInterpolatedAssetPropertyValuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInterpolatedAssetPropertyValuesOutputError>
}

public struct GetInterpolatedAssetPropertyValuesInput: Equatable {
    /// <p>The ID of the asset.</p>
    public let assetId: String?
    /// <p>The inclusive end of the range from which to interpolate data, expressed in seconds in
    ///       Unix epoch time.</p>
    public let endTimeInSeconds: Int?
    /// <p>The nanosecond offset converted from <code>endTimeInSeconds</code>.</p>
    public let endTimeOffsetInNanos: Int?
    /// <p>The time interval in seconds over which to interpolate data. Each interval starts when the
    ///       previous one ends.</p>
    public let intervalInSeconds: Int?
    /// <p>The maximum number of results to be returned per paginated request.
    ///       If not specified, the default value is 10.</p>
    public let maxResults: Int?
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?
    /// <p>The property alias that identifies the property, such as an OPC-UA server data stream path
    ///         (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the
    ///         <i>AWS IoT SiteWise User Guide</i>.</p>
    public let propertyAlias: String?
    /// <p>The ID of the asset property.</p>
    public let propertyId: String?
    /// <p>The quality of the asset property value. You can use this parameter as a filter to choose
    ///       only the asset property values that have a specific quality.</p>
    public let quality: Quality?
    /// <p>The exclusive start of the range from which to interpolate data, expressed in seconds in
    ///       Unix epoch time.</p>
    public let startTimeInSeconds: Int?
    /// <p>The nanosecond offset converted from <code>startTimeInSeconds</code>.</p>
    public let startTimeOffsetInNanos: Int?
    /// <p>The interpolation type.</p>
    ///          <p>Valid values: <code>LINEAR_INTERPOLATION</code>
    ///          </p>
    public let type: String?

    public init (
        assetId: String? = nil,
        endTimeInSeconds: Int? = nil,
        endTimeOffsetInNanos: Int? = nil,
        intervalInSeconds: Int? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        propertyAlias: String? = nil,
        propertyId: String? = nil,
        quality: Quality? = nil,
        startTimeInSeconds: Int? = nil,
        startTimeOffsetInNanos: Int? = nil,
        type: String? = nil
    )
    {
        self.assetId = assetId
        self.endTimeInSeconds = endTimeInSeconds
        self.endTimeOffsetInNanos = endTimeOffsetInNanos
        self.intervalInSeconds = intervalInSeconds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.quality = quality
        self.startTimeInSeconds = startTimeInSeconds
        self.startTimeOffsetInNanos = startTimeOffsetInNanos
        self.type = type
    }
}

struct GetInterpolatedAssetPropertyValuesInputBody: Equatable {
}

extension GetInterpolatedAssetPropertyValuesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetInterpolatedAssetPropertyValuesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInterpolatedAssetPropertyValuesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInterpolatedAssetPropertyValuesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInterpolatedAssetPropertyValuesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInterpolatedAssetPropertyValuesOutputResponse(interpolatedAssetPropertyValues: \(String(describing: interpolatedAssetPropertyValues)), nextToken: \(String(describing: nextToken)))"}
}

extension GetInterpolatedAssetPropertyValuesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInterpolatedAssetPropertyValuesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.interpolatedAssetPropertyValues = output.interpolatedAssetPropertyValues
            self.nextToken = output.nextToken
        } else {
            self.interpolatedAssetPropertyValues = nil
            self.nextToken = nil
        }
    }
}

public struct GetInterpolatedAssetPropertyValuesOutputResponse: Equatable {
    /// <p>The requested interpolated values.</p>
    public let interpolatedAssetPropertyValues: [InterpolatedAssetPropertyValue]?
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?

    public init (
        interpolatedAssetPropertyValues: [InterpolatedAssetPropertyValue]? = nil,
        nextToken: String? = nil
    )
    {
        self.interpolatedAssetPropertyValues = interpolatedAssetPropertyValues
        self.nextToken = nextToken
    }
}

struct GetInterpolatedAssetPropertyValuesOutputResponseBody: Equatable {
    public let interpolatedAssetPropertyValues: [InterpolatedAssetPropertyValue]?
    public let nextToken: String?
}

extension GetInterpolatedAssetPropertyValuesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case interpolatedAssetPropertyValues
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interpolatedAssetPropertyValuesContainer = try containerValues.decodeIfPresent([InterpolatedAssetPropertyValue?].self, forKey: .interpolatedAssetPropertyValues)
        var interpolatedAssetPropertyValuesDecoded0:[InterpolatedAssetPropertyValue]? = nil
        if let interpolatedAssetPropertyValuesContainer = interpolatedAssetPropertyValuesContainer {
            interpolatedAssetPropertyValuesDecoded0 = [InterpolatedAssetPropertyValue]()
            for structure0 in interpolatedAssetPropertyValuesContainer {
                if let structure0 = structure0 {
                    interpolatedAssetPropertyValuesDecoded0?.append(structure0)
                }
            }
        }
        interpolatedAssetPropertyValues = interpolatedAssetPropertyValuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension Greengrass: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupArn = groupArn {
            try encodeContainer.encode(groupArn, forKey: .groupArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupArn)
        groupArn = groupArnDecoded
    }
}

extension Greengrass: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Greengrass(groupArn: \(String(describing: groupArn)))"}
}

/// <p>Contains details for a gateway that runs on AWS IoT Greengrass. To create a gateway that runs on AWS IoT Greengrass,
///       you must add the IoT SiteWise connector to a Greengrass group and deploy it. Your Greengrass
///       group must also have permissions to upload data to AWS IoT SiteWise. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/gateway-connector.html">Ingesting data using a
///         gateway</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
public struct Greengrass: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the Greengrass group. For more information about how to find a group's
    ///       ARN, see <a href="https://docs.aws.amazon.com/greengrass/latest/apireference/listgroups-get.html">ListGroups</a> and <a href="https://docs.aws.amazon.com/greengrass/latest/apireference/getgroup-get.html">GetGroup</a> in the
    ///         <i>AWS IoT Greengrass API Reference</i>.</p>
    public let groupArn: String?

    public init (
        groupArn: String? = nil
    )
    {
        self.groupArn = groupArn
    }
}

extension GroupIdentity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension GroupIdentity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupIdentity(id: \(String(describing: id)))"}
}

/// <p>Contains information for a group identity in an access policy.</p>
public struct GroupIdentity: Equatable {
    /// <p>The AWS SSO ID of the group.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

extension IAMRoleIdentity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IAMRoleIdentity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IAMRoleIdentity(arn: \(String(describing: arn)))"}
}

/// <p>Contains information about an AWS Identity and Access Management (IAM) role. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html">IAM roles</a> in the
///       <i>IAM User Guide</i>.</p>
public struct IAMRoleIdentity: Equatable {
    /// <p>The ARN of the IAM role. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM ARNs</a> in the
    ///       <i>IAM User Guide</i>.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

extension IAMUserIdentity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IAMUserIdentity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IAMUserIdentity(arn: \(String(describing: arn)))"}
}

/// <p>Contains information about an AWS Identity and Access Management (IAM) user.</p>
public struct IAMUserIdentity: Equatable {
    /// <p>The ARN of the IAM user. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM ARNs</a> in the
    ///       <i>IAM User Guide</i>.</p>
    ///          <note>
    ///             <p>If you delete the IAM user, access policies that contain this identity include an
    ///         empty <code>arn</code>. You can delete the access policy for the IAM user that no longer
    ///         exists.</p>
    ///          </note>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

extension Identity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case group
        case iamRole
        case iamUser
        case user
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let iamUser = iamUser {
            try encodeContainer.encode(iamUser, forKey: .iamUser)
        }
        if let user = user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(UserIdentity.self, forKey: .user)
        user = userDecoded
        let groupDecoded = try containerValues.decodeIfPresent(GroupIdentity.self, forKey: .group)
        group = groupDecoded
        let iamUserDecoded = try containerValues.decodeIfPresent(IAMUserIdentity.self, forKey: .iamUser)
        iamUser = iamUserDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(IAMRoleIdentity.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
    }
}

extension Identity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Identity(group: \(String(describing: group)), iamRole: \(String(describing: iamRole)), iamUser: \(String(describing: iamUser)), user: \(String(describing: user)))"}
}

/// <p>Contains an identity that can access an AWS IoT SiteWise Monitor resource.</p>
///          <note>
///             <p>Currently, you can't use AWS APIs to retrieve AWS SSO identity IDs. You can find the
///         AWS SSO identity IDs in the URL of user and group pages in the <a href="https://console.aws.amazon.com/singlesignon">AWS SSO console</a>.</p>
///          </note>
public struct Identity: Equatable {
    /// <p>An AWS SSO group identity.</p>
    public let group: GroupIdentity?
    /// <p>An IAM role identity.</p>
    public let iamRole: IAMRoleIdentity?
    /// <p>An IAM user identity.</p>
    public let iamUser: IAMUserIdentity?
    /// <p>An AWS SSO user identity.</p>
    public let user: UserIdentity?

    public init (
        group: GroupIdentity? = nil,
        iamRole: IAMRoleIdentity? = nil,
        iamUser: IAMUserIdentity? = nil,
        user: UserIdentity? = nil
    )
    {
        self.group = group
        self.iamRole = iamRole
        self.iamUser = iamUser
        self.user = user
    }
}

public enum IdentityType {
    case group
    case iam
    case user
    case sdkUnknown(String)
}

extension IdentityType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IdentityType] {
        return [
            .group,
            .iam,
            .user,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .group: return "GROUP"
        case .iam: return "IAM"
        case .user: return "USER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IdentityType(rawValue: rawValue) ?? IdentityType.sdkUnknown(rawValue)
    }
}

extension Image: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case file
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let file = file {
            try encodeContainer.encode(file, forKey: .file)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let fileDecoded = try containerValues.decodeIfPresent(ImageFile.self, forKey: .file)
        file = fileDecoded
    }
}

extension Image: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Image(file: \(String(describing: file)), id: \(String(describing: id)))"}
}

/// <p>Contains an image that is one of the following:</p>
///          <ul>
///             <li>
///                <p>An image file. Choose this option to upload a new image.</p>
///             </li>
///             <li>
///                <p>The ID of an existing image. Choose this option to keep an existing image.</p>
///             </li>
///          </ul>
public struct Image: Equatable {
    /// <p>Contains an image file.</p>
    public let file: ImageFile?
    /// <p>The ID of an existing image. Specify this parameter to keep an existing image.</p>
    public let id: String?

    public init (
        file: ImageFile? = nil,
        id: String? = nil
    )
    {
        self.file = file
        self.id = id
    }
}

extension ImageFile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case data
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .data)
        data = dataDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImageFileType.self, forKey: .type)
        type = typeDecoded
    }
}

extension ImageFile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageFile(data: \(String(describing: data)), type: \(String(describing: type)))"}
}

/// <p>Contains an image file.</p>
public struct ImageFile: Equatable {
    /// <p>The image file contents, represented as a base64-encoded string. The file size must be
    ///       less than 1 MB.</p>
    public let data: Data?
    /// <p>The file type of the image.</p>
    public let type: ImageFileType?

    public init (
        data: Data? = nil,
        type: ImageFileType? = nil
    )
    {
        self.data = data
        self.type = type
    }
}

public enum ImageFileType {
    case png
    case sdkUnknown(String)
}

extension ImageFileType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImageFileType] {
        return [
            .png,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .png: return "PNG"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImageFileType(rawValue: rawValue) ?? ImageFileType.sdkUnknown(rawValue)
    }
}

extension ImageLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case url
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension ImageLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageLocation(id: \(String(describing: id)), url: \(String(describing: url)))"}
}

/// <p>Contains an image that is uploaded to AWS IoT SiteWise and available at a URL.</p>
public struct ImageLocation: Equatable {
    /// <p>The ID of the image.</p>
    public let id: String?
    /// <p>The URL where the image is available. The URL is valid for 15 minutes so that you can view
    ///       and download the image</p>
    public let url: String?

    public init (
        id: String? = nil,
        url: String? = nil
    )
    {
        self.id = id
        self.url = url
    }
}

extension InternalFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalFailureException(message: \(String(describing: message)))"}
}

extension InternalFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS IoT SiteWise can't process your request right now. Try again later.</p>
public struct InternalFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Equatable {
    public let message: String?
}

extension InternalFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InterpolatedAssetPropertyValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timestamp
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(TimeInNanos.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Variant.self, forKey: .value)
        value = valueDecoded
    }
}

extension InterpolatedAssetPropertyValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InterpolatedAssetPropertyValue(timestamp: \(String(describing: timestamp)), value: \(String(describing: value)))"}
}

/// <p>Contains information about an interpolated asset property value.</p>
public struct InterpolatedAssetPropertyValue: Equatable {
    /// <p>Contains a timestamp with optional nanosecond granularity.</p>
    public let timestamp: TimeInNanos?
    /// <p>Contains an asset property value (of a single type only).</p>
    public let value: Variant?

    public init (
        timestamp: TimeInNanos? = nil,
        value: Variant? = nil
    )
    {
        self.timestamp = timestamp
        self.value = value
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request isn't valid. This can occur if your request contains malformed JSON or
///       unsupported characters. Check your request and try again.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit for a resource. For example, this can occur if you're trying to
///       associate more than the allowed number of child assets or attempting to create more than the
///       allowed number of properties for an asset model.</p>
///          <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAccessPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccessPoliciesInput(iamArn: \(String(describing: iamArn)), identityId: \(String(describing: identityId)), identityType: \(String(describing: identityType)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ListAccessPoliciesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAccessPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAccessPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessPoliciesInput>
    public typealias MOutput = OperationOutput<ListAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessPoliciesOutputError>
}

public struct ListAccessPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAccessPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceId = input.operationInput.resourceId {
            let resourceIdQueryItem = URLQueryItem(name: "resourceId".urlPercentEncoding(), value: String(resourceId).urlPercentEncoding())
            input.builder.withQueryItem(resourceIdQueryItem)
        }
        if let identityType = input.operationInput.identityType {
            let identityTypeQueryItem = URLQueryItem(name: "identityType".urlPercentEncoding(), value: String(identityType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(identityTypeQueryItem)
        }
        if let identityId = input.operationInput.identityId {
            let identityIdQueryItem = URLQueryItem(name: "identityId".urlPercentEncoding(), value: String(identityId).urlPercentEncoding())
            input.builder.withQueryItem(identityIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let iamArn = input.operationInput.iamArn {
            let iamArnQueryItem = URLQueryItem(name: "iamArn".urlPercentEncoding(), value: String(iamArn).urlPercentEncoding())
            input.builder.withQueryItem(iamArnQueryItem)
        }
        if let resourceType = input.operationInput.resourceType {
            let resourceTypeQueryItem = URLQueryItem(name: "resourceType".urlPercentEncoding(), value: String(resourceType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(resourceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessPoliciesInput>
    public typealias MOutput = OperationOutput<ListAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessPoliciesOutputError>
}

public struct ListAccessPoliciesInput: Equatable {
    /// <p>The ARN of the IAM user. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM ARNs</a> in the
    ///         <i>IAM User Guide</i>. This parameter is required if you specify
    ///         <code>IAM</code> for <code>identityType</code>.</p>
    public let iamArn: String?
    /// <p>The ID of the identity. This parameter is required if you specify <code>USER</code> or
    ///         <code>GROUP</code> for <code>identityType</code>.</p>
    public let identityId: String?
    /// <p>The type of identity (AWS SSO user, AWS SSO group, or IAM user). This parameter is required
    ///       if you specify <code>identityId</code>.</p>
    public let identityType: IdentityType?
    /// <p>The maximum number of results to be returned per paginated request.</p>
    ///          <p>Default: 50</p>
    public let maxResults: Int?
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?
    /// <p>The ID of the resource. This parameter is required if you specify
    ///         <code>resourceType</code>.</p>
    public let resourceId: String?
    /// <p>The type of resource (portal or project). This parameter is required if you specify
    ///         <code>resourceId</code>.</p>
    public let resourceType: ResourceType?

    public init (
        iamArn: String? = nil,
        identityId: String? = nil,
        identityType: IdentityType? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceId: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.iamArn = iamArn
        self.identityId = identityId
        self.identityType = identityType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ListAccessPoliciesInputBody: Equatable {
}

extension ListAccessPoliciesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAccessPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccessPoliciesOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccessPoliciesOutputResponse(accessPolicySummaries: \(String(describing: accessPolicySummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAccessPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAccessPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessPolicySummaries = output.accessPolicySummaries
            self.nextToken = output.nextToken
        } else {
            self.accessPolicySummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessPoliciesOutputResponse: Equatable {
    /// <p>A list that summarizes each access policy.</p>
    public let accessPolicySummaries: [AccessPolicySummary]?
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?

    public init (
        accessPolicySummaries: [AccessPolicySummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.accessPolicySummaries = accessPolicySummaries
        self.nextToken = nextToken
    }
}

struct ListAccessPoliciesOutputResponseBody: Equatable {
    public let accessPolicySummaries: [AccessPolicySummary]?
    public let nextToken: String?
}

extension ListAccessPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessPolicySummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicySummariesContainer = try containerValues.decodeIfPresent([AccessPolicySummary?].self, forKey: .accessPolicySummaries)
        var accessPolicySummariesDecoded0:[AccessPolicySummary]? = nil
        if let accessPolicySummariesContainer = accessPolicySummariesContainer {
            accessPolicySummariesDecoded0 = [AccessPolicySummary]()
            for structure0 in accessPolicySummariesContainer {
                if let structure0 = structure0 {
                    accessPolicySummariesDecoded0?.append(structure0)
                }
            }
        }
        accessPolicySummaries = accessPolicySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssetModelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssetModelsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssetModelsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAssetModelsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssetModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssetModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssetModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssetModelsInput>
    public typealias MOutput = OperationOutput<ListAssetModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssetModelsOutputError>
}

public struct ListAssetModelsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssetModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssetModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssetModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssetModelsInput>
    public typealias MOutput = OperationOutput<ListAssetModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssetModelsOutputError>
}

public struct ListAssetModelsInput: Equatable {
    /// <p>The maximum number of results to be returned per paginated request.</p>
    ///          <p>Default: 50</p>
    public let maxResults: Int?
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssetModelsInputBody: Equatable {
}

extension ListAssetModelsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAssetModelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssetModelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssetModelsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssetModelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssetModelsOutputResponse(assetModelSummaries: \(String(describing: assetModelSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssetModelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssetModelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assetModelSummaries = output.assetModelSummaries
            self.nextToken = output.nextToken
        } else {
            self.assetModelSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetModelsOutputResponse: Equatable {
    /// <p>A list that summarizes each asset model.</p>
    public let assetModelSummaries: [AssetModelSummary]?
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?

    public init (
        assetModelSummaries: [AssetModelSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.assetModelSummaries = assetModelSummaries
        self.nextToken = nextToken
    }
}

struct ListAssetModelsOutputResponseBody: Equatable {
    public let assetModelSummaries: [AssetModelSummary]?
    public let nextToken: String?
}

extension ListAssetModelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetModelSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelSummariesContainer = try containerValues.decodeIfPresent([AssetModelSummary?].self, forKey: .assetModelSummaries)
        var assetModelSummariesDecoded0:[AssetModelSummary]? = nil
        if let assetModelSummariesContainer = assetModelSummariesContainer {
            assetModelSummariesDecoded0 = [AssetModelSummary]()
            for structure0 in assetModelSummariesContainer {
                if let structure0 = structure0 {
                    assetModelSummariesDecoded0?.append(structure0)
                }
            }
        }
        assetModelSummaries = assetModelSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssetRelationshipsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssetRelationshipsInput(assetId: \(String(describing: assetId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), traversalType: \(String(describing: traversalType)))"}
}

extension ListAssetRelationshipsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAssetRelationshipsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssetRelationshipsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssetRelationshipsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssetRelationshipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssetRelationshipsInput>
    public typealias MOutput = OperationOutput<ListAssetRelationshipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssetRelationshipsOutputError>
}

public struct ListAssetRelationshipsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssetRelationshipsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssetRelationshipsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssetRelationshipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let traversalType = input.operationInput.traversalType {
            let traversalTypeQueryItem = URLQueryItem(name: "traversalType".urlPercentEncoding(), value: String(traversalType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(traversalTypeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssetRelationshipsInput>
    public typealias MOutput = OperationOutput<ListAssetRelationshipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssetRelationshipsOutputError>
}

public struct ListAssetRelationshipsInput: Equatable {
    /// <p>The ID of the asset.</p>
    public let assetId: String?
    /// <p>The maximum number of results to be returned per paginated request.</p>
    public let maxResults: Int?
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?
    /// <p>The type of traversal to use to identify asset relationships. Choose the following
    ///       option:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PATH_TO_ROOT</code> – Identify the asset's parent assets up to the root
    ///           asset. The asset that you specify in <code>assetId</code> is the first result in the list
    ///           of <code>assetRelationshipSummaries</code>, and the root asset is the last result.</p>
    ///             </li>
    ///          </ul>
    public let traversalType: TraversalType?

    public init (
        assetId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        traversalType: TraversalType? = nil
    )
    {
        self.assetId = assetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.traversalType = traversalType
    }
}

struct ListAssetRelationshipsInputBody: Equatable {
}

extension ListAssetRelationshipsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAssetRelationshipsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssetRelationshipsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssetRelationshipsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssetRelationshipsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssetRelationshipsOutputResponse(assetRelationshipSummaries: \(String(describing: assetRelationshipSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssetRelationshipsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssetRelationshipsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assetRelationshipSummaries = output.assetRelationshipSummaries
            self.nextToken = output.nextToken
        } else {
            self.assetRelationshipSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetRelationshipsOutputResponse: Equatable {
    /// <p>A list that summarizes each asset relationship.</p>
    public let assetRelationshipSummaries: [AssetRelationshipSummary]?
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?

    public init (
        assetRelationshipSummaries: [AssetRelationshipSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.assetRelationshipSummaries = assetRelationshipSummaries
        self.nextToken = nextToken
    }
}

struct ListAssetRelationshipsOutputResponseBody: Equatable {
    public let assetRelationshipSummaries: [AssetRelationshipSummary]?
    public let nextToken: String?
}

extension ListAssetRelationshipsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetRelationshipSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetRelationshipSummariesContainer = try containerValues.decodeIfPresent([AssetRelationshipSummary?].self, forKey: .assetRelationshipSummaries)
        var assetRelationshipSummariesDecoded0:[AssetRelationshipSummary]? = nil
        if let assetRelationshipSummariesContainer = assetRelationshipSummariesContainer {
            assetRelationshipSummariesDecoded0 = [AssetRelationshipSummary]()
            for structure0 in assetRelationshipSummariesContainer {
                if let structure0 = structure0 {
                    assetRelationshipSummariesDecoded0?.append(structure0)
                }
            }
        }
        assetRelationshipSummaries = assetRelationshipSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum ListAssetsFilter {
    case all
    case topLevel
    case sdkUnknown(String)
}

extension ListAssetsFilter : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ListAssetsFilter] {
        return [
            .all,
            .topLevel,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .topLevel: return "TOP_LEVEL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ListAssetsFilter(rawValue: rawValue) ?? ListAssetsFilter.sdkUnknown(rawValue)
    }
}

extension ListAssetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssetsInput(assetModelId: \(String(describing: assetModelId)), filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssetsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAssetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssetsInput>
    public typealias MOutput = OperationOutput<ListAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssetsOutputError>
}

public struct ListAssetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let filter = input.operationInput.filter {
            let filterQueryItem = URLQueryItem(name: "filter".urlPercentEncoding(), value: String(filter.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(filterQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let assetModelId = input.operationInput.assetModelId {
            let assetModelIdQueryItem = URLQueryItem(name: "assetModelId".urlPercentEncoding(), value: String(assetModelId).urlPercentEncoding())
            input.builder.withQueryItem(assetModelIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssetsInput>
    public typealias MOutput = OperationOutput<ListAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssetsOutputError>
}

public struct ListAssetsInput: Equatable {
    /// <p>The ID of the asset model by which to filter the list of assets. This parameter is
    ///       required if you choose <code>ALL</code> for <code>filter</code>.</p>
    public let assetModelId: String?
    /// <p>The filter for the requested list of assets. Choose one of the following options:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ALL</code> – The list includes all assets for a given asset model ID. The
    ///             <code>assetModelId</code> parameter is required if you filter by
    ///           <code>ALL</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TOP_LEVEL</code> – The list includes only top-level assets in the asset
    ///           hierarchy tree.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Default: <code>ALL</code>
    ///          </p>
    public let filter: ListAssetsFilter?
    /// <p>The maximum number of results to be returned per paginated request.</p>
    ///          <p>Default: 50</p>
    public let maxResults: Int?
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?

    public init (
        assetModelId: String? = nil,
        filter: ListAssetsFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.assetModelId = assetModelId
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssetsInputBody: Equatable {
}

extension ListAssetsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAssetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssetsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssetsOutputResponse(assetSummaries: \(String(describing: assetSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assetSummaries = output.assetSummaries
            self.nextToken = output.nextToken
        } else {
            self.assetSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetsOutputResponse: Equatable {
    /// <p>A list that summarizes each asset.</p>
    public let assetSummaries: [AssetSummary]?
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?

    public init (
        assetSummaries: [AssetSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.assetSummaries = assetSummaries
        self.nextToken = nextToken
    }
}

struct ListAssetsOutputResponseBody: Equatable {
    public let assetSummaries: [AssetSummary]?
    public let nextToken: String?
}

extension ListAssetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSummariesContainer = try containerValues.decodeIfPresent([AssetSummary?].self, forKey: .assetSummaries)
        var assetSummariesDecoded0:[AssetSummary]? = nil
        if let assetSummariesContainer = assetSummariesContainer {
            assetSummariesDecoded0 = [AssetSummary]()
            for structure0 in assetSummariesContainer {
                if let structure0 = structure0 {
                    assetSummariesDecoded0?.append(structure0)
                }
            }
        }
        assetSummaries = assetSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociatedAssetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssociatedAssetsInput(assetId: \(String(describing: assetId)), hierarchyId: \(String(describing: hierarchyId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), traversalDirection: \(String(describing: traversalDirection)))"}
}

extension ListAssociatedAssetsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAssociatedAssetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssociatedAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociatedAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociatedAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociatedAssetsInput>
    public typealias MOutput = OperationOutput<ListAssociatedAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociatedAssetsOutputError>
}

public struct ListAssociatedAssetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssociatedAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociatedAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociatedAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let traversalDirection = input.operationInput.traversalDirection {
            let traversalDirectionQueryItem = URLQueryItem(name: "traversalDirection".urlPercentEncoding(), value: String(traversalDirection.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(traversalDirectionQueryItem)
        }
        if let hierarchyId = input.operationInput.hierarchyId {
            let hierarchyIdQueryItem = URLQueryItem(name: "hierarchyId".urlPercentEncoding(), value: String(hierarchyId).urlPercentEncoding())
            input.builder.withQueryItem(hierarchyIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociatedAssetsInput>
    public typealias MOutput = OperationOutput<ListAssociatedAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociatedAssetsOutputError>
}

public struct ListAssociatedAssetsInput: Equatable {
    /// <p>The ID of the asset to query.</p>
    public let assetId: String?
    /// <p>The ID of the hierarchy by which child assets are associated to the asset. To find a
    ///       hierarchy ID, use the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeAsset.html">DescribeAsset</a> or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeAssetModel.html">DescribeAssetModel</a> operations. This
    ///       parameter is required if you choose <code>CHILD</code> for
    ///       <code>traversalDirection</code>.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let hierarchyId: String?
    /// <p>The maximum number of results to be returned per paginated request.</p>
    ///          <p>Default: 50</p>
    public let maxResults: Int?
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?
    /// <p>The direction to list associated assets. Choose one of the following options:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CHILD</code> – The list includes all child assets associated to the
    ///           asset. The <code>hierarchyId</code> parameter is required if you choose
    ///           <code>CHILD</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PARENT</code> – The list includes the asset's parent asset.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Default: <code>CHILD</code>
    ///          </p>
    public let traversalDirection: TraversalDirection?

    public init (
        assetId: String? = nil,
        hierarchyId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        traversalDirection: TraversalDirection? = nil
    )
    {
        self.assetId = assetId
        self.hierarchyId = hierarchyId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.traversalDirection = traversalDirection
    }
}

struct ListAssociatedAssetsInputBody: Equatable {
}

extension ListAssociatedAssetsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAssociatedAssetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociatedAssetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociatedAssetsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociatedAssetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssociatedAssetsOutputResponse(assetSummaries: \(String(describing: assetSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssociatedAssetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssociatedAssetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assetSummaries = output.assetSummaries
            self.nextToken = output.nextToken
        } else {
            self.assetSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociatedAssetsOutputResponse: Equatable {
    /// <p>A list that summarizes the associated assets.</p>
    public let assetSummaries: [AssociatedAssetsSummary]?
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?

    public init (
        assetSummaries: [AssociatedAssetsSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.assetSummaries = assetSummaries
        self.nextToken = nextToken
    }
}

struct ListAssociatedAssetsOutputResponseBody: Equatable {
    public let assetSummaries: [AssociatedAssetsSummary]?
    public let nextToken: String?
}

extension ListAssociatedAssetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSummariesContainer = try containerValues.decodeIfPresent([AssociatedAssetsSummary?].self, forKey: .assetSummaries)
        var assetSummariesDecoded0:[AssociatedAssetsSummary]? = nil
        if let assetSummariesContainer = assetSummariesContainer {
            assetSummariesDecoded0 = [AssociatedAssetsSummary]()
            for structure0 in assetSummariesContainer {
                if let structure0 = structure0 {
                    assetSummariesDecoded0?.append(structure0)
                }
            }
        }
        assetSummaries = assetSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDashboardsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDashboardsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), projectId: \(String(describing: projectId)))"}
}

extension ListDashboardsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDashboardsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDashboardsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDashboardsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDashboardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDashboardsInput>
    public typealias MOutput = OperationOutput<ListDashboardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDashboardsOutputError>
}

public struct ListDashboardsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDashboardsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDashboardsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDashboardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let projectId = input.operationInput.projectId {
            let projectIdQueryItem = URLQueryItem(name: "projectId".urlPercentEncoding(), value: String(projectId).urlPercentEncoding())
            input.builder.withQueryItem(projectIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDashboardsInput>
    public typealias MOutput = OperationOutput<ListDashboardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDashboardsOutputError>
}

public struct ListDashboardsInput: Equatable {
    /// <p>The maximum number of results to be returned per paginated request.</p>
    ///          <p>Default: 50</p>
    public let maxResults: Int?
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?
    /// <p>The ID of the project.</p>
    public let projectId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        projectId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

struct ListDashboardsInputBody: Equatable {
}

extension ListDashboardsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDashboardsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDashboardsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDashboardsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDashboardsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDashboardsOutputResponse(dashboardSummaries: \(String(describing: dashboardSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDashboardsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDashboardsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dashboardSummaries = output.dashboardSummaries
            self.nextToken = output.nextToken
        } else {
            self.dashboardSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDashboardsOutputResponse: Equatable {
    /// <p>A list that summarizes each dashboard in the project.</p>
    public let dashboardSummaries: [DashboardSummary]?
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?

    public init (
        dashboardSummaries: [DashboardSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.dashboardSummaries = dashboardSummaries
        self.nextToken = nextToken
    }
}

struct ListDashboardsOutputResponseBody: Equatable {
    public let dashboardSummaries: [DashboardSummary]?
    public let nextToken: String?
}

extension ListDashboardsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dashboardSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardSummariesContainer = try containerValues.decodeIfPresent([DashboardSummary?].self, forKey: .dashboardSummaries)
        var dashboardSummariesDecoded0:[DashboardSummary]? = nil
        if let dashboardSummariesContainer = dashboardSummariesContainer {
            dashboardSummariesDecoded0 = [DashboardSummary]()
            for structure0 in dashboardSummariesContainer {
                if let structure0 = structure0 {
                    dashboardSummariesDecoded0?.append(structure0)
                }
            }
        }
        dashboardSummaries = dashboardSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGatewaysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGatewaysInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGatewaysInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListGatewaysInputHeadersMiddleware: Middleware {
    public let id: String = "ListGatewaysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGatewaysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGatewaysInput>
    public typealias MOutput = OperationOutput<ListGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGatewaysOutputError>
}

public struct ListGatewaysInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGatewaysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGatewaysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGatewaysInput>
    public typealias MOutput = OperationOutput<ListGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGatewaysOutputError>
}

public struct ListGatewaysInput: Equatable {
    /// <p>The maximum number of results to be returned per paginated request.</p>
    ///          <p>Default: 50</p>
    public let maxResults: Int?
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGatewaysInputBody: Equatable {
}

extension ListGatewaysInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListGatewaysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGatewaysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGatewaysOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGatewaysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGatewaysOutputResponse(gatewaySummaries: \(String(describing: gatewaySummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGatewaysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewaySummaries = output.gatewaySummaries
            self.nextToken = output.nextToken
        } else {
            self.gatewaySummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListGatewaysOutputResponse: Equatable {
    /// <p>A list that summarizes each gateway.</p>
    public let gatewaySummaries: [GatewaySummary]?
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?

    public init (
        gatewaySummaries: [GatewaySummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.gatewaySummaries = gatewaySummaries
        self.nextToken = nextToken
    }
}

struct ListGatewaysOutputResponseBody: Equatable {
    public let gatewaySummaries: [GatewaySummary]?
    public let nextToken: String?
}

extension ListGatewaysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewaySummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewaySummariesContainer = try containerValues.decodeIfPresent([GatewaySummary?].self, forKey: .gatewaySummaries)
        var gatewaySummariesDecoded0:[GatewaySummary]? = nil
        if let gatewaySummariesContainer = gatewaySummariesContainer {
            gatewaySummariesDecoded0 = [GatewaySummary]()
            for structure0 in gatewaySummariesContainer {
                if let structure0 = structure0 {
                    gatewaySummariesDecoded0?.append(structure0)
                }
            }
        }
        gatewaySummaries = gatewaySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPortalsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPortalsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPortalsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPortalsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPortalsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPortalsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPortalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPortalsInput>
    public typealias MOutput = OperationOutput<ListPortalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPortalsOutputError>
}

public struct ListPortalsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPortalsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPortalsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPortalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPortalsInput>
    public typealias MOutput = OperationOutput<ListPortalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPortalsOutputError>
}

public struct ListPortalsInput: Equatable {
    /// <p>The maximum number of results to be returned per paginated request.</p>
    ///          <p>Default: 50</p>
    public let maxResults: Int?
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPortalsInputBody: Equatable {
}

extension ListPortalsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPortalsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPortalsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPortalsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPortalsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPortalsOutputResponse(nextToken: \(String(describing: nextToken)), portalSummaries: \(String(describing: portalSummaries)))"}
}

extension ListPortalsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPortalsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.portalSummaries = output.portalSummaries
        } else {
            self.nextToken = nil
            self.portalSummaries = nil
        }
    }
}

public struct ListPortalsOutputResponse: Equatable {
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?
    /// <p>A list that summarizes each portal.</p>
    public let portalSummaries: [PortalSummary]?

    public init (
        nextToken: String? = nil,
        portalSummaries: [PortalSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.portalSummaries = portalSummaries
    }
}

struct ListPortalsOutputResponseBody: Equatable {
    public let portalSummaries: [PortalSummary]?
    public let nextToken: String?
}

extension ListPortalsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case portalSummaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalSummariesContainer = try containerValues.decodeIfPresent([PortalSummary?].self, forKey: .portalSummaries)
        var portalSummariesDecoded0:[PortalSummary]? = nil
        if let portalSummariesContainer = portalSummariesContainer {
            portalSummariesDecoded0 = [PortalSummary]()
            for structure0 in portalSummariesContainer {
                if let structure0 = structure0 {
                    portalSummariesDecoded0?.append(structure0)
                }
            }
        }
        portalSummaries = portalSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectAssetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProjectAssetsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), projectId: \(String(describing: projectId)))"}
}

extension ListProjectAssetsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListProjectAssetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProjectAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectAssetsInput>
    public typealias MOutput = OperationOutput<ListProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectAssetsOutputError>
}

public struct ListProjectAssetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProjectAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectAssetsInput>
    public typealias MOutput = OperationOutput<ListProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectAssetsOutputError>
}

public struct ListProjectAssetsInput: Equatable {
    /// <p>The maximum number of results to be returned per paginated request.</p>
    ///          <p>Default: 50</p>
    public let maxResults: Int?
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?
    /// <p>The ID of the project.</p>
    public let projectId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        projectId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

struct ListProjectAssetsInputBody: Equatable {
}

extension ListProjectAssetsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListProjectAssetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectAssetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProjectAssetsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectAssetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProjectAssetsOutputResponse(assetIds: \(String(describing: assetIds)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProjectAssetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProjectAssetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assetIds = output.assetIds
            self.nextToken = output.nextToken
        } else {
            self.assetIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListProjectAssetsOutputResponse: Equatable {
    /// <p>A list that contains the IDs of each asset associated with the project.</p>
    public let assetIds: [String]?
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?

    public init (
        assetIds: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.assetIds = assetIds
        self.nextToken = nextToken
    }
}

struct ListProjectAssetsOutputResponseBody: Equatable {
    public let assetIds: [String]?
    public let nextToken: String?
}

extension ListProjectAssetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetIds
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .assetIds)
        var assetIdsDecoded0:[String]? = nil
        if let assetIdsContainer = assetIdsContainer {
            assetIdsDecoded0 = [String]()
            for string0 in assetIdsContainer {
                if let string0 = string0 {
                    assetIdsDecoded0?.append(string0)
                }
            }
        }
        assetIds = assetIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProjectsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), portalId: \(String(describing: portalId)))"}
}

extension ListProjectsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListProjectsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let portalId = input.operationInput.portalId {
            let portalIdQueryItem = URLQueryItem(name: "portalId".urlPercentEncoding(), value: String(portalId).urlPercentEncoding())
            input.builder.withQueryItem(portalIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

public struct ListProjectsInput: Equatable {
    /// <p>The maximum number of results to be returned per paginated request.</p>
    ///          <p>Default: 50</p>
    public let maxResults: Int?
    /// <p>The token to be used for the next set of paginated results.</p>
    public let nextToken: String?
    /// <p>The ID of the portal.</p>
    public let portalId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        portalId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.portalId = portalId
    }
}

struct ListProjectsInputBody: Equatable {
}

extension ListProjectsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListProjectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProjectsOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProjectsOutputResponse(nextToken: \(String(describing: nextToken)), projectSummaries: \(String(describing: projectSummaries)))"}
}

extension ListProjectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.projectSummaries = output.projectSummaries
        } else {
            self.nextToken = nil
            self.projectSummaries = nil
        }
    }
}

public struct ListProjectsOutputResponse: Equatable {
    /// <p>The token for the next set of results, or null if there are no additional results.</p>
    public let nextToken: String?
    /// <p>A list that summarizes each project in the portal.</p>
    public let projectSummaries: [ProjectSummary]?

    public init (
        nextToken: String? = nil,
        projectSummaries: [ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projectSummaries = projectSummaries
    }
}

struct ListProjectsOutputResponseBody: Equatable {
    public let projectSummaries: [ProjectSummary]?
    public let nextToken: String?
}

extension ListProjectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case projectSummaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectSummariesContainer = try containerValues.decodeIfPresent([ProjectSummary?].self, forKey: .projectSummaries)
        var projectSummariesDecoded0:[ProjectSummary]? = nil
        if let projectSummariesContainer = projectSummariesContainer {
            projectSummariesDecoded0 = [ProjectSummary]()
            for structure0 in projectSummariesContainer {
                if let structure0 = structure0 {
                    projectSummariesDecoded0?.append(structure0)
                }
            }
        }
        projectSummaries = projectSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The list of key-value pairs that contain metadata for the resource. For more information,
    ///       see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your AWS IoT SiteWise
    ///         resources</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum LoggingLevel {
    case error
    case info
    case off
    case sdkUnknown(String)
}

extension LoggingLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LoggingLevel] {
        return [
            .error,
            .info,
            .off,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .error: return "ERROR"
        case .info: return "INFO"
        case .off: return "OFF"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LoggingLevel(rawValue: rawValue) ?? LoggingLevel.sdkUnknown(rawValue)
    }
}

extension LoggingOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case level
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let level = level {
            try encodeContainer.encode(level.rawValue, forKey: .level)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let levelDecoded = try containerValues.decodeIfPresent(LoggingLevel.self, forKey: .level)
        level = levelDecoded
    }
}

extension LoggingOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoggingOptions(level: \(String(describing: level)))"}
}

/// <p>Contains logging options.</p>
public struct LoggingOptions: Equatable {
    /// <p>The AWS IoT SiteWise logging verbosity level.</p>
    public let level: LoggingLevel?

    public init (
        level: LoggingLevel? = nil
    )
    {
        self.level = level
    }
}

extension Measurement: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension Measurement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Measurement()"}
}

/// <p>Contains an asset measurement property. For more information, see
///       <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#measurements">Measurements</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
public struct Measurement: Equatable {

    public init() {}
}

extension Metric: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expression
        case variables
        case window
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variables)
            for expressionvariables0 in variables {
                try variablesContainer.encode(expressionvariables0)
            }
        }
        if let window = window {
            try encodeContainer.encode(window, forKey: .window)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let variablesContainer = try containerValues.decodeIfPresent([ExpressionVariable?].self, forKey: .variables)
        var variablesDecoded0:[ExpressionVariable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [ExpressionVariable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let windowDecoded = try containerValues.decodeIfPresent(MetricWindow.self, forKey: .window)
        window = windowDecoded
    }
}

extension Metric: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Metric(expression: \(String(describing: expression)), variables: \(String(describing: variables)), window: \(String(describing: window)))"}
}

/// <p>Contains an asset metric property. With metrics, you can calculate aggregate functions,
///       such as an average, maximum, or minimum, as specified through an expression. A metric maps
///       several values to a single value (such as a sum).</p>
///          <p>The maximum number of dependent/cascading variables used in any one metric calculation is
///       10. Therefore, a <i>root</i> metric can have
///       up to 10 cascading metrics in its computational dependency
///       tree. Additionally, a metric can only have a data type of <code>DOUBLE</code> and consume
///       properties with data types of <code>INTEGER</code> or <code>DOUBLE</code>.</p>
///          <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#metrics">Metrics</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
public struct Metric: Equatable {
    /// <p>The mathematical expression that defines the metric aggregation function. You can specify
    ///       up to 10 variables per expression. You can specify up to 10 functions
    ///       per expression. </p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let expression: String?
    /// <p>The list of variables used in the expression.</p>
    public let variables: [ExpressionVariable]?
    /// <p>The window (time interval) over which AWS IoT SiteWise computes the metric's aggregation expression.
    ///       AWS IoT SiteWise computes one data point per <code>window</code>.</p>
    public let window: MetricWindow?

    public init (
        expression: String? = nil,
        variables: [ExpressionVariable]? = nil,
        window: MetricWindow? = nil
    )
    {
        self.expression = expression
        self.variables = variables
        self.window = window
    }
}

extension MetricWindow: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tumbling
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tumbling = tumbling {
            try encodeContainer.encode(tumbling, forKey: .tumbling)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tumblingDecoded = try containerValues.decodeIfPresent(TumblingWindow.self, forKey: .tumbling)
        tumbling = tumblingDecoded
    }
}

extension MetricWindow: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricWindow(tumbling: \(String(describing: tumbling)))"}
}

/// <p>Contains a time interval window used for data aggregate computations (for example,
///       average, sum, count, and so on).</p>
public struct MetricWindow: Equatable {
    /// <p>The tumbling time interval window.</p>
    public let tumbling: TumblingWindow?

    public init (
        tumbling: TumblingWindow? = nil
    )
    {
        self.tumbling = tumbling
    }
}

public enum MonitorErrorCode {
    case internalFailure
    case limitExceeded
    case validationError
    case sdkUnknown(String)
}

extension MonitorErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MonitorErrorCode] {
        return [
            .internalFailure,
            .limitExceeded,
            .validationError,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .internalFailure: return "INTERNAL_FAILURE"
        case .limitExceeded: return "LIMIT_EXCEEDED"
        case .validationError: return "VALIDATION_ERROR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MonitorErrorCode(rawValue: rawValue) ?? MonitorErrorCode.sdkUnknown(rawValue)
    }
}

extension MonitorErrorDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(MonitorErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MonitorErrorDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MonitorErrorDetails(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

/// <p>Contains AWS IoT SiteWise Monitor error details.</p>
public struct MonitorErrorDetails: Equatable {
    /// <p>The error code.</p>
    public let code: MonitorErrorCode?
    /// <p>The error message.</p>
    public let message: String?

    public init (
        code: MonitorErrorCode? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

public enum Permission {
    case administrator
    case viewer
    case sdkUnknown(String)
}

extension Permission : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Permission] {
        return [
            .administrator,
            .viewer,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .administrator: return "ADMINISTRATOR"
        case .viewer: return "VIEWER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
    }
}

extension PortalResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension PortalResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortalResource(id: \(String(describing: id)))"}
}

/// <p>Identifies an AWS IoT SiteWise Monitor portal.</p>
public struct PortalResource: Equatable {
    /// <p>The ID of the portal.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

public enum PortalState {
    case active
    case creating
    case deleting
    case failed
    case updating
    case sdkUnknown(String)
}

extension PortalState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PortalState] {
        return [
            .active,
            .creating,
            .deleting,
            .failed,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PortalState(rawValue: rawValue) ?? PortalState.sdkUnknown(rawValue)
    }
}

extension PortalStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(PortalState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(MonitorErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension PortalStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortalStatus(error: \(String(describing: error)), state: \(String(describing: state)))"}
}

/// <p>Contains information about the current status of a portal.</p>
public struct PortalStatus: Equatable {
    /// <p>Contains associated error information, if any.</p>
    public let error: MonitorErrorDetails?
    /// <p>The current state of the portal.</p>
    public let state: PortalState?

    public init (
        error: MonitorErrorDetails? = nil,
        state: PortalState? = nil
    )
    {
        self.error = error
        self.state = state
    }
}

extension PortalSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case description
        case id
        case lastUpdateDate
        case name
        case roleArn
        case startUrl
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = lastUpdateDate {
            try encodeContainer.encode(lastUpdateDate.timeIntervalSince1970, forKey: .lastUpdateDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let startUrl = startUrl {
            try encodeContainer.encode(startUrl, forKey: .startUrl)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let startUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startUrl)
        startUrl = startUrlDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PortalStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension PortalSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortalSummary(creationDate: \(String(describing: creationDate)), description: \(String(describing: description)), id: \(String(describing: id)), lastUpdateDate: \(String(describing: lastUpdateDate)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), startUrl: \(String(describing: startUrl)), status: \(String(describing: status)))"}
}

/// <p>Contains a portal summary.</p>
public struct PortalSummary: Equatable {
    /// <p>The date the portal was created, in Unix epoch time.</p>
    public let creationDate: Date?
    /// <p>The portal's description.</p>
    public let description: String?
    /// <p>The ID of the portal.</p>
    public let id: String?
    /// <p>The date the portal was last updated, in Unix epoch time.</p>
    public let lastUpdateDate: Date?
    /// <p>The name of the portal.</p>
    public let name: String?
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the service role that allows the portal's users to access your AWS IoT SiteWise
    ///       resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for AWS IoT SiteWise Monitor</a> in the
    ///         <i>AWS IoT SiteWise User Guide</i>.</p>
    public let roleArn: String?
    /// <p>The URL for the AWS IoT SiteWise Monitor portal. You can use this URL to access portals that
    ///       use AWS SSO for authentication. For portals that use IAM for authentication, you must use the
    ///       AWS IoT SiteWise console to get a URL that you can use to access the portal.</p>
    public let startUrl: String?
    /// <p>Contains information about the current status of a portal.</p>
    public let status: PortalStatus?

    public init (
        creationDate: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        lastUpdateDate: Date? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        startUrl: String? = nil,
        status: PortalStatus? = nil
    )
    {
        self.creationDate = creationDate
        self.description = description
        self.id = id
        self.lastUpdateDate = lastUpdateDate
        self.name = name
        self.roleArn = roleArn
        self.startUrl = startUrl
        self.status = status
    }
}

extension ProjectResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension ProjectResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectResource(id: \(String(describing: id)))"}
}

/// <p>Identifies a specific AWS IoT SiteWise Monitor project.</p>
public struct ProjectResource: Equatable {
    /// <p>The ID of the project.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

extension ProjectSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate
        case description
        case id
        case lastUpdateDate
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = lastUpdateDate {
            try encodeContainer.encode(lastUpdateDate.timeIntervalSince1970, forKey: .lastUpdateDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension ProjectSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectSummary(creationDate: \(String(describing: creationDate)), description: \(String(describing: description)), id: \(String(describing: id)), lastUpdateDate: \(String(describing: lastUpdateDate)), name: \(String(describing: name)))"}
}

/// <p>Contains project summary information.</p>
public struct ProjectSummary: Equatable {
    /// <p>The date the project was created, in Unix epoch time.</p>
    public let creationDate: Date?
    /// <p>The project's description.</p>
    public let description: String?
    /// <p>The ID of the project.</p>
    public let id: String?
    /// <p>The date the project was last updated, in Unix epoch time.</p>
    public let lastUpdateDate: Date?
    /// <p>The name of the project.</p>
    public let name: String?

    public init (
        creationDate: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        lastUpdateDate: Date? = nil,
        name: String? = nil
    )
    {
        self.creationDate = creationDate
        self.description = description
        self.id = id
        self.lastUpdateDate = lastUpdateDate
        self.name = name
    }
}

extension Property: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alias
        case dataType
        case id
        case name
        case notification
        case type
        case unit
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(PropertyNotification.self, forKey: .notification)
        notification = notificationDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let unitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unit)
        unit = unitDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PropertyType.self, forKey: .type)
        type = typeDecoded
    }
}

extension Property: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Property(alias: \(String(describing: alias)), dataType: \(String(describing: dataType)), id: \(String(describing: id)), name: \(String(describing: name)), notification: \(String(describing: notification)), type: \(String(describing: type)), unit: \(String(describing: unit)))"}
}

/// <p>Contains asset property information.</p>
public struct Property: Equatable {
    /// <p>The property alias that identifies the property, such as an OPC-UA server data stream path
    ///         (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the
    ///         <i>AWS IoT SiteWise User Guide</i>.</p>
    public let alias: String?
    /// <p>The property data type.</p>
    public let dataType: PropertyDataType?
    /// <p>The ID of the asset property.</p>
    public let id: String?
    /// <p>The name of the property.</p>
    public let name: String?
    /// <p>The asset property's notification topic and state. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html">UpdateAssetProperty</a>.</p>
    public let notification: PropertyNotification?
    /// <p>The property type (see <code>PropertyType</code>). A property contains one type.</p>
    public let type: PropertyType?
    /// <p>The unit (such as <code>Newtons</code> or <code>RPM</code>) of the asset property.</p>
    public let unit: String?

    public init (
        alias: String? = nil,
        dataType: PropertyDataType? = nil,
        id: String? = nil,
        name: String? = nil,
        notification: PropertyNotification? = nil,
        type: PropertyType? = nil,
        unit: String? = nil
    )
    {
        self.alias = alias
        self.dataType = dataType
        self.id = id
        self.name = name
        self.notification = notification
        self.type = type
        self.unit = unit
    }
}

public enum PropertyDataType {
    case boolean
    case double
    case integer
    case string
    case `struct`
    case sdkUnknown(String)
}

extension PropertyDataType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PropertyDataType] {
        return [
            .boolean,
            .double,
            .integer,
            .string,
            .struct,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .boolean: return "BOOLEAN"
        case .double: return "DOUBLE"
        case .integer: return "INTEGER"
        case .string: return "STRING"
        case .struct: return "STRUCT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PropertyDataType(rawValue: rawValue) ?? PropertyDataType.sdkUnknown(rawValue)
    }
}

extension PropertyNotification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case state
        case topic
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let topic = topic {
            try encodeContainer.encode(topic, forKey: .topic)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topic)
        topic = topicDecoded
        let stateDecoded = try containerValues.decodeIfPresent(PropertyNotificationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension PropertyNotification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PropertyNotification(state: \(String(describing: state)), topic: \(String(describing: topic)))"}
}

/// <p>Contains asset property value notification information. When the notification state is enabled, AWS IoT SiteWise publishes property value
///       updates to a unique MQTT topic. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html">Interacting with other services</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
public struct PropertyNotification: Equatable {
    /// <p>The current notification state.</p>
    public let state: PropertyNotificationState?
    /// <p>The MQTT topic to which AWS IoT SiteWise publishes property value update notifications.</p>
    public let topic: String?

    public init (
        state: PropertyNotificationState? = nil,
        topic: String? = nil
    )
    {
        self.state = state
        self.topic = topic
    }
}

public enum PropertyNotificationState {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension PropertyNotificationState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PropertyNotificationState] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PropertyNotificationState(rawValue: rawValue) ?? PropertyNotificationState.sdkUnknown(rawValue)
    }
}

extension PropertyType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attribute
        case measurement
        case metric
        case transform
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
        if let measurement = measurement {
            try encodeContainer.encode(measurement, forKey: .measurement)
        }
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let transform = transform {
            try encodeContainer.encode(transform, forKey: .transform)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(Attribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let measurementDecoded = try containerValues.decodeIfPresent(Measurement.self, forKey: .measurement)
        measurement = measurementDecoded
        let transformDecoded = try containerValues.decodeIfPresent(Transform.self, forKey: .transform)
        transform = transformDecoded
        let metricDecoded = try containerValues.decodeIfPresent(Metric.self, forKey: .metric)
        metric = metricDecoded
    }
}

extension PropertyType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PropertyType(attribute: \(String(describing: attribute)), measurement: \(String(describing: measurement)), metric: \(String(describing: metric)), transform: \(String(describing: transform)))"}
}

/// <p>Contains a property type, which can be one of <code>attribute</code>,
///         <code>measurement</code>, <code>metric</code>, or <code>transform</code>.</p>
public struct PropertyType: Equatable {
    /// <p>Specifies an asset attribute property. An attribute generally contains static information,
    ///       such as the serial number of an <a href="https://en.wikipedia.org/wiki/Internet_of_things#Industrial_applications">IIoT</a> wind turbine.</p>
    public let attribute: Attribute?
    /// <p>Specifies an asset measurement property. A measurement represents a device's raw sensor
    ///       data stream, such as timestamped temperature values or timestamped power values.</p>
    public let measurement: Measurement?
    /// <p>Specifies an asset metric property. A metric contains a mathematical expression that uses
    ///       aggregate functions to process all input data points over a time interval and output a single
    ///       data point, such as to calculate the average hourly temperature.</p>
    public let metric: Metric?
    /// <p>Specifies an asset transform property. A transform contains a mathematical expression that
    ///       maps a property's data points from one form to another, such as a unit conversion from Celsius
    ///       to Fahrenheit.</p>
    public let transform: Transform?

    public init (
        attribute: Attribute? = nil,
        measurement: Measurement? = nil,
        metric: Metric? = nil,
        transform: Transform? = nil
    )
    {
        self.attribute = attribute
        self.measurement = measurement
        self.metric = metric
        self.transform = transform
    }
}

extension PutAssetPropertyValueEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetId
        case entryId
        case propertyAlias
        case propertyId
        case propertyValues
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let entryId = entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let propertyAlias = propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyId = propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
        if let propertyValues = propertyValues {
            var propertyValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyValues)
            for assetpropertyvalues0 in propertyValues {
                try propertyValuesContainer.encode(assetpropertyvalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let propertyAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
        let propertyValuesContainer = try containerValues.decodeIfPresent([AssetPropertyValue?].self, forKey: .propertyValues)
        var propertyValuesDecoded0:[AssetPropertyValue]? = nil
        if let propertyValuesContainer = propertyValuesContainer {
            propertyValuesDecoded0 = [AssetPropertyValue]()
            for structure0 in propertyValuesContainer {
                if let structure0 = structure0 {
                    propertyValuesDecoded0?.append(structure0)
                }
            }
        }
        propertyValues = propertyValuesDecoded0
    }
}

extension PutAssetPropertyValueEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAssetPropertyValueEntry(assetId: \(String(describing: assetId)), entryId: \(String(describing: entryId)), propertyAlias: \(String(describing: propertyAlias)), propertyId: \(String(describing: propertyId)), propertyValues: \(String(describing: propertyValues)))"}
}

/// <p>Contains a list of value updates for an asset property in the list of asset entries
///       consumed by the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchPutAssetPropertyValue.html">BatchPutAssetPropertyValue</a> API
///       operation.</p>
public struct PutAssetPropertyValueEntry: Equatable {
    /// <p>The ID of the asset to update.</p>
    public let assetId: String?
    /// <p>The user specified ID for the entry. You can use this ID to identify which entries
    ///       failed.</p>
    public let entryId: String?
    /// <p>The property alias that identifies the property, such as an OPC-UA server data stream path
    ///         (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the
    ///         <i>AWS IoT SiteWise User Guide</i>.</p>
    public let propertyAlias: String?
    /// <p>The ID of the asset property for this entry.</p>
    public let propertyId: String?
    /// <p>The list of property values to upload. You can specify up to 10
    ///         <code>propertyValues</code> array elements. </p>
    public let propertyValues: [AssetPropertyValue]?

    public init (
        assetId: String? = nil,
        entryId: String? = nil,
        propertyAlias: String? = nil,
        propertyId: String? = nil,
        propertyValues: [AssetPropertyValue]? = nil
    )
    {
        self.assetId = assetId
        self.entryId = entryId
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.propertyValues = propertyValues
    }
}

public struct PutDefaultEncryptionConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutDefaultEncryptionConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDefaultEncryptionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDefaultEncryptionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDefaultEncryptionConfigurationInput>
    public typealias MOutput = OperationOutput<PutDefaultEncryptionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDefaultEncryptionConfigurationOutputError>
}

extension PutDefaultEncryptionConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDefaultEncryptionConfigurationInput(encryptionType: \(String(describing: encryptionType)), kmsKeyId: \(String(describing: kmsKeyId)))"}
}

extension PutDefaultEncryptionConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionType
        case kmsKeyId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }
}

public struct PutDefaultEncryptionConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutDefaultEncryptionConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDefaultEncryptionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDefaultEncryptionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDefaultEncryptionConfigurationInput>
    public typealias MOutput = OperationOutput<PutDefaultEncryptionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDefaultEncryptionConfigurationOutputError>
}

public struct PutDefaultEncryptionConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutDefaultEncryptionConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutDefaultEncryptionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutDefaultEncryptionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutDefaultEncryptionConfigurationInput>
    public typealias MOutput = OperationOutput<PutDefaultEncryptionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutDefaultEncryptionConfigurationOutputError>
}

public struct PutDefaultEncryptionConfigurationInput: Equatable {
    /// <p>The type of encryption used for the encryption configuration.</p>
    public let encryptionType: EncryptionType?
    /// <p>The Key ID of the customer managed customer master key (CMK) used for AWS KMS encryption. This is required if you use
    ///       <code>KMS_BASED_ENCRYPTION</code>.</p>
    public let kmsKeyId: String?

    public init (
        encryptionType: EncryptionType? = nil,
        kmsKeyId: String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.kmsKeyId = kmsKeyId
    }
}

struct PutDefaultEncryptionConfigurationInputBody: Equatable {
    public let encryptionType: EncryptionType?
    public let kmsKeyId: String?
}

extension PutDefaultEncryptionConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionType
        case kmsKeyId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension PutDefaultEncryptionConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDefaultEncryptionConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDefaultEncryptionConfigurationOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDefaultEncryptionConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutDefaultEncryptionConfigurationOutputResponse(configurationStatus: \(String(describing: configurationStatus)), encryptionType: \(String(describing: encryptionType)), kmsKeyArn: \(String(describing: kmsKeyArn)))"}
}

extension PutDefaultEncryptionConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutDefaultEncryptionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationStatus = output.configurationStatus
            self.encryptionType = output.encryptionType
            self.kmsKeyArn = output.kmsKeyArn
        } else {
            self.configurationStatus = nil
            self.encryptionType = nil
            self.kmsKeyArn = nil
        }
    }
}

public struct PutDefaultEncryptionConfigurationOutputResponse: Equatable {
    /// <p>The status of the account configuration. This contains the
    ///       <code>ConfigurationState</code>. If there is an error, it also contains the
    ///         <code>ErrorDetails</code>.</p>
    public let configurationStatus: ConfigurationStatus?
    /// <p>The type of encryption used for the encryption configuration.</p>
    public let encryptionType: EncryptionType?
    /// <p>The Key ARN of the AWS KMS CMK used for AWS KMS encryption if you use
    ///       <code>KMS_BASED_ENCRYPTION</code>.</p>
    public let kmsKeyArn: String?

    public init (
        configurationStatus: ConfigurationStatus? = nil,
        encryptionType: EncryptionType? = nil,
        kmsKeyArn: String? = nil
    )
    {
        self.configurationStatus = configurationStatus
        self.encryptionType = encryptionType
        self.kmsKeyArn = kmsKeyArn
    }
}

struct PutDefaultEncryptionConfigurationOutputResponseBody: Equatable {
    public let encryptionType: EncryptionType?
    public let kmsKeyArn: String?
    public let configurationStatus: ConfigurationStatus?
}

extension PutDefaultEncryptionConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationStatus
        case encryptionType
        case kmsKeyArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let configurationStatusDecoded = try containerValues.decodeIfPresent(ConfigurationStatus.self, forKey: .configurationStatus)
        configurationStatus = configurationStatusDecoded
    }
}

public struct PutLoggingOptionsInputBodyMiddleware: Middleware {
    public let id: String = "PutLoggingOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLoggingOptionsInput>
    public typealias MOutput = OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLoggingOptionsOutputError>
}

extension PutLoggingOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLoggingOptionsInput(loggingOptions: \(String(describing: loggingOptions)))"}
}

extension PutLoggingOptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case loggingOptions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingOptions = loggingOptions {
            try encodeContainer.encode(loggingOptions, forKey: .loggingOptions)
        }
    }
}

public struct PutLoggingOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "PutLoggingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLoggingOptionsInput>
    public typealias MOutput = OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLoggingOptionsOutputError>
}

public struct PutLoggingOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutLoggingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLoggingOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLoggingOptionsInput>
    public typealias MOutput = OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLoggingOptionsOutputError>
}

public struct PutLoggingOptionsInput: Equatable {
    /// <p>The logging options to set.</p>
    public let loggingOptions: LoggingOptions?

    public init (
        loggingOptions: LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

struct PutLoggingOptionsInputBody: Equatable {
    public let loggingOptions: LoggingOptions?
}

extension PutLoggingOptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loggingOptions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsDecoded = try containerValues.decodeIfPresent(LoggingOptions.self, forKey: .loggingOptions)
        loggingOptions = loggingOptionsDecoded
    }
}

extension PutLoggingOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLoggingOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLoggingOptionsOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLoggingOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLoggingOptionsOutputResponse()"}
}

extension PutLoggingOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutLoggingOptionsOutputResponse: Equatable {

    public init() {}
}

struct PutLoggingOptionsOutputResponseBody: Equatable {
}

extension PutLoggingOptionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum Quality {
    case bad
    case good
    case uncertain
    case sdkUnknown(String)
}

extension Quality : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Quality] {
        return [
            .bad,
            .good,
            .uncertain,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bad: return "BAD"
        case .good: return "GOOD"
        case .uncertain: return "UNCERTAIN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Quality(rawValue: rawValue) ?? Quality.sdkUnknown(rawValue)
    }
}

extension Resource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case portal
        case project
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let portal = portal {
            try encodeContainer.encode(portal, forKey: .portal)
        }
        if let project = project {
            try encodeContainer.encode(project, forKey: .project)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalDecoded = try containerValues.decodeIfPresent(PortalResource.self, forKey: .portal)
        portal = portalDecoded
        let projectDecoded = try containerValues.decodeIfPresent(ProjectResource.self, forKey: .project)
        project = projectDecoded
    }
}

extension Resource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Resource(portal: \(String(describing: portal)), project: \(String(describing: project)))"}
}

/// <p>Contains an AWS IoT SiteWise Monitor resource ID for a portal or project.</p>
public struct Resource: Equatable {
    /// <p>A portal resource.</p>
    public let portal: PortalResource?
    /// <p>A project resource.</p>
    public let project: ProjectResource?

    public init (
        portal: PortalResource? = nil,
        project: ProjectResource? = nil
    )
    {
        self.portal = portal
        self.project = project
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)), resourceArn: \(String(describing: resourceArn)), resourceId: \(String(describing: resourceId)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceArn = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource already exists.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The ARN of the resource that already exists.</p>
    public var resourceArn: String?
    /// <p>The ID of the resource that already exists.</p>
    public var resourceId: String?

    public init (
        message: String? = nil,
        resourceArn: String? = nil,
        resourceId: String? = nil
    )
    {
        self.message = message
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceArn: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceArn
        case resourceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource can't be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ResourceType {
    case portal
    case project
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .portal,
            .project,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .portal: return "PORTAL"
        case .project: return "PROJECT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested service is unavailable.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the resource to tag.</p>
    public let resourceArn: String?
    /// <p>A list of key-value pairs that contain metadata for the resource. For more information,
    ///       see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your AWS IoT SiteWise
    ///         resources</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case tooManyTagsException(TooManyTagsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request exceeded a rate limit. For example, you might have exceeded the number of
///       AWS IoT SiteWise assets that can be created per second, the allowed number of messages per second, and so
///       on.</p>
///          <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimeInNanos: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case offsetInNanos
        case timeInSeconds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offsetInNanos = offsetInNanos {
            try encodeContainer.encode(offsetInNanos, forKey: .offsetInNanos)
        }
        if let timeInSeconds = timeInSeconds {
            try encodeContainer.encode(timeInSeconds, forKey: .timeInSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeInSeconds)
        timeInSeconds = timeInSecondsDecoded
        let offsetInNanosDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .offsetInNanos)
        offsetInNanos = offsetInNanosDecoded
    }
}

extension TimeInNanos: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimeInNanos(offsetInNanos: \(String(describing: offsetInNanos)), timeInSeconds: \(String(describing: timeInSeconds)))"}
}

/// <p>Contains a timestamp with optional nanosecond granularity.</p>
public struct TimeInNanos: Equatable {
    /// <p>The nanosecond offset from <code>timeInSeconds</code>.</p>
    public let offsetInNanos: Int?
    /// <p>The timestamp date, in seconds, in the Unix epoch format. Fractional nanosecond data is
    ///       provided by <code>offsetInNanos</code>.</p>
    public let timeInSeconds: Int?

    public init (
        offsetInNanos: Int? = nil,
        timeInSeconds: Int? = nil
    )
    {
        self.offsetInNanos = offsetInNanos
        self.timeInSeconds = timeInSeconds
    }
}

public enum TimeOrdering {
    case ascending
    case descending
    case sdkUnknown(String)
}

extension TimeOrdering : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TimeOrdering] {
        return [
            .ascending,
            .descending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascending: return "ASCENDING"
        case .descending: return "DESCENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TimeOrdering(rawValue: rawValue) ?? TimeOrdering.sdkUnknown(rawValue)
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)), resourceName: \(String(describing: resourceName)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit for the number of tags allowed for a resource. For more
///       information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html#tag-conventions">Tag naming limits and
///         requirements</a> in the <i>AWS General Reference</i>.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The name of the resource with too many tags.</p>
    public var resourceName: String?

    public init (
        message: String? = nil,
        resourceName: String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
    public let resourceName: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension Transform: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expression
        case variables
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variables)
            for expressionvariables0 in variables {
                try variablesContainer.encode(expressionvariables0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let variablesContainer = try containerValues.decodeIfPresent([ExpressionVariable?].self, forKey: .variables)
        var variablesDecoded0:[ExpressionVariable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [ExpressionVariable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
    }
}

extension Transform: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Transform(expression: \(String(describing: expression)), variables: \(String(describing: variables)))"}
}

/// <p>Contains an asset transform property. A transform is a one-to-one mapping of a property's
///       data points from one form to another. For example, you can use a transform to convert a
///       Celsius data stream to Fahrenheit by applying the transformation expression to each data point
///       of the Celsius stream. A transform can only have a data type of <code>DOUBLE</code> and
///       consume properties with data types of <code>INTEGER</code> or <code>DOUBLE</code>.</p>
///          <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#transforms">Transforms</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
public struct Transform: Equatable {
    /// <p>The mathematical expression that defines the transformation function. You can specify up
    ///       to 10 variables per expression. You can specify up to 10 functions per
    ///       expression. </p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let expression: String?
    /// <p>The list of variables used in the expression.</p>
    public let variables: [ExpressionVariable]?

    public init (
        expression: String? = nil,
        variables: [ExpressionVariable]? = nil
    )
    {
        self.expression = expression
        self.variables = variables
    }
}

public enum TraversalDirection {
    case child
    case parent
    case sdkUnknown(String)
}

extension TraversalDirection : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TraversalDirection] {
        return [
            .child,
            .parent,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .child: return "CHILD"
        case .parent: return "PARENT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TraversalDirection(rawValue: rawValue) ?? TraversalDirection.sdkUnknown(rawValue)
    }
}

public enum TraversalType {
    case pathToRoot
    case sdkUnknown(String)
}

extension TraversalType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TraversalType] {
        return [
            .pathToRoot,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .pathToRoot: return "PATH_TO_ROOT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TraversalType(rawValue: rawValue) ?? TraversalType.sdkUnknown(rawValue)
    }
}

extension TumblingWindow: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case interval
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interval = interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intervalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .interval)
        interval = intervalDecoded
    }
}

extension TumblingWindow: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TumblingWindow(interval: \(String(describing: interval)))"}
}

/// <p>Contains a tumbling window, which is a repeating fixed-sized, non-overlapping, and
///       contiguous time interval. This window is used in metric and aggregation computations.</p>
public struct TumblingWindow: Equatable {
    /// <p>The time interval for the tumbling window. Note that <code>w</code> represents weeks,
    ///         <code>d</code> represents days, <code>h</code> represents hours, and <code>m</code>
    ///       represents minutes. AWS IoT SiteWise computes the <code>1w</code> interval the end of Sunday at midnight
    ///       each week (UTC), the <code>1d</code> interval at the end of each day at midnight (UTC), the
    ///         <code>1h</code> interval at the end of each hour, and so on. </p>
    ///          <p>When AWS IoT SiteWise aggregates data points for metric computations, the start of each interval is
    ///       exclusive and the end of each interval is inclusive. AWS IoT SiteWise places the computed data point at
    ///       the end of the interval.</p>
    public let interval: String?

    public init (
        interval: String? = nil
    )
    {
        self.interval = interval
    }
}

extension UnauthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedException(message: \(String(describing: message)))"}
}

extension UnauthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You are not authorized.</p>
public struct UnauthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Equatable {
    public let message: String?
}

extension UnauthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of the resource to untag.</p>
    public let resourceArn: String?
    /// <p>A list of keys for tags to remove from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAccessPolicyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAccessPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccessPolicyInput>
    public typealias MOutput = OperationOutput<UpdateAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccessPolicyOutputError>
}

extension UpdateAccessPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAccessPolicyInput(accessPolicyId: \(String(describing: accessPolicyId)), accessPolicyIdentity: \(String(describing: accessPolicyIdentity)), accessPolicyPermission: \(String(describing: accessPolicyPermission)), accessPolicyResource: \(String(describing: accessPolicyResource)), clientToken: \(String(describing: clientToken)))"}
}

extension UpdateAccessPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessPolicyIdentity
        case accessPolicyPermission
        case accessPolicyResource
        case clientToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPolicyIdentity = accessPolicyIdentity {
            try encodeContainer.encode(accessPolicyIdentity, forKey: .accessPolicyIdentity)
        }
        if let accessPolicyPermission = accessPolicyPermission {
            try encodeContainer.encode(accessPolicyPermission.rawValue, forKey: .accessPolicyPermission)
        }
        if let accessPolicyResource = accessPolicyResource {
            try encodeContainer.encode(accessPolicyResource, forKey: .accessPolicyResource)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct UpdateAccessPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccessPolicyInput>
    public typealias MOutput = OperationOutput<UpdateAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccessPolicyOutputError>
}

public struct UpdateAccessPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccessPolicyInput>
    public typealias MOutput = OperationOutput<UpdateAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccessPolicyOutputError>
}

public struct UpdateAccessPolicyInput: Equatable {
    /// <p>The ID of the access policy.</p>
    public let accessPolicyId: String?
    /// <p>The identity for this access policy. Choose an AWS SSO user, an AWS SSO group, or an IAM user.</p>
    public let accessPolicyIdentity: Identity?
    /// <p>The permission level for this access policy. Note that a project <code>ADMINISTRATOR</code> is also known as a project owner.</p>
    public let accessPolicyPermission: Permission?
    /// <p>The AWS IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.</p>
    public let accessPolicyResource: Resource?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?

    public init (
        accessPolicyId: String? = nil,
        accessPolicyIdentity: Identity? = nil,
        accessPolicyPermission: Permission? = nil,
        accessPolicyResource: Resource? = nil,
        clientToken: String? = nil
    )
    {
        self.accessPolicyId = accessPolicyId
        self.accessPolicyIdentity = accessPolicyIdentity
        self.accessPolicyPermission = accessPolicyPermission
        self.accessPolicyResource = accessPolicyResource
        self.clientToken = clientToken
    }
}

struct UpdateAccessPolicyInputBody: Equatable {
    public let accessPolicyIdentity: Identity?
    public let accessPolicyResource: Resource?
    public let accessPolicyPermission: Permission?
    public let clientToken: String?
}

extension UpdateAccessPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessPolicyIdentity
        case accessPolicyPermission
        case accessPolicyResource
        case clientToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyIdentityDecoded = try containerValues.decodeIfPresent(Identity.self, forKey: .accessPolicyIdentity)
        accessPolicyIdentity = accessPolicyIdentityDecoded
        let accessPolicyResourceDecoded = try containerValues.decodeIfPresent(Resource.self, forKey: .accessPolicyResource)
        accessPolicyResource = accessPolicyResourceDecoded
        let accessPolicyPermissionDecoded = try containerValues.decodeIfPresent(Permission.self, forKey: .accessPolicyPermission)
        accessPolicyPermission = accessPolicyPermissionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateAccessPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccessPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAccessPolicyOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccessPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAccessPolicyOutputResponse()"}
}

extension UpdateAccessPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAccessPolicyOutputResponse: Equatable {

    public init() {}
}

struct UpdateAccessPolicyOutputResponseBody: Equatable {
}

extension UpdateAccessPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAssetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAssetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssetInput>
    public typealias MOutput = OperationOutput<UpdateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssetOutputError>
}

extension UpdateAssetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssetInput(assetId: \(String(describing: assetId)), assetName: \(String(describing: assetName)), clientToken: \(String(describing: clientToken)))"}
}

extension UpdateAssetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetName
        case clientToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetName = assetName {
            try encodeContainer.encode(assetName, forKey: .assetName)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct UpdateAssetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssetInput>
    public typealias MOutput = OperationOutput<UpdateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssetOutputError>
}

public struct UpdateAssetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssetInput>
    public typealias MOutput = OperationOutput<UpdateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssetOutputError>
}

public struct UpdateAssetInput: Equatable {
    /// <p>The ID of the asset to update.</p>
    public let assetId: String?
    /// <p>A unique, friendly name for the asset.</p>
    public let assetName: String?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?

    public init (
        assetId: String? = nil,
        assetName: String? = nil,
        clientToken: String? = nil
    )
    {
        self.assetId = assetId
        self.assetName = assetName
        self.clientToken = clientToken
    }
}

struct UpdateAssetInputBody: Equatable {
    public let assetName: String?
    public let clientToken: String?
}

extension UpdateAssetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetName
        case clientToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct UpdateAssetModelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAssetModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssetModelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssetModelInput>
    public typealias MOutput = OperationOutput<UpdateAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssetModelOutputError>
}

extension UpdateAssetModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssetModelInput(assetModelCompositeModels: \(String(describing: assetModelCompositeModels)), assetModelDescription: \(String(describing: assetModelDescription)), assetModelHierarchies: \(String(describing: assetModelHierarchies)), assetModelId: \(String(describing: assetModelId)), assetModelName: \(String(describing: assetModelName)), assetModelProperties: \(String(describing: assetModelProperties)), clientToken: \(String(describing: clientToken)))"}
}

extension UpdateAssetModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assetModelCompositeModels
        case assetModelDescription
        case assetModelHierarchies
        case assetModelName
        case assetModelProperties
        case clientToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetModelCompositeModels = assetModelCompositeModels {
            var assetModelCompositeModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelCompositeModels)
            for assetmodelcompositemodels0 in assetModelCompositeModels {
                try assetModelCompositeModelsContainer.encode(assetmodelcompositemodels0)
            }
        }
        if let assetModelDescription = assetModelDescription {
            try encodeContainer.encode(assetModelDescription, forKey: .assetModelDescription)
        }
        if let assetModelHierarchies = assetModelHierarchies {
            var assetModelHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelHierarchies)
            for assetmodelhierarchies0 in assetModelHierarchies {
                try assetModelHierarchiesContainer.encode(assetmodelhierarchies0)
            }
        }
        if let assetModelName = assetModelName {
            try encodeContainer.encode(assetModelName, forKey: .assetModelName)
        }
        if let assetModelProperties = assetModelProperties {
            var assetModelPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelProperties)
            for assetmodelproperties0 in assetModelProperties {
                try assetModelPropertiesContainer.encode(assetmodelproperties0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct UpdateAssetModelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAssetModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssetModelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssetModelInput>
    public typealias MOutput = OperationOutput<UpdateAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssetModelOutputError>
}

public struct UpdateAssetModelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAssetModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssetModelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssetModelInput>
    public typealias MOutput = OperationOutput<UpdateAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssetModelOutputError>
}

public struct UpdateAssetModelInput: Equatable {
    /// <p>The composite asset models that are part of this asset model.
    ///       Composite asset models are asset models that contain specific properties. Each composite model
    ///       has a type that defines the properties that the composite model supports. Use composite asset
    ///       models to define alarms on this asset model.</p>
    public let assetModelCompositeModels: [AssetModelCompositeModel]?
    /// <p>A description for the asset model.</p>
    public let assetModelDescription: String?
    /// <p>The updated hierarchy definitions of the asset model. Each hierarchy specifies an asset
    ///       model whose assets can be children of any other assets created from this asset model. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    ///          <p>You can specify up to 10 hierarchies per asset model. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let assetModelHierarchies: [AssetModelHierarchy]?
    /// <p>The ID of the asset model to update.</p>
    public let assetModelId: String?
    /// <p>A unique, friendly name for the asset model.</p>
    public let assetModelName: String?
    /// <p>The updated property definitions of the asset model. For more information, see
    ///       <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html">Asset properties</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    ///          <p>You can specify up to 200 properties per asset model. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let assetModelProperties: [AssetModelProperty]?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?

    public init (
        assetModelCompositeModels: [AssetModelCompositeModel]? = nil,
        assetModelDescription: String? = nil,
        assetModelHierarchies: [AssetModelHierarchy]? = nil,
        assetModelId: String? = nil,
        assetModelName: String? = nil,
        assetModelProperties: [AssetModelProperty]? = nil,
        clientToken: String? = nil
    )
    {
        self.assetModelCompositeModels = assetModelCompositeModels
        self.assetModelDescription = assetModelDescription
        self.assetModelHierarchies = assetModelHierarchies
        self.assetModelId = assetModelId
        self.assetModelName = assetModelName
        self.assetModelProperties = assetModelProperties
        self.clientToken = clientToken
    }
}

struct UpdateAssetModelInputBody: Equatable {
    public let assetModelName: String?
    public let assetModelDescription: String?
    public let assetModelProperties: [AssetModelProperty]?
    public let assetModelHierarchies: [AssetModelHierarchy]?
    public let assetModelCompositeModels: [AssetModelCompositeModel]?
    public let clientToken: String?
}

extension UpdateAssetModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetModelCompositeModels
        case assetModelDescription
        case assetModelHierarchies
        case assetModelName
        case assetModelProperties
        case clientToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetModelName)
        assetModelName = assetModelNameDecoded
        let assetModelDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assetModelDescription)
        assetModelDescription = assetModelDescriptionDecoded
        let assetModelPropertiesContainer = try containerValues.decodeIfPresent([AssetModelProperty?].self, forKey: .assetModelProperties)
        var assetModelPropertiesDecoded0:[AssetModelProperty]? = nil
        if let assetModelPropertiesContainer = assetModelPropertiesContainer {
            assetModelPropertiesDecoded0 = [AssetModelProperty]()
            for structure0 in assetModelPropertiesContainer {
                if let structure0 = structure0 {
                    assetModelPropertiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelProperties = assetModelPropertiesDecoded0
        let assetModelHierarchiesContainer = try containerValues.decodeIfPresent([AssetModelHierarchy?].self, forKey: .assetModelHierarchies)
        var assetModelHierarchiesDecoded0:[AssetModelHierarchy]? = nil
        if let assetModelHierarchiesContainer = assetModelHierarchiesContainer {
            assetModelHierarchiesDecoded0 = [AssetModelHierarchy]()
            for structure0 in assetModelHierarchiesContainer {
                if let structure0 = structure0 {
                    assetModelHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelHierarchies = assetModelHierarchiesDecoded0
        let assetModelCompositeModelsContainer = try containerValues.decodeIfPresent([AssetModelCompositeModel?].self, forKey: .assetModelCompositeModels)
        var assetModelCompositeModelsDecoded0:[AssetModelCompositeModel]? = nil
        if let assetModelCompositeModelsContainer = assetModelCompositeModelsContainer {
            assetModelCompositeModelsDecoded0 = [AssetModelCompositeModel]()
            for structure0 in assetModelCompositeModelsContainer {
                if let structure0 = structure0 {
                    assetModelCompositeModelsDecoded0?.append(structure0)
                }
            }
        }
        assetModelCompositeModels = assetModelCompositeModelsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateAssetModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssetModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssetModelOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssetModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssetModelOutputResponse(assetModelStatus: \(String(describing: assetModelStatus)))"}
}

extension UpdateAssetModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAssetModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assetModelStatus = output.assetModelStatus
        } else {
            self.assetModelStatus = nil
        }
    }
}

public struct UpdateAssetModelOutputResponse: Equatable {
    /// <p>The status of the asset model, which contains a state (<code>UPDATING</code> after
    ///       successfully calling this operation) and any error message.</p>
    public let assetModelStatus: AssetModelStatus?

    public init (
        assetModelStatus: AssetModelStatus? = nil
    )
    {
        self.assetModelStatus = assetModelStatus
    }
}

struct UpdateAssetModelOutputResponseBody: Equatable {
    public let assetModelStatus: AssetModelStatus?
}

extension UpdateAssetModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetModelStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelStatusDecoded = try containerValues.decodeIfPresent(AssetModelStatus.self, forKey: .assetModelStatus)
        assetModelStatus = assetModelStatusDecoded
    }
}

extension UpdateAssetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssetOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssetOutputResponse(assetStatus: \(String(describing: assetStatus)))"}
}

extension UpdateAssetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAssetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assetStatus = output.assetStatus
        } else {
            self.assetStatus = nil
        }
    }
}

public struct UpdateAssetOutputResponse: Equatable {
    /// <p>The status of the asset, which contains a state (<code>UPDATING</code> after successfully
    ///       calling this operation) and any error message.</p>
    public let assetStatus: AssetStatus?

    public init (
        assetStatus: AssetStatus? = nil
    )
    {
        self.assetStatus = assetStatus
    }
}

struct UpdateAssetOutputResponseBody: Equatable {
    public let assetStatus: AssetStatus?
}

extension UpdateAssetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assetStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetStatusDecoded = try containerValues.decodeIfPresent(AssetStatus.self, forKey: .assetStatus)
        assetStatus = assetStatusDecoded
    }
}

public struct UpdateAssetPropertyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAssetPropertyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssetPropertyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssetPropertyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssetPropertyInput>
    public typealias MOutput = OperationOutput<UpdateAssetPropertyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssetPropertyOutputError>
}

extension UpdateAssetPropertyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssetPropertyInput(assetId: \(String(describing: assetId)), clientToken: \(String(describing: clientToken)), propertyAlias: \(String(describing: propertyAlias)), propertyId: \(String(describing: propertyId)), propertyNotificationState: \(String(describing: propertyNotificationState)))"}
}

extension UpdateAssetPropertyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case propertyAlias
        case propertyNotificationState
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let propertyAlias = propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyNotificationState = propertyNotificationState {
            try encodeContainer.encode(propertyNotificationState.rawValue, forKey: .propertyNotificationState)
        }
    }
}

public struct UpdateAssetPropertyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAssetPropertyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssetPropertyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssetPropertyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssetPropertyInput>
    public typealias MOutput = OperationOutput<UpdateAssetPropertyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssetPropertyOutputError>
}

public struct UpdateAssetPropertyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAssetPropertyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssetPropertyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssetPropertyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssetPropertyInput>
    public typealias MOutput = OperationOutput<UpdateAssetPropertyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssetPropertyOutputError>
}

public struct UpdateAssetPropertyInput: Equatable {
    /// <p>The ID of the asset to be updated.</p>
    public let assetId: String?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?
    /// <p>The property alias that identifies the property, such as an OPC-UA server data stream path
    ///         (for example, <code>/company/windfarm/3/turbine/7/temperature</code>). For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties</a> in the
    ///         <i>AWS IoT SiteWise User Guide</i>.</p>
    ///          <p>If you omit this parameter, the alias is removed from the property.</p>
    public let propertyAlias: String?
    /// <p>The ID of the asset property to be updated.</p>
    public let propertyId: String?
    /// <p>The MQTT notification state (enabled or disabled) for this asset property.
    ///       When the notification state is enabled, AWS IoT SiteWise publishes property value
    ///       updates to a unique MQTT topic. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html">Interacting with other services</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    ///          <p>If you omit this parameter, the notification state is set to <code>DISABLED</code>.</p>
    public let propertyNotificationState: PropertyNotificationState?

    public init (
        assetId: String? = nil,
        clientToken: String? = nil,
        propertyAlias: String? = nil,
        propertyId: String? = nil,
        propertyNotificationState: PropertyNotificationState? = nil
    )
    {
        self.assetId = assetId
        self.clientToken = clientToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.propertyNotificationState = propertyNotificationState
    }
}

struct UpdateAssetPropertyInputBody: Equatable {
    public let propertyAlias: String?
    public let propertyNotificationState: PropertyNotificationState?
    public let clientToken: String?
}

extension UpdateAssetPropertyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case propertyAlias
        case propertyNotificationState
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyAliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
        let propertyNotificationStateDecoded = try containerValues.decodeIfPresent(PropertyNotificationState.self, forKey: .propertyNotificationState)
        propertyNotificationState = propertyNotificationStateDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateAssetPropertyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssetPropertyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssetPropertyOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssetPropertyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssetPropertyOutputResponse()"}
}

extension UpdateAssetPropertyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAssetPropertyOutputResponse: Equatable {

    public init() {}
}

struct UpdateAssetPropertyOutputResponseBody: Equatable {
}

extension UpdateAssetPropertyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDashboardInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDashboardInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDashboardInput>
    public typealias MOutput = OperationOutput<UpdateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDashboardOutputError>
}

extension UpdateDashboardInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDashboardInput(clientToken: \(String(describing: clientToken)), dashboardDefinition: \(String(describing: dashboardDefinition)), dashboardDescription: \(String(describing: dashboardDescription)), dashboardId: \(String(describing: dashboardId)), dashboardName: \(String(describing: dashboardName)))"}
}

extension UpdateDashboardInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case dashboardDefinition
        case dashboardDescription
        case dashboardName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dashboardDefinition = dashboardDefinition {
            try encodeContainer.encode(dashboardDefinition, forKey: .dashboardDefinition)
        }
        if let dashboardDescription = dashboardDescription {
            try encodeContainer.encode(dashboardDescription, forKey: .dashboardDescription)
        }
        if let dashboardName = dashboardName {
            try encodeContainer.encode(dashboardName, forKey: .dashboardName)
        }
    }
}

public struct UpdateDashboardInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDashboardInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDashboardInput>
    public typealias MOutput = OperationOutput<UpdateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDashboardOutputError>
}

public struct UpdateDashboardInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDashboardInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDashboardInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDashboardInput>
    public typealias MOutput = OperationOutput<UpdateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDashboardOutputError>
}

public struct UpdateDashboardInput: Equatable {
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?
    /// <p>The new dashboard definition, as specified in a JSON literal. For detailed information,
    ///       see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html">Creating dashboards (CLI)</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let dashboardDefinition: String?
    /// <p>A new description for the dashboard.</p>
    public let dashboardDescription: String?
    /// <p>The ID of the dashboard to update.</p>
    public let dashboardId: String?
    /// <p>A new friendly name for the dashboard.</p>
    public let dashboardName: String?

    public init (
        clientToken: String? = nil,
        dashboardDefinition: String? = nil,
        dashboardDescription: String? = nil,
        dashboardId: String? = nil,
        dashboardName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.dashboardDefinition = dashboardDefinition
        self.dashboardDescription = dashboardDescription
        self.dashboardId = dashboardId
        self.dashboardName = dashboardName
    }
}

struct UpdateDashboardInputBody: Equatable {
    public let dashboardName: String?
    public let dashboardDescription: String?
    public let dashboardDefinition: String?
    public let clientToken: String?
}

extension UpdateDashboardInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case dashboardDefinition
        case dashboardDescription
        case dashboardName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardName)
        dashboardName = dashboardNameDecoded
        let dashboardDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardDescription)
        dashboardDescription = dashboardDescriptionDecoded
        let dashboardDefinitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dashboardDefinition)
        dashboardDefinition = dashboardDefinitionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateDashboardOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDashboardOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDashboardOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDashboardOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDashboardOutputResponse()"}
}

extension UpdateDashboardOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDashboardOutputResponse: Equatable {

    public init() {}
}

struct UpdateDashboardOutputResponseBody: Equatable {
}

extension UpdateDashboardOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateGatewayCapabilityConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGatewayCapabilityConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayCapabilityConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayCapabilityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayCapabilityConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateGatewayCapabilityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayCapabilityConfigurationOutputError>
}

extension UpdateGatewayCapabilityConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGatewayCapabilityConfigurationInput(capabilityConfiguration: \(String(describing: capabilityConfiguration)), capabilityNamespace: \(String(describing: capabilityNamespace)), gatewayId: \(String(describing: gatewayId)))"}
}

extension UpdateGatewayCapabilityConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case capabilityConfiguration
        case capabilityNamespace
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilityConfiguration = capabilityConfiguration {
            try encodeContainer.encode(capabilityConfiguration, forKey: .capabilityConfiguration)
        }
        if let capabilityNamespace = capabilityNamespace {
            try encodeContainer.encode(capabilityNamespace, forKey: .capabilityNamespace)
        }
    }
}

public struct UpdateGatewayCapabilityConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGatewayCapabilityConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayCapabilityConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayCapabilityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayCapabilityConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateGatewayCapabilityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayCapabilityConfigurationOutputError>
}

public struct UpdateGatewayCapabilityConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGatewayCapabilityConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayCapabilityConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayCapabilityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayCapabilityConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateGatewayCapabilityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayCapabilityConfigurationOutputError>
}

public struct UpdateGatewayCapabilityConfigurationInput: Equatable {
    /// <p>The JSON document that defines the configuration for the gateway capability. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/configure-sources.html#configure-source-cli">Configuring data sources (CLI)</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let capabilityConfiguration: String?
    /// <p>The namespace of the gateway capability configuration to be updated.
    ///       For example, if you configure OPC-UA
    ///       sources from the AWS IoT SiteWise console, your OPC-UA capability configuration has the namespace
    ///         <code>iotsitewise:opcuacollector:version</code>, where <code>version</code> is a number such as
    ///         <code>1</code>.</p>
    public let capabilityNamespace: String?
    /// <p>The ID of the gateway to be updated.</p>
    public let gatewayId: String?

    public init (
        capabilityConfiguration: String? = nil,
        capabilityNamespace: String? = nil,
        gatewayId: String? = nil
    )
    {
        self.capabilityConfiguration = capabilityConfiguration
        self.capabilityNamespace = capabilityNamespace
        self.gatewayId = gatewayId
    }
}

struct UpdateGatewayCapabilityConfigurationInputBody: Equatable {
    public let capabilityNamespace: String?
    public let capabilityConfiguration: String?
}

extension UpdateGatewayCapabilityConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case capabilityConfiguration
        case capabilityNamespace
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilityNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .capabilityNamespace)
        capabilityNamespace = capabilityNamespaceDecoded
        let capabilityConfigurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .capabilityConfiguration)
        capabilityConfiguration = capabilityConfigurationDecoded
    }
}

extension UpdateGatewayCapabilityConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewayCapabilityConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGatewayCapabilityConfigurationOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewayCapabilityConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGatewayCapabilityConfigurationOutputResponse(capabilityNamespace: \(String(describing: capabilityNamespace)), capabilitySyncStatus: \(String(describing: capabilitySyncStatus)))"}
}

extension UpdateGatewayCapabilityConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateGatewayCapabilityConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.capabilityNamespace = output.capabilityNamespace
            self.capabilitySyncStatus = output.capabilitySyncStatus
        } else {
            self.capabilityNamespace = nil
            self.capabilitySyncStatus = nil
        }
    }
}

public struct UpdateGatewayCapabilityConfigurationOutputResponse: Equatable {
    /// <p>The namespace of the gateway capability.</p>
    public let capabilityNamespace: String?
    /// <p>The synchronization status of the capability configuration. The sync status can be one of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>IN_SYNC</code> – The gateway is running the capability configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OUT_OF_SYNC</code> – The gateway hasn't received the capability configuration.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SYNC_FAILED</code> – The gateway rejected the capability configuration.</p>
    ///             </li>
    ///          </ul>
    ///          <p>After you update a capability configuration, its sync status is <code>OUT_OF_SYNC</code>
    ///       until the gateway receives and applies or rejects the updated configuration.</p>
    public let capabilitySyncStatus: CapabilitySyncStatus?

    public init (
        capabilityNamespace: String? = nil,
        capabilitySyncStatus: CapabilitySyncStatus? = nil
    )
    {
        self.capabilityNamespace = capabilityNamespace
        self.capabilitySyncStatus = capabilitySyncStatus
    }
}

struct UpdateGatewayCapabilityConfigurationOutputResponseBody: Equatable {
    public let capabilityNamespace: String?
    public let capabilitySyncStatus: CapabilitySyncStatus?
}

extension UpdateGatewayCapabilityConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case capabilityNamespace
        case capabilitySyncStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilityNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .capabilityNamespace)
        capabilityNamespace = capabilityNamespaceDecoded
        let capabilitySyncStatusDecoded = try containerValues.decodeIfPresent(CapabilitySyncStatus.self, forKey: .capabilitySyncStatus)
        capabilitySyncStatus = capabilitySyncStatusDecoded
    }
}

public struct UpdateGatewayInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayInput>
    public typealias MOutput = OperationOutput<UpdateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayOutputError>
}

extension UpdateGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGatewayInput(gatewayId: \(String(describing: gatewayId)), gatewayName: \(String(describing: gatewayName)))"}
}

extension UpdateGatewayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayName = gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
    }
}

public struct UpdateGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayInput>
    public typealias MOutput = OperationOutput<UpdateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayOutputError>
}

public struct UpdateGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayInput>
    public typealias MOutput = OperationOutput<UpdateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayOutputError>
}

public struct UpdateGatewayInput: Equatable {
    /// <p>The ID of the gateway to update.</p>
    public let gatewayId: String?
    /// <p>A unique, friendly name for the gateway.</p>
    public let gatewayName: String?

    public init (
        gatewayId: String? = nil,
        gatewayName: String? = nil
    )
    {
        self.gatewayId = gatewayId
        self.gatewayName = gatewayName
    }
}

struct UpdateGatewayInputBody: Equatable {
    public let gatewayName: String?
}

extension UpdateGatewayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
    }
}

extension UpdateGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGatewayOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGatewayOutputResponse()"}
}

extension UpdateGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateGatewayOutputResponse: Equatable {

    public init() {}
}

struct UpdateGatewayOutputResponseBody: Equatable {
}

extension UpdateGatewayOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdatePortalInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePortalInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePortalInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePortalInput>
    public typealias MOutput = OperationOutput<UpdatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePortalOutputError>
}

extension UpdatePortalInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePortalInput(alarms: \(String(describing: alarms)), clientToken: \(String(describing: clientToken)), notificationSenderEmail: \(String(describing: notificationSenderEmail)), portalContactEmail: \(String(describing: portalContactEmail)), portalDescription: \(String(describing: portalDescription)), portalId: \(String(describing: portalId)), portalLogoImage: \(String(describing: portalLogoImage)), portalName: \(String(describing: portalName)), roleArn: \(String(describing: roleArn)))"}
}

extension UpdatePortalInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarms
        case clientToken
        case notificationSenderEmail
        case portalContactEmail
        case portalDescription
        case portalLogoImage
        case portalName
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarms = alarms {
            try encodeContainer.encode(alarms, forKey: .alarms)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let notificationSenderEmail = notificationSenderEmail {
            try encodeContainer.encode(notificationSenderEmail, forKey: .notificationSenderEmail)
        }
        if let portalContactEmail = portalContactEmail {
            try encodeContainer.encode(portalContactEmail, forKey: .portalContactEmail)
        }
        if let portalDescription = portalDescription {
            try encodeContainer.encode(portalDescription, forKey: .portalDescription)
        }
        if let portalLogoImage = portalLogoImage {
            try encodeContainer.encode(portalLogoImage, forKey: .portalLogoImage)
        }
        if let portalName = portalName {
            try encodeContainer.encode(portalName, forKey: .portalName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct UpdatePortalInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePortalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePortalInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePortalInput>
    public typealias MOutput = OperationOutput<UpdatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePortalOutputError>
}

public struct UpdatePortalInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePortalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePortalInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePortalInput>
    public typealias MOutput = OperationOutput<UpdatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePortalOutputError>
}

public struct UpdatePortalInput: Equatable {
    /// <p>Contains the configuration information of an alarm created in an AWS IoT SiteWise Monitor portal.
    ///   You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see .</p>
    public let alarms: Alarms?
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?
    /// <p>The email address that sends alarm notifications.</p>
    public let notificationSenderEmail: String?
    /// <p>The AWS administrator's contact email address.</p>
    public let portalContactEmail: String?
    /// <p>A new description for the portal.</p>
    public let portalDescription: String?
    /// <p>The ID of the portal to update.</p>
    public let portalId: String?
    /// <p>Contains an image that is one of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>An image file. Choose this option to upload a new image.</p>
    ///             </li>
    ///             <li>
    ///                <p>The ID of an existing image. Choose this option to keep an existing image.</p>
    ///             </li>
    ///          </ul>
    public let portalLogoImage: Image?
    /// <p>A new friendly name for the portal.</p>
    public let portalName: String?
    /// <p>The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN</a> of a service role that allows the portal's users to access your AWS IoT SiteWise
    ///       resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for AWS IoT SiteWise Monitor</a> in the
    ///         <i>AWS IoT SiteWise User Guide</i>.</p>
    public let roleArn: String?

    public init (
        alarms: Alarms? = nil,
        clientToken: String? = nil,
        notificationSenderEmail: String? = nil,
        portalContactEmail: String? = nil,
        portalDescription: String? = nil,
        portalId: String? = nil,
        portalLogoImage: Image? = nil,
        portalName: String? = nil,
        roleArn: String? = nil
    )
    {
        self.alarms = alarms
        self.clientToken = clientToken
        self.notificationSenderEmail = notificationSenderEmail
        self.portalContactEmail = portalContactEmail
        self.portalDescription = portalDescription
        self.portalId = portalId
        self.portalLogoImage = portalLogoImage
        self.portalName = portalName
        self.roleArn = roleArn
    }
}

struct UpdatePortalInputBody: Equatable {
    public let portalName: String?
    public let portalDescription: String?
    public let portalContactEmail: String?
    public let portalLogoImage: Image?
    public let roleArn: String?
    public let clientToken: String?
    public let notificationSenderEmail: String?
    public let alarms: Alarms?
}

extension UpdatePortalInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alarms
        case clientToken
        case notificationSenderEmail
        case portalContactEmail
        case portalDescription
        case portalLogoImage
        case portalName
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portalName)
        portalName = portalNameDecoded
        let portalDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portalDescription)
        portalDescription = portalDescriptionDecoded
        let portalContactEmailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portalContactEmail)
        portalContactEmail = portalContactEmailDecoded
        let portalLogoImageDecoded = try containerValues.decodeIfPresent(Image.self, forKey: .portalLogoImage)
        portalLogoImage = portalLogoImageDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let notificationSenderEmailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notificationSenderEmail)
        notificationSenderEmail = notificationSenderEmailDecoded
        let alarmsDecoded = try containerValues.decodeIfPresent(Alarms.self, forKey: .alarms)
        alarms = alarmsDecoded
    }
}

extension UpdatePortalOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePortalOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePortalOutputError: Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePortalOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePortalOutputResponse(portalStatus: \(String(describing: portalStatus)))"}
}

extension UpdatePortalOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdatePortalOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.portalStatus = output.portalStatus
        } else {
            self.portalStatus = nil
        }
    }
}

public struct UpdatePortalOutputResponse: Equatable {
    /// <p>The status of the portal, which contains a state (<code>UPDATING</code> after successfully
    ///       calling this operation) and any error message.</p>
    public let portalStatus: PortalStatus?

    public init (
        portalStatus: PortalStatus? = nil
    )
    {
        self.portalStatus = portalStatus
    }
}

struct UpdatePortalOutputResponseBody: Equatable {
    public let portalStatus: PortalStatus?
}

extension UpdatePortalOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case portalStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalStatusDecoded = try containerValues.decodeIfPresent(PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
    }
}

public struct UpdateProjectInputBodyMiddleware: Middleware {
    public let id: String = "UpdateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

extension UpdateProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProjectInput(clientToken: \(String(describing: clientToken)), projectDescription: \(String(describing: projectDescription)), projectId: \(String(describing: projectId)), projectName: \(String(describing: projectName)))"}
}

extension UpdateProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case projectDescription
        case projectName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let projectDescription = projectDescription {
            try encodeContainer.encode(projectDescription, forKey: .projectDescription)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }
}

public struct UpdateProjectInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInput: Equatable {
    /// <p>A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.</p>
    public var clientToken: String?
    /// <p>A new description for the project.</p>
    public let projectDescription: String?
    /// <p>The ID of the project to update.</p>
    public let projectId: String?
    /// <p>A new friendly name for the project.</p>
    public let projectName: String?

    public init (
        clientToken: String? = nil,
        projectDescription: String? = nil,
        projectId: String? = nil,
        projectName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectDescription = projectDescription
        self.projectId = projectId
        self.projectName = projectName
    }
}

struct UpdateProjectInputBody: Equatable {
    public let projectName: String?
    public let projectDescription: String?
    public let clientToken: String?
}

extension UpdateProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case projectDescription
        case projectName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let projectDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectDescription)
        projectDescription = projectDescriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProjectOutputError: Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProjectOutputResponse()"}
}

extension UpdateProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateProjectOutputResponse: Equatable {

    public init() {}
}

struct UpdateProjectOutputResponseBody: Equatable {
}

extension UpdateProjectOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UserIdentity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension UserIdentity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserIdentity(id: \(String(describing: id)))"}
}

/// <p>Contains information for a user identity in an access policy.</p>
public struct UserIdentity: Equatable {
    /// <p>The AWS SSO ID of the user.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

extension VariableValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hierarchyId
        case propertyId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hierarchyId = hierarchyId {
            try encodeContainer.encode(hierarchyId, forKey: .hierarchyId)
        }
        if let propertyId = propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let hierarchyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hierarchyId)
        hierarchyId = hierarchyIdDecoded
    }
}

extension VariableValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VariableValue(hierarchyId: \(String(describing: hierarchyId)), propertyId: \(String(describing: propertyId)))"}
}

/// <p>Identifies a property value used in an expression.</p>
public struct VariableValue: Equatable {
    /// <p>The ID of the hierarchy to query for the property ID. You can use the hierarchy's name
    ///       instead of the hierarchy's ID.</p>
    ///          <p>You use a hierarchy ID instead of a model ID because you can have several hierarchies
    ///       using the same model and therefore the same <code>propertyId</code>. For example, you might
    ///       have separately grouped assets that come from the same asset model. For more information, see
    ///       <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies</a> in the <i>AWS IoT SiteWise User Guide</i>.</p>
    public let hierarchyId: String?
    /// <p>The ID of the property to use as the variable. You can use the property <code>name</code>
    ///       if it's from the same asset model.</p>
    public let propertyId: String?

    public init (
        hierarchyId: String? = nil,
        propertyId: String? = nil
    )
    {
        self.hierarchyId = hierarchyId
        self.propertyId = propertyId
    }
}

extension Variant: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case booleanValue
        case doubleValue
        case integerValue
        case stringValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let booleanValue = booleanValue {
            try encodeContainer.encode(booleanValue, forKey: .booleanValue)
        }
        if let doubleValue = doubleValue {
            try encodeContainer.encode(doubleValue, forKey: .doubleValue)
        }
        if let integerValue = integerValue {
            try encodeContainer.encode(integerValue, forKey: .integerValue)
        }
        if let stringValue = stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
        let integerValueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .integerValue)
        integerValue = integerValueDecoded
        let doubleValueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .doubleValue)
        doubleValue = doubleValueDecoded
        let booleanValueDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .booleanValue)
        booleanValue = booleanValueDecoded
    }
}

extension Variant: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Variant(booleanValue: \(String(describing: booleanValue)), doubleValue: \(String(describing: doubleValue)), integerValue: \(String(describing: integerValue)), stringValue: \(String(describing: stringValue)))"}
}

/// <p>Contains an asset property value (of a single type only).</p>
public struct Variant: Equatable {
    /// <p>Asset property data of type Boolean (true or false).</p>
    public let booleanValue: Bool?
    /// <p>Asset property data of type double (floating point number).</p>
    public let doubleValue: Double?
    /// <p>Asset property data of type integer (whole number).</p>
    public let integerValue: Int?
    /// <p>Asset property data of type string (sequence of characters).</p>
    public let stringValue: String?

    public init (
        booleanValue: Bool? = nil,
        doubleValue: Double? = nil,
        integerValue: Int? = nil,
        stringValue: String? = nil
    )
    {
        self.booleanValue = booleanValue
        self.doubleValue = doubleValue
        self.integerValue = integerValue
        self.stringValue = stringValue
    }
}
