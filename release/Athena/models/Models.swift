// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct BatchGetNamedQueryInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetNamedQueryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetNamedQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetNamedQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetNamedQueryInput>
    public typealias MOutput = OperationOutput<BatchGetNamedQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetNamedQueryOutputError>
}

extension BatchGetNamedQueryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetNamedQueryInput(namedQueryIds: \(String(describing: namedQueryIds)))"}
}

extension BatchGetNamedQueryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case namedQueryIds = "NamedQueryIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namedQueryIds = namedQueryIds {
            var namedQueryIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .namedQueryIds)
            for namedqueryidlist0 in namedQueryIds {
                try namedQueryIdsContainer.encode(namedqueryidlist0)
            }
        }
    }
}

public struct BatchGetNamedQueryInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetNamedQueryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetNamedQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetNamedQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetNamedQueryInput>
    public typealias MOutput = OperationOutput<BatchGetNamedQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetNamedQueryOutputError>
}

public struct BatchGetNamedQueryInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetNamedQueryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetNamedQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetNamedQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetNamedQueryInput>
    public typealias MOutput = OperationOutput<BatchGetNamedQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetNamedQueryOutputError>
}

public struct BatchGetNamedQueryInput: Equatable {
    /// <p>An array of query IDs.</p>
    public let namedQueryIds: [String]?

    public init (
        namedQueryIds: [String]? = nil
    )
    {
        self.namedQueryIds = namedQueryIds
    }
}

struct BatchGetNamedQueryInputBody: Equatable {
    public let namedQueryIds: [String]?
}

extension BatchGetNamedQueryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case namedQueryIds = "NamedQueryIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .namedQueryIds)
        var namedQueryIdsDecoded0:[String]? = nil
        if let namedQueryIdsContainer = namedQueryIdsContainer {
            namedQueryIdsDecoded0 = [String]()
            for string0 in namedQueryIdsContainer {
                if let string0 = string0 {
                    namedQueryIdsDecoded0?.append(string0)
                }
            }
        }
        namedQueryIds = namedQueryIdsDecoded0
    }
}

extension BatchGetNamedQueryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetNamedQueryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetNamedQueryOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetNamedQueryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetNamedQueryOutputResponse(namedQueries: \(String(describing: namedQueries)), unprocessedNamedQueryIds: \(String(describing: unprocessedNamedQueryIds)))"}
}

extension BatchGetNamedQueryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchGetNamedQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namedQueries = output.namedQueries
            self.unprocessedNamedQueryIds = output.unprocessedNamedQueryIds
        } else {
            self.namedQueries = nil
            self.unprocessedNamedQueryIds = nil
        }
    }
}

public struct BatchGetNamedQueryOutputResponse: Equatable {
    /// <p>Information about the named query IDs submitted.</p>
    public let namedQueries: [NamedQuery]?
    /// <p>Information about provided query IDs.</p>
    public let unprocessedNamedQueryIds: [UnprocessedNamedQueryId]?

    public init (
        namedQueries: [NamedQuery]? = nil,
        unprocessedNamedQueryIds: [UnprocessedNamedQueryId]? = nil
    )
    {
        self.namedQueries = namedQueries
        self.unprocessedNamedQueryIds = unprocessedNamedQueryIds
    }
}

struct BatchGetNamedQueryOutputResponseBody: Equatable {
    public let namedQueries: [NamedQuery]?
    public let unprocessedNamedQueryIds: [UnprocessedNamedQueryId]?
}

extension BatchGetNamedQueryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case namedQueries = "NamedQueries"
        case unprocessedNamedQueryIds = "UnprocessedNamedQueryIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueriesContainer = try containerValues.decodeIfPresent([NamedQuery?].self, forKey: .namedQueries)
        var namedQueriesDecoded0:[NamedQuery]? = nil
        if let namedQueriesContainer = namedQueriesContainer {
            namedQueriesDecoded0 = [NamedQuery]()
            for structure0 in namedQueriesContainer {
                if let structure0 = structure0 {
                    namedQueriesDecoded0?.append(structure0)
                }
            }
        }
        namedQueries = namedQueriesDecoded0
        let unprocessedNamedQueryIdsContainer = try containerValues.decodeIfPresent([UnprocessedNamedQueryId?].self, forKey: .unprocessedNamedQueryIds)
        var unprocessedNamedQueryIdsDecoded0:[UnprocessedNamedQueryId]? = nil
        if let unprocessedNamedQueryIdsContainer = unprocessedNamedQueryIdsContainer {
            unprocessedNamedQueryIdsDecoded0 = [UnprocessedNamedQueryId]()
            for structure0 in unprocessedNamedQueryIdsContainer {
                if let structure0 = structure0 {
                    unprocessedNamedQueryIdsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedNamedQueryIds = unprocessedNamedQueryIdsDecoded0
    }
}

public struct BatchGetQueryExecutionInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetQueryExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetQueryExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetQueryExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetQueryExecutionInput>
    public typealias MOutput = OperationOutput<BatchGetQueryExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetQueryExecutionOutputError>
}

extension BatchGetQueryExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetQueryExecutionInput(queryExecutionIds: \(String(describing: queryExecutionIds)))"}
}

extension BatchGetQueryExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case queryExecutionIds = "QueryExecutionIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryExecutionIds = queryExecutionIds {
            var queryExecutionIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queryExecutionIds)
            for queryexecutionidlist0 in queryExecutionIds {
                try queryExecutionIdsContainer.encode(queryexecutionidlist0)
            }
        }
    }
}

public struct BatchGetQueryExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetQueryExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetQueryExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetQueryExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetQueryExecutionInput>
    public typealias MOutput = OperationOutput<BatchGetQueryExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetQueryExecutionOutputError>
}

public struct BatchGetQueryExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetQueryExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetQueryExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetQueryExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetQueryExecutionInput>
    public typealias MOutput = OperationOutput<BatchGetQueryExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetQueryExecutionOutputError>
}

public struct BatchGetQueryExecutionInput: Equatable {
    /// <p>An array of query execution IDs.</p>
    public let queryExecutionIds: [String]?

    public init (
        queryExecutionIds: [String]? = nil
    )
    {
        self.queryExecutionIds = queryExecutionIds
    }
}

struct BatchGetQueryExecutionInputBody: Equatable {
    public let queryExecutionIds: [String]?
}

extension BatchGetQueryExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case queryExecutionIds = "QueryExecutionIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .queryExecutionIds)
        var queryExecutionIdsDecoded0:[String]? = nil
        if let queryExecutionIdsContainer = queryExecutionIdsContainer {
            queryExecutionIdsDecoded0 = [String]()
            for string0 in queryExecutionIdsContainer {
                if let string0 = string0 {
                    queryExecutionIdsDecoded0?.append(string0)
                }
            }
        }
        queryExecutionIds = queryExecutionIdsDecoded0
    }
}

extension BatchGetQueryExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetQueryExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetQueryExecutionOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetQueryExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetQueryExecutionOutputResponse(queryExecutions: \(String(describing: queryExecutions)), unprocessedQueryExecutionIds: \(String(describing: unprocessedQueryExecutionIds)))"}
}

extension BatchGetQueryExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchGetQueryExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.queryExecutions = output.queryExecutions
            self.unprocessedQueryExecutionIds = output.unprocessedQueryExecutionIds
        } else {
            self.queryExecutions = nil
            self.unprocessedQueryExecutionIds = nil
        }
    }
}

public struct BatchGetQueryExecutionOutputResponse: Equatable {
    /// <p>Information about a query execution.</p>
    public let queryExecutions: [QueryExecution]?
    /// <p>Information about the query executions that failed to run.</p>
    public let unprocessedQueryExecutionIds: [UnprocessedQueryExecutionId]?

    public init (
        queryExecutions: [QueryExecution]? = nil,
        unprocessedQueryExecutionIds: [UnprocessedQueryExecutionId]? = nil
    )
    {
        self.queryExecutions = queryExecutions
        self.unprocessedQueryExecutionIds = unprocessedQueryExecutionIds
    }
}

struct BatchGetQueryExecutionOutputResponseBody: Equatable {
    public let queryExecutions: [QueryExecution]?
    public let unprocessedQueryExecutionIds: [UnprocessedQueryExecutionId]?
}

extension BatchGetQueryExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case queryExecutions = "QueryExecutions"
        case unprocessedQueryExecutionIds = "UnprocessedQueryExecutionIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionsContainer = try containerValues.decodeIfPresent([QueryExecution?].self, forKey: .queryExecutions)
        var queryExecutionsDecoded0:[QueryExecution]? = nil
        if let queryExecutionsContainer = queryExecutionsContainer {
            queryExecutionsDecoded0 = [QueryExecution]()
            for structure0 in queryExecutionsContainer {
                if let structure0 = structure0 {
                    queryExecutionsDecoded0?.append(structure0)
                }
            }
        }
        queryExecutions = queryExecutionsDecoded0
        let unprocessedQueryExecutionIdsContainer = try containerValues.decodeIfPresent([UnprocessedQueryExecutionId?].self, forKey: .unprocessedQueryExecutionIds)
        var unprocessedQueryExecutionIdsDecoded0:[UnprocessedQueryExecutionId]? = nil
        if let unprocessedQueryExecutionIdsContainer = unprocessedQueryExecutionIdsContainer {
            unprocessedQueryExecutionIdsDecoded0 = [UnprocessedQueryExecutionId]()
            for structure0 in unprocessedQueryExecutionIdsContainer {
                if let structure0 = structure0 {
                    unprocessedQueryExecutionIdsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedQueryExecutionIds = unprocessedQueryExecutionIdsDecoded0
    }
}

extension Column: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comment = "Comment"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension Column: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Column(comment: \(String(describing: comment)), name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>Contains metadata for a column in a table.</p>
public struct Column: Equatable {
    /// <p>Optional information about the column.</p>
    public let comment: String?
    /// <p>The name of the column.</p>
    public let name: String?
    /// <p>The data type of the column.</p>
    public let type: String?

    public init (
        comment: String? = nil,
        name: String? = nil,
        type: String? = nil
    )
    {
        self.comment = comment
        self.name = name
        self.type = type
    }
}

extension ColumnInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case caseSensitive = "CaseSensitive"
        case catalogName = "CatalogName"
        case label = "Label"
        case name = "Name"
        case nullable = "Nullable"
        case precision = "Precision"
        case scale = "Scale"
        case schemaName = "SchemaName"
        case tableName = "TableName"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if caseSensitive != false {
            try encodeContainer.encode(caseSensitive, forKey: .caseSensitive)
        }
        if let catalogName = catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nullable = nullable {
            try encodeContainer.encode(nullable.rawValue, forKey: .nullable)
        }
        if precision != 0 {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if scale != 0 {
            try encodeContainer.encode(scale, forKey: .scale)
        }
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let labelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .label)
        label = labelDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let precisionDecoded = try containerValues.decode(Int.self, forKey: .precision)
        precision = precisionDecoded
        let scaleDecoded = try containerValues.decode(Int.self, forKey: .scale)
        scale = scaleDecoded
        let nullableDecoded = try containerValues.decodeIfPresent(ColumnNullable.self, forKey: .nullable)
        nullable = nullableDecoded
        let caseSensitiveDecoded = try containerValues.decode(Bool.self, forKey: .caseSensitive)
        caseSensitive = caseSensitiveDecoded
    }
}

extension ColumnInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnInfo(caseSensitive: \(String(describing: caseSensitive)), catalogName: \(String(describing: catalogName)), label: \(String(describing: label)), name: \(String(describing: name)), nullable: \(String(describing: nullable)), precision: \(String(describing: precision)), scale: \(String(describing: scale)), schemaName: \(String(describing: schemaName)), tableName: \(String(describing: tableName)), type: \(String(describing: type)))"}
}

/// <p>Information about the columns in a query execution result.</p>
public struct ColumnInfo: Equatable {
    /// <p>Indicates whether values in the column are case-sensitive.</p>
    public let caseSensitive: Bool
    /// <p>The catalog to which the query results belong.</p>
    public let catalogName: String?
    /// <p>A column label.</p>
    public let label: String?
    /// <p>The name of the column.</p>
    public let name: String?
    /// <p>Indicates the column's nullable status.</p>
    public let nullable: ColumnNullable?
    /// <p>For <code>DECIMAL</code> data types, specifies the total number of digits, up to 38.
    ///             For performance reasons, we recommend up to 18 digits.</p>
    public let precision: Int
    /// <p>For <code>DECIMAL</code> data types, specifies the total number of digits in the
    ///             fractional part of the value. Defaults to 0.</p>
    public let scale: Int
    /// <p>The schema name (database name) to which the query results belong.</p>
    public let schemaName: String?
    /// <p>The table name for the query results.</p>
    public let tableName: String?
    /// <p>The data type of the column.</p>
    public let type: String?

    public init (
        caseSensitive: Bool = false,
        catalogName: String? = nil,
        label: String? = nil,
        name: String? = nil,
        nullable: ColumnNullable? = nil,
        precision: Int = 0,
        scale: Int = 0,
        schemaName: String? = nil,
        tableName: String? = nil,
        type: String? = nil
    )
    {
        self.caseSensitive = caseSensitive
        self.catalogName = catalogName
        self.label = label
        self.name = name
        self.nullable = nullable
        self.precision = precision
        self.scale = scale
        self.schemaName = schemaName
        self.tableName = tableName
        self.type = type
    }
}

public enum ColumnNullable {
    case notNull
    case nullable
    case unknown
    case sdkUnknown(String)
}

extension ColumnNullable : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ColumnNullable] {
        return [
            .notNull,
            .nullable,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .notNull: return "NOT_NULL"
        case .nullable: return "NULLABLE"
        case .unknown: return "UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ColumnNullable(rawValue: rawValue) ?? ColumnNullable.sdkUnknown(rawValue)
    }
}

public struct CreateDataCatalogInputBodyMiddleware: Middleware {
    public let id: String = "CreateDataCatalogInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataCatalogInput>
    public typealias MOutput = OperationOutput<CreateDataCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataCatalogOutputError>
}

extension CreateDataCatalogInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDataCatalogInput(description: \(String(describing: description)), name: \(String(describing: name)), parameters: \(String(describing: parameters)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

extension CreateDataCatalogInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateDataCatalogInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDataCatalogInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataCatalogInput>
    public typealias MOutput = OperationOutput<CreateDataCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataCatalogOutputError>
}

public struct CreateDataCatalogInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDataCatalogInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataCatalogInput>
    public typealias MOutput = OperationOutput<CreateDataCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataCatalogOutputError>
}

public struct CreateDataCatalogInput: Equatable {
    /// <p>A description of the data catalog to be created.</p>
    public let description: String?
    /// <p>The name of the data catalog to create. The catalog name must be unique for the AWS
    ///             account and can use a maximum of 128 alphanumeric, underscore, at sign, or hyphen
    ///             characters.</p>
    public let name: String?
    /// <p>Specifies the Lambda function or functions to use for creating the data catalog. This
    ///             is a mapping whose values depend on the catalog type. </p>
    ///         <ul>
    ///             <li>
    ///                 <p>For the <code>HIVE</code> data catalog type, use the following syntax. The
    ///                         <code>metadata-function</code> parameter is required. <code>The
    ///                         sdk-version</code> parameter is optional and defaults to the currently
    ///                     supported version.</p>
    ///                 <p>
    ///                   <code>metadata-function=<i>lambda_arn</i>,
    ///                             sdk-version=<i>version_number</i>
    ///                   </code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>LAMBDA</code> data catalog type, use one of the following sets
    ///                     of required parameters, but not both.</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>If you have one Lambda function that processes metadata and another
    ///                             for reading the actual data, use the following syntax. Both parameters
    ///                             are required.</p>
    ///                         <p>
    ///                         <code>metadata-function=<i>lambda_arn</i>,
    ///                                     record-function=<i>lambda_arn</i>
    ///                         </code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p> If you have a composite Lambda function that processes both metadata
    ///                             and data, use the following syntax to specify your Lambda
    ///                             function.</p>
    ///                         <p>
    ///                         <code>function=<i>lambda_arn</i>
    ///                         </code>
    ///                      </p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let parameters: [String:String]?
    /// <p>A list of comma separated tags to add to the data catalog that is created.</p>
    public let tags: [Tag]?
    /// <p>The type of data catalog to create: <code>LAMBDA</code> for a federated catalog or
    ///                 <code>HIVE</code> for an external hive metastore.</p>
    ///         <note>
    ///             <p>Do not use the <code>GLUE</code> type. This refers to the
    ///                     <code>AwsDataCatalog</code> that already exists in your account, of which you
    ///                 can have only one. Specifying the <code>GLUE</code> type will result in an
    ///                     <code>INVALID_INPUT</code> error.</p>
    ///         </note>
    public let type: DataCatalogType?

    public init (
        description: String? = nil,
        name: String? = nil,
        parameters: [String:String]? = nil,
        tags: [Tag]? = nil,
        type: DataCatalogType? = nil
    )
    {
        self.description = description
        self.name = name
        self.parameters = parameters
        self.tags = tags
        self.type = type
    }
}

struct CreateDataCatalogInputBody: Equatable {
    public let name: String?
    public let type: DataCatalogType?
    public let description: String?
    public let parameters: [String:String]?
    public let tags: [Tag]?
}

extension CreateDataCatalogInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataCatalogType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDataCatalogOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataCatalogOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataCatalogOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataCatalogOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDataCatalogOutputResponse()"}
}

extension CreateDataCatalogOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateDataCatalogOutputResponse: Equatable {

    public init() {}
}

struct CreateDataCatalogOutputResponseBody: Equatable {
}

extension CreateDataCatalogOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateNamedQueryInputBodyMiddleware: Middleware {
    public let id: String = "CreateNamedQueryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNamedQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNamedQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNamedQueryInput>
    public typealias MOutput = OperationOutput<CreateNamedQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNamedQueryOutputError>
}

extension CreateNamedQueryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateNamedQueryInput(clientRequestToken: \(String(describing: clientRequestToken)), database: \(String(describing: database)), description: \(String(describing: description)), name: \(String(describing: name)), queryString: \(String(describing: queryString)), workGroup: \(String(describing: workGroup)))"}
}

extension CreateNamedQueryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case database = "Database"
        case description = "Description"
        case name = "Name"
        case queryString = "QueryString"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

public struct CreateNamedQueryInputHeadersMiddleware: Middleware {
    public let id: String = "CreateNamedQueryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNamedQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNamedQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNamedQueryInput>
    public typealias MOutput = OperationOutput<CreateNamedQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNamedQueryOutputError>
}

public struct CreateNamedQueryInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateNamedQueryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateNamedQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateNamedQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateNamedQueryInput>
    public typealias MOutput = OperationOutput<CreateNamedQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateNamedQueryOutputError>
}

public struct CreateNamedQueryInput: Equatable {
    /// <p>A unique case-sensitive string used to ensure the request to create the query is
    ///             idempotent (executes only once). If another <code>CreateNamedQuery</code> request is
    ///             received, the same response is returned and another query is not created. If a parameter
    ///             has changed, for example, the <code>QueryString</code>, an error is returned.</p>
    ///         <important>
    ///             <p>This token is listed as not required because AWS SDKs (for example the AWS SDK for
    ///                 Java) auto-generate the token for users. If you are not using the AWS SDK or the AWS
    ///                 CLI, you must provide this token or the action will fail.</p>
    ///         </important>
    public var clientRequestToken: String?
    /// <p>The database to which the query belongs.</p>
    public let database: String?
    /// <p>The query description.</p>
    public let description: String?
    /// <p>The query name.</p>
    public let name: String?
    /// <p>The contents of the query with all query statements.</p>
    public let queryString: String?
    /// <p>The name of the workgroup in which the named query is being created.</p>
    public let workGroup: String?

    public init (
        clientRequestToken: String? = nil,
        database: String? = nil,
        description: String? = nil,
        name: String? = nil,
        queryString: String? = nil,
        workGroup: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.database = database
        self.description = description
        self.name = name
        self.queryString = queryString
        self.workGroup = workGroup
    }
}

struct CreateNamedQueryInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let database: String?
    public let queryString: String?
    public let clientRequestToken: String?
    public let workGroup: String?
}

extension CreateNamedQueryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case database = "Database"
        case description = "Description"
        case name = "Name"
        case queryString = "QueryString"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension CreateNamedQueryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNamedQueryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateNamedQueryOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNamedQueryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateNamedQueryOutputResponse(namedQueryId: \(String(describing: namedQueryId)))"}
}

extension CreateNamedQueryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateNamedQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namedQueryId = output.namedQueryId
        } else {
            self.namedQueryId = nil
        }
    }
}

public struct CreateNamedQueryOutputResponse: Equatable {
    /// <p>The unique ID of the query.</p>
    public let namedQueryId: String?

    public init (
        namedQueryId: String? = nil
    )
    {
        self.namedQueryId = namedQueryId
    }
}

struct CreateNamedQueryOutputResponseBody: Equatable {
    public let namedQueryId: String?
}

extension CreateNamedQueryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
    }
}

public struct CreatePreparedStatementInputBodyMiddleware: Middleware {
    public let id: String = "CreatePreparedStatementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePreparedStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePreparedStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePreparedStatementInput>
    public typealias MOutput = OperationOutput<CreatePreparedStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePreparedStatementOutputError>
}

extension CreatePreparedStatementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePreparedStatementInput(description: \(String(describing: description)), queryStatement: \(String(describing: queryStatement)), statementName: \(String(describing: statementName)), workGroup: \(String(describing: workGroup)))"}
}

extension CreatePreparedStatementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let queryStatement = queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
        if let statementName = statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

public struct CreatePreparedStatementInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePreparedStatementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePreparedStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePreparedStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePreparedStatementInput>
    public typealias MOutput = OperationOutput<CreatePreparedStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePreparedStatementOutputError>
}

public struct CreatePreparedStatementInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePreparedStatementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePreparedStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePreparedStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePreparedStatementInput>
    public typealias MOutput = OperationOutput<CreatePreparedStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePreparedStatementOutputError>
}

public struct CreatePreparedStatementInput: Equatable {
    /// <p>The description of the prepared statement.</p>
    public let description: String?
    /// <p>The query string for the prepared statement.</p>
    public let queryStatement: String?
    /// <p>The name of the prepared statement.</p>
    public let statementName: String?
    /// <p>The name of the workgroup to which the prepared statement belongs.</p>
    public let workGroup: String?

    public init (
        description: String? = nil,
        queryStatement: String? = nil,
        statementName: String? = nil,
        workGroup: String? = nil
    )
    {
        self.description = description
        self.queryStatement = queryStatement
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

struct CreatePreparedStatementInputBody: Equatable {
    public let statementName: String?
    public let workGroup: String?
    public let queryStatement: String?
    public let description: String?
}

extension CreatePreparedStatementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let queryStatementDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreatePreparedStatementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePreparedStatementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePreparedStatementOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePreparedStatementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePreparedStatementOutputResponse()"}
}

extension CreatePreparedStatementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreatePreparedStatementOutputResponse: Equatable {

    public init() {}
}

struct CreatePreparedStatementOutputResponseBody: Equatable {
}

extension CreatePreparedStatementOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateWorkGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateWorkGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkGroupInput>
    public typealias MOutput = OperationOutput<CreateWorkGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkGroupOutputError>
}

extension CreateWorkGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorkGroupInput(configuration: \(String(describing: configuration)), description: \(String(describing: description)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateWorkGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateWorkGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWorkGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkGroupInput>
    public typealias MOutput = OperationOutput<CreateWorkGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkGroupOutputError>
}

public struct CreateWorkGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWorkGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkGroupInput>
    public typealias MOutput = OperationOutput<CreateWorkGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkGroupOutputError>
}

public struct CreateWorkGroupInput: Equatable {
    /// <p>The configuration for the workgroup, which includes the location in Amazon S3 where
    ///             query results are stored, the encryption configuration, if any, used for encrypting
    ///             query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup, the
    ///             limit for the amount of bytes scanned (cutoff) per query, if it is specified, and
    ///             whether workgroup's settings (specified with EnforceWorkGroupConfiguration) in the
    ///             WorkGroupConfiguration override client-side settings. See <a>WorkGroupConfiguration$EnforceWorkGroupConfiguration</a>.</p>
    public let configuration: WorkGroupConfiguration?
    /// <p>The workgroup description.</p>
    public let description: String?
    /// <p>The workgroup name.</p>
    public let name: String?
    /// <p>A list of comma separated tags to add to the workgroup that is created.</p>
    public let tags: [Tag]?

    public init (
        configuration: WorkGroupConfiguration? = nil,
        description: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.configuration = configuration
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateWorkGroupInputBody: Equatable {
    public let name: String?
    public let configuration: WorkGroupConfiguration?
    public let description: String?
    public let tags: [Tag]?
}

extension CreateWorkGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(WorkGroupConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWorkGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkGroupOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorkGroupOutputResponse()"}
}

extension CreateWorkGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateWorkGroupOutputResponse: Equatable {

    public init() {}
}

struct CreateWorkGroupOutputResponseBody: Equatable {
}

extension CreateWorkGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DataCatalog: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataCatalogType.self, forKey: .type)
        type = typeDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension DataCatalog: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataCatalog(description: \(String(describing: description)), name: \(String(describing: name)), parameters: \(String(describing: parameters)), type: \(String(describing: type)))"}
}

/// <p>Contains information about a data catalog in an AWS account.</p>
public struct DataCatalog: Equatable {
    /// <p>An optional description of the data catalog.</p>
    public let description: String?
    /// <p>The name of the data catalog. The catalog name must be unique for the AWS account and
    ///             can use a maximum of 128 alphanumeric, underscore, at sign, or hyphen characters.</p>
    public let name: String?
    /// <p>Specifies the Lambda function or functions to use for the data catalog. This is a
    ///             mapping whose values depend on the catalog type. </p>
    ///         <ul>
    ///             <li>
    ///                 <p>For the <code>HIVE</code> data catalog type, use the following syntax. The
    ///                         <code>metadata-function</code> parameter is required. <code>The
    ///                         sdk-version</code> parameter is optional and defaults to the currently
    ///                     supported version.</p>
    ///                 <p>
    ///                   <code>metadata-function=<i>lambda_arn</i>,
    ///                             sdk-version=<i>version_number</i>
    ///                   </code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>LAMBDA</code> data catalog type, use one of the following sets
    ///                     of required parameters, but not both.</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>If you have one Lambda function that processes metadata and another
    ///                             for reading the actual data, use the following syntax. Both parameters
    ///                             are required.</p>
    ///                         <p>
    ///                         <code>metadata-function=<i>lambda_arn</i>,
    ///                                     record-function=<i>lambda_arn</i>
    ///                         </code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p> If you have a composite Lambda function that processes both metadata
    ///                             and data, use the following syntax to specify your Lambda
    ///                             function.</p>
    ///                         <p>
    ///                         <code>function=<i>lambda_arn</i>
    ///                         </code>
    ///                      </p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let parameters: [String:String]?
    /// <p>The type of data catalog: <code>LAMBDA</code> for a federated catalog or
    ///                 <code>HIVE</code> for an external hive metastore. <code>GLUE</code> refers to the
    ///                 <code>AwsDataCatalog</code> that already exists in your account, of which you can
    ///             have only one.</p>
    public let type: DataCatalogType?

    public init (
        description: String? = nil,
        name: String? = nil,
        parameters: [String:String]? = nil,
        type: DataCatalogType? = nil
    )
    {
        self.description = description
        self.name = name
        self.parameters = parameters
        self.type = type
    }
}

extension DataCatalogSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogName = "CatalogName"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataCatalogType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DataCatalogSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataCatalogSummary(catalogName: \(String(describing: catalogName)), type: \(String(describing: type)))"}
}

/// <p>The summary information for the data catalog, which includes its name and type.</p>
public struct DataCatalogSummary: Equatable {
    /// <p>The name of the data catalog.</p>
    public let catalogName: String?
    /// <p>The data catalog type.</p>
    public let type: DataCatalogType?

    public init (
        catalogName: String? = nil,
        type: DataCatalogType? = nil
    )
    {
        self.catalogName = catalogName
        self.type = type
    }
}

public enum DataCatalogType {
    case glue
    case hive
    case lambda
    case sdkUnknown(String)
}

extension DataCatalogType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataCatalogType] {
        return [
            .glue,
            .hive,
            .lambda,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .glue: return "GLUE"
        case .hive: return "HIVE"
        case .lambda: return "LAMBDA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataCatalogType(rawValue: rawValue) ?? DataCatalogType.sdkUnknown(rawValue)
    }
}

extension Database: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension Database: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Database(description: \(String(describing: description)), name: \(String(describing: name)), parameters: \(String(describing: parameters)))"}
}

/// <p>Contains metadata information for a database in a data catalog.</p>
public struct Database: Equatable {
    /// <p>An optional description of the database.</p>
    public let description: String?
    /// <p>The name of the database.</p>
    public let name: String?
    /// <p>A set of custom key/value pairs.</p>
    public let parameters: [String:String]?

    public init (
        description: String? = nil,
        name: String? = nil,
        parameters: [String:String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.parameters = parameters
    }
}

extension Datum: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case varCharValue = "VarCharValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let varCharValue = varCharValue {
            try encodeContainer.encode(varCharValue, forKey: .varCharValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let varCharValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .varCharValue)
        varCharValue = varCharValueDecoded
    }
}

extension Datum: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Datum(varCharValue: \(String(describing: varCharValue)))"}
}

/// <p>A piece of data (a field in the table).</p>
public struct Datum: Equatable {
    /// <p>The value of the datum.</p>
    public let varCharValue: String?

    public init (
        varCharValue: String? = nil
    )
    {
        self.varCharValue = varCharValue
    }
}

public struct DeleteDataCatalogInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDataCatalogInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDataCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDataCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDataCatalogInput>
    public typealias MOutput = OperationOutput<DeleteDataCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDataCatalogOutputError>
}

extension DeleteDataCatalogInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDataCatalogInput(name: \(String(describing: name)))"}
}

extension DeleteDataCatalogInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteDataCatalogInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDataCatalogInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDataCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDataCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDataCatalogInput>
    public typealias MOutput = OperationOutput<DeleteDataCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDataCatalogOutputError>
}

public struct DeleteDataCatalogInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDataCatalogInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDataCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDataCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDataCatalogInput>
    public typealias MOutput = OperationOutput<DeleteDataCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDataCatalogOutputError>
}

public struct DeleteDataCatalogInput: Equatable {
    /// <p>The name of the data catalog to delete.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteDataCatalogInputBody: Equatable {
    public let name: String?
}

extension DeleteDataCatalogInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteDataCatalogOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataCatalogOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDataCatalogOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataCatalogOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDataCatalogOutputResponse()"}
}

extension DeleteDataCatalogOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDataCatalogOutputResponse: Equatable {

    public init() {}
}

struct DeleteDataCatalogOutputResponseBody: Equatable {
}

extension DeleteDataCatalogOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteNamedQueryInputBodyMiddleware: Middleware {
    public let id: String = "DeleteNamedQueryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNamedQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNamedQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNamedQueryInput>
    public typealias MOutput = OperationOutput<DeleteNamedQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNamedQueryOutputError>
}

extension DeleteNamedQueryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNamedQueryInput(namedQueryId: \(String(describing: namedQueryId)))"}
}

extension DeleteNamedQueryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namedQueryId = namedQueryId {
            try encodeContainer.encode(namedQueryId, forKey: .namedQueryId)
        }
    }
}

public struct DeleteNamedQueryInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteNamedQueryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNamedQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNamedQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNamedQueryInput>
    public typealias MOutput = OperationOutput<DeleteNamedQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNamedQueryOutputError>
}

public struct DeleteNamedQueryInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteNamedQueryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteNamedQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteNamedQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteNamedQueryInput>
    public typealias MOutput = OperationOutput<DeleteNamedQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteNamedQueryOutputError>
}

public struct DeleteNamedQueryInput: Equatable {
    /// <p>The unique ID of the query to delete.</p>
    public var namedQueryId: String?

    public init (
        namedQueryId: String? = nil
    )
    {
        self.namedQueryId = namedQueryId
    }
}

struct DeleteNamedQueryInputBody: Equatable {
    public let namedQueryId: String?
}

extension DeleteNamedQueryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
    }
}

extension DeleteNamedQueryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNamedQueryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNamedQueryOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNamedQueryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteNamedQueryOutputResponse()"}
}

extension DeleteNamedQueryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteNamedQueryOutputResponse: Equatable {

    public init() {}
}

struct DeleteNamedQueryOutputResponseBody: Equatable {
}

extension DeleteNamedQueryOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePreparedStatementInputBodyMiddleware: Middleware {
    public let id: String = "DeletePreparedStatementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePreparedStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePreparedStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePreparedStatementInput>
    public typealias MOutput = OperationOutput<DeletePreparedStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePreparedStatementOutputError>
}

extension DeletePreparedStatementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePreparedStatementInput(statementName: \(String(describing: statementName)), workGroup: \(String(describing: workGroup)))"}
}

extension DeletePreparedStatementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statementName = statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

public struct DeletePreparedStatementInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePreparedStatementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePreparedStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePreparedStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePreparedStatementInput>
    public typealias MOutput = OperationOutput<DeletePreparedStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePreparedStatementOutputError>
}

public struct DeletePreparedStatementInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePreparedStatementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePreparedStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePreparedStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePreparedStatementInput>
    public typealias MOutput = OperationOutput<DeletePreparedStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePreparedStatementOutputError>
}

public struct DeletePreparedStatementInput: Equatable {
    /// <p>The name of the prepared statement to delete.</p>
    public let statementName: String?
    /// <p>The workgroup to which the statement to be deleted belongs.</p>
    public let workGroup: String?

    public init (
        statementName: String? = nil,
        workGroup: String? = nil
    )
    {
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

struct DeletePreparedStatementInputBody: Equatable {
    public let statementName: String?
    public let workGroup: String?
}

extension DeletePreparedStatementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension DeletePreparedStatementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePreparedStatementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePreparedStatementOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePreparedStatementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePreparedStatementOutputResponse()"}
}

extension DeletePreparedStatementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePreparedStatementOutputResponse: Equatable {

    public init() {}
}

struct DeletePreparedStatementOutputResponseBody: Equatable {
}

extension DeletePreparedStatementOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteWorkGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteWorkGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkGroupInput>
    public typealias MOutput = OperationOutput<DeleteWorkGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkGroupOutputError>
}

extension DeleteWorkGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWorkGroupInput(recursiveDeleteOption: \(String(describing: recursiveDeleteOption)), workGroup: \(String(describing: workGroup)))"}
}

extension DeleteWorkGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recursiveDeleteOption = "RecursiveDeleteOption"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recursiveDeleteOption = recursiveDeleteOption {
            try encodeContainer.encode(recursiveDeleteOption, forKey: .recursiveDeleteOption)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

public struct DeleteWorkGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteWorkGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkGroupInput>
    public typealias MOutput = OperationOutput<DeleteWorkGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkGroupOutputError>
}

public struct DeleteWorkGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteWorkGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkGroupInput>
    public typealias MOutput = OperationOutput<DeleteWorkGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkGroupOutputError>
}

public struct DeleteWorkGroupInput: Equatable {
    /// <p>The option to delete the workgroup and its contents even if the workgroup contains any
    ///             named queries or query executions.</p>
    public let recursiveDeleteOption: Bool?
    /// <p>The unique name of the workgroup to delete.</p>
    public let workGroup: String?

    public init (
        recursiveDeleteOption: Bool? = nil,
        workGroup: String? = nil
    )
    {
        self.recursiveDeleteOption = recursiveDeleteOption
        self.workGroup = workGroup
    }
}

struct DeleteWorkGroupInputBody: Equatable {
    public let workGroup: String?
    public let recursiveDeleteOption: Bool?
}

extension DeleteWorkGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recursiveDeleteOption = "RecursiveDeleteOption"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let recursiveDeleteOptionDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .recursiveDeleteOption)
        recursiveDeleteOption = recursiveDeleteOptionDecoded
    }
}

extension DeleteWorkGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkGroupOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWorkGroupOutputResponse()"}
}

extension DeleteWorkGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteWorkGroupOutputResponseBody: Equatable {
}

extension DeleteWorkGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EncryptionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionOption = "EncryptionOption"
        case kmsKey = "KmsKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionOption = encryptionOption {
            try encodeContainer.encode(encryptionOption.rawValue, forKey: .encryptionOption)
        }
        if let kmsKey = kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionOptionDecoded = try containerValues.decodeIfPresent(EncryptionOption.self, forKey: .encryptionOption)
        encryptionOption = encryptionOptionDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

extension EncryptionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionConfiguration(encryptionOption: \(String(describing: encryptionOption)), kmsKey: \(String(describing: kmsKey)))"}
}

/// <p>If query results are encrypted in Amazon S3, indicates the encryption option used (for
///             example, <code>SSE-KMS</code> or <code>CSE-KMS</code>) and key information.</p>
public struct EncryptionConfiguration: Equatable {
    /// <p>Indicates whether Amazon S3 server-side encryption with Amazon S3-managed keys
    ///                 (<code>SSE-S3</code>), server-side encryption with KMS-managed keys
    ///                 (<code>SSE-KMS</code>), or client-side encryption with KMS-managed keys (CSE-KMS) is
    ///             used.</p>
    ///         <p>If a query runs in a workgroup and the workgroup overrides client-side settings, then
    ///             the workgroup's setting for encryption is used. It specifies whether query results must
    ///             be encrypted, for all queries that run in this workgroup. </p>
    public let encryptionOption: EncryptionOption?
    /// <p>For <code>SSE-KMS</code> and <code>CSE-KMS</code>, this is the KMS key ARN or
    ///             ID.</p>
    public let kmsKey: String?

    public init (
        encryptionOption: EncryptionOption? = nil,
        kmsKey: String? = nil
    )
    {
        self.encryptionOption = encryptionOption
        self.kmsKey = kmsKey
    }
}

public enum EncryptionOption {
    case cseKms
    case sseKms
    case sseS3
    case sdkUnknown(String)
}

extension EncryptionOption : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncryptionOption] {
        return [
            .cseKms,
            .sseKms,
            .sseS3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cseKms: return "CSE_KMS"
        case .sseKms: return "SSE_KMS"
        case .sseS3: return "SSE_S3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncryptionOption(rawValue: rawValue) ?? EncryptionOption.sdkUnknown(rawValue)
    }
}

extension EngineVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case effectiveEngineVersion = "EffectiveEngineVersion"
        case selectedEngineVersion = "SelectedEngineVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectiveEngineVersion = effectiveEngineVersion {
            try encodeContainer.encode(effectiveEngineVersion, forKey: .effectiveEngineVersion)
        }
        if let selectedEngineVersion = selectedEngineVersion {
            try encodeContainer.encode(selectedEngineVersion, forKey: .selectedEngineVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedEngineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .selectedEngineVersion)
        selectedEngineVersion = selectedEngineVersionDecoded
        let effectiveEngineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .effectiveEngineVersion)
        effectiveEngineVersion = effectiveEngineVersionDecoded
    }
}

extension EngineVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EngineVersion(effectiveEngineVersion: \(String(describing: effectiveEngineVersion)), selectedEngineVersion: \(String(describing: selectedEngineVersion)))"}
}

/// <p>The Athena engine version for running queries.</p>
public struct EngineVersion: Equatable {
    /// <p>Read only. The engine version on which the query runs. If the user requests
    ///             a valid engine version other than Auto, the effective engine version is the same as the
    ///             engine version that the user requested. If the user requests Auto, the effective engine version is chosen by Athena. When a request to update the engine version is made by a <code>CreateWorkGroup</code> or <code>UpdateWorkGroup</code> operation, the
    ///             <code>EffectiveEngineVersion</code> field is ignored.</p>
    public let effectiveEngineVersion: String?
    /// <p>The engine version requested by the user. Possible values are determined by the output of <code>ListEngineVersions</code>, including Auto. The default is Auto.</p>
    public let selectedEngineVersion: String?

    public init (
        effectiveEngineVersion: String? = nil,
        selectedEngineVersion: String? = nil
    )
    {
        self.effectiveEngineVersion = effectiveEngineVersion
        self.selectedEngineVersion = selectedEngineVersion
    }
}

public struct GetDataCatalogInputBodyMiddleware: Middleware {
    public let id: String = "GetDataCatalogInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataCatalogInput>
    public typealias MOutput = OperationOutput<GetDataCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataCatalogOutputError>
}

extension GetDataCatalogInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDataCatalogInput(name: \(String(describing: name)))"}
}

extension GetDataCatalogInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetDataCatalogInputHeadersMiddleware: Middleware {
    public let id: String = "GetDataCatalogInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataCatalogInput>
    public typealias MOutput = OperationOutput<GetDataCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataCatalogOutputError>
}

public struct GetDataCatalogInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDataCatalogInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataCatalogInput>
    public typealias MOutput = OperationOutput<GetDataCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataCatalogOutputError>
}

public struct GetDataCatalogInput: Equatable {
    /// <p>The name of the data catalog to return.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct GetDataCatalogInputBody: Equatable {
    public let name: String?
}

extension GetDataCatalogInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetDataCatalogOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataCatalogOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDataCatalogOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataCatalogOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDataCatalogOutputResponse(dataCatalog: \(String(describing: dataCatalog)))"}
}

extension GetDataCatalogOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDataCatalogOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataCatalog = output.dataCatalog
        } else {
            self.dataCatalog = nil
        }
    }
}

public struct GetDataCatalogOutputResponse: Equatable {
    /// <p>The data catalog returned.</p>
    public let dataCatalog: DataCatalog?

    public init (
        dataCatalog: DataCatalog? = nil
    )
    {
        self.dataCatalog = dataCatalog
    }
}

struct GetDataCatalogOutputResponseBody: Equatable {
    public let dataCatalog: DataCatalog?
}

extension GetDataCatalogOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataCatalog = "DataCatalog"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataCatalogDecoded = try containerValues.decodeIfPresent(DataCatalog.self, forKey: .dataCatalog)
        dataCatalog = dataCatalogDecoded
    }
}

public struct GetDatabaseInputBodyMiddleware: Middleware {
    public let id: String = "GetDatabaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDatabaseInput>
    public typealias MOutput = OperationOutput<GetDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDatabaseOutputError>
}

extension GetDatabaseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDatabaseInput(catalogName: \(String(describing: catalogName)), databaseName: \(String(describing: databaseName)))"}
}

extension GetDatabaseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
    }
}

public struct GetDatabaseInputHeadersMiddleware: Middleware {
    public let id: String = "GetDatabaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDatabaseInput>
    public typealias MOutput = OperationOutput<GetDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDatabaseOutputError>
}

public struct GetDatabaseInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDatabaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDatabaseInput>
    public typealias MOutput = OperationOutput<GetDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDatabaseOutputError>
}

public struct GetDatabaseInput: Equatable {
    /// <p>The name of the data catalog that contains the database to return.</p>
    public let catalogName: String?
    /// <p>The name of the database to return.</p>
    public let databaseName: String?

    public init (
        catalogName: String? = nil,
        databaseName: String? = nil
    )
    {
        self.catalogName = catalogName
        self.databaseName = databaseName
    }
}

struct GetDatabaseInputBody: Equatable {
    public let catalogName: String?
    public let databaseName: String?
}

extension GetDatabaseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension GetDatabaseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDatabaseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MetadataException" : self = .metadataException(try MetadataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDatabaseOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case metadataException(MetadataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDatabaseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDatabaseOutputResponse(database: \(String(describing: database)))"}
}

extension GetDatabaseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDatabaseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.database = output.database
        } else {
            self.database = nil
        }
    }
}

public struct GetDatabaseOutputResponse: Equatable {
    /// <p>The database returned.</p>
    public let database: Database?

    public init (
        database: Database? = nil
    )
    {
        self.database = database
    }
}

struct GetDatabaseOutputResponseBody: Equatable {
    public let database: Database?
}

extension GetDatabaseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case database = "Database"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(Database.self, forKey: .database)
        database = databaseDecoded
    }
}

public struct GetNamedQueryInputBodyMiddleware: Middleware {
    public let id: String = "GetNamedQueryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetNamedQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetNamedQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetNamedQueryInput>
    public typealias MOutput = OperationOutput<GetNamedQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetNamedQueryOutputError>
}

extension GetNamedQueryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetNamedQueryInput(namedQueryId: \(String(describing: namedQueryId)))"}
}

extension GetNamedQueryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namedQueryId = namedQueryId {
            try encodeContainer.encode(namedQueryId, forKey: .namedQueryId)
        }
    }
}

public struct GetNamedQueryInputHeadersMiddleware: Middleware {
    public let id: String = "GetNamedQueryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetNamedQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetNamedQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetNamedQueryInput>
    public typealias MOutput = OperationOutput<GetNamedQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetNamedQueryOutputError>
}

public struct GetNamedQueryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetNamedQueryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetNamedQueryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetNamedQueryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetNamedQueryInput>
    public typealias MOutput = OperationOutput<GetNamedQueryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetNamedQueryOutputError>
}

public struct GetNamedQueryInput: Equatable {
    /// <p>The unique ID of the query. Use <a>ListNamedQueries</a> to get query
    ///             IDs.</p>
    public let namedQueryId: String?

    public init (
        namedQueryId: String? = nil
    )
    {
        self.namedQueryId = namedQueryId
    }
}

struct GetNamedQueryInputBody: Equatable {
    public let namedQueryId: String?
}

extension GetNamedQueryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case namedQueryId = "NamedQueryId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
    }
}

extension GetNamedQueryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNamedQueryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNamedQueryOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNamedQueryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetNamedQueryOutputResponse(namedQuery: \(String(describing: namedQuery)))"}
}

extension GetNamedQueryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetNamedQueryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namedQuery = output.namedQuery
        } else {
            self.namedQuery = nil
        }
    }
}

public struct GetNamedQueryOutputResponse: Equatable {
    /// <p>Information about the query.</p>
    public let namedQuery: NamedQuery?

    public init (
        namedQuery: NamedQuery? = nil
    )
    {
        self.namedQuery = namedQuery
    }
}

struct GetNamedQueryOutputResponseBody: Equatable {
    public let namedQuery: NamedQuery?
}

extension GetNamedQueryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case namedQuery = "NamedQuery"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryDecoded = try containerValues.decodeIfPresent(NamedQuery.self, forKey: .namedQuery)
        namedQuery = namedQueryDecoded
    }
}

public struct GetPreparedStatementInputBodyMiddleware: Middleware {
    public let id: String = "GetPreparedStatementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPreparedStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPreparedStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPreparedStatementInput>
    public typealias MOutput = OperationOutput<GetPreparedStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPreparedStatementOutputError>
}

extension GetPreparedStatementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPreparedStatementInput(statementName: \(String(describing: statementName)), workGroup: \(String(describing: workGroup)))"}
}

extension GetPreparedStatementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statementName = statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

public struct GetPreparedStatementInputHeadersMiddleware: Middleware {
    public let id: String = "GetPreparedStatementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPreparedStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPreparedStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPreparedStatementInput>
    public typealias MOutput = OperationOutput<GetPreparedStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPreparedStatementOutputError>
}

public struct GetPreparedStatementInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPreparedStatementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPreparedStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPreparedStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPreparedStatementInput>
    public typealias MOutput = OperationOutput<GetPreparedStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPreparedStatementOutputError>
}

public struct GetPreparedStatementInput: Equatable {
    /// <p>The name of the prepared statement to retrieve.</p>
    public let statementName: String?
    /// <p>The workgroup to which the statement to be retrieved belongs.</p>
    public let workGroup: String?

    public init (
        statementName: String? = nil,
        workGroup: String? = nil
    )
    {
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

struct GetPreparedStatementInputBody: Equatable {
    public let statementName: String?
    public let workGroup: String?
}

extension GetPreparedStatementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension GetPreparedStatementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPreparedStatementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPreparedStatementOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPreparedStatementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPreparedStatementOutputResponse(preparedStatement: \(String(describing: preparedStatement)))"}
}

extension GetPreparedStatementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPreparedStatementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.preparedStatement = output.preparedStatement
        } else {
            self.preparedStatement = nil
        }
    }
}

public struct GetPreparedStatementOutputResponse: Equatable {
    /// <p>The name of the prepared statement that was retrieved.</p>
    public let preparedStatement: PreparedStatement?

    public init (
        preparedStatement: PreparedStatement? = nil
    )
    {
        self.preparedStatement = preparedStatement
    }
}

struct GetPreparedStatementOutputResponseBody: Equatable {
    public let preparedStatement: PreparedStatement?
}

extension GetPreparedStatementOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case preparedStatement = "PreparedStatement"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preparedStatementDecoded = try containerValues.decodeIfPresent(PreparedStatement.self, forKey: .preparedStatement)
        preparedStatement = preparedStatementDecoded
    }
}

public struct GetQueryExecutionInputBodyMiddleware: Middleware {
    public let id: String = "GetQueryExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetQueryExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetQueryExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetQueryExecutionInput>
    public typealias MOutput = OperationOutput<GetQueryExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetQueryExecutionOutputError>
}

extension GetQueryExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetQueryExecutionInput(queryExecutionId: \(String(describing: queryExecutionId)))"}
}

extension GetQueryExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryExecutionId = queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
    }
}

public struct GetQueryExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "GetQueryExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetQueryExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetQueryExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetQueryExecutionInput>
    public typealias MOutput = OperationOutput<GetQueryExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetQueryExecutionOutputError>
}

public struct GetQueryExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetQueryExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetQueryExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetQueryExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetQueryExecutionInput>
    public typealias MOutput = OperationOutput<GetQueryExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetQueryExecutionOutputError>
}

public struct GetQueryExecutionInput: Equatable {
    /// <p>The unique ID of the query execution.</p>
    public let queryExecutionId: String?

    public init (
        queryExecutionId: String? = nil
    )
    {
        self.queryExecutionId = queryExecutionId
    }
}

struct GetQueryExecutionInputBody: Equatable {
    public let queryExecutionId: String?
}

extension GetQueryExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
    }
}

extension GetQueryExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetQueryExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetQueryExecutionOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetQueryExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetQueryExecutionOutputResponse(queryExecution: \(String(describing: queryExecution)))"}
}

extension GetQueryExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetQueryExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.queryExecution = output.queryExecution
        } else {
            self.queryExecution = nil
        }
    }
}

public struct GetQueryExecutionOutputResponse: Equatable {
    /// <p>Information about the query execution.</p>
    public let queryExecution: QueryExecution?

    public init (
        queryExecution: QueryExecution? = nil
    )
    {
        self.queryExecution = queryExecution
    }
}

struct GetQueryExecutionOutputResponseBody: Equatable {
    public let queryExecution: QueryExecution?
}

extension GetQueryExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case queryExecution = "QueryExecution"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionDecoded = try containerValues.decodeIfPresent(QueryExecution.self, forKey: .queryExecution)
        queryExecution = queryExecutionDecoded
    }
}

public struct GetQueryResultsInputBodyMiddleware: Middleware {
    public let id: String = "GetQueryResultsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetQueryResultsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetQueryResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetQueryResultsInput>
    public typealias MOutput = OperationOutput<GetQueryResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetQueryResultsOutputError>
}

extension GetQueryResultsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetQueryResultsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), queryExecutionId: \(String(describing: queryExecutionId)))"}
}

extension GetQueryResultsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case queryExecutionId = "QueryExecutionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let queryExecutionId = queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
    }
}

public struct GetQueryResultsInputHeadersMiddleware: Middleware {
    public let id: String = "GetQueryResultsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetQueryResultsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetQueryResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetQueryResultsInput>
    public typealias MOutput = OperationOutput<GetQueryResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetQueryResultsOutputError>
}

public struct GetQueryResultsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetQueryResultsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetQueryResultsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetQueryResultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetQueryResultsInput>
    public typealias MOutput = OperationOutput<GetQueryResultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetQueryResultsOutputError>
}

public struct GetQueryResultsInput: Equatable {
    /// <p>The maximum number of results (rows) to return in this request.</p>
    public let maxResults: Int?
    /// <p>A token generated by the Athena service that specifies where to continue pagination if
    ///             a previous request was truncated. To obtain the next set of pages, pass in the
    ///                 <code>NextToken</code> from the response object of the previous page call.</p>
    public let nextToken: String?
    /// <p>The unique ID of the query execution.</p>
    public let queryExecutionId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        queryExecutionId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryExecutionId = queryExecutionId
    }
}

struct GetQueryResultsInputBody: Equatable {
    public let queryExecutionId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetQueryResultsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case queryExecutionId = "QueryExecutionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetQueryResultsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetQueryResultsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetQueryResultsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetQueryResultsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetQueryResultsOutputResponse(nextToken: \(String(describing: nextToken)), resultSet: \(String(describing: resultSet)), updateCount: \(String(describing: updateCount)))"}
}

extension GetQueryResultsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetQueryResultsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resultSet = output.resultSet
            self.updateCount = output.updateCount
        } else {
            self.nextToken = nil
            self.resultSet = nil
            self.updateCount = nil
        }
    }
}

public struct GetQueryResultsOutputResponse: Equatable {
    /// <p>A token generated by the Athena service that specifies where to continue pagination if
    ///             a previous request was truncated. To obtain the next set of pages, pass in the
    ///                 <code>NextToken</code> from the response object of the previous page call.</p>
    public let nextToken: String?
    /// <p>The results of the query execution.</p>
    public let resultSet: ResultSet?
    /// <p>The number of rows inserted with a CREATE TABLE AS SELECT statement. </p>
    public let updateCount: Int?

    public init (
        nextToken: String? = nil,
        resultSet: ResultSet? = nil,
        updateCount: Int? = nil
    )
    {
        self.nextToken = nextToken
        self.resultSet = resultSet
        self.updateCount = updateCount
    }
}

struct GetQueryResultsOutputResponseBody: Equatable {
    public let updateCount: Int?
    public let resultSet: ResultSet?
    public let nextToken: String?
}

extension GetQueryResultsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resultSet = "ResultSet"
        case updateCount = "UpdateCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .updateCount)
        updateCount = updateCountDecoded
        let resultSetDecoded = try containerValues.decodeIfPresent(ResultSet.self, forKey: .resultSet)
        resultSet = resultSetDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetTableMetadataInputBodyMiddleware: Middleware {
    public let id: String = "GetTableMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTableMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTableMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTableMetadataInput>
    public typealias MOutput = OperationOutput<GetTableMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTableMetadataOutputError>
}

extension GetTableMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTableMetadataInput(catalogName: \(String(describing: catalogName)), databaseName: \(String(describing: databaseName)), tableName: \(String(describing: tableName)))"}
}

extension GetTableMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct GetTableMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "GetTableMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTableMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTableMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTableMetadataInput>
    public typealias MOutput = OperationOutput<GetTableMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTableMetadataOutputError>
}

public struct GetTableMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTableMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTableMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTableMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTableMetadataInput>
    public typealias MOutput = OperationOutput<GetTableMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTableMetadataOutputError>
}

public struct GetTableMetadataInput: Equatable {
    /// <p>The name of the data catalog that contains the database and table metadata to
    ///             return.</p>
    public let catalogName: String?
    /// <p>The name of the database that contains the table metadata to return.</p>
    public let databaseName: String?
    /// <p>The name of the table for which metadata is returned.</p>
    public let tableName: String?

    public init (
        catalogName: String? = nil,
        databaseName: String? = nil,
        tableName: String? = nil
    )
    {
        self.catalogName = catalogName
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

struct GetTableMetadataInputBody: Equatable {
    public let catalogName: String?
    public let databaseName: String?
    public let tableName: String?
}

extension GetTableMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension GetTableMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTableMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MetadataException" : self = .metadataException(try MetadataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTableMetadataOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case metadataException(MetadataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTableMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTableMetadataOutputResponse(tableMetadata: \(String(describing: tableMetadata)))"}
}

extension GetTableMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTableMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tableMetadata = output.tableMetadata
        } else {
            self.tableMetadata = nil
        }
    }
}

public struct GetTableMetadataOutputResponse: Equatable {
    /// <p>An object that contains table metadata.</p>
    public let tableMetadata: TableMetadata?

    public init (
        tableMetadata: TableMetadata? = nil
    )
    {
        self.tableMetadata = tableMetadata
    }
}

struct GetTableMetadataOutputResponseBody: Equatable {
    public let tableMetadata: TableMetadata?
}

extension GetTableMetadataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tableMetadata = "TableMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableMetadataDecoded = try containerValues.decodeIfPresent(TableMetadata.self, forKey: .tableMetadata)
        tableMetadata = tableMetadataDecoded
    }
}

public struct GetWorkGroupInputBodyMiddleware: Middleware {
    public let id: String = "GetWorkGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkGroupInput>
    public typealias MOutput = OperationOutput<GetWorkGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkGroupOutputError>
}

extension GetWorkGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWorkGroupInput(workGroup: \(String(describing: workGroup)))"}
}

extension GetWorkGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

public struct GetWorkGroupInputHeadersMiddleware: Middleware {
    public let id: String = "GetWorkGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkGroupInput>
    public typealias MOutput = OperationOutput<GetWorkGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkGroupOutputError>
}

public struct GetWorkGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWorkGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWorkGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWorkGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWorkGroupInput>
    public typealias MOutput = OperationOutput<GetWorkGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWorkGroupOutputError>
}

public struct GetWorkGroupInput: Equatable {
    /// <p>The name of the workgroup.</p>
    public let workGroup: String?

    public init (
        workGroup: String? = nil
    )
    {
        self.workGroup = workGroup
    }
}

struct GetWorkGroupInputBody: Equatable {
    public let workGroup: String?
}

extension GetWorkGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension GetWorkGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWorkGroupOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWorkGroupOutputResponse(workGroup: \(String(describing: workGroup)))"}
}

extension GetWorkGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetWorkGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.workGroup = output.workGroup
        } else {
            self.workGroup = nil
        }
    }
}

public struct GetWorkGroupOutputResponse: Equatable {
    /// <p>Information about the workgroup.</p>
    public let workGroup: WorkGroup?

    public init (
        workGroup: WorkGroup? = nil
    )
    {
        self.workGroup = workGroup
    }
}

struct GetWorkGroupOutputResponseBody: Equatable {
    public let workGroup: WorkGroup?
}

extension GetWorkGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(WorkGroup.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates a platform issue, which may be due to a transient condition or
///             outage.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(athenaErrorCode: \(String(describing: athenaErrorCode)), message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.athenaErrorCode = output.athenaErrorCode
            self.message = output.message
        } else {
            self.athenaErrorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that something is wrong with the input to the request. For example, a
///             required parameter may be missing or out of range.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error code returned when the query execution failed to process, or when the
    ///             processing request for the named query failed.</p>
    public var athenaErrorCode: String?
    public var message: String?

    public init (
        athenaErrorCode: String? = nil,
        message: String? = nil
    )
    {
        self.athenaErrorCode = athenaErrorCode
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let athenaErrorCode: String?
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case athenaErrorCode = "AthenaErrorCode"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let athenaErrorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .athenaErrorCode)
        athenaErrorCode = athenaErrorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListDataCatalogsInputBodyMiddleware: Middleware {
    public let id: String = "ListDataCatalogsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataCatalogsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataCatalogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataCatalogsInput>
    public typealias MOutput = OperationOutput<ListDataCatalogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataCatalogsOutputError>
}

extension ListDataCatalogsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataCatalogsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDataCatalogsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDataCatalogsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDataCatalogsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataCatalogsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataCatalogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataCatalogsInput>
    public typealias MOutput = OperationOutput<ListDataCatalogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataCatalogsOutputError>
}

public struct ListDataCatalogsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDataCatalogsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataCatalogsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataCatalogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataCatalogsInput>
    public typealias MOutput = OperationOutput<ListDataCatalogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataCatalogsOutputError>
}

public struct ListDataCatalogsInput: Equatable {
    /// <p>Specifies the maximum number of data catalogs to return.</p>
    public let maxResults: Int?
    /// <p>A token generated by the Athena service that specifies where to continue pagination if
    ///             a previous request was truncated. To obtain the next set of pages, pass in the NextToken
    ///             from the response object of the previous page call.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataCatalogsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDataCatalogsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDataCatalogsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataCatalogsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataCatalogsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataCatalogsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataCatalogsOutputResponse(dataCatalogsSummary: \(String(describing: dataCatalogsSummary)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDataCatalogsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDataCatalogsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataCatalogsSummary = output.dataCatalogsSummary
            self.nextToken = output.nextToken
        } else {
            self.dataCatalogsSummary = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataCatalogsOutputResponse: Equatable {
    /// <p>A summary list of data catalogs.</p>
    public let dataCatalogsSummary: [DataCatalogSummary]?
    /// <p>A token generated by the Athena service that specifies where to continue pagination if
    ///             a previous request was truncated. To obtain the next set of pages, pass in the NextToken
    ///             from the response object of the previous page call.</p>
    public let nextToken: String?

    public init (
        dataCatalogsSummary: [DataCatalogSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.dataCatalogsSummary = dataCatalogsSummary
        self.nextToken = nextToken
    }
}

struct ListDataCatalogsOutputResponseBody: Equatable {
    public let dataCatalogsSummary: [DataCatalogSummary]?
    public let nextToken: String?
}

extension ListDataCatalogsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataCatalogsSummary = "DataCatalogsSummary"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataCatalogsSummaryContainer = try containerValues.decodeIfPresent([DataCatalogSummary?].self, forKey: .dataCatalogsSummary)
        var dataCatalogsSummaryDecoded0:[DataCatalogSummary]? = nil
        if let dataCatalogsSummaryContainer = dataCatalogsSummaryContainer {
            dataCatalogsSummaryDecoded0 = [DataCatalogSummary]()
            for structure0 in dataCatalogsSummaryContainer {
                if let structure0 = structure0 {
                    dataCatalogsSummaryDecoded0?.append(structure0)
                }
            }
        }
        dataCatalogsSummary = dataCatalogsSummaryDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDatabasesInputBodyMiddleware: Middleware {
    public let id: String = "ListDatabasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatabasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatabasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatabasesInput>
    public typealias MOutput = OperationOutput<ListDatabasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatabasesOutputError>
}

extension ListDatabasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatabasesInput(catalogName: \(String(describing: catalogName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatabasesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogName = "CatalogName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDatabasesInputHeadersMiddleware: Middleware {
    public let id: String = "ListDatabasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatabasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatabasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatabasesInput>
    public typealias MOutput = OperationOutput<ListDatabasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatabasesOutputError>
}

public struct ListDatabasesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDatabasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatabasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatabasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatabasesInput>
    public typealias MOutput = OperationOutput<ListDatabasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatabasesOutputError>
}

public struct ListDatabasesInput: Equatable {
    /// <p>The name of the data catalog that contains the databases to return.</p>
    public let catalogName: String?
    /// <p>Specifies the maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>A token generated by the Athena service that specifies where to continue pagination if
    ///             a previous request was truncated. To obtain the next set of pages, pass in the
    ///                 <code>NextToken</code> from the response object of the previous page call.</p>
    public let nextToken: String?

    public init (
        catalogName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.catalogName = catalogName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatabasesInputBody: Equatable {
    public let catalogName: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDatabasesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogName = "CatalogName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatabasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatabasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MetadataException" : self = .metadataException(try MetadataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatabasesOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case metadataException(MetadataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatabasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatabasesOutputResponse(databaseList: \(String(describing: databaseList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatabasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDatabasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.databaseList = output.databaseList
            self.nextToken = output.nextToken
        } else {
            self.databaseList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatabasesOutputResponse: Equatable {
    /// <p>A list of databases from a data catalog.</p>
    public let databaseList: [Database]?
    /// <p>A token generated by the Athena service that specifies where to continue pagination if
    ///             a previous request was truncated. To obtain the next set of pages, pass in the NextToken
    ///             from the response object of the previous page call.</p>
    public let nextToken: String?

    public init (
        databaseList: [Database]? = nil,
        nextToken: String? = nil
    )
    {
        self.databaseList = databaseList
        self.nextToken = nextToken
    }
}

struct ListDatabasesOutputResponseBody: Equatable {
    public let databaseList: [Database]?
    public let nextToken: String?
}

extension ListDatabasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case databaseList = "DatabaseList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseListContainer = try containerValues.decodeIfPresent([Database?].self, forKey: .databaseList)
        var databaseListDecoded0:[Database]? = nil
        if let databaseListContainer = databaseListContainer {
            databaseListDecoded0 = [Database]()
            for structure0 in databaseListContainer {
                if let structure0 = structure0 {
                    databaseListDecoded0?.append(structure0)
                }
            }
        }
        databaseList = databaseListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListEngineVersionsInputBodyMiddleware: Middleware {
    public let id: String = "ListEngineVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEngineVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEngineVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEngineVersionsInput>
    public typealias MOutput = OperationOutput<ListEngineVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEngineVersionsOutputError>
}

extension ListEngineVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEngineVersionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEngineVersionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEngineVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListEngineVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEngineVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEngineVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEngineVersionsInput>
    public typealias MOutput = OperationOutput<ListEngineVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEngineVersionsOutputError>
}

public struct ListEngineVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEngineVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEngineVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEngineVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEngineVersionsInput>
    public typealias MOutput = OperationOutput<ListEngineVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEngineVersionsOutputError>
}

public struct ListEngineVersionsInput: Equatable {
    /// <p>The maximum number of engine versions to return in this request.</p>
    public let maxResults: Int?
    /// <p>A token generated by the Athena service that specifies where to continue pagination if
    ///             a previous request was truncated. To obtain the next set of pages, pass in the
    ///                 <code>NextToken</code> from the response object of the previous page call.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEngineVersionsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListEngineVersionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEngineVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEngineVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEngineVersionsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEngineVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEngineVersionsOutputResponse(engineVersions: \(String(describing: engineVersions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEngineVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEngineVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.engineVersions = output.engineVersions
            self.nextToken = output.nextToken
        } else {
            self.engineVersions = nil
            self.nextToken = nil
        }
    }
}

public struct ListEngineVersionsOutputResponse: Equatable {
    /// <p>A list of engine versions that are available to choose from.</p>
    public let engineVersions: [EngineVersion]?
    /// <p>A token generated by the Athena service that specifies where to continue pagination if
    ///             a previous request was truncated. To obtain the next set of pages, pass in the
    ///                 <code>NextToken</code> from the response object of the previous page call.</p>
    public let nextToken: String?

    public init (
        engineVersions: [EngineVersion]? = nil,
        nextToken: String? = nil
    )
    {
        self.engineVersions = engineVersions
        self.nextToken = nextToken
    }
}

struct ListEngineVersionsOutputResponseBody: Equatable {
    public let engineVersions: [EngineVersion]?
    public let nextToken: String?
}

extension ListEngineVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engineVersions = "EngineVersions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineVersionsContainer = try containerValues.decodeIfPresent([EngineVersion?].self, forKey: .engineVersions)
        var engineVersionsDecoded0:[EngineVersion]? = nil
        if let engineVersionsContainer = engineVersionsContainer {
            engineVersionsDecoded0 = [EngineVersion]()
            for structure0 in engineVersionsContainer {
                if let structure0 = structure0 {
                    engineVersionsDecoded0?.append(structure0)
                }
            }
        }
        engineVersions = engineVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListNamedQueriesInputBodyMiddleware: Middleware {
    public let id: String = "ListNamedQueriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNamedQueriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNamedQueriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNamedQueriesInput>
    public typealias MOutput = OperationOutput<ListNamedQueriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNamedQueriesOutputError>
}

extension ListNamedQueriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNamedQueriesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), workGroup: \(String(describing: workGroup)))"}
}

extension ListNamedQueriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

public struct ListNamedQueriesInputHeadersMiddleware: Middleware {
    public let id: String = "ListNamedQueriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNamedQueriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNamedQueriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNamedQueriesInput>
    public typealias MOutput = OperationOutput<ListNamedQueriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNamedQueriesOutputError>
}

public struct ListNamedQueriesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListNamedQueriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNamedQueriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNamedQueriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNamedQueriesInput>
    public typealias MOutput = OperationOutput<ListNamedQueriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNamedQueriesOutputError>
}

public struct ListNamedQueriesInput: Equatable {
    /// <p>The maximum number of queries to return in this request.</p>
    public let maxResults: Int?
    /// <p>A token generated by the Athena service that specifies where to continue pagination if
    ///             a previous request was truncated. To obtain the next set of pages, pass in the
    ///                 <code>NextToken</code> from the response object of the previous page call.</p>
    public let nextToken: String?
    /// <p>The name of the workgroup from which the named queries are being returned. If a
    ///             workgroup is not specified, the saved queries for the primary workgroup are
    ///             returned.</p>
    public let workGroup: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        workGroup: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

struct ListNamedQueriesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let workGroup: String?
}

extension ListNamedQueriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension ListNamedQueriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNamedQueriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNamedQueriesOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNamedQueriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNamedQueriesOutputResponse(namedQueryIds: \(String(describing: namedQueryIds)), nextToken: \(String(describing: nextToken)))"}
}

extension ListNamedQueriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListNamedQueriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.namedQueryIds = output.namedQueryIds
            self.nextToken = output.nextToken
        } else {
            self.namedQueryIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListNamedQueriesOutputResponse: Equatable {
    /// <p>The list of unique query IDs.</p>
    public let namedQueryIds: [String]?
    /// <p>A token generated by the Athena service that specifies where to continue pagination if
    ///             a previous request was truncated. To obtain the next set of pages, pass in the
    ///                 <code>NextToken</code> from the response object of the previous page call.</p>
    public let nextToken: String?

    public init (
        namedQueryIds: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.namedQueryIds = namedQueryIds
        self.nextToken = nextToken
    }
}

struct ListNamedQueriesOutputResponseBody: Equatable {
    public let namedQueryIds: [String]?
    public let nextToken: String?
}

extension ListNamedQueriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case namedQueryIds = "NamedQueryIds"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .namedQueryIds)
        var namedQueryIdsDecoded0:[String]? = nil
        if let namedQueryIdsContainer = namedQueryIdsContainer {
            namedQueryIdsDecoded0 = [String]()
            for string0 in namedQueryIdsContainer {
                if let string0 = string0 {
                    namedQueryIdsDecoded0?.append(string0)
                }
            }
        }
        namedQueryIds = namedQueryIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPreparedStatementsInputBodyMiddleware: Middleware {
    public let id: String = "ListPreparedStatementsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPreparedStatementsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPreparedStatementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPreparedStatementsInput>
    public typealias MOutput = OperationOutput<ListPreparedStatementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPreparedStatementsOutputError>
}

extension ListPreparedStatementsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPreparedStatementsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), workGroup: \(String(describing: workGroup)))"}
}

extension ListPreparedStatementsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

public struct ListPreparedStatementsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPreparedStatementsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPreparedStatementsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPreparedStatementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPreparedStatementsInput>
    public typealias MOutput = OperationOutput<ListPreparedStatementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPreparedStatementsOutputError>
}

public struct ListPreparedStatementsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPreparedStatementsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPreparedStatementsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPreparedStatementsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPreparedStatementsInput>
    public typealias MOutput = OperationOutput<ListPreparedStatementsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPreparedStatementsOutputError>
}

public struct ListPreparedStatementsInput: Equatable {
    /// <p>The maximum number of results to return in this request.</p>
    public let maxResults: Int?
    /// <p>A token generated by the Athena service that specifies where to continue pagination if
    ///             a previous request was truncated. To obtain the next set of pages, pass in the
    ///                 <code>NextToken</code> from the response object of the previous page call.</p>
    public let nextToken: String?
    /// <p>The workgroup to list the prepared statements for.</p>
    public let workGroup: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        workGroup: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

struct ListPreparedStatementsInputBody: Equatable {
    public let workGroup: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListPreparedStatementsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPreparedStatementsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPreparedStatementsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPreparedStatementsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPreparedStatementsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPreparedStatementsOutputResponse(nextToken: \(String(describing: nextToken)), preparedStatements: \(String(describing: preparedStatements)))"}
}

extension ListPreparedStatementsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPreparedStatementsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.preparedStatements = output.preparedStatements
        } else {
            self.nextToken = nil
            self.preparedStatements = nil
        }
    }
}

public struct ListPreparedStatementsOutputResponse: Equatable {
    /// <p>A token generated by the Athena service that specifies where to continue pagination if
    ///             a previous request was truncated. To obtain the next set of pages, pass in the
    ///                 <code>NextToken</code> from the response object of the previous page call.</p>
    public let nextToken: String?
    /// <p>The list of prepared statements for the workgroup.</p>
    public let preparedStatements: [PreparedStatementSummary]?

    public init (
        nextToken: String? = nil,
        preparedStatements: [PreparedStatementSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.preparedStatements = preparedStatements
    }
}

struct ListPreparedStatementsOutputResponseBody: Equatable {
    public let preparedStatements: [PreparedStatementSummary]?
    public let nextToken: String?
}

extension ListPreparedStatementsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case preparedStatements = "PreparedStatements"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preparedStatementsContainer = try containerValues.decodeIfPresent([PreparedStatementSummary?].self, forKey: .preparedStatements)
        var preparedStatementsDecoded0:[PreparedStatementSummary]? = nil
        if let preparedStatementsContainer = preparedStatementsContainer {
            preparedStatementsDecoded0 = [PreparedStatementSummary]()
            for structure0 in preparedStatementsContainer {
                if let structure0 = structure0 {
                    preparedStatementsDecoded0?.append(structure0)
                }
            }
        }
        preparedStatements = preparedStatementsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListQueryExecutionsInputBodyMiddleware: Middleware {
    public let id: String = "ListQueryExecutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListQueryExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListQueryExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListQueryExecutionsInput>
    public typealias MOutput = OperationOutput<ListQueryExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListQueryExecutionsOutputError>
}

extension ListQueryExecutionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListQueryExecutionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), workGroup: \(String(describing: workGroup)))"}
}

extension ListQueryExecutionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

public struct ListQueryExecutionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListQueryExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListQueryExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListQueryExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListQueryExecutionsInput>
    public typealias MOutput = OperationOutput<ListQueryExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListQueryExecutionsOutputError>
}

public struct ListQueryExecutionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListQueryExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListQueryExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListQueryExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListQueryExecutionsInput>
    public typealias MOutput = OperationOutput<ListQueryExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListQueryExecutionsOutputError>
}

public struct ListQueryExecutionsInput: Equatable {
    /// <p>The maximum number of query executions to return in this request.</p>
    public let maxResults: Int?
    /// <p>A token generated by the Athena service that specifies where to continue pagination if
    ///             a previous request was truncated. To obtain the next set of pages, pass in the
    ///                 <code>NextToken</code> from the response object of the previous page call.</p>
    public let nextToken: String?
    /// <p>The name of the workgroup from which queries are being returned. If a workgroup is not
    ///             specified, a list of available query execution IDs for the queries in the primary
    ///             workgroup is returned.</p>
    public let workGroup: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        workGroup: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workGroup = workGroup
    }
}

struct ListQueryExecutionsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let workGroup: String?
}

extension ListQueryExecutionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension ListQueryExecutionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListQueryExecutionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListQueryExecutionsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListQueryExecutionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListQueryExecutionsOutputResponse(nextToken: \(String(describing: nextToken)), queryExecutionIds: \(String(describing: queryExecutionIds)))"}
}

extension ListQueryExecutionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListQueryExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.queryExecutionIds = output.queryExecutionIds
        } else {
            self.nextToken = nil
            self.queryExecutionIds = nil
        }
    }
}

public struct ListQueryExecutionsOutputResponse: Equatable {
    /// <p>A token to be used by the next request if this request is truncated.</p>
    public let nextToken: String?
    /// <p>The unique IDs of each query execution as an array of strings.</p>
    public let queryExecutionIds: [String]?

    public init (
        nextToken: String? = nil,
        queryExecutionIds: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.queryExecutionIds = queryExecutionIds
    }
}

struct ListQueryExecutionsOutputResponseBody: Equatable {
    public let queryExecutionIds: [String]?
    public let nextToken: String?
}

extension ListQueryExecutionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case queryExecutionIds = "QueryExecutionIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .queryExecutionIds)
        var queryExecutionIdsDecoded0:[String]? = nil
        if let queryExecutionIdsContainer = queryExecutionIdsContainer {
            queryExecutionIdsDecoded0 = [String]()
            for string0 in queryExecutionIdsContainer {
                if let string0 = string0 {
                    queryExecutionIdsDecoded0?.append(string0)
                }
            }
        }
        queryExecutionIds = queryExecutionIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTableMetadataInputBodyMiddleware: Middleware {
    public let id: String = "ListTableMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTableMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTableMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTableMetadataInput>
    public typealias MOutput = OperationOutput<ListTableMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTableMetadataOutputError>
}

extension ListTableMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTableMetadataInput(catalogName: \(String(describing: catalogName)), databaseName: \(String(describing: databaseName)), expression: \(String(describing: expression)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTableMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogName = catalogName {
            try encodeContainer.encode(catalogName, forKey: .catalogName)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTableMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "ListTableMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTableMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTableMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTableMetadataInput>
    public typealias MOutput = OperationOutput<ListTableMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTableMetadataOutputError>
}

public struct ListTableMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTableMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTableMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTableMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTableMetadataInput>
    public typealias MOutput = OperationOutput<ListTableMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTableMetadataOutputError>
}

public struct ListTableMetadataInput: Equatable {
    /// <p>The name of the data catalog for which table metadata should be returned.</p>
    public let catalogName: String?
    /// <p>The name of the database for which table metadata should be returned.</p>
    public let databaseName: String?
    /// <p>A regex filter that pattern-matches table names. If no expression is supplied,
    ///             metadata for all tables are listed.</p>
    public let expression: String?
    /// <p>Specifies the maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>A token generated by the Athena service that specifies where to continue pagination if
    ///             a previous request was truncated. To obtain the next set of pages, pass in the NextToken
    ///             from the response object of the previous page call.</p>
    public let nextToken: String?

    public init (
        catalogName: String? = nil,
        databaseName: String? = nil,
        expression: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.catalogName = catalogName
        self.databaseName = databaseName
        self.expression = expression
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTableMetadataInputBody: Equatable {
    public let catalogName: String?
    public let databaseName: String?
    public let expression: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListTableMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogName = "CatalogName"
        case databaseName = "DatabaseName"
        case expression = "Expression"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalogName)
        catalogName = catalogNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTableMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTableMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MetadataException" : self = .metadataException(try MetadataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTableMetadataOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case metadataException(MetadataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTableMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTableMetadataOutputResponse(nextToken: \(String(describing: nextToken)), tableMetadataList: \(String(describing: tableMetadataList)))"}
}

extension ListTableMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTableMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tableMetadataList = output.tableMetadataList
        } else {
            self.nextToken = nil
            self.tableMetadataList = nil
        }
    }
}

public struct ListTableMetadataOutputResponse: Equatable {
    /// <p>A token generated by the Athena service that specifies where to continue pagination if
    ///             a previous request was truncated. To obtain the next set of pages, pass in the NextToken
    ///             from the response object of the previous page call.</p>
    public let nextToken: String?
    /// <p>A list of table metadata.</p>
    public let tableMetadataList: [TableMetadata]?

    public init (
        nextToken: String? = nil,
        tableMetadataList: [TableMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.tableMetadataList = tableMetadataList
    }
}

struct ListTableMetadataOutputResponseBody: Equatable {
    public let tableMetadataList: [TableMetadata]?
    public let nextToken: String?
}

extension ListTableMetadataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tableMetadataList = "TableMetadataList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableMetadataListContainer = try containerValues.decodeIfPresent([TableMetadata?].self, forKey: .tableMetadataList)
        var tableMetadataListDecoded0:[TableMetadata]? = nil
        if let tableMetadataListContainer = tableMetadataListContainer {
            tableMetadataListDecoded0 = [TableMetadata]()
            for structure0 in tableMetadataListContainer {
                if let structure0 = structure0 {
                    tableMetadataListDecoded0?.append(structure0)
                }
            }
        }
        tableMetadataList = tableMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The maximum number of results to be returned per request that lists the tags for the
    ///             resource.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results, or null if there are no additional results for
    ///             this request, where the request lists the tags for the resource with the specified
    ///             ARN.</p>
    public let nextToken: String?
    /// <p>Lists the tags for the resource with the specified ARN.</p>
    public let resourceARN: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceARN: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceARN: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A token to be used by the next request if this request is truncated.</p>
    public let nextToken: String?
    /// <p>The list of tags associated with the specified resource.</p>
    public let tags: [Tag]?

    public init (
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let nextToken: String?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListWorkGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListWorkGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkGroupsInput>
    public typealias MOutput = OperationOutput<ListWorkGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkGroupsOutputError>
}

extension ListWorkGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorkGroupsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListWorkGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListWorkGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListWorkGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkGroupsInput>
    public typealias MOutput = OperationOutput<ListWorkGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkGroupsOutputError>
}

public struct ListWorkGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWorkGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkGroupsInput>
    public typealias MOutput = OperationOutput<ListWorkGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkGroupsOutputError>
}

public struct ListWorkGroupsInput: Equatable {
    /// <p>The maximum number of workgroups to return in this request.</p>
    public let maxResults: Int?
    /// <p>A token generated by the Athena service that specifies where to continue pagination if
    ///             a previous request was truncated. To obtain the next set of pages, pass in the
    ///                 <code>NextToken</code> from the response object of the previous page call.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkGroupsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListWorkGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWorkGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkGroupsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorkGroupsOutputResponse(nextToken: \(String(describing: nextToken)), workGroups: \(String(describing: workGroups)))"}
}

extension ListWorkGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWorkGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workGroups = output.workGroups
        } else {
            self.nextToken = nil
            self.workGroups = nil
        }
    }
}

public struct ListWorkGroupsOutputResponse: Equatable {
    /// <p>A token generated by the Athena service that specifies where to continue pagination if
    ///             a previous request was truncated. To obtain the next set of pages, pass in the
    ///                 <code>NextToken</code> from the response object of the previous page call.</p>
    public let nextToken: String?
    /// <p>A list of <a>WorkGroupSummary</a> objects that include the names,
    ///             descriptions, creation times, and states for each workgroup.</p>
    public let workGroups: [WorkGroupSummary]?

    public init (
        nextToken: String? = nil,
        workGroups: [WorkGroupSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workGroups = workGroups
    }
}

struct ListWorkGroupsOutputResponseBody: Equatable {
    public let workGroups: [WorkGroupSummary]?
    public let nextToken: String?
}

extension ListWorkGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case workGroups = "WorkGroups"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupsContainer = try containerValues.decodeIfPresent([WorkGroupSummary?].self, forKey: .workGroups)
        var workGroupsDecoded0:[WorkGroupSummary]? = nil
        if let workGroupsContainer = workGroupsContainer {
            workGroupsDecoded0 = [WorkGroupSummary]()
            for structure0 in workGroupsContainer {
                if let structure0 = structure0 {
                    workGroupsDecoded0?.append(structure0)
                }
            }
        }
        workGroups = workGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MetadataException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetadataException(message: \(String(describing: message)))"}
}

extension MetadataException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MetadataExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An exception that Athena received when it called a custom metastore. Occurs if the
///             error is not caused by user input (<code>InvalidRequestException</code>) or from the
///             Athena platform (<code>InternalServerException</code>). For example, if a user-created
///             Lambda function is missing permissions, the Lambda <code>4XX</code> exception is
///             returned in a <code>MetadataException</code>.</p>
public struct MetadataException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MetadataExceptionBody: Equatable {
    public let message: String?
}

extension MetadataExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NamedQuery: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case database = "Database"
        case description = "Description"
        case name = "Name"
        case namedQueryId = "NamedQueryId"
        case queryString = "QueryString"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namedQueryId = namedQueryId {
            try encodeContainer.encode(namedQueryId, forKey: .namedQueryId)
        }
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension NamedQuery: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NamedQuery(database: \(String(describing: database)), description: \(String(describing: description)), name: \(String(describing: name)), namedQueryId: \(String(describing: namedQueryId)), queryString: \(String(describing: queryString)), workGroup: \(String(describing: workGroup)))"}
}

/// <p>A query, where <code>QueryString</code> is the list of SQL query statements that
///             comprise the query.</p>
public struct NamedQuery: Equatable {
    /// <p>The database to which the query belongs.</p>
    public let database: String?
    /// <p>The query description.</p>
    public let description: String?
    /// <p>The query name.</p>
    public let name: String?
    /// <p>The unique identifier of the query.</p>
    public let namedQueryId: String?
    /// <p>The SQL query statements that comprise the query.</p>
    public let queryString: String?
    /// <p>The name of the workgroup that contains the named query.</p>
    public let workGroup: String?

    public init (
        database: String? = nil,
        description: String? = nil,
        name: String? = nil,
        namedQueryId: String? = nil,
        queryString: String? = nil,
        workGroup: String? = nil
    )
    {
        self.database = database
        self.description = description
        self.name = name
        self.namedQueryId = namedQueryId
        self.queryString = queryString
        self.workGroup = workGroup
    }
}

extension PreparedStatement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case lastModifiedTime = "LastModifiedTime"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroupName = "WorkGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let queryStatement = queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
        if let statementName = statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroupName = workGroupName {
            try encodeContainer.encode(workGroupName, forKey: .workGroupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let queryStatementDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
        let workGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workGroupName)
        workGroupName = workGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension PreparedStatement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PreparedStatement(description: \(String(describing: description)), lastModifiedTime: \(String(describing: lastModifiedTime)), queryStatement: \(String(describing: queryStatement)), statementName: \(String(describing: statementName)), workGroupName: \(String(describing: workGroupName)))"}
}

/// <p>A prepared SQL statement for use with Athena.</p>
public struct PreparedStatement: Equatable {
    /// <p>The description of the prepared statement.</p>
    public let description: String?
    /// <p>The last modified time of the prepared statement.</p>
    public let lastModifiedTime: Date?
    /// <p>The query string for the prepared statement.</p>
    public let queryStatement: String?
    /// <p>The name of the prepared statement.</p>
    public let statementName: String?
    /// <p>The name of the workgroup to which the prepared statement belongs.</p>
    public let workGroupName: String?

    public init (
        description: String? = nil,
        lastModifiedTime: Date? = nil,
        queryStatement: String? = nil,
        statementName: String? = nil,
        workGroupName: String? = nil
    )
    {
        self.description = description
        self.lastModifiedTime = lastModifiedTime
        self.queryStatement = queryStatement
        self.statementName = statementName
        self.workGroupName = workGroupName
    }
}

extension PreparedStatementSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastModifiedTime = "LastModifiedTime"
        case statementName = "StatementName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let statementName = statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension PreparedStatementSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PreparedStatementSummary(lastModifiedTime: \(String(describing: lastModifiedTime)), statementName: \(String(describing: statementName)))"}
}

/// <p>The name and last modified time of the prepared statement.</p>
public struct PreparedStatementSummary: Equatable {
    /// <p>The last modified time of the prepared statement.</p>
    public let lastModifiedTime: Date?
    /// <p>The name of the prepared statement.</p>
    public let statementName: String?

    public init (
        lastModifiedTime: Date? = nil,
        statementName: String? = nil
    )
    {
        self.lastModifiedTime = lastModifiedTime
        self.statementName = statementName
    }
}

extension QueryExecution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case engineVersion = "EngineVersion"
        case query = "Query"
        case queryExecutionContext = "QueryExecutionContext"
        case queryExecutionId = "QueryExecutionId"
        case resultConfiguration = "ResultConfiguration"
        case statementType = "StatementType"
        case statistics = "Statistics"
        case status = "Status"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let query = query {
            try encodeContainer.encode(query, forKey: .query)
        }
        if let queryExecutionContext = queryExecutionContext {
            try encodeContainer.encode(queryExecutionContext, forKey: .queryExecutionContext)
        }
        if let queryExecutionId = queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
        if let resultConfiguration = resultConfiguration {
            try encodeContainer.encode(resultConfiguration, forKey: .resultConfiguration)
        }
        if let statementType = statementType {
            try encodeContainer.encode(statementType.rawValue, forKey: .statementType)
        }
        if let statistics = statistics {
            try encodeContainer.encode(statistics, forKey: .statistics)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
        let queryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .query)
        query = queryDecoded
        let statementTypeDecoded = try containerValues.decodeIfPresent(StatementType.self, forKey: .statementType)
        statementType = statementTypeDecoded
        let resultConfigurationDecoded = try containerValues.decodeIfPresent(ResultConfiguration.self, forKey: .resultConfiguration)
        resultConfiguration = resultConfigurationDecoded
        let queryExecutionContextDecoded = try containerValues.decodeIfPresent(QueryExecutionContext.self, forKey: .queryExecutionContext)
        queryExecutionContext = queryExecutionContextDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QueryExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(QueryExecutionStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(EngineVersion.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension QueryExecution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryExecution(engineVersion: \(String(describing: engineVersion)), query: \(String(describing: query)), queryExecutionContext: \(String(describing: queryExecutionContext)), queryExecutionId: \(String(describing: queryExecutionId)), resultConfiguration: \(String(describing: resultConfiguration)), statementType: \(String(describing: statementType)), statistics: \(String(describing: statistics)), status: \(String(describing: status)), workGroup: \(String(describing: workGroup)))"}
}

/// <p>Information about a single instance of a query execution.</p>
public struct QueryExecution: Equatable {
    /// <p>The engine version that executed the query.</p>
    public let engineVersion: EngineVersion?
    /// <p>The SQL query statements which the query execution ran.</p>
    public let query: String?
    /// <p>The database in which the query execution occurred.</p>
    public let queryExecutionContext: QueryExecutionContext?
    /// <p>The unique identifier for each query execution.</p>
    public let queryExecutionId: String?
    /// <p>The location in Amazon S3 where query results were stored and the encryption option,
    ///             if any, used for query results. These are known as "client-side settings". If workgroup
    ///             settings override client-side settings, then the query uses the location for the query
    ///             results and the encryption configuration that are specified for the workgroup.</p>
    public let resultConfiguration: ResultConfiguration?
    /// <p>The type of query statement that was run. <code>DDL</code> indicates DDL query
    ///             statements. <code>DML</code> indicates DML (Data Manipulation Language) query
    ///             statements, such as <code>CREATE TABLE AS SELECT</code>. <code>UTILITY</code> indicates
    ///             query statements other than DDL and DML, such as <code>SHOW CREATE TABLE</code>, or
    ///                 <code>DESCRIBE <table></code>.</p>
    public let statementType: StatementType?
    /// <p>Query execution statistics, such as the amount of data scanned, the amount of time
    ///             that the query took to process, and the type of statement that was run.</p>
    public let statistics: QueryExecutionStatistics?
    /// <p>The completion date, current state, submission time, and state change reason (if
    ///             applicable) for the query execution.</p>
    public let status: QueryExecutionStatus?
    /// <p>The name of the workgroup in which the query ran.</p>
    public let workGroup: String?

    public init (
        engineVersion: EngineVersion? = nil,
        query: String? = nil,
        queryExecutionContext: QueryExecutionContext? = nil,
        queryExecutionId: String? = nil,
        resultConfiguration: ResultConfiguration? = nil,
        statementType: StatementType? = nil,
        statistics: QueryExecutionStatistics? = nil,
        status: QueryExecutionStatus? = nil,
        workGroup: String? = nil
    )
    {
        self.engineVersion = engineVersion
        self.query = query
        self.queryExecutionContext = queryExecutionContext
        self.queryExecutionId = queryExecutionId
        self.resultConfiguration = resultConfiguration
        self.statementType = statementType
        self.statistics = statistics
        self.status = status
        self.workGroup = workGroup
    }
}

extension QueryExecutionContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalog = "Catalog"
        case database = "Database"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
        let catalogDecoded = try containerValues.decodeIfPresent(String.self, forKey: .catalog)
        catalog = catalogDecoded
    }
}

extension QueryExecutionContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryExecutionContext(catalog: \(String(describing: catalog)), database: \(String(describing: database)))"}
}

/// <p>The database and data catalog context in which the query execution occurs.</p>
public struct QueryExecutionContext: Equatable {
    /// <p>The name of the data catalog used in the query execution.</p>
    public let catalog: String?
    /// <p>The name of the database used in the query execution.</p>
    public let database: String?

    public init (
        catalog: String? = nil,
        database: String? = nil
    )
    {
        self.catalog = catalog
        self.database = database
    }
}

public enum QueryExecutionState {
    case cancelled
    case failed
    case queued
    case running
    case succeeded
    case sdkUnknown(String)
}

extension QueryExecutionState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [QueryExecutionState] {
        return [
            .cancelled,
            .failed,
            .queued,
            .running,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "CANCELLED"
        case .failed: return "FAILED"
        case .queued: return "QUEUED"
        case .running: return "RUNNING"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = QueryExecutionState(rawValue: rawValue) ?? QueryExecutionState.sdkUnknown(rawValue)
    }
}

extension QueryExecutionStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataManifestLocation = "DataManifestLocation"
        case dataScannedInBytes = "DataScannedInBytes"
        case engineExecutionTimeInMillis = "EngineExecutionTimeInMillis"
        case queryPlanningTimeInMillis = "QueryPlanningTimeInMillis"
        case queryQueueTimeInMillis = "QueryQueueTimeInMillis"
        case serviceProcessingTimeInMillis = "ServiceProcessingTimeInMillis"
        case totalExecutionTimeInMillis = "TotalExecutionTimeInMillis"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataManifestLocation = dataManifestLocation {
            try encodeContainer.encode(dataManifestLocation, forKey: .dataManifestLocation)
        }
        if let dataScannedInBytes = dataScannedInBytes {
            try encodeContainer.encode(dataScannedInBytes, forKey: .dataScannedInBytes)
        }
        if let engineExecutionTimeInMillis = engineExecutionTimeInMillis {
            try encodeContainer.encode(engineExecutionTimeInMillis, forKey: .engineExecutionTimeInMillis)
        }
        if let queryPlanningTimeInMillis = queryPlanningTimeInMillis {
            try encodeContainer.encode(queryPlanningTimeInMillis, forKey: .queryPlanningTimeInMillis)
        }
        if let queryQueueTimeInMillis = queryQueueTimeInMillis {
            try encodeContainer.encode(queryQueueTimeInMillis, forKey: .queryQueueTimeInMillis)
        }
        if let serviceProcessingTimeInMillis = serviceProcessingTimeInMillis {
            try encodeContainer.encode(serviceProcessingTimeInMillis, forKey: .serviceProcessingTimeInMillis)
        }
        if let totalExecutionTimeInMillis = totalExecutionTimeInMillis {
            try encodeContainer.encode(totalExecutionTimeInMillis, forKey: .totalExecutionTimeInMillis)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineExecutionTimeInMillisDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .engineExecutionTimeInMillis)
        engineExecutionTimeInMillis = engineExecutionTimeInMillisDecoded
        let dataScannedInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dataScannedInBytes)
        dataScannedInBytes = dataScannedInBytesDecoded
        let dataManifestLocationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataManifestLocation)
        dataManifestLocation = dataManifestLocationDecoded
        let totalExecutionTimeInMillisDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalExecutionTimeInMillis)
        totalExecutionTimeInMillis = totalExecutionTimeInMillisDecoded
        let queryQueueTimeInMillisDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .queryQueueTimeInMillis)
        queryQueueTimeInMillis = queryQueueTimeInMillisDecoded
        let queryPlanningTimeInMillisDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .queryPlanningTimeInMillis)
        queryPlanningTimeInMillis = queryPlanningTimeInMillisDecoded
        let serviceProcessingTimeInMillisDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .serviceProcessingTimeInMillis)
        serviceProcessingTimeInMillis = serviceProcessingTimeInMillisDecoded
    }
}

extension QueryExecutionStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryExecutionStatistics(dataManifestLocation: \(String(describing: dataManifestLocation)), dataScannedInBytes: \(String(describing: dataScannedInBytes)), engineExecutionTimeInMillis: \(String(describing: engineExecutionTimeInMillis)), queryPlanningTimeInMillis: \(String(describing: queryPlanningTimeInMillis)), queryQueueTimeInMillis: \(String(describing: queryQueueTimeInMillis)), serviceProcessingTimeInMillis: \(String(describing: serviceProcessingTimeInMillis)), totalExecutionTimeInMillis: \(String(describing: totalExecutionTimeInMillis)))"}
}

/// <p>The amount of data scanned during the query execution and the amount of time that it
///             took to execute, and the type of statement that was run.</p>
public struct QueryExecutionStatistics: Equatable {
    /// <p>The location and file name of a data manifest file. The manifest file is saved to the
    ///             Athena query results location in Amazon S3. The manifest file tracks files that the
    ///             query wrote to Amazon S3. If the query fails, the manifest file also tracks files that
    ///             the query intended to write. The manifest is useful for identifying orphaned files
    ///             resulting from a failed query. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Working with Query Results, Output Files, and
    ///                 Query History</a> in the <i>Amazon Athena User Guide</i>.</p>
    public let dataManifestLocation: String?
    /// <p>The number of bytes in the data that was queried.</p>
    public let dataScannedInBytes: Int?
    /// <p>The number of milliseconds that the query took to execute.</p>
    public let engineExecutionTimeInMillis: Int?
    /// <p>The number of milliseconds that Athena took to plan the query processing flow. This
    ///             includes the time spent retrieving table partitions from the data source. Note that
    ///             because the query engine performs the query planning, query planning time is a subset of
    ///             engine processing time.</p>
    public let queryPlanningTimeInMillis: Int?
    /// <p>The number of milliseconds that the query was in your query queue waiting for
    ///             resources. Note that if transient errors occur, Athena might automatically add the query
    ///             back to the queue.</p>
    public let queryQueueTimeInMillis: Int?
    /// <p>The number of milliseconds that Athena took to finalize and publish the query results
    ///             after the query engine finished running the query.</p>
    public let serviceProcessingTimeInMillis: Int?
    /// <p>The number of milliseconds that Athena took to run the query.</p>
    public let totalExecutionTimeInMillis: Int?

    public init (
        dataManifestLocation: String? = nil,
        dataScannedInBytes: Int? = nil,
        engineExecutionTimeInMillis: Int? = nil,
        queryPlanningTimeInMillis: Int? = nil,
        queryQueueTimeInMillis: Int? = nil,
        serviceProcessingTimeInMillis: Int? = nil,
        totalExecutionTimeInMillis: Int? = nil
    )
    {
        self.dataManifestLocation = dataManifestLocation
        self.dataScannedInBytes = dataScannedInBytes
        self.engineExecutionTimeInMillis = engineExecutionTimeInMillis
        self.queryPlanningTimeInMillis = queryPlanningTimeInMillis
        self.queryQueueTimeInMillis = queryQueueTimeInMillis
        self.serviceProcessingTimeInMillis = serviceProcessingTimeInMillis
        self.totalExecutionTimeInMillis = totalExecutionTimeInMillis
    }
}

extension QueryExecutionStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case completionDateTime = "CompletionDateTime"
        case state = "State"
        case stateChangeReason = "StateChangeReason"
        case submissionDateTime = "SubmissionDateTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionDateTime = completionDateTime {
            try encodeContainer.encode(completionDateTime.timeIntervalSince1970, forKey: .completionDateTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangeReason = stateChangeReason {
            try encodeContainer.encode(stateChangeReason, forKey: .stateChangeReason)
        }
        if let submissionDateTime = submissionDateTime {
            try encodeContainer.encode(submissionDateTime.timeIntervalSince1970, forKey: .submissionDateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(QueryExecutionState.self, forKey: .state)
        state = stateDecoded
        let stateChangeReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateChangeReason)
        stateChangeReason = stateChangeReasonDecoded
        let submissionDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submissionDateTime)
        submissionDateTime = submissionDateTimeDecoded
        let completionDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completionDateTime)
        completionDateTime = completionDateTimeDecoded
    }
}

extension QueryExecutionStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryExecutionStatus(completionDateTime: \(String(describing: completionDateTime)), state: \(String(describing: state)), stateChangeReason: \(String(describing: stateChangeReason)), submissionDateTime: \(String(describing: submissionDateTime)))"}
}

/// <p>The completion date, current state, submission time, and state change reason (if
///             applicable) for the query execution.</p>
public struct QueryExecutionStatus: Equatable {
    /// <p>The date and time that the query completed.</p>
    public let completionDateTime: Date?
    /// <p>The state of query execution. <code>QUEUED</code> indicates that the query has been
    ///             submitted to the service, and Athena will execute the query as soon as resources are
    ///             available. <code>RUNNING</code> indicates that the query is in execution phase.
    ///                 <code>SUCCEEDED</code> indicates that the query completed without errors.
    ///                 <code>FAILED</code> indicates that the query experienced an error and did not
    ///             complete processing. <code>CANCELLED</code> indicates that a user input interrupted
    ///             query execution.</p>
    ///         <note>
    ///             <p>Athena automatically retries your queries in cases of certain transient errors. As
    ///                 a result, you may see the query state transition from <code>RUNNING</code> or
    ///                     <code>FAILED</code> to <code>QUEUED</code>. </p>
    ///         </note>
    public let state: QueryExecutionState?
    /// <p>Further detail about the status of the query.</p>
    public let stateChangeReason: String?
    /// <p>The date and time that the query was submitted.</p>
    public let submissionDateTime: Date?

    public init (
        completionDateTime: Date? = nil,
        state: QueryExecutionState? = nil,
        stateChangeReason: String? = nil,
        submissionDateTime: Date? = nil
    )
    {
        self.completionDateTime = completionDateTime
        self.state = state
        self.stateChangeReason = stateChangeReason
        self.submissionDateTime = submissionDateTime
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceName: \(String(describing: resourceName)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource, such as a workgroup, was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var resourceName: String?

    public init (
        message: String? = nil,
        resourceName: String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceName: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ResultConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionConfiguration = "EncryptionConfiguration"
        case outputLocation = "OutputLocation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputLocationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
    }
}

extension ResultConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResultConfiguration(encryptionConfiguration: \(String(describing: encryptionConfiguration)), outputLocation: \(String(describing: outputLocation)))"}
}

/// <p>The location in Amazon S3 where query results are stored and the encryption option, if
///             any, used for query results. These are known as "client-side settings". If workgroup
///             settings override client-side settings, then the query uses the workgroup
///             settings.</p>
public struct ResultConfiguration: Equatable {
    /// <p>If query results are encrypted in Amazon S3, indicates the encryption option used (for
    ///             example, <code>SSE-KMS</code> or <code>CSE-KMS</code>) and key information. This is a
    ///             client-side setting. If workgroup settings override client-side settings, then the query
    ///             uses the encryption configuration that is specified for the workgroup, and also uses the
    ///             location for storing query results specified in the workgroup. See <a>WorkGroupConfiguration$EnforceWorkGroupConfiguration</a> and <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    public let encryptionConfiguration: EncryptionConfiguration?
    /// <p>The location in Amazon S3 where your query results are stored, such as
    ///                 <code>s3://path/to/query/bucket/</code>. To run the query, you must specify the
    ///             query results location using one of the ways: either for individual queries using either
    ///             this setting (client-side), or in the workgroup, using <a>WorkGroupConfiguration</a>. If none of them is set, Athena issues an error
    ///             that no output location is provided. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a>. If
    ///             workgroup settings override client-side settings, then the query uses the settings
    ///             specified for the workgroup. See <a>WorkGroupConfiguration$EnforceWorkGroupConfiguration</a>.</p>
    public let outputLocation: String?

    public init (
        encryptionConfiguration: EncryptionConfiguration? = nil,
        outputLocation: String? = nil
    )
    {
        self.encryptionConfiguration = encryptionConfiguration
        self.outputLocation = outputLocation
    }
}

extension ResultConfigurationUpdates: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionConfiguration = "EncryptionConfiguration"
        case outputLocation = "OutputLocation"
        case removeEncryptionConfiguration = "RemoveEncryptionConfiguration"
        case removeOutputLocation = "RemoveOutputLocation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let removeEncryptionConfiguration = removeEncryptionConfiguration {
            try encodeContainer.encode(removeEncryptionConfiguration, forKey: .removeEncryptionConfiguration)
        }
        if let removeOutputLocation = removeOutputLocation {
            try encodeContainer.encode(removeOutputLocation, forKey: .removeOutputLocation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputLocationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let removeOutputLocationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .removeOutputLocation)
        removeOutputLocation = removeOutputLocationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let removeEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .removeEncryptionConfiguration)
        removeEncryptionConfiguration = removeEncryptionConfigurationDecoded
    }
}

extension ResultConfigurationUpdates: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResultConfigurationUpdates(encryptionConfiguration: \(String(describing: encryptionConfiguration)), outputLocation: \(String(describing: outputLocation)), removeEncryptionConfiguration: \(String(describing: removeEncryptionConfiguration)), removeOutputLocation: \(String(describing: removeOutputLocation)))"}
}

/// <p>The information about the updates in the query results, such as output location and
///             encryption configuration for the query results.</p>
public struct ResultConfigurationUpdates: Equatable {
    /// <p>The encryption configuration for the query results.</p>
    public let encryptionConfiguration: EncryptionConfiguration?
    /// <p>The location in Amazon S3 where your query results are stored, such as
    ///                 <code>s3://path/to/query/bucket/</code>. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query Results</a> If
    ///             workgroup settings override client-side settings, then the query uses the location for
    ///             the query results and the encryption configuration that are specified for the workgroup.
    ///             The "workgroup settings override" is specified in EnforceWorkGroupConfiguration
    ///             (true/false) in the WorkGroupConfiguration. See <a>WorkGroupConfiguration$EnforceWorkGroupConfiguration</a>.</p>
    public let outputLocation: String?
    /// <p>If set to "true", indicates that the previously-specified encryption configuration
    ///             (also known as the client-side setting) for queries in this workgroup should be ignored
    ///             and set to null. If set to "false" or not set, and a value is present in the
    ///             EncryptionConfiguration in ResultConfigurationUpdates (the client-side setting), the
    ///             EncryptionConfiguration in the workgroup's ResultConfiguration will be updated with the
    ///             new value. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override
    ///                 Client-Side Settings</a>.</p>
    public let removeEncryptionConfiguration: Bool?
    /// <p>If set to "true", indicates that the previously-specified query results location (also
    ///             known as a client-side setting) for queries in this workgroup should be ignored and set
    ///             to null. If set to "false" or not set, and a value is present in the OutputLocation in
    ///             ResultConfigurationUpdates (the client-side setting), the OutputLocation in the
    ///             workgroup's ResultConfiguration will be updated with the new value. For more
    ///             information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override
    ///                 Client-Side Settings</a>.</p>
    public let removeOutputLocation: Bool?

    public init (
        encryptionConfiguration: EncryptionConfiguration? = nil,
        outputLocation: String? = nil,
        removeEncryptionConfiguration: Bool? = nil,
        removeOutputLocation: Bool? = nil
    )
    {
        self.encryptionConfiguration = encryptionConfiguration
        self.outputLocation = outputLocation
        self.removeEncryptionConfiguration = removeEncryptionConfiguration
        self.removeOutputLocation = removeOutputLocation
    }
}

extension ResultSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resultSetMetadata = "ResultSetMetadata"
        case rows = "Rows"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resultSetMetadata = resultSetMetadata {
            try encodeContainer.encode(resultSetMetadata, forKey: .resultSetMetadata)
        }
        if let rows = rows {
            var rowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rows)
            for rowlist0 in rows {
                try rowsContainer.encode(rowlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowsContainer = try containerValues.decodeIfPresent([Row?].self, forKey: .rows)
        var rowsDecoded0:[Row]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [Row]()
            for structure0 in rowsContainer {
                if let structure0 = structure0 {
                    rowsDecoded0?.append(structure0)
                }
            }
        }
        rows = rowsDecoded0
        let resultSetMetadataDecoded = try containerValues.decodeIfPresent(ResultSetMetadata.self, forKey: .resultSetMetadata)
        resultSetMetadata = resultSetMetadataDecoded
    }
}

extension ResultSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResultSet(resultSetMetadata: \(String(describing: resultSetMetadata)), rows: \(String(describing: rows)))"}
}

/// <p>The metadata and rows that comprise a query result set. The metadata describes the
///             column structure and data types. To return a <code>ResultSet</code> object, use <a>GetQueryResults</a>.</p>
public struct ResultSet: Equatable {
    /// <p>The metadata that describes the column structure and data types of a table of query
    ///             results.</p>
    public let resultSetMetadata: ResultSetMetadata?
    /// <p>The rows in the table.</p>
    public let rows: [Row]?

    public init (
        resultSetMetadata: ResultSetMetadata? = nil,
        rows: [Row]? = nil
    )
    {
        self.resultSetMetadata = resultSetMetadata
        self.rows = rows
    }
}

extension ResultSetMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnInfo = "ColumnInfo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnInfo = columnInfo {
            var columnInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnInfo)
            for columninfolist0 in columnInfo {
                try columnInfoContainer.encode(columninfolist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnInfoContainer = try containerValues.decodeIfPresent([ColumnInfo?].self, forKey: .columnInfo)
        var columnInfoDecoded0:[ColumnInfo]? = nil
        if let columnInfoContainer = columnInfoContainer {
            columnInfoDecoded0 = [ColumnInfo]()
            for structure0 in columnInfoContainer {
                if let structure0 = structure0 {
                    columnInfoDecoded0?.append(structure0)
                }
            }
        }
        columnInfo = columnInfoDecoded0
    }
}

extension ResultSetMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResultSetMetadata(columnInfo: \(String(describing: columnInfo)))"}
}

/// <p>The metadata that describes the column structure and data types of a table of query
///             results. To return a <code>ResultSetMetadata</code> object, use <a>GetQueryResults</a>.</p>
public struct ResultSetMetadata: Equatable {
    /// <p>Information about the columns returned in a query result metadata.</p>
    public let columnInfo: [ColumnInfo]?

    public init (
        columnInfo: [ColumnInfo]? = nil
    )
    {
        self.columnInfo = columnInfo
    }
}

extension Row: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case data = "Data"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            var dataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .data)
            for datumlist0 in data {
                try dataContainer.encode(datumlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataContainer = try containerValues.decodeIfPresent([Datum?].self, forKey: .data)
        var dataDecoded0:[Datum]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [Datum]()
            for structure0 in dataContainer {
                if let structure0 = structure0 {
                    dataDecoded0?.append(structure0)
                }
            }
        }
        data = dataDecoded0
    }
}

extension Row: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Row(data: \(String(describing: data)))"}
}

/// <p>The rows that comprise a query result table.</p>
public struct Row: Equatable {
    /// <p>The data that populates a row in a query result table.</p>
    public let data: [Datum]?

    public init (
        data: [Datum]? = nil
    )
    {
        self.data = data
    }
}

public struct StartQueryExecutionInputBodyMiddleware: Middleware {
    public let id: String = "StartQueryExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartQueryExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartQueryExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartQueryExecutionInput>
    public typealias MOutput = OperationOutput<StartQueryExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartQueryExecutionOutputError>
}

extension StartQueryExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartQueryExecutionInput(clientRequestToken: \(String(describing: clientRequestToken)), queryExecutionContext: \(String(describing: queryExecutionContext)), queryString: \(String(describing: queryString)), resultConfiguration: \(String(describing: resultConfiguration)), workGroup: \(String(describing: workGroup)))"}
}

extension StartQueryExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case queryExecutionContext = "QueryExecutionContext"
        case queryString = "QueryString"
        case resultConfiguration = "ResultConfiguration"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let queryExecutionContext = queryExecutionContext {
            try encodeContainer.encode(queryExecutionContext, forKey: .queryExecutionContext)
        }
        if let queryString = queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let resultConfiguration = resultConfiguration {
            try encodeContainer.encode(resultConfiguration, forKey: .resultConfiguration)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

public struct StartQueryExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "StartQueryExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartQueryExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartQueryExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartQueryExecutionInput>
    public typealias MOutput = OperationOutput<StartQueryExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartQueryExecutionOutputError>
}

public struct StartQueryExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "StartQueryExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartQueryExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartQueryExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartQueryExecutionInput>
    public typealias MOutput = OperationOutput<StartQueryExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartQueryExecutionOutputError>
}

public struct StartQueryExecutionInput: Equatable {
    /// <p>A unique case-sensitive string used to ensure the request to create the query is
    ///             idempotent (executes only once). If another <code>StartQueryExecution</code> request is
    ///             received, the same response is returned and another query is not created. If a parameter
    ///             has changed, for example, the <code>QueryString</code>, an error is returned.</p>
    ///         <important>
    ///             <p>This token is listed as not required because AWS SDKs (for example the AWS SDK for
    ///                 Java) auto-generate the token for users. If you are not using the AWS SDK or the AWS
    ///                 CLI, you must provide this token or the action will fail.</p>
    ///         </important>
    public var clientRequestToken: String?
    /// <p>The database within which the query executes.</p>
    public let queryExecutionContext: QueryExecutionContext?
    /// <p>The SQL query statements to be executed.</p>
    public let queryString: String?
    /// <p>Specifies information about where and how to save the results of the query execution.
    ///             If the query runs in a workgroup, then workgroup's settings may override query settings.
    ///             This affects the query results location. The workgroup settings override is specified in
    ///             EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See <a>WorkGroupConfiguration$EnforceWorkGroupConfiguration</a>.</p>
    public let resultConfiguration: ResultConfiguration?
    /// <p>The name of the workgroup in which the query is being started.</p>
    public let workGroup: String?

    public init (
        clientRequestToken: String? = nil,
        queryExecutionContext: QueryExecutionContext? = nil,
        queryString: String? = nil,
        resultConfiguration: ResultConfiguration? = nil,
        workGroup: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.queryExecutionContext = queryExecutionContext
        self.queryString = queryString
        self.resultConfiguration = resultConfiguration
        self.workGroup = workGroup
    }
}

struct StartQueryExecutionInputBody: Equatable {
    public let queryString: String?
    public let clientRequestToken: String?
    public let queryExecutionContext: QueryExecutionContext?
    public let resultConfiguration: ResultConfiguration?
    public let workGroup: String?
}

extension StartQueryExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case queryExecutionContext = "QueryExecutionContext"
        case queryString = "QueryString"
        case resultConfiguration = "ResultConfiguration"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let queryExecutionContextDecoded = try containerValues.decodeIfPresent(QueryExecutionContext.self, forKey: .queryExecutionContext)
        queryExecutionContext = queryExecutionContextDecoded
        let resultConfigurationDecoded = try containerValues.decodeIfPresent(ResultConfiguration.self, forKey: .resultConfiguration)
        resultConfiguration = resultConfigurationDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
    }
}

extension StartQueryExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartQueryExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartQueryExecutionOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartQueryExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartQueryExecutionOutputResponse(queryExecutionId: \(String(describing: queryExecutionId)))"}
}

extension StartQueryExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartQueryExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.queryExecutionId = output.queryExecutionId
        } else {
            self.queryExecutionId = nil
        }
    }
}

public struct StartQueryExecutionOutputResponse: Equatable {
    /// <p>The unique ID of the query that ran as a result of this request.</p>
    public let queryExecutionId: String?

    public init (
        queryExecutionId: String? = nil
    )
    {
        self.queryExecutionId = queryExecutionId
    }
}

struct StartQueryExecutionOutputResponseBody: Equatable {
    public let queryExecutionId: String?
}

extension StartQueryExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
    }
}

public enum StatementType {
    case ddl
    case dml
    case utility
    case sdkUnknown(String)
}

extension StatementType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StatementType] {
        return [
            .ddl,
            .dml,
            .utility,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ddl: return "DDL"
        case .dml: return "DML"
        case .utility: return "UTILITY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StatementType(rawValue: rawValue) ?? StatementType.sdkUnknown(rawValue)
    }
}

public struct StopQueryExecutionInputBodyMiddleware: Middleware {
    public let id: String = "StopQueryExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopQueryExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StopQueryExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopQueryExecutionInput>
    public typealias MOutput = OperationOutput<StopQueryExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopQueryExecutionOutputError>
}

extension StopQueryExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopQueryExecutionInput(queryExecutionId: \(String(describing: queryExecutionId)))"}
}

extension StopQueryExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryExecutionId = queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
    }
}

public struct StopQueryExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "StopQueryExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopQueryExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StopQueryExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopQueryExecutionInput>
    public typealias MOutput = OperationOutput<StopQueryExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopQueryExecutionOutputError>
}

public struct StopQueryExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "StopQueryExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopQueryExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StopQueryExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopQueryExecutionInput>
    public typealias MOutput = OperationOutput<StopQueryExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopQueryExecutionOutputError>
}

public struct StopQueryExecutionInput: Equatable {
    /// <p>The unique ID of the query execution to stop.</p>
    public var queryExecutionId: String?

    public init (
        queryExecutionId: String? = nil
    )
    {
        self.queryExecutionId = queryExecutionId
    }
}

struct StopQueryExecutionInputBody: Equatable {
    public let queryExecutionId: String?
}

extension StopQueryExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case queryExecutionId = "QueryExecutionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
    }
}

extension StopQueryExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopQueryExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopQueryExecutionOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopQueryExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopQueryExecutionOutputResponse()"}
}

extension StopQueryExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopQueryExecutionOutputResponse: Equatable {

    public init() {}
}

struct StopQueryExecutionOutputResponseBody: Equatable {
}

extension StopQueryExecutionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TableMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columns = "Columns"
        case createTime = "CreateTime"
        case lastAccessTime = "LastAccessTime"
        case name = "Name"
        case parameters = "Parameters"
        case partitionKeys = "PartitionKeys"
        case tableType = "TableType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for columnlist0 in columns {
                try columnsContainer.encode(columnlist0)
            }
        }
        if let createTime = createTime {
            try encodeContainer.encode(createTime.timeIntervalSince1970, forKey: .createTime)
        }
        if let lastAccessTime = lastAccessTime {
            try encodeContainer.encode(lastAccessTime.timeIntervalSince1970, forKey: .lastAccessTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let partitionKeys = partitionKeys {
            var partitionKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionKeys)
            for columnlist0 in partitionKeys {
                try partitionKeysContainer.encode(columnlist0)
            }
        }
        if let tableType = tableType {
            try encodeContainer.encode(tableType, forKey: .tableType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createTime)
        createTime = createTimeDecoded
        let lastAccessTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAccessTime)
        lastAccessTime = lastAccessTimeDecoded
        let tableTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableType)
        tableType = tableTypeDecoded
        let columnsContainer = try containerValues.decodeIfPresent([Column?].self, forKey: .columns)
        var columnsDecoded0:[Column]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [Column]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
        let partitionKeysContainer = try containerValues.decodeIfPresent([Column?].self, forKey: .partitionKeys)
        var partitionKeysDecoded0:[Column]? = nil
        if let partitionKeysContainer = partitionKeysContainer {
            partitionKeysDecoded0 = [Column]()
            for structure0 in partitionKeysContainer {
                if let structure0 = structure0 {
                    partitionKeysDecoded0?.append(structure0)
                }
            }
        }
        partitionKeys = partitionKeysDecoded0
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension TableMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableMetadata(columns: \(String(describing: columns)), createTime: \(String(describing: createTime)), lastAccessTime: \(String(describing: lastAccessTime)), name: \(String(describing: name)), parameters: \(String(describing: parameters)), partitionKeys: \(String(describing: partitionKeys)), tableType: \(String(describing: tableType)))"}
}

/// <p>Contains metadata for a table.</p>
public struct TableMetadata: Equatable {
    /// <p>A list of the columns in the table.</p>
    public let columns: [Column]?
    /// <p>The time that the table was created.</p>
    public let createTime: Date?
    /// <p>The last time the table was accessed.</p>
    public let lastAccessTime: Date?
    /// <p>The name of the table.</p>
    public let name: String?
    /// <p>A set of custom key/value pairs for table properties.</p>
    public let parameters: [String:String]?
    /// <p>A list of the partition keys in the table.</p>
    public let partitionKeys: [Column]?
    /// <p>The type of table. In Athena, only <code>EXTERNAL_TABLE</code> is supported.</p>
    public let tableType: String?

    public init (
        columns: [Column]? = nil,
        createTime: Date? = nil,
        lastAccessTime: Date? = nil,
        name: String? = nil,
        parameters: [String:String]? = nil,
        partitionKeys: [Column]? = nil,
        tableType: String? = nil
    )
    {
        self.columns = columns
        self.createTime = createTime
        self.lastAccessTime = lastAccessTime
        self.name = name
        self.parameters = parameters
        self.partitionKeys = partitionKeys
        self.tableType = tableType
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A label that you assign to a resource. In Athena, a resource can be a workgroup or
///             data catalog. Each tag consists of a key and an optional value, both of which you
///             define. For example, you can use tags to categorize Athena workgroups or data catalogs
///             by purpose, owner, or environment. Use a consistent set of tag keys to make it easier to
///             search and filter workgroups or data catalogs in your account. For best practices, see
///                 <a href="https://aws.amazon.com/answers/account-management/aws-tagging-strategies/">Tagging Best Practices</a>. Tag keys can be from 1 to 128 UTF-8 Unicode
///             characters, and tag values can be from 0 to 256 UTF-8 Unicode characters. Tags can use
///             letters and numbers representable in UTF-8, and the following characters: + - = . _ : /
///             @. Tag keys and values are case-sensitive. Tag keys must be unique per resource. If you
///             specify more than one tag, separate them by commas. </p>
public struct Tag: Equatable {
    /// <p>A tag key. The tag key length is from 1 to 128 Unicode characters in UTF-8. You can
    ///             use letters and numbers representable in UTF-8, and the following characters: + - = . _
    ///             : / @. Tag keys are case-sensitive and must be unique per resource. </p>
    public let key: String?
    /// <p>A tag value. The tag value length is from 0 to 256 Unicode characters in UTF-8. You
    ///             can use letters and numbers representable in UTF-8, and the following characters: + - =
    ///             . _ : / @. Tag values are case-sensitive. </p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>Specifies the ARN of the Athena resource (workgroup or data catalog) to which tags are
    ///             to be added.</p>
    public let resourceARN: String?
    /// <p>A collection of one or more tags, separated by commas, to be added to an Athena
    ///             workgroup or data catalog resource.</p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

/// <p>The reason for the query throttling, for example, when it exceeds the concurrent query
///             limit.</p>
public enum ThrottleReason {
    case concurrentQueryLimitExceeded
    case sdkUnknown(String)
}

extension ThrottleReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ThrottleReason] {
        return [
            .concurrentQueryLimitExceeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .concurrentQueryLimitExceeded: return "CONCURRENT_QUERY_LIMIT_EXCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ThrottleReason(rawValue: rawValue) ?? ThrottleReason.sdkUnknown(rawValue)
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)), reason: \(String(describing: reason)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Indicates that the request was throttled.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The reason for the query throttling, for example, when it exceeds the concurrent query
    ///             limit.</p>
    public var reason: ThrottleReason?

    public init (
        message: String? = nil,
        reason: ThrottleReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
    public let reason: ThrottleReason?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ThrottleReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension UnprocessedNamedQueryId: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case namedQueryId = "NamedQueryId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let namedQueryId = namedQueryId {
            try encodeContainer.encode(namedQueryId, forKey: .namedQueryId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namedQueryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namedQueryId)
        namedQueryId = namedQueryIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension UnprocessedNamedQueryId: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnprocessedNamedQueryId(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), namedQueryId: \(String(describing: namedQueryId)))"}
}

/// <p>Information about a named query ID that could not be processed.</p>
public struct UnprocessedNamedQueryId: Equatable {
    /// <p>The error code returned when the processing request for the named query failed, if
    ///             applicable.</p>
    public let errorCode: String?
    /// <p>The error message returned when the processing request for the named query failed, if
    ///             applicable.</p>
    public let errorMessage: String?
    /// <p>The unique identifier of the named query.</p>
    public let namedQueryId: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        namedQueryId: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.namedQueryId = namedQueryId
    }
}

extension UnprocessedQueryExecutionId: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case queryExecutionId = "QueryExecutionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let queryExecutionId = queryExecutionId {
            try encodeContainer.encode(queryExecutionId, forKey: .queryExecutionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryExecutionId)
        queryExecutionId = queryExecutionIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension UnprocessedQueryExecutionId: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnprocessedQueryExecutionId(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), queryExecutionId: \(String(describing: queryExecutionId)))"}
}

/// <p>Describes a query execution that failed to process.</p>
public struct UnprocessedQueryExecutionId: Equatable {
    /// <p>The error code returned when the query execution failed to process, if
    ///             applicable.</p>
    public let errorCode: String?
    /// <p>The error message returned when the query execution failed to process, if
    ///             applicable.</p>
    public let errorMessage: String?
    /// <p>The unique identifier of the query execution.</p>
    public let queryExecutionId: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        queryExecutionId: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.queryExecutionId = queryExecutionId
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>Specifies the ARN of the resource from which tags are to be removed.</p>
    public let resourceARN: String?
    /// <p>A comma-separated list of one or more tag keys whose tags are to be removed from the
    ///             specified resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDataCatalogInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDataCatalogInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataCatalogInput>
    public typealias MOutput = OperationOutput<UpdateDataCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataCatalogOutputError>
}

extension UpdateDataCatalogInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDataCatalogInput(description: \(String(describing: description)), name: \(String(describing: name)), parameters: \(String(describing: parameters)), type: \(String(describing: type)))"}
}

extension UpdateDataCatalogInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, parametersmap0) in parameters {
                try parametersContainer.encode(parametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct UpdateDataCatalogInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDataCatalogInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataCatalogInput>
    public typealias MOutput = OperationOutput<UpdateDataCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataCatalogOutputError>
}

public struct UpdateDataCatalogInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDataCatalogInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataCatalogInput>
    public typealias MOutput = OperationOutput<UpdateDataCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataCatalogOutputError>
}

public struct UpdateDataCatalogInput: Equatable {
    /// <p>New or modified text that describes the data catalog.</p>
    public let description: String?
    /// <p>The name of the data catalog to update. The catalog name must be unique for the AWS
    ///             account and can use a maximum of 128 alphanumeric, underscore, at sign, or hyphen
    ///             characters.</p>
    public let name: String?
    /// <p>Specifies the Lambda function or functions to use for updating the data catalog. This
    ///             is a mapping whose values depend on the catalog type. </p>
    ///         <ul>
    ///             <li>
    ///                 <p>For the <code>HIVE</code> data catalog type, use the following syntax. The
    ///                         <code>metadata-function</code> parameter is required. <code>The
    ///                         sdk-version</code> parameter is optional and defaults to the currently
    ///                     supported version.</p>
    ///                 <p>
    ///                   <code>metadata-function=<i>lambda_arn</i>,
    ///                             sdk-version=<i>version_number</i>
    ///                   </code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>For the <code>LAMBDA</code> data catalog type, use one of the following sets
    ///                     of required parameters, but not both.</p>
    ///                 <ul>
    ///                   <li>
    ///                         <p>If you have one Lambda function that processes metadata and another
    ///                             for reading the actual data, use the following syntax. Both parameters
    ///                             are required.</p>
    ///                         <p>
    ///                         <code>metadata-function=<i>lambda_arn</i>,
    ///                                     record-function=<i>lambda_arn</i>
    ///                         </code>
    ///                      </p>
    ///                     </li>
    ///                   <li>
    ///                         <p> If you have a composite Lambda function that processes both metadata
    ///                             and data, use the following syntax to specify your Lambda
    ///                             function.</p>
    ///                         <p>
    ///                         <code>function=<i>lambda_arn</i>
    ///                         </code>
    ///                      </p>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let parameters: [String:String]?
    /// <p>Specifies the type of data catalog to update. Specify <code>LAMBDA</code> for a
    ///             federated catalog or <code>HIVE</code> for an external hive metastore.</p>
    ///         <note>
    ///             <p>Do not use the <code>GLUE</code> type. This refers to the
    ///                     <code>AwsDataCatalog</code> that already exists in your account, of which you
    ///                 can have only one. Specifying the <code>GLUE</code> type will result in an
    ///                     <code>INVALID_INPUT</code> error.</p>
    ///         </note>
    public let type: DataCatalogType?

    public init (
        description: String? = nil,
        name: String? = nil,
        parameters: [String:String]? = nil,
        type: DataCatalogType? = nil
    )
    {
        self.description = description
        self.name = name
        self.parameters = parameters
        self.type = type
    }
}

struct UpdateDataCatalogInputBody: Equatable {
    public let name: String?
    public let type: DataCatalogType?
    public let description: String?
    public let parameters: [String:String]?
}

extension UpdateDataCatalogInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case parameters = "Parameters"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataCatalogType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .parameters)
        var parametersDecoded0: [String:String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:String]()
            for (key0, parametersmapvalue0) in parametersContainer {
                if let parametersmapvalue0 = parametersmapvalue0 {
                    parametersDecoded0?[key0] = parametersmapvalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension UpdateDataCatalogOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataCatalogOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataCatalogOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataCatalogOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDataCatalogOutputResponse()"}
}

extension UpdateDataCatalogOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDataCatalogOutputResponse: Equatable {

    public init() {}
}

struct UpdateDataCatalogOutputResponseBody: Equatable {
}

extension UpdateDataCatalogOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdatePreparedStatementInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePreparedStatementInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePreparedStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePreparedStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePreparedStatementInput>
    public typealias MOutput = OperationOutput<UpdatePreparedStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePreparedStatementOutputError>
}

extension UpdatePreparedStatementInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePreparedStatementInput(description: \(String(describing: description)), queryStatement: \(String(describing: queryStatement)), statementName: \(String(describing: statementName)), workGroup: \(String(describing: workGroup)))"}
}

extension UpdatePreparedStatementInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let queryStatement = queryStatement {
            try encodeContainer.encode(queryStatement, forKey: .queryStatement)
        }
        if let statementName = statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

public struct UpdatePreparedStatementInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePreparedStatementInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePreparedStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePreparedStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePreparedStatementInput>
    public typealias MOutput = OperationOutput<UpdatePreparedStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePreparedStatementOutputError>
}

public struct UpdatePreparedStatementInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePreparedStatementInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePreparedStatementInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePreparedStatementOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePreparedStatementInput>
    public typealias MOutput = OperationOutput<UpdatePreparedStatementOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePreparedStatementOutputError>
}

public struct UpdatePreparedStatementInput: Equatable {
    /// <p>The description of the prepared statement.</p>
    public let description: String?
    /// <p>The query string for the prepared statement.</p>
    public let queryStatement: String?
    /// <p>The name of the prepared statement.</p>
    public let statementName: String?
    /// <p>The workgroup for the prepared statement.</p>
    public let workGroup: String?

    public init (
        description: String? = nil,
        queryStatement: String? = nil,
        statementName: String? = nil,
        workGroup: String? = nil
    )
    {
        self.description = description
        self.queryStatement = queryStatement
        self.statementName = statementName
        self.workGroup = workGroup
    }
}

struct UpdatePreparedStatementInputBody: Equatable {
    public let statementName: String?
    public let workGroup: String?
    public let queryStatement: String?
    public let description: String?
}

extension UpdatePreparedStatementInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case queryStatement = "QueryStatement"
        case statementName = "StatementName"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let workGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let queryStatementDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryStatement)
        queryStatement = queryStatementDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdatePreparedStatementOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePreparedStatementOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePreparedStatementOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePreparedStatementOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePreparedStatementOutputResponse()"}
}

extension UpdatePreparedStatementOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePreparedStatementOutputResponse: Equatable {

    public init() {}
}

struct UpdatePreparedStatementOutputResponseBody: Equatable {
}

extension UpdatePreparedStatementOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateWorkGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateWorkGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkGroupInput>
    public typealias MOutput = OperationOutput<UpdateWorkGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkGroupOutputError>
}

extension UpdateWorkGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWorkGroupInput(configurationUpdates: \(String(describing: configurationUpdates)), description: \(String(describing: description)), state: \(String(describing: state)), workGroup: \(String(describing: workGroup)))"}
}

extension UpdateWorkGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationUpdates = "ConfigurationUpdates"
        case description = "Description"
        case state = "State"
        case workGroup = "WorkGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationUpdates = configurationUpdates {
            try encodeContainer.encode(configurationUpdates, forKey: .configurationUpdates)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let workGroup = workGroup {
            try encodeContainer.encode(workGroup, forKey: .workGroup)
        }
    }
}

public struct UpdateWorkGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateWorkGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkGroupInput>
    public typealias MOutput = OperationOutput<UpdateWorkGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkGroupOutputError>
}

public struct UpdateWorkGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateWorkGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkGroupInput>
    public typealias MOutput = OperationOutput<UpdateWorkGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkGroupOutputError>
}

public struct UpdateWorkGroupInput: Equatable {
    /// <p>The workgroup configuration that will be updated for the given workgroup.</p>
    public let configurationUpdates: WorkGroupConfigurationUpdates?
    /// <p>The workgroup description.</p>
    public let description: String?
    /// <p>The workgroup state that will be updated for the given workgroup.</p>
    public let state: WorkGroupState?
    /// <p>The specified workgroup that will be updated.</p>
    public let workGroup: String?

    public init (
        configurationUpdates: WorkGroupConfigurationUpdates? = nil,
        description: String? = nil,
        state: WorkGroupState? = nil,
        workGroup: String? = nil
    )
    {
        self.configurationUpdates = configurationUpdates
        self.description = description
        self.state = state
        self.workGroup = workGroup
    }
}

struct UpdateWorkGroupInputBody: Equatable {
    public let workGroup: String?
    public let description: String?
    public let configurationUpdates: WorkGroupConfigurationUpdates?
    public let state: WorkGroupState?
}

extension UpdateWorkGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationUpdates = "ConfigurationUpdates"
        case description = "Description"
        case state = "State"
        case workGroup = "WorkGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workGroup)
        workGroup = workGroupDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let configurationUpdatesDecoded = try containerValues.decodeIfPresent(WorkGroupConfigurationUpdates.self, forKey: .configurationUpdates)
        configurationUpdates = configurationUpdatesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkGroupState.self, forKey: .state)
        state = stateDecoded
    }
}

extension UpdateWorkGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorkGroupOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWorkGroupOutputResponse()"}
}

extension UpdateWorkGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWorkGroupOutputResponse: Equatable {

    public init() {}
}

struct UpdateWorkGroupOutputResponseBody: Equatable {
}

extension UpdateWorkGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension WorkGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
        case creationTime = "CreationTime"
        case description = "Description"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkGroupState.self, forKey: .state)
        state = stateDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(WorkGroupConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension WorkGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkGroup(configuration: \(String(describing: configuration)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), name: \(String(describing: name)), state: \(String(describing: state)))"}
}

/// <p>A workgroup, which contains a name, description, creation time, state, and other
///             configuration, listed under <a>WorkGroup$Configuration</a>. Each workgroup
///             enables you to isolate queries for you or your group of users from other queries in the
///             same account, to configure the query results location and the encryption configuration
///             (known as workgroup settings), to enable sending query metrics to Amazon CloudWatch, and
///             to establish per-query data usage control limits for all queries in a workgroup. The
///             workgroup settings override is specified in EnforceWorkGroupConfiguration (true/false)
///             in the WorkGroupConfiguration. See <a>WorkGroupConfiguration$EnforceWorkGroupConfiguration</a>.</p>
public struct WorkGroup: Equatable {
    /// <p>The configuration of the workgroup, which includes the location in Amazon S3 where
    ///             query results are stored, the encryption configuration, if any, used for query results;
    ///             whether the Amazon CloudWatch Metrics are enabled for the workgroup; whether workgroup
    ///             settings override client-side settings; and the data usage limits for the amount of data
    ///             scanned per query or per workgroup. The workgroup settings override is specified in
    ///             EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See <a>WorkGroupConfiguration$EnforceWorkGroupConfiguration</a>.</p>
    public let configuration: WorkGroupConfiguration?
    /// <p>The date and time the workgroup was created.</p>
    public let creationTime: Date?
    /// <p>The workgroup description.</p>
    public let description: String?
    /// <p>The workgroup name.</p>
    public let name: String?
    /// <p>The state of the workgroup: ENABLED or DISABLED.</p>
    public let state: WorkGroupState?

    public init (
        configuration: WorkGroupConfiguration? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        name: String? = nil,
        state: WorkGroupState? = nil
    )
    {
        self.configuration = configuration
        self.creationTime = creationTime
        self.description = description
        self.name = name
        self.state = state
    }
}

extension WorkGroupConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bytesScannedCutoffPerQuery = "BytesScannedCutoffPerQuery"
        case enforceWorkGroupConfiguration = "EnforceWorkGroupConfiguration"
        case engineVersion = "EngineVersion"
        case publishCloudWatchMetricsEnabled = "PublishCloudWatchMetricsEnabled"
        case requesterPaysEnabled = "RequesterPaysEnabled"
        case resultConfiguration = "ResultConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bytesScannedCutoffPerQuery = bytesScannedCutoffPerQuery {
            try encodeContainer.encode(bytesScannedCutoffPerQuery, forKey: .bytesScannedCutoffPerQuery)
        }
        if let enforceWorkGroupConfiguration = enforceWorkGroupConfiguration {
            try encodeContainer.encode(enforceWorkGroupConfiguration, forKey: .enforceWorkGroupConfiguration)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabled {
            try encodeContainer.encode(publishCloudWatchMetricsEnabled, forKey: .publishCloudWatchMetricsEnabled)
        }
        if let requesterPaysEnabled = requesterPaysEnabled {
            try encodeContainer.encode(requesterPaysEnabled, forKey: .requesterPaysEnabled)
        }
        if let resultConfiguration = resultConfiguration {
            try encodeContainer.encode(resultConfiguration, forKey: .resultConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultConfigurationDecoded = try containerValues.decodeIfPresent(ResultConfiguration.self, forKey: .resultConfiguration)
        resultConfiguration = resultConfigurationDecoded
        let enforceWorkGroupConfigurationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enforceWorkGroupConfiguration)
        enforceWorkGroupConfiguration = enforceWorkGroupConfigurationDecoded
        let publishCloudWatchMetricsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .publishCloudWatchMetricsEnabled)
        publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabledDecoded
        let bytesScannedCutoffPerQueryDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .bytesScannedCutoffPerQuery)
        bytesScannedCutoffPerQuery = bytesScannedCutoffPerQueryDecoded
        let requesterPaysEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .requesterPaysEnabled)
        requesterPaysEnabled = requesterPaysEnabledDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(EngineVersion.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension WorkGroupConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkGroupConfiguration(bytesScannedCutoffPerQuery: \(String(describing: bytesScannedCutoffPerQuery)), enforceWorkGroupConfiguration: \(String(describing: enforceWorkGroupConfiguration)), engineVersion: \(String(describing: engineVersion)), publishCloudWatchMetricsEnabled: \(String(describing: publishCloudWatchMetricsEnabled)), requesterPaysEnabled: \(String(describing: requesterPaysEnabled)), resultConfiguration: \(String(describing: resultConfiguration)))"}
}

/// <p>The configuration of the workgroup, which includes the location in Amazon S3 where
///             query results are stored, the encryption option, if any, used for query results, whether
///             the Amazon CloudWatch Metrics are enabled for the workgroup and whether workgroup
///             settings override query settings, and the data usage limits for the amount of data
///             scanned per query or per workgroup. The workgroup settings override is specified in
///             EnforceWorkGroupConfiguration (true/false) in the WorkGroupConfiguration. See <a>WorkGroupConfiguration$EnforceWorkGroupConfiguration</a>. </p>
public struct WorkGroupConfiguration: Equatable {
    /// <p>The upper data usage limit (cutoff) for the amount of bytes a single query in a
    ///             workgroup is allowed to scan.</p>
    public let bytesScannedCutoffPerQuery: Int?
    /// <p>If set to "true", the settings for the workgroup override client-side settings. If set
    ///             to "false", client-side settings are used. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    public let enforceWorkGroupConfiguration: Bool?
    /// <p>The engine version that all queries running on
    ///             the workgroup use. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
    public let engineVersion: EngineVersion?
    /// <p>Indicates that the Amazon CloudWatch metrics are enabled for the workgroup.</p>
    public let publishCloudWatchMetricsEnabled: Bool?
    /// <p>If set to <code>true</code>, allows members assigned to a workgroup to reference
    ///             Amazon S3 Requester Pays buckets in queries. If set to <code>false</code>, workgroup
    ///             members cannot query data from Requester Pays buckets, and queries that retrieve data
    ///             from Requester Pays buckets cause an error. The default is <code>false</code>. For more
    ///             information about Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html">Requester Pays Buckets</a>
    ///             in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
    public let requesterPaysEnabled: Bool?
    /// <p>The configuration for the workgroup, which includes the location in Amazon S3 where
    ///             query results are stored and the encryption option, if any, used for query results. To
    ///             run the query, you must specify the query results location using one of the ways: either
    ///             in the workgroup using this setting, or for individual queries (client-side), using
    ///                 <a>ResultConfiguration$OutputLocation</a>. If none of them is set, Athena
    ///             issues an error that no output location is provided. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/querying.html">Query
    ///             Results</a>.</p>
    public let resultConfiguration: ResultConfiguration?

    public init (
        bytesScannedCutoffPerQuery: Int? = nil,
        enforceWorkGroupConfiguration: Bool? = nil,
        engineVersion: EngineVersion? = nil,
        publishCloudWatchMetricsEnabled: Bool? = nil,
        requesterPaysEnabled: Bool? = nil,
        resultConfiguration: ResultConfiguration? = nil
    )
    {
        self.bytesScannedCutoffPerQuery = bytesScannedCutoffPerQuery
        self.enforceWorkGroupConfiguration = enforceWorkGroupConfiguration
        self.engineVersion = engineVersion
        self.publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabled
        self.requesterPaysEnabled = requesterPaysEnabled
        self.resultConfiguration = resultConfiguration
    }
}

extension WorkGroupConfigurationUpdates: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bytesScannedCutoffPerQuery = "BytesScannedCutoffPerQuery"
        case enforceWorkGroupConfiguration = "EnforceWorkGroupConfiguration"
        case engineVersion = "EngineVersion"
        case publishCloudWatchMetricsEnabled = "PublishCloudWatchMetricsEnabled"
        case removeBytesScannedCutoffPerQuery = "RemoveBytesScannedCutoffPerQuery"
        case requesterPaysEnabled = "RequesterPaysEnabled"
        case resultConfigurationUpdates = "ResultConfigurationUpdates"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bytesScannedCutoffPerQuery = bytesScannedCutoffPerQuery {
            try encodeContainer.encode(bytesScannedCutoffPerQuery, forKey: .bytesScannedCutoffPerQuery)
        }
        if let enforceWorkGroupConfiguration = enforceWorkGroupConfiguration {
            try encodeContainer.encode(enforceWorkGroupConfiguration, forKey: .enforceWorkGroupConfiguration)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabled {
            try encodeContainer.encode(publishCloudWatchMetricsEnabled, forKey: .publishCloudWatchMetricsEnabled)
        }
        if let removeBytesScannedCutoffPerQuery = removeBytesScannedCutoffPerQuery {
            try encodeContainer.encode(removeBytesScannedCutoffPerQuery, forKey: .removeBytesScannedCutoffPerQuery)
        }
        if let requesterPaysEnabled = requesterPaysEnabled {
            try encodeContainer.encode(requesterPaysEnabled, forKey: .requesterPaysEnabled)
        }
        if let resultConfigurationUpdates = resultConfigurationUpdates {
            try encodeContainer.encode(resultConfigurationUpdates, forKey: .resultConfigurationUpdates)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enforceWorkGroupConfigurationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enforceWorkGroupConfiguration)
        enforceWorkGroupConfiguration = enforceWorkGroupConfigurationDecoded
        let resultConfigurationUpdatesDecoded = try containerValues.decodeIfPresent(ResultConfigurationUpdates.self, forKey: .resultConfigurationUpdates)
        resultConfigurationUpdates = resultConfigurationUpdatesDecoded
        let publishCloudWatchMetricsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .publishCloudWatchMetricsEnabled)
        publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabledDecoded
        let bytesScannedCutoffPerQueryDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .bytesScannedCutoffPerQuery)
        bytesScannedCutoffPerQuery = bytesScannedCutoffPerQueryDecoded
        let removeBytesScannedCutoffPerQueryDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .removeBytesScannedCutoffPerQuery)
        removeBytesScannedCutoffPerQuery = removeBytesScannedCutoffPerQueryDecoded
        let requesterPaysEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .requesterPaysEnabled)
        requesterPaysEnabled = requesterPaysEnabledDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(EngineVersion.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension WorkGroupConfigurationUpdates: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkGroupConfigurationUpdates(bytesScannedCutoffPerQuery: \(String(describing: bytesScannedCutoffPerQuery)), enforceWorkGroupConfiguration: \(String(describing: enforceWorkGroupConfiguration)), engineVersion: \(String(describing: engineVersion)), publishCloudWatchMetricsEnabled: \(String(describing: publishCloudWatchMetricsEnabled)), removeBytesScannedCutoffPerQuery: \(String(describing: removeBytesScannedCutoffPerQuery)), requesterPaysEnabled: \(String(describing: requesterPaysEnabled)), resultConfigurationUpdates: \(String(describing: resultConfigurationUpdates)))"}
}

/// <p>The configuration information that will be updated for this workgroup, which includes
///             the location in Amazon S3 where query results are stored, the encryption option, if any,
///             used for query results, whether the Amazon CloudWatch Metrics are enabled for the
///             workgroup, whether the workgroup settings override the client-side settings, and the
///             data usage limit for the amount of bytes scanned per query, if it is specified.</p>
public struct WorkGroupConfigurationUpdates: Equatable {
    /// <p>The upper limit (cutoff) for the amount of bytes a single query in a workgroup is
    ///             allowed to scan.</p>
    public let bytesScannedCutoffPerQuery: Int?
    /// <p>If set to "true", the settings for the workgroup override client-side settings. If set
    ///             to "false" client-side settings are used. For more information, see <a href="https://docs.aws.amazon.com/athena/latest/ug/workgroups-settings-override.html">Workgroup Settings Override Client-Side Settings</a>.</p>
    public let enforceWorkGroupConfiguration: Bool?
    /// <p>The engine version requested when a workgroup is updated. After the update, all queries on the workgroup run on the requested engine version. If no value was previously set, the default is Auto. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
    public let engineVersion: EngineVersion?
    /// <p>Indicates whether this workgroup enables publishing metrics to Amazon
    ///             CloudWatch.</p>
    public let publishCloudWatchMetricsEnabled: Bool?
    /// <p>Indicates that the data usage control limit per query is removed. <a>WorkGroupConfiguration$BytesScannedCutoffPerQuery</a>
    ///          </p>
    public let removeBytesScannedCutoffPerQuery: Bool?
    /// <p>If set to <code>true</code>, allows members assigned to a workgroup to specify Amazon
    ///             S3 Requester Pays buckets in queries. If set to <code>false</code>, workgroup members
    ///             cannot query data from Requester Pays buckets, and queries that retrieve data from
    ///             Requester Pays buckets cause an error. The default is <code>false</code>. For more
    ///             information about Requester Pays buckets, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html">Requester Pays Buckets</a>
    ///             in the <i>Amazon Simple Storage Service Developer Guide</i>.</p>
    public let requesterPaysEnabled: Bool?
    /// <p>The result configuration information about the queries in this workgroup that will be
    ///             updated. Includes the updated results location and an updated option for encrypting
    ///             query results.</p>
    public let resultConfigurationUpdates: ResultConfigurationUpdates?

    public init (
        bytesScannedCutoffPerQuery: Int? = nil,
        enforceWorkGroupConfiguration: Bool? = nil,
        engineVersion: EngineVersion? = nil,
        publishCloudWatchMetricsEnabled: Bool? = nil,
        removeBytesScannedCutoffPerQuery: Bool? = nil,
        requesterPaysEnabled: Bool? = nil,
        resultConfigurationUpdates: ResultConfigurationUpdates? = nil
    )
    {
        self.bytesScannedCutoffPerQuery = bytesScannedCutoffPerQuery
        self.enforceWorkGroupConfiguration = enforceWorkGroupConfiguration
        self.engineVersion = engineVersion
        self.publishCloudWatchMetricsEnabled = publishCloudWatchMetricsEnabled
        self.removeBytesScannedCutoffPerQuery = removeBytesScannedCutoffPerQuery
        self.requesterPaysEnabled = requesterPaysEnabled
        self.resultConfigurationUpdates = resultConfigurationUpdates
    }
}

public enum WorkGroupState {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension WorkGroupState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WorkGroupState] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WorkGroupState(rawValue: rawValue) ?? WorkGroupState.sdkUnknown(rawValue)
    }
}

extension WorkGroupSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case description = "Description"
        case engineVersion = "EngineVersion"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkGroupState.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(EngineVersion.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
    }
}

extension WorkGroupSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkGroupSummary(creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), engineVersion: \(String(describing: engineVersion)), name: \(String(describing: name)), state: \(String(describing: state)))"}
}

/// <p>The summary information for the workgroup, which includes its name, state,
///             description, and the date and time it was created.</p>
public struct WorkGroupSummary: Equatable {
    /// <p>The workgroup creation date and time.</p>
    public let creationTime: Date?
    /// <p>The workgroup description.</p>
    public let description: String?
    /// <p>The engine version setting for all queries on the workgroup. Queries on the <code>AmazonAthenaPreviewFunctionality</code> workgroup run on the preview engine regardless of this setting.</p>
    public let engineVersion: EngineVersion?
    /// <p>The name of the workgroup.</p>
    public let name: String?
    /// <p>The state of the workgroup.</p>
    public let state: WorkGroupState?

    public init (
        creationTime: Date? = nil,
        description: String? = nil,
        engineVersion: EngineVersion? = nil,
        name: String? = nil,
        state: WorkGroupState? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.engineVersion = engineVersion
        self.name = name
        self.state = state
    }
}
