// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ApplicationDiscoveryClientTypes.AgentConfigurationStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case description
        case operationSucceeded
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if operationSucceeded != false {
            try encodeContainer.encode(operationSucceeded, forKey: .operationSucceeded)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let operationSucceededDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .operationSucceeded) ?? false
        operationSucceeded = operationSucceededDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Information about agents or connectors that were instructed to start collecting data. Information includes the agent/connector ID, a description of the operation, and whether the agent/connector configuration was updated.
    public struct AgentConfigurationStatus: Swift.Equatable {
        /// The agent/connector ID.
        public var agentId: Swift.String?
        /// A description of the operation performed.
        public var description: Swift.String?
        /// Information about the status of the StartDataCollection and StopDataCollection operations. The system has recorded the data collection operation. The agent/connector receives this command the next time it polls for a new command.
        public var operationSucceeded: Swift.Bool

        public init (
            agentId: Swift.String? = nil,
            description: Swift.String? = nil,
            operationSucceeded: Swift.Bool = false
        )
        {
            self.agentId = agentId
            self.description = description
            self.operationSucceeded = operationSucceeded
        }
    }

}

extension ApplicationDiscoveryClientTypes.AgentInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case agentNetworkInfoList
        case agentType
        case collectionStatus
        case connectorId
        case health
        case hostName
        case lastHealthPingTime
        case registeredTime
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let agentNetworkInfoList = agentNetworkInfoList {
            var agentNetworkInfoListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentNetworkInfoList)
            for agentnetworkinfo0 in agentNetworkInfoList {
                try agentNetworkInfoListContainer.encode(agentnetworkinfo0)
            }
        }
        if let agentType = self.agentType {
            try encodeContainer.encode(agentType, forKey: .agentType)
        }
        if let collectionStatus = self.collectionStatus {
            try encodeContainer.encode(collectionStatus, forKey: .collectionStatus)
        }
        if let connectorId = self.connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
        if let health = self.health {
            try encodeContainer.encode(health.rawValue, forKey: .health)
        }
        if let hostName = self.hostName {
            try encodeContainer.encode(hostName, forKey: .hostName)
        }
        if let lastHealthPingTime = self.lastHealthPingTime {
            try encodeContainer.encode(lastHealthPingTime, forKey: .lastHealthPingTime)
        }
        if let registeredTime = self.registeredTime {
            try encodeContainer.encode(registeredTime, forKey: .registeredTime)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let hostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostName)
        hostName = hostNameDecoded
        let agentNetworkInfoListContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.AgentNetworkInfo?].self, forKey: .agentNetworkInfoList)
        var agentNetworkInfoListDecoded0:[ApplicationDiscoveryClientTypes.AgentNetworkInfo]? = nil
        if let agentNetworkInfoListContainer = agentNetworkInfoListContainer {
            agentNetworkInfoListDecoded0 = [ApplicationDiscoveryClientTypes.AgentNetworkInfo]()
            for structure0 in agentNetworkInfoListContainer {
                if let structure0 = structure0 {
                    agentNetworkInfoListDecoded0?.append(structure0)
                }
            }
        }
        agentNetworkInfoList = agentNetworkInfoListDecoded0
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let healthDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.AgentStatus.self, forKey: .health)
        health = healthDecoded
        let lastHealthPingTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastHealthPingTime)
        lastHealthPingTime = lastHealthPingTimeDecoded
        let collectionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionStatus)
        collectionStatus = collectionStatusDecoded
        let agentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentType)
        agentType = agentTypeDecoded
        let registeredTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredTime)
        registeredTime = registeredTimeDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Information about agents or connectors associated with the userâ€™s Amazon Web Services account. Information includes agent or connector IDs, IP addresses, media access control (MAC) addresses, agent or connector health, hostname where the agent or connector resides, and agent version for each agent.
    public struct AgentInfo: Swift.Equatable {
        /// The agent or connector ID.
        public var agentId: Swift.String?
        /// Network details about the host where the agent or connector resides.
        public var agentNetworkInfoList: [ApplicationDiscoveryClientTypes.AgentNetworkInfo]?
        /// Type of agent.
        public var agentType: Swift.String?
        /// Status of the collection process for an agent or connector.
        public var collectionStatus: Swift.String?
        /// The ID of the connector.
        public var connectorId: Swift.String?
        /// The health of the agent or connector.
        public var health: ApplicationDiscoveryClientTypes.AgentStatus?
        /// The name of the host where the agent or connector resides. The host can be a server or virtual machine.
        public var hostName: Swift.String?
        /// Time since agent or connector health was reported.
        public var lastHealthPingTime: Swift.String?
        /// Agent's first registration timestamp in UTC.
        public var registeredTime: Swift.String?
        /// The agent or connector version.
        public var version: Swift.String?

        public init (
            agentId: Swift.String? = nil,
            agentNetworkInfoList: [ApplicationDiscoveryClientTypes.AgentNetworkInfo]? = nil,
            agentType: Swift.String? = nil,
            collectionStatus: Swift.String? = nil,
            connectorId: Swift.String? = nil,
            health: ApplicationDiscoveryClientTypes.AgentStatus? = nil,
            hostName: Swift.String? = nil,
            lastHealthPingTime: Swift.String? = nil,
            registeredTime: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.agentId = agentId
            self.agentNetworkInfoList = agentNetworkInfoList
            self.agentType = agentType
            self.collectionStatus = collectionStatus
            self.connectorId = connectorId
            self.health = health
            self.hostName = hostName
            self.lastHealthPingTime = lastHealthPingTime
            self.registeredTime = registeredTime
            self.version = version
        }
    }

}

extension ApplicationDiscoveryClientTypes.AgentNetworkInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddress
        case macAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let macAddress = self.macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Network details about the host where the agent/connector resides.
    public struct AgentNetworkInfo: Swift.Equatable {
        /// The IP address for the host where the agent/connector resides.
        public var ipAddress: Swift.String?
        /// The MAC address for the host where the agent/connector resides.
        public var macAddress: Swift.String?

        public init (
            ipAddress: Swift.String? = nil,
            macAddress: Swift.String? = nil
        )
        {
            self.ipAddress = ipAddress
            self.macAddress = macAddress
        }
    }

}

extension ApplicationDiscoveryClientTypes {
    public enum AgentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case blacklisted
        case healthy
        case running
        case shutdown
        case unhealthy
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentStatus] {
            return [
                .blacklisted,
                .healthy,
                .running,
                .shutdown,
                .unhealthy,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .blacklisted: return "BLACKLISTED"
            case .healthy: return "HEALTHY"
            case .running: return "RUNNING"
            case .shutdown: return "SHUTDOWN"
            case .unhealthy: return "UNHEALTHY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgentStatus(rawValue: rawValue) ?? AgentStatus.sdkUnknown(rawValue)
        }
    }
}

extension AssociateConfigurationItemsToApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfigurationId
        case configurationIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfigurationId = self.applicationConfigurationId {
            try encodeContainer.encode(applicationConfigurationId, forKey: .applicationConfigurationId)
        }
        if let configurationIds = configurationIds {
            var configurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationIds)
            for configurationid0 in configurationIds {
                try configurationIdsContainer.encode(configurationid0)
            }
        }
    }
}

extension AssociateConfigurationItemsToApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateConfigurationItemsToApplicationInput: Swift.Equatable {
    /// The configuration ID of an application with which items are to be associated.
    /// This member is required.
    public var applicationConfigurationId: Swift.String?
    /// The ID of each configuration item to be associated with an application.
    /// This member is required.
    public var configurationIds: [Swift.String]?

    public init (
        applicationConfigurationId: Swift.String? = nil,
        configurationIds: [Swift.String]? = nil
    )
    {
        self.applicationConfigurationId = applicationConfigurationId
        self.configurationIds = configurationIds
    }
}

struct AssociateConfigurationItemsToApplicationInputBody: Swift.Equatable {
    let applicationConfigurationId: Swift.String?
    let configurationIds: [Swift.String]?
}

extension AssociateConfigurationItemsToApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfigurationId
        case configurationIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationConfigurationId)
        applicationConfigurationId = applicationConfigurationIdDecoded
        let configurationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationIds)
        var configurationIdsDecoded0:[Swift.String]? = nil
        if let configurationIdsContainer = configurationIdsContainer {
            configurationIdsDecoded0 = [Swift.String]()
            for string0 in configurationIdsContainer {
                if let string0 = string0 {
                    configurationIdsDecoded0?.append(string0)
                }
            }
        }
        configurationIds = configurationIdsDecoded0
    }
}

extension AssociateConfigurationItemsToApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateConfigurationItemsToApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateConfigurationItemsToApplicationOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateConfigurationItemsToApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateConfigurationItemsToApplicationOutputResponse: Swift.Equatable {

    public init () { }
}

extension AuthorizationErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AuthorizationErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Amazon Web Services user account does not have permission to perform the action. Check the IAM policy associated with this account.
public struct AuthorizationErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorizationErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AuthorizationErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationDiscoveryClientTypes.BatchDeleteImportDataError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorDescription
        case importTaskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorDescription = self.errorDescription {
            try encodeContainer.encode(errorDescription, forKey: .errorDescription)
        }
        if let importTaskId = self.importTaskId {
            try encodeContainer.encode(importTaskId, forKey: .importTaskId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importTaskId)
        importTaskId = importTaskIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.BatchDeleteImportDataErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorDescription)
        errorDescription = errorDescriptionDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Error messages returned for each import task that you deleted as a response for this command.
    public struct BatchDeleteImportDataError: Swift.Equatable {
        /// The type of error that occurred for a specific import task.
        public var errorCode: ApplicationDiscoveryClientTypes.BatchDeleteImportDataErrorCode?
        /// The description of the error that occurred for a specific import task.
        public var errorDescription: Swift.String?
        /// The unique import ID associated with the error that occurred.
        public var importTaskId: Swift.String?

        public init (
            errorCode: ApplicationDiscoveryClientTypes.BatchDeleteImportDataErrorCode? = nil,
            errorDescription: Swift.String? = nil,
            importTaskId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorDescription = errorDescription
            self.importTaskId = importTaskId
        }
    }

}

extension ApplicationDiscoveryClientTypes {
    public enum BatchDeleteImportDataErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalServerError
        case notFound
        case overLimit
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchDeleteImportDataErrorCode] {
            return [
                .internalServerError,
                .notFound,
                .overLimit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalServerError: return "INTERNAL_SERVER_ERROR"
            case .notFound: return "NOT_FOUND"
            case .overLimit: return "OVER_LIMIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchDeleteImportDataErrorCode(rawValue: rawValue) ?? BatchDeleteImportDataErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension BatchDeleteImportDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importTaskIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importTaskIds = importTaskIds {
            var importTaskIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .importTaskIds)
            for importtaskidentifier0 in importTaskIds {
                try importTaskIdsContainer.encode(importtaskidentifier0)
            }
        }
    }
}

extension BatchDeleteImportDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchDeleteImportDataInput: Swift.Equatable {
    /// The IDs for the import tasks that you want to delete.
    /// This member is required.
    public var importTaskIds: [Swift.String]?

    public init (
        importTaskIds: [Swift.String]? = nil
    )
    {
        self.importTaskIds = importTaskIds
    }
}

struct BatchDeleteImportDataInputBody: Swift.Equatable {
    let importTaskIds: [Swift.String]?
}

extension BatchDeleteImportDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importTaskIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importTaskIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .importTaskIds)
        var importTaskIdsDecoded0:[Swift.String]? = nil
        if let importTaskIdsContainer = importTaskIdsContainer {
            importTaskIdsDecoded0 = [Swift.String]()
            for string0 in importTaskIdsContainer {
                if let string0 = string0 {
                    importTaskIdsDecoded0?.append(string0)
                }
            }
        }
        importTaskIds = importTaskIdsDecoded0
    }
}

extension BatchDeleteImportDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteImportDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchDeleteImportDataOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteImportDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchDeleteImportDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDeleteImportDataOutputResponse: Swift.Equatable {
    /// Error messages returned for each import task that you deleted as a response for this command.
    public var errors: [ApplicationDiscoveryClientTypes.BatchDeleteImportDataError]?

    public init (
        errors: [ApplicationDiscoveryClientTypes.BatchDeleteImportDataError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDeleteImportDataOutputResponseBody: Swift.Equatable {
    let errors: [ApplicationDiscoveryClientTypes.BatchDeleteImportDataError]?
}

extension BatchDeleteImportDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.BatchDeleteImportDataError?].self, forKey: .errors)
        var errorsDecoded0:[ApplicationDiscoveryClientTypes.BatchDeleteImportDataError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ApplicationDiscoveryClientTypes.BatchDeleteImportDataError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension ApplicationDiscoveryClientTypes {
    public enum ConfigurationItemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case application
        case connections
        case process
        case server
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationItemType] {
            return [
                .application,
                .connections,
                .process,
                .server,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .connections: return "CONNECTION"
            case .process: return "PROCESS"
            case .server: return "SERVER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationItemType(rawValue: rawValue) ?? ConfigurationItemType.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationDiscoveryClientTypes.ConfigurationTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId
        case configurationType
        case key
        case timeOfCreation
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationId = self.configurationId {
            try encodeContainer.encode(configurationId, forKey: .configurationId)
        }
        if let configurationType = self.configurationType {
            try encodeContainer.encode(configurationType.rawValue, forKey: .configurationType)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let timeOfCreation = self.timeOfCreation {
            try encodeContainer.encodeTimestamp(timeOfCreation, format: .epochSeconds, forKey: .timeOfCreation)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.ConfigurationItemType.self, forKey: .configurationType)
        configurationType = configurationTypeDecoded
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let timeOfCreationDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timeOfCreation)
        timeOfCreation = timeOfCreationDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Tags for a configuration item. Tags are metadata that help you categorize IT assets.
    public struct ConfigurationTag: Swift.Equatable {
        /// The configuration ID for the item to tag. You can specify a list of keys and values.
        public var configurationId: Swift.String?
        /// A type of IT asset to tag.
        public var configurationType: ApplicationDiscoveryClientTypes.ConfigurationItemType?
        /// A type of tag on which to filter. For example, serverType.
        public var key: Swift.String?
        /// The time the configuration tag was created in Coordinated Universal Time (UTC).
        public var timeOfCreation: ClientRuntime.Date?
        /// A value on which to filter. For example key = serverType and value = web server.
        public var value: Swift.String?

        public init (
            configurationId: Swift.String? = nil,
            configurationType: ApplicationDiscoveryClientTypes.ConfigurationItemType? = nil,
            key: Swift.String? = nil,
            timeOfCreation: ClientRuntime.Date? = nil,
            value: Swift.String? = nil
        )
        {
            self.configurationId = configurationId
            self.configurationType = configurationType
            self.key = key
            self.timeOfCreation = timeOfCreation
            self.value = value
        }
    }

}

extension ConflictErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ConflictErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationDiscoveryClientTypes.ContinuousExportDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case exportId
        case s3Bucket
        case schemaStorageConfig
        case startTime
        case status
        case statusDetail
        case stopTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let exportId = self.exportId {
            try encodeContainer.encode(exportId, forKey: .exportId)
        }
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let schemaStorageConfig = schemaStorageConfig {
            var schemaStorageConfigContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .schemaStorageConfig)
            for (dictKey0, schemaStorageConfig0) in schemaStorageConfig {
                try schemaStorageConfigContainer.encode(schemaStorageConfig0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetail = self.statusDetail {
            try encodeContainer.encode(statusDetail, forKey: .statusDetail)
        }
        if let stopTime = self.stopTime {
            try encodeContainer.encodeTimestamp(stopTime, format: .epochSeconds, forKey: .stopTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.ContinuousExportStatus.self, forKey: .status)
        status = statusDecoded
        let statusDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetail)
        statusDetail = statusDetailDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stopTime)
        stopTime = stopTimeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let schemaStorageConfigContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .schemaStorageConfig)
        var schemaStorageConfigDecoded0: [Swift.String:Swift.String]? = nil
        if let schemaStorageConfigContainer = schemaStorageConfigContainer {
            schemaStorageConfigDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in schemaStorageConfigContainer {
                if let string0 = string0 {
                    schemaStorageConfigDecoded0?[key0] = string0
                }
            }
        }
        schemaStorageConfig = schemaStorageConfigDecoded0
    }
}

extension ApplicationDiscoveryClientTypes {
    /// A list of continuous export descriptions.
    public struct ContinuousExportDescription: Swift.Equatable {
        /// The type of data collector used to gather this data (currently only offered for AGENT).
        public var dataSource: ApplicationDiscoveryClientTypes.DataSource?
        /// The unique ID assigned to this export.
        public var exportId: Swift.String?
        /// The name of the s3 bucket where the export data parquet files are stored.
        public var s3Bucket: Swift.String?
        /// An object which describes how the data is stored.
        ///
        /// * databaseName - the name of the Glue database used to store the schema.
        public var schemaStorageConfig: [Swift.String:Swift.String]?
        /// The timestamp representing when the continuous export was started.
        public var startTime: ClientRuntime.Date?
        /// Describes the status of the export. Can be one of the following values:
        ///
        /// * START_IN_PROGRESS - setting up resources to start continuous export.
        ///
        /// * START_FAILED - an error occurred setting up continuous export. To recover, call start-continuous-export again.
        ///
        /// * ACTIVE - data is being exported to the customer bucket.
        ///
        /// * ERROR - an error occurred during export. To fix the issue, call stop-continuous-export and start-continuous-export.
        ///
        /// * STOP_IN_PROGRESS - stopping the export.
        ///
        /// * STOP_FAILED - an error occurred stopping the export. To recover, call stop-continuous-export again.
        ///
        /// * INACTIVE - the continuous export has been stopped. Data is no longer being exported to the customer bucket.
        public var status: ApplicationDiscoveryClientTypes.ContinuousExportStatus?
        /// Contains information about any errors that have occurred. This data type can have the following values:
        ///
        /// * ACCESS_DENIED - You donâ€™t have permission to start Data Exploration in Amazon Athena. Contact your Amazon Web Services administrator for help. For more information, see [Setting Up Amazon Web Services Application Discovery Service](http://docs.aws.amazon.com/application-discovery/latest/userguide/setting-up.html) in the Application Discovery Service User Guide.
        ///
        /// * DELIVERY_STREAM_LIMIT_FAILURE - You reached the limit for Amazon Kinesis Data Firehose delivery streams. Reduce the number of streams or request a limit increase and try again. For more information, see [Kinesis Data Streams Limits](http://docs.aws.amazon.com/streams/latest/dev/service-sizes-and-limits.html) in the Amazon Kinesis Data Streams Developer Guide.
        ///
        /// * FIREHOSE_ROLE_MISSING - The Data Exploration feature is in an error state because your IAM User is missing the AWSApplicationDiscoveryServiceFirehose role. Turn on Data Exploration in Amazon Athena and try again. For more information, see [Step 3: Provide Application Discovery Service Access to Non-Administrator Users by Attaching Policies](http://docs.aws.amazon.com/application-discovery/latest/userguide/setting-up.html#setting-up-user-policy) in the Application Discovery Service User Guide.
        ///
        /// * FIREHOSE_STREAM_DOES_NOT_EXIST - The Data Exploration feature is in an error state because your IAM User is missing one or more of the Kinesis data delivery streams.
        ///
        /// * INTERNAL_FAILURE - The Data Exploration feature is in an error state because of an internal failure. Try again later. If this problem persists, contact Amazon Web Services Support.
        ///
        /// * LAKE_FORMATION_ACCESS_DENIED - You don't have sufficient lake formation permissions to start continuous export. For more information, see [ Upgrading Amazon Web Services Glue Data Permissions to the Amazon Web Services Lake Formation Model ](http://docs.aws.amazon.com/lake-formation/latest/dg/upgrade-glue-lake-formation.html) in the Amazon Web Services Lake Formation Developer Guide. You can use one of the following two ways to resolve this issue.
        ///
        /// * If you donâ€™t want to use the Lake Formation permission model, you can change the default Data Catalog settings to use only Amazon Web Services Identity and Access Management (IAM) access control for new databases. For more information, see [Change Data Catalog Settings](https://docs.aws.amazon.com/lake-formation/latest/dg/getting-started-setup.html#setup-change-cat-settings) in the Lake Formation Developer Guide.
        ///
        /// * You can give the service-linked IAM roles AWSServiceRoleForApplicationDiscoveryServiceContinuousExport and AWSApplicationDiscoveryServiceFirehose the required Lake Formation permissions. For more information, see [ Granting Database Permissions](https://docs.aws.amazon.com/lake-formation/latest/dg/granting-database-permissions.html) in the Lake Formation Developer Guide.
        ///
        /// * AWSServiceRoleForApplicationDiscoveryServiceContinuousExport - Grant database creator permissions, which gives the role database creation ability and implicit permissions for any created tables. For more information, see [ Implicit Lake Formation Permissions ](https://docs.aws.amazon.com/lake-formation/latest/dg/implicit-permissions.html) in the Lake Formation Developer Guide.
        ///
        /// * AWSApplicationDiscoveryServiceFirehose - Grant describe permissions for all tables in the database.
        ///
        ///
        ///
        ///
        ///
        ///
        ///
        /// * S3_BUCKET_LIMIT_FAILURE - You reached the limit for Amazon S3 buckets. Reduce the number of S3 buckets or request a limit increase and try again. For more information, see [Bucket Restrictions and Limitations](http://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html) in the Amazon Simple Storage Service Developer Guide.
        ///
        /// * S3_NOT_SIGNED_UP - Your account is not signed up for the Amazon S3 service. You must sign up before you can use Amazon S3. You can sign up at the following URL: [https://aws.amazon.com/s3](https://aws.amazon.com/s3).
        public var statusDetail: Swift.String?
        /// The timestamp that represents when this continuous export was stopped.
        public var stopTime: ClientRuntime.Date?

        public init (
            dataSource: ApplicationDiscoveryClientTypes.DataSource? = nil,
            exportId: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            schemaStorageConfig: [Swift.String:Swift.String]? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: ApplicationDiscoveryClientTypes.ContinuousExportStatus? = nil,
            statusDetail: Swift.String? = nil,
            stopTime: ClientRuntime.Date? = nil
        )
        {
            self.dataSource = dataSource
            self.exportId = exportId
            self.s3Bucket = s3Bucket
            self.schemaStorageConfig = schemaStorageConfig
            self.startTime = startTime
            self.status = status
            self.statusDetail = statusDetail
            self.stopTime = stopTime
        }
    }

}

extension ApplicationDiscoveryClientTypes {
    public enum ContinuousExportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case error
        case inactive
        case startFailed
        case startInProgress
        case stopFailed
        case stopInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ContinuousExportStatus] {
            return [
                .active,
                .error,
                .inactive,
                .startFailed,
                .startInProgress,
                .stopFailed,
                .stopInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .error: return "ERROR"
            case .inactive: return "INACTIVE"
            case .startFailed: return "START_FAILED"
            case .startInProgress: return "START_IN_PROGRESS"
            case .stopFailed: return "STOP_FAILED"
            case .stopInProgress: return "STOP_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContinuousExportStatus(rawValue: rawValue) ?? ContinuousExportStatus.sdkUnknown(rawValue)
        }
    }
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// Description of the application to be created.
    public var description: Swift.String?
    /// Name of the application to be created.
    /// This member is required.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateApplicationOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationId = output.configurationId
        } else {
            self.configurationId = nil
        }
    }
}

public struct CreateApplicationOutputResponse: Swift.Equatable {
    /// Configuration ID of an application to be created.
    public var configurationId: Swift.String?

    public init (
        configurationId: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
    }
}

struct CreateApplicationOutputResponseBody: Swift.Equatable {
    let configurationId: Swift.String?
}

extension CreateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
    }
}

extension CreateTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationIds
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationIds = configurationIds {
            var configurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationIds)
            for configurationid0 in configurationIds {
                try configurationIdsContainer.encode(configurationid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateTagsInput: Swift.Equatable {
    /// A list of configuration items that you want to tag.
    /// This member is required.
    public var configurationIds: [Swift.String]?
    /// Tags that you want to associate with one or more configuration items. Specify the tags that you want to create in a key-value format. For example: {"key": "serverType", "value": "webServer"}
    /// This member is required.
    public var tags: [ApplicationDiscoveryClientTypes.Tag]?

    public init (
        configurationIds: [Swift.String]? = nil,
        tags: [ApplicationDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.configurationIds = configurationIds
        self.tags = tags
    }
}

struct CreateTagsInputBody: Swift.Equatable {
    let configurationIds: [Swift.String]?
    let tags: [ApplicationDiscoveryClientTypes.Tag]?
}

extension CreateTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationIds
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationIds)
        var configurationIdsDecoded0:[Swift.String]? = nil
        if let configurationIdsContainer = configurationIdsContainer {
            configurationIdsDecoded0 = [Swift.String]()
            for string0 in configurationIdsContainer {
                if let string0 = string0 {
                    configurationIdsDecoded0?.append(string0)
                }
            }
        }
        configurationIds = configurationIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ApplicationDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ApplicationDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTagsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateTagsOutputResponse: Swift.Equatable {

    public init () { }
}

extension ApplicationDiscoveryClientTypes.CustomerAgentInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeAgents
        case blackListedAgents
        case healthyAgents
        case shutdownAgents
        case totalAgents
        case unhealthyAgents
        case unknownAgents
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activeAgents != 0 {
            try encodeContainer.encode(activeAgents, forKey: .activeAgents)
        }
        if blackListedAgents != 0 {
            try encodeContainer.encode(blackListedAgents, forKey: .blackListedAgents)
        }
        if healthyAgents != 0 {
            try encodeContainer.encode(healthyAgents, forKey: .healthyAgents)
        }
        if shutdownAgents != 0 {
            try encodeContainer.encode(shutdownAgents, forKey: .shutdownAgents)
        }
        if totalAgents != 0 {
            try encodeContainer.encode(totalAgents, forKey: .totalAgents)
        }
        if unhealthyAgents != 0 {
            try encodeContainer.encode(unhealthyAgents, forKey: .unhealthyAgents)
        }
        if unknownAgents != 0 {
            try encodeContainer.encode(unknownAgents, forKey: .unknownAgents)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeAgentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeAgents) ?? 0
        activeAgents = activeAgentsDecoded
        let healthyAgentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthyAgents) ?? 0
        healthyAgents = healthyAgentsDecoded
        let blackListedAgentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blackListedAgents) ?? 0
        blackListedAgents = blackListedAgentsDecoded
        let shutdownAgentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shutdownAgents) ?? 0
        shutdownAgents = shutdownAgentsDecoded
        let unhealthyAgentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unhealthyAgents) ?? 0
        unhealthyAgents = unhealthyAgentsDecoded
        let totalAgentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalAgents) ?? 0
        totalAgents = totalAgentsDecoded
        let unknownAgentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unknownAgents) ?? 0
        unknownAgents = unknownAgentsDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Inventory data for installed discovery agents.
    public struct CustomerAgentInfo: Swift.Equatable {
        /// Number of active discovery agents.
        /// This member is required.
        public var activeAgents: Swift.Int
        /// Number of blacklisted discovery agents.
        /// This member is required.
        public var blackListedAgents: Swift.Int
        /// Number of healthy discovery agents
        /// This member is required.
        public var healthyAgents: Swift.Int
        /// Number of discovery agents with status SHUTDOWN.
        /// This member is required.
        public var shutdownAgents: Swift.Int
        /// Total number of discovery agents.
        /// This member is required.
        public var totalAgents: Swift.Int
        /// Number of unhealthy discovery agents.
        /// This member is required.
        public var unhealthyAgents: Swift.Int
        /// Number of unknown discovery agents.
        /// This member is required.
        public var unknownAgents: Swift.Int

        public init (
            activeAgents: Swift.Int = 0,
            blackListedAgents: Swift.Int = 0,
            healthyAgents: Swift.Int = 0,
            shutdownAgents: Swift.Int = 0,
            totalAgents: Swift.Int = 0,
            unhealthyAgents: Swift.Int = 0,
            unknownAgents: Swift.Int = 0
        )
        {
            self.activeAgents = activeAgents
            self.blackListedAgents = blackListedAgents
            self.healthyAgents = healthyAgents
            self.shutdownAgents = shutdownAgents
            self.totalAgents = totalAgents
            self.unhealthyAgents = unhealthyAgents
            self.unknownAgents = unknownAgents
        }
    }

}

extension ApplicationDiscoveryClientTypes.CustomerAgentlessCollectorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeAgentlessCollectors
        case denyListedAgentlessCollectors
        case healthyAgentlessCollectors
        case shutdownAgentlessCollectors
        case totalAgentlessCollectors
        case unhealthyAgentlessCollectors
        case unknownAgentlessCollectors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activeAgentlessCollectors != 0 {
            try encodeContainer.encode(activeAgentlessCollectors, forKey: .activeAgentlessCollectors)
        }
        if denyListedAgentlessCollectors != 0 {
            try encodeContainer.encode(denyListedAgentlessCollectors, forKey: .denyListedAgentlessCollectors)
        }
        if healthyAgentlessCollectors != 0 {
            try encodeContainer.encode(healthyAgentlessCollectors, forKey: .healthyAgentlessCollectors)
        }
        if shutdownAgentlessCollectors != 0 {
            try encodeContainer.encode(shutdownAgentlessCollectors, forKey: .shutdownAgentlessCollectors)
        }
        if totalAgentlessCollectors != 0 {
            try encodeContainer.encode(totalAgentlessCollectors, forKey: .totalAgentlessCollectors)
        }
        if unhealthyAgentlessCollectors != 0 {
            try encodeContainer.encode(unhealthyAgentlessCollectors, forKey: .unhealthyAgentlessCollectors)
        }
        if unknownAgentlessCollectors != 0 {
            try encodeContainer.encode(unknownAgentlessCollectors, forKey: .unknownAgentlessCollectors)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeAgentlessCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeAgentlessCollectors) ?? 0
        activeAgentlessCollectors = activeAgentlessCollectorsDecoded
        let healthyAgentlessCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthyAgentlessCollectors) ?? 0
        healthyAgentlessCollectors = healthyAgentlessCollectorsDecoded
        let denyListedAgentlessCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .denyListedAgentlessCollectors) ?? 0
        denyListedAgentlessCollectors = denyListedAgentlessCollectorsDecoded
        let shutdownAgentlessCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shutdownAgentlessCollectors) ?? 0
        shutdownAgentlessCollectors = shutdownAgentlessCollectorsDecoded
        let unhealthyAgentlessCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unhealthyAgentlessCollectors) ?? 0
        unhealthyAgentlessCollectors = unhealthyAgentlessCollectorsDecoded
        let totalAgentlessCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalAgentlessCollectors) ?? 0
        totalAgentlessCollectors = totalAgentlessCollectorsDecoded
        let unknownAgentlessCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unknownAgentlessCollectors) ?? 0
        unknownAgentlessCollectors = unknownAgentlessCollectorsDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    public struct CustomerAgentlessCollectorInfo: Swift.Equatable {
        /// This member is required.
        public var activeAgentlessCollectors: Swift.Int
        /// This member is required.
        public var denyListedAgentlessCollectors: Swift.Int
        /// This member is required.
        public var healthyAgentlessCollectors: Swift.Int
        /// This member is required.
        public var shutdownAgentlessCollectors: Swift.Int
        /// This member is required.
        public var totalAgentlessCollectors: Swift.Int
        /// This member is required.
        public var unhealthyAgentlessCollectors: Swift.Int
        /// This member is required.
        public var unknownAgentlessCollectors: Swift.Int

        public init (
            activeAgentlessCollectors: Swift.Int = 0,
            denyListedAgentlessCollectors: Swift.Int = 0,
            healthyAgentlessCollectors: Swift.Int = 0,
            shutdownAgentlessCollectors: Swift.Int = 0,
            totalAgentlessCollectors: Swift.Int = 0,
            unhealthyAgentlessCollectors: Swift.Int = 0,
            unknownAgentlessCollectors: Swift.Int = 0
        )
        {
            self.activeAgentlessCollectors = activeAgentlessCollectors
            self.denyListedAgentlessCollectors = denyListedAgentlessCollectors
            self.healthyAgentlessCollectors = healthyAgentlessCollectors
            self.shutdownAgentlessCollectors = shutdownAgentlessCollectors
            self.totalAgentlessCollectors = totalAgentlessCollectors
            self.unhealthyAgentlessCollectors = unhealthyAgentlessCollectors
            self.unknownAgentlessCollectors = unknownAgentlessCollectors
        }
    }

}

extension ApplicationDiscoveryClientTypes.CustomerConnectorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeConnectors
        case blackListedConnectors
        case healthyConnectors
        case shutdownConnectors
        case totalConnectors
        case unhealthyConnectors
        case unknownConnectors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activeConnectors != 0 {
            try encodeContainer.encode(activeConnectors, forKey: .activeConnectors)
        }
        if blackListedConnectors != 0 {
            try encodeContainer.encode(blackListedConnectors, forKey: .blackListedConnectors)
        }
        if healthyConnectors != 0 {
            try encodeContainer.encode(healthyConnectors, forKey: .healthyConnectors)
        }
        if shutdownConnectors != 0 {
            try encodeContainer.encode(shutdownConnectors, forKey: .shutdownConnectors)
        }
        if totalConnectors != 0 {
            try encodeContainer.encode(totalConnectors, forKey: .totalConnectors)
        }
        if unhealthyConnectors != 0 {
            try encodeContainer.encode(unhealthyConnectors, forKey: .unhealthyConnectors)
        }
        if unknownConnectors != 0 {
            try encodeContainer.encode(unknownConnectors, forKey: .unknownConnectors)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeConnectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeConnectors) ?? 0
        activeConnectors = activeConnectorsDecoded
        let healthyConnectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthyConnectors) ?? 0
        healthyConnectors = healthyConnectorsDecoded
        let blackListedConnectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blackListedConnectors) ?? 0
        blackListedConnectors = blackListedConnectorsDecoded
        let shutdownConnectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shutdownConnectors) ?? 0
        shutdownConnectors = shutdownConnectorsDecoded
        let unhealthyConnectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unhealthyConnectors) ?? 0
        unhealthyConnectors = unhealthyConnectorsDecoded
        let totalConnectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalConnectors) ?? 0
        totalConnectors = totalConnectorsDecoded
        let unknownConnectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unknownConnectors) ?? 0
        unknownConnectors = unknownConnectorsDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Inventory data for installed discovery connectors.
    public struct CustomerConnectorInfo: Swift.Equatable {
        /// Number of active discovery connectors.
        /// This member is required.
        public var activeConnectors: Swift.Int
        /// Number of blacklisted discovery connectors.
        /// This member is required.
        public var blackListedConnectors: Swift.Int
        /// Number of healthy discovery connectors.
        /// This member is required.
        public var healthyConnectors: Swift.Int
        /// Number of discovery connectors with status SHUTDOWN,
        /// This member is required.
        public var shutdownConnectors: Swift.Int
        /// Total number of discovery connectors.
        /// This member is required.
        public var totalConnectors: Swift.Int
        /// Number of unhealthy discovery connectors.
        /// This member is required.
        public var unhealthyConnectors: Swift.Int
        /// Number of unknown discovery connectors.
        /// This member is required.
        public var unknownConnectors: Swift.Int

        public init (
            activeConnectors: Swift.Int = 0,
            blackListedConnectors: Swift.Int = 0,
            healthyConnectors: Swift.Int = 0,
            shutdownConnectors: Swift.Int = 0,
            totalConnectors: Swift.Int = 0,
            unhealthyConnectors: Swift.Int = 0,
            unknownConnectors: Swift.Int = 0
        )
        {
            self.activeConnectors = activeConnectors
            self.blackListedConnectors = blackListedConnectors
            self.healthyConnectors = healthyConnectors
            self.shutdownConnectors = shutdownConnectors
            self.totalConnectors = totalConnectors
            self.unhealthyConnectors = unhealthyConnectors
            self.unknownConnectors = unknownConnectors
        }
    }

}

extension ApplicationDiscoveryClientTypes.CustomerMeCollectorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeMeCollectors
        case denyListedMeCollectors
        case healthyMeCollectors
        case shutdownMeCollectors
        case totalMeCollectors
        case unhealthyMeCollectors
        case unknownMeCollectors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activeMeCollectors != 0 {
            try encodeContainer.encode(activeMeCollectors, forKey: .activeMeCollectors)
        }
        if denyListedMeCollectors != 0 {
            try encodeContainer.encode(denyListedMeCollectors, forKey: .denyListedMeCollectors)
        }
        if healthyMeCollectors != 0 {
            try encodeContainer.encode(healthyMeCollectors, forKey: .healthyMeCollectors)
        }
        if shutdownMeCollectors != 0 {
            try encodeContainer.encode(shutdownMeCollectors, forKey: .shutdownMeCollectors)
        }
        if totalMeCollectors != 0 {
            try encodeContainer.encode(totalMeCollectors, forKey: .totalMeCollectors)
        }
        if unhealthyMeCollectors != 0 {
            try encodeContainer.encode(unhealthyMeCollectors, forKey: .unhealthyMeCollectors)
        }
        if unknownMeCollectors != 0 {
            try encodeContainer.encode(unknownMeCollectors, forKey: .unknownMeCollectors)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeMeCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeMeCollectors) ?? 0
        activeMeCollectors = activeMeCollectorsDecoded
        let healthyMeCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthyMeCollectors) ?? 0
        healthyMeCollectors = healthyMeCollectorsDecoded
        let denyListedMeCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .denyListedMeCollectors) ?? 0
        denyListedMeCollectors = denyListedMeCollectorsDecoded
        let shutdownMeCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shutdownMeCollectors) ?? 0
        shutdownMeCollectors = shutdownMeCollectorsDecoded
        let unhealthyMeCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unhealthyMeCollectors) ?? 0
        unhealthyMeCollectors = unhealthyMeCollectorsDecoded
        let totalMeCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalMeCollectors) ?? 0
        totalMeCollectors = totalMeCollectorsDecoded
        let unknownMeCollectorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unknownMeCollectors) ?? 0
        unknownMeCollectors = unknownMeCollectorsDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// The inventory data for installed Migration Evaluator collectors.
    public struct CustomerMeCollectorInfo: Swift.Equatable {
        /// The number of active Migration Evaluator collectors.
        /// This member is required.
        public var activeMeCollectors: Swift.Int
        /// The number of deny-listed Migration Evaluator collectors.
        /// This member is required.
        public var denyListedMeCollectors: Swift.Int
        /// The number of healthy Migration Evaluator collectors.
        /// This member is required.
        public var healthyMeCollectors: Swift.Int
        /// The number of Migration Evaluator collectors with SHUTDOWN status.
        /// This member is required.
        public var shutdownMeCollectors: Swift.Int
        /// The total number of Migration Evaluator collectors.
        /// This member is required.
        public var totalMeCollectors: Swift.Int
        /// The number of unhealthy Migration Evaluator collectors.
        /// This member is required.
        public var unhealthyMeCollectors: Swift.Int
        /// The number of unknown Migration Evaluator collectors.
        /// This member is required.
        public var unknownMeCollectors: Swift.Int

        public init (
            activeMeCollectors: Swift.Int = 0,
            denyListedMeCollectors: Swift.Int = 0,
            healthyMeCollectors: Swift.Int = 0,
            shutdownMeCollectors: Swift.Int = 0,
            totalMeCollectors: Swift.Int = 0,
            unhealthyMeCollectors: Swift.Int = 0,
            unknownMeCollectors: Swift.Int = 0
        )
        {
            self.activeMeCollectors = activeMeCollectors
            self.denyListedMeCollectors = denyListedMeCollectors
            self.healthyMeCollectors = healthyMeCollectors
            self.shutdownMeCollectors = shutdownMeCollectors
            self.totalMeCollectors = totalMeCollectors
            self.unhealthyMeCollectors = unhealthyMeCollectors
            self.unknownMeCollectors = unknownMeCollectors
        }
    }

}

extension ApplicationDiscoveryClientTypes {
    public enum DataSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agent
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSource] {
            return [
                .agent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSource(rawValue: rawValue) ?? DataSource.sdkUnknown(rawValue)
        }
    }
}

extension DeleteApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationIds = configurationIds {
            var configurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationIds)
            for applicationid0 in configurationIds {
                try configurationIdsContainer.encode(applicationid0)
            }
        }
    }
}

extension DeleteApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationsInput: Swift.Equatable {
    /// Configuration ID of an application to be deleted.
    /// This member is required.
    public var configurationIds: [Swift.String]?

    public init (
        configurationIds: [Swift.String]? = nil
    )
    {
        self.configurationIds = configurationIds
    }
}

struct DeleteApplicationsInputBody: Swift.Equatable {
    let configurationIds: [Swift.String]?
}

extension DeleteApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationIds)
        var configurationIdsDecoded0:[Swift.String]? = nil
        if let configurationIdsContainer = configurationIdsContainer {
            configurationIdsDecoded0 = [Swift.String]()
            for string0 in configurationIdsContainer {
                if let string0 = string0 {
                    configurationIdsDecoded0?.append(string0)
                }
            }
        }
        configurationIds = configurationIdsDecoded0
    }
}

extension DeleteApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteApplicationsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationsOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationIds
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationIds = configurationIds {
            var configurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationIds)
            for configurationid0 in configurationIds {
                try configurationIdsContainer.encode(configurationid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension DeleteTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteTagsInput: Swift.Equatable {
    /// A list of configuration items with tags that you want to delete.
    /// This member is required.
    public var configurationIds: [Swift.String]?
    /// Tags that you want to delete from one or more configuration items. Specify the tags that you want to delete in a key-value format. For example: {"key": "serverType", "value": "webServer"}
    public var tags: [ApplicationDiscoveryClientTypes.Tag]?

    public init (
        configurationIds: [Swift.String]? = nil,
        tags: [ApplicationDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.configurationIds = configurationIds
        self.tags = tags
    }
}

struct DeleteTagsInputBody: Swift.Equatable {
    let configurationIds: [Swift.String]?
    let tags: [ApplicationDiscoveryClientTypes.Tag]?
}

extension DeleteTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationIds
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationIds)
        var configurationIdsDecoded0:[Swift.String]? = nil
        if let configurationIdsContainer = configurationIdsContainer {
            configurationIdsDecoded0 = [Swift.String]()
            for string0 in configurationIdsContainer {
                if let string0 = string0 {
                    configurationIdsDecoded0?.append(string0)
                }
            }
        }
        configurationIds = configurationIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ApplicationDiscoveryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ApplicationDiscoveryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DeleteTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTagsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTagsOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeAgentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentIds
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentIds = agentIds {
            var agentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentIds)
            for agentid0 in agentIds {
                try agentIdsContainer.encode(agentid0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAgentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAgentsInput: Swift.Equatable {
    /// The agent or the Connector IDs for which you want information. If you specify no IDs, the system returns information about all agents/Connectors associated with your Amazon Web Services user account.
    public var agentIds: [Swift.String]?
    /// You can filter the request using various logical operators and a key-value format. For example: {"key": "collectionStatus", "value": "STARTED"}
    public var filters: [ApplicationDiscoveryClientTypes.Filter]?
    /// The total number of agents/Connectors to return in a single page of output. The maximum value is 100.
    public var maxResults: Swift.Int
    /// Token to retrieve the next set of results. For example, if you previously specified 100 IDs for DescribeAgentsRequest$agentIds but set DescribeAgentsRequest$maxResults to 10, you received a set of 10 results along with a token. Use that token in this query to get the next set of 10.
    public var nextToken: Swift.String?

    public init (
        agentIds: [Swift.String]? = nil,
        filters: [ApplicationDiscoveryClientTypes.Filter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.agentIds = agentIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAgentsInputBody: Swift.Equatable {
    let agentIds: [Swift.String]?
    let filters: [ApplicationDiscoveryClientTypes.Filter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeAgentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentIds
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .agentIds)
        var agentIdsDecoded0:[Swift.String]? = nil
        if let agentIdsContainer = agentIdsContainer {
            agentIdsDecoded0 = [Swift.String]()
            for string0 in agentIdsContainer {
                if let string0 = string0 {
                    agentIdsDecoded0?.append(string0)
                }
            }
        }
        agentIds = agentIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ApplicationDiscoveryClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ApplicationDiscoveryClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAgentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAgentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAgentsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAgentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAgentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agentsInfo = output.agentsInfo
            self.nextToken = output.nextToken
        } else {
            self.agentsInfo = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAgentsOutputResponse: Swift.Equatable {
    /// Lists agents or the Connector by ID or lists all agents/Connectors associated with your user account if you did not specify an agent/Connector ID. The output includes agent/Connector IDs, IP addresses, media access control (MAC) addresses, agent/Connector health, host name where the agent/Connector resides, and the version number of each agent/Connector.
    public var agentsInfo: [ApplicationDiscoveryClientTypes.AgentInfo]?
    /// Token to retrieve the next set of results. For example, if you specified 100 IDs for DescribeAgentsRequest$agentIds but set DescribeAgentsRequest$maxResults to 10, you received a set of 10 results along with this token. Use this token in the next query to retrieve the next set of 10.
    public var nextToken: Swift.String?

    public init (
        agentsInfo: [ApplicationDiscoveryClientTypes.AgentInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentsInfo = agentsInfo
        self.nextToken = nextToken
    }
}

struct DescribeAgentsOutputResponseBody: Swift.Equatable {
    let agentsInfo: [ApplicationDiscoveryClientTypes.AgentInfo]?
    let nextToken: Swift.String?
}

extension DescribeAgentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentsInfo
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentsInfoContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.AgentInfo?].self, forKey: .agentsInfo)
        var agentsInfoDecoded0:[ApplicationDiscoveryClientTypes.AgentInfo]? = nil
        if let agentsInfoContainer = agentsInfoContainer {
            agentsInfoDecoded0 = [ApplicationDiscoveryClientTypes.AgentInfo]()
            for structure0 in agentsInfoContainer {
                if let structure0 = structure0 {
                    agentsInfoDecoded0?.append(structure0)
                }
            }
        }
        agentsInfo = agentsInfoDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationIds = configurationIds {
            var configurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationIds)
            for configurationid0 in configurationIds {
                try configurationIdsContainer.encode(configurationid0)
            }
        }
    }
}

extension DescribeConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeConfigurationsInput: Swift.Equatable {
    /// One or more configuration IDs.
    /// This member is required.
    public var configurationIds: [Swift.String]?

    public init (
        configurationIds: [Swift.String]? = nil
    )
    {
        self.configurationIds = configurationIds
    }
}

struct DescribeConfigurationsInputBody: Swift.Equatable {
    let configurationIds: [Swift.String]?
}

extension DescribeConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationIds)
        var configurationIdsDecoded0:[Swift.String]? = nil
        if let configurationIdsContainer = configurationIdsContainer {
            configurationIdsDecoded0 = [Swift.String]()
            for string0 in configurationIdsContainer {
                if let string0 = string0 {
                    configurationIdsDecoded0?.append(string0)
                }
            }
        }
        configurationIds = configurationIdsDecoded0
    }
}

extension DescribeConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurations = output.configurations
        } else {
            self.configurations = nil
        }
    }
}

public struct DescribeConfigurationsOutputResponse: Swift.Equatable {
    /// A key in the response map. The value is an array of data.
    public var configurations: [[Swift.String:Swift.String]]?

    public init (
        configurations: [[Swift.String:Swift.String]]? = nil
    )
    {
        self.configurations = configurations
    }
}

struct DescribeConfigurationsOutputResponseBody: Swift.Equatable {
    let configurations: [[Swift.String:Swift.String]]?
}

extension DescribeConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationsContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .configurations)
        var configurationsDecoded0:[[Swift.String:Swift.String]]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in configurationsContainer {
                var configurationsContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    configurationsContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in map0 {
                        if let string1 = string1 {
                            configurationsContainerDecoded0?[key1] = string1
                        }
                    }
                }
                if let configurationsContainerDecoded0 = configurationsContainerDecoded0 {
                    configurationsDecoded0?.append(configurationsContainerDecoded0)
                }
            }
        }
        configurations = configurationsDecoded0
    }
}

extension DescribeContinuousExportsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportIds
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportIds = exportIds {
            var exportIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exportIds)
            for configurationsexportid0 in exportIds {
                try exportIdsContainer.encode(configurationsexportid0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeContinuousExportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeContinuousExportsInput: Swift.Equatable {
    /// The unique IDs assigned to the exports.
    public var exportIds: [Swift.String]?
    /// A number between 1 and 100 specifying the maximum number of continuous export descriptions returned.
    public var maxResults: Swift.Int?
    /// The token from the previous call to DescribeExportTasks.
    public var nextToken: Swift.String?

    public init (
        exportIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportIds = exportIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeContinuousExportsInputBody: Swift.Equatable {
    let exportIds: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeContinuousExportsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportIds
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exportIds)
        var exportIdsDecoded0:[Swift.String]? = nil
        if let exportIdsContainer = exportIdsContainer {
            exportIdsDecoded0 = [Swift.String]()
            for string0 in exportIdsContainer {
                if let string0 = string0 {
                    exportIdsDecoded0?.append(string0)
                }
            }
        }
        exportIds = exportIdsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeContinuousExportsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeContinuousExportsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeContinuousExportsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeContinuousExportsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeContinuousExportsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.descriptions = output.descriptions
            self.nextToken = output.nextToken
        } else {
            self.descriptions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeContinuousExportsOutputResponse: Swift.Equatable {
    /// A list of continuous export descriptions.
    public var descriptions: [ApplicationDiscoveryClientTypes.ContinuousExportDescription]?
    /// The token from the previous call to DescribeExportTasks.
    public var nextToken: Swift.String?

    public init (
        descriptions: [ApplicationDiscoveryClientTypes.ContinuousExportDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.descriptions = descriptions
        self.nextToken = nextToken
    }
}

struct DescribeContinuousExportsOutputResponseBody: Swift.Equatable {
    let descriptions: [ApplicationDiscoveryClientTypes.ContinuousExportDescription]?
    let nextToken: Swift.String?
}

extension DescribeContinuousExportsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case descriptions
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionsContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.ContinuousExportDescription?].self, forKey: .descriptions)
        var descriptionsDecoded0:[ApplicationDiscoveryClientTypes.ContinuousExportDescription]? = nil
        if let descriptionsContainer = descriptionsContainer {
            descriptionsDecoded0 = [ApplicationDiscoveryClientTypes.ContinuousExportDescription]()
            for structure0 in descriptionsContainer {
                if let structure0 = structure0 {
                    descriptionsDecoded0?.append(structure0)
                }
            }
        }
        descriptions = descriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeExportConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportIds
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportIds = exportIds {
            var exportIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exportIds)
            for configurationsexportid0 in exportIds {
                try exportIdsContainer.encode(configurationsexportid0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeExportConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeExportConfigurationsInput: Swift.Equatable {
    /// A list of continuous export IDs to search for.
    public var exportIds: [Swift.String]?
    /// A number between 1 and 100 specifying the maximum number of continuous export descriptions returned.
    public var maxResults: Swift.Int
    /// The token from the previous call to describe-export-tasks.
    public var nextToken: Swift.String?

    public init (
        exportIds: [Swift.String]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.exportIds = exportIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeExportConfigurationsInputBody: Swift.Equatable {
    let exportIds: [Swift.String]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeExportConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportIds
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exportIds)
        var exportIdsDecoded0:[Swift.String]? = nil
        if let exportIdsContainer = exportIdsContainer {
            exportIdsDecoded0 = [Swift.String]()
            for string0 in exportIdsContainer {
                if let string0 = string0 {
                    exportIdsDecoded0?.append(string0)
                }
            }
        }
        exportIds = exportIdsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeExportConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeExportConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeExportConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExportConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeExportConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportsInfo = output.exportsInfo
            self.nextToken = output.nextToken
        } else {
            self.exportsInfo = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeExportConfigurationsOutputResponse: Swift.Equatable {
    ///
    public var exportsInfo: [ApplicationDiscoveryClientTypes.ExportInfo]?
    /// The token from the previous call to describe-export-tasks.
    public var nextToken: Swift.String?

    public init (
        exportsInfo: [ApplicationDiscoveryClientTypes.ExportInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportsInfo = exportsInfo
        self.nextToken = nextToken
    }
}

struct DescribeExportConfigurationsOutputResponseBody: Swift.Equatable {
    let exportsInfo: [ApplicationDiscoveryClientTypes.ExportInfo]?
    let nextToken: Swift.String?
}

extension DescribeExportConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportsInfo
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportsInfoContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.ExportInfo?].self, forKey: .exportsInfo)
        var exportsInfoDecoded0:[ApplicationDiscoveryClientTypes.ExportInfo]? = nil
        if let exportsInfoContainer = exportsInfoContainer {
            exportsInfoDecoded0 = [ApplicationDiscoveryClientTypes.ExportInfo]()
            for structure0 in exportsInfoContainer {
                if let structure0 = structure0 {
                    exportsInfoDecoded0?.append(structure0)
                }
            }
        }
        exportsInfo = exportsInfoDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeExportTasksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportIds
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportIds = exportIds {
            var exportIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exportIds)
            for configurationsexportid0 in exportIds {
                try exportIdsContainer.encode(configurationsexportid0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for exportfilter0 in filters {
                try filtersContainer.encode(exportfilter0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeExportTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeExportTasksInput: Swift.Equatable {
    /// One or more unique identifiers used to query the status of an export request.
    public var exportIds: [Swift.String]?
    /// One or more filters.
    ///
    /// * AgentId - ID of the agent whose collected data will be exported
    public var filters: [ApplicationDiscoveryClientTypes.ExportFilter]?
    /// The maximum number of volume results returned by DescribeExportTasks in paginated output. When this parameter is used, DescribeExportTasks only returns maxResults results in a single page along with a nextToken response element.
    public var maxResults: Swift.Int
    /// The nextToken value returned from a previous paginated DescribeExportTasks request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        exportIds: [Swift.String]? = nil,
        filters: [ApplicationDiscoveryClientTypes.ExportFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.exportIds = exportIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeExportTasksInputBody: Swift.Equatable {
    let exportIds: [Swift.String]?
    let filters: [ApplicationDiscoveryClientTypes.ExportFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeExportTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportIds
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exportIds)
        var exportIdsDecoded0:[Swift.String]? = nil
        if let exportIdsContainer = exportIdsContainer {
            exportIdsDecoded0 = [Swift.String]()
            for string0 in exportIdsContainer {
                if let string0 = string0 {
                    exportIdsDecoded0?.append(string0)
                }
            }
        }
        exportIds = exportIdsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.ExportFilter?].self, forKey: .filters)
        var filtersDecoded0:[ApplicationDiscoveryClientTypes.ExportFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ApplicationDiscoveryClientTypes.ExportFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeExportTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeExportTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeExportTasksOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExportTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeExportTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportsInfo = output.exportsInfo
            self.nextToken = output.nextToken
        } else {
            self.exportsInfo = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeExportTasksOutputResponse: Swift.Equatable {
    /// Contains one or more sets of export request details. When the status of a request is SUCCEEDED, the response includes a URL for an Amazon S3 bucket where you can view the data in a CSV file.
    public var exportsInfo: [ApplicationDiscoveryClientTypes.ExportInfo]?
    /// The nextToken value to include in a future DescribeExportTasks request. When the results of a DescribeExportTasks request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        exportsInfo: [ApplicationDiscoveryClientTypes.ExportInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportsInfo = exportsInfo
        self.nextToken = nextToken
    }
}

struct DescribeExportTasksOutputResponseBody: Swift.Equatable {
    let exportsInfo: [ApplicationDiscoveryClientTypes.ExportInfo]?
    let nextToken: Swift.String?
}

extension DescribeExportTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportsInfo
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportsInfoContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.ExportInfo?].self, forKey: .exportsInfo)
        var exportsInfoDecoded0:[ApplicationDiscoveryClientTypes.ExportInfo]? = nil
        if let exportsInfoContainer = exportsInfoContainer {
            exportsInfoDecoded0 = [ApplicationDiscoveryClientTypes.ExportInfo]()
            for structure0 in exportsInfoContainer {
                if let structure0 = structure0 {
                    exportsInfoDecoded0?.append(structure0)
                }
            }
        }
        exportsInfo = exportsInfoDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeImportTasksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for importtaskfilter0 in filters {
                try filtersContainer.encode(importtaskfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeImportTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeImportTasksInput: Swift.Equatable {
    /// An array of name-value pairs that you provide to filter the results for the DescribeImportTask request to a specific subset of results. Currently, wildcard values aren't supported for filters.
    public var filters: [ApplicationDiscoveryClientTypes.ImportTaskFilter]?
    /// The maximum number of results that you want this request to return, up to 100.
    public var maxResults: Swift.Int?
    /// The token to request a specific page of results.
    public var nextToken: Swift.String?

    public init (
        filters: [ApplicationDiscoveryClientTypes.ImportTaskFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeImportTasksInputBody: Swift.Equatable {
    let filters: [ApplicationDiscoveryClientTypes.ImportTaskFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeImportTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.ImportTaskFilter?].self, forKey: .filters)
        var filtersDecoded0:[ApplicationDiscoveryClientTypes.ImportTaskFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ApplicationDiscoveryClientTypes.ImportTaskFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeImportTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImportTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeImportTasksOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImportTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeImportTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tasks = output.tasks
        } else {
            self.nextToken = nil
            self.tasks = nil
        }
    }
}

public struct DescribeImportTasksOutputResponse: Swift.Equatable {
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// A returned array of import tasks that match any applied filters, up to the specified number of maximum results.
    public var tasks: [ApplicationDiscoveryClientTypes.ImportTask]?

    public init (
        nextToken: Swift.String? = nil,
        tasks: [ApplicationDiscoveryClientTypes.ImportTask]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

struct DescribeImportTasksOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let tasks: [ApplicationDiscoveryClientTypes.ImportTask]?
}

extension DescribeImportTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tasks
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tasksContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.ImportTask?].self, forKey: .tasks)
        var tasksDecoded0:[ApplicationDiscoveryClientTypes.ImportTask]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [ApplicationDiscoveryClientTypes.ImportTask]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
    }
}

extension DescribeTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for tagfilter0 in filters {
                try filtersContainer.encode(tagfilter0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeTagsInput: Swift.Equatable {
    /// You can filter the list using a key-value format. You can separate these items by using logical operators. Allowed filters include tagKey, tagValue, and configurationId.
    public var filters: [ApplicationDiscoveryClientTypes.TagFilter]?
    /// The total number of items to return in a single page of output. The maximum value is 100.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        filters: [ApplicationDiscoveryClientTypes.TagFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeTagsInputBody: Swift.Equatable {
    let filters: [ApplicationDiscoveryClientTypes.TagFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.TagFilter?].self, forKey: .filters)
        var filtersDecoded0:[ApplicationDiscoveryClientTypes.TagFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ApplicationDiscoveryClientTypes.TagFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeTagsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct DescribeTagsOutputResponse: Swift.Equatable {
    /// The call returns a token. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// Depending on the input, this is a list of configuration items tagged with a specific tag, or a list of tags for a specific configuration item.
    public var tags: [ApplicationDiscoveryClientTypes.ConfigurationTag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [ApplicationDiscoveryClientTypes.ConfigurationTag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct DescribeTagsOutputResponseBody: Swift.Equatable {
    let tags: [ApplicationDiscoveryClientTypes.ConfigurationTag]?
    let nextToken: Swift.String?
}

extension DescribeTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.ConfigurationTag?].self, forKey: .tags)
        var tagsDecoded0:[ApplicationDiscoveryClientTypes.ConfigurationTag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ApplicationDiscoveryClientTypes.ConfigurationTag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DisassociateConfigurationItemsFromApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfigurationId
        case configurationIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfigurationId = self.applicationConfigurationId {
            try encodeContainer.encode(applicationConfigurationId, forKey: .applicationConfigurationId)
        }
        if let configurationIds = configurationIds {
            var configurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationIds)
            for configurationid0 in configurationIds {
                try configurationIdsContainer.encode(configurationid0)
            }
        }
    }
}

extension DisassociateConfigurationItemsFromApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateConfigurationItemsFromApplicationInput: Swift.Equatable {
    /// Configuration ID of an application from which each item is disassociated.
    /// This member is required.
    public var applicationConfigurationId: Swift.String?
    /// Configuration ID of each item to be disassociated from an application.
    /// This member is required.
    public var configurationIds: [Swift.String]?

    public init (
        applicationConfigurationId: Swift.String? = nil,
        configurationIds: [Swift.String]? = nil
    )
    {
        self.applicationConfigurationId = applicationConfigurationId
        self.configurationIds = configurationIds
    }
}

struct DisassociateConfigurationItemsFromApplicationInputBody: Swift.Equatable {
    let applicationConfigurationId: Swift.String?
    let configurationIds: [Swift.String]?
}

extension DisassociateConfigurationItemsFromApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfigurationId
        case configurationIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationConfigurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationConfigurationId)
        applicationConfigurationId = applicationConfigurationIdDecoded
        let configurationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationIds)
        var configurationIdsDecoded0:[Swift.String]? = nil
        if let configurationIdsContainer = configurationIdsContainer {
            configurationIdsDecoded0 = [Swift.String]()
            for string0 in configurationIdsContainer {
                if let string0 = string0 {
                    configurationIdsDecoded0?.append(string0)
                }
            }
        }
        configurationIds = configurationIdsDecoded0
    }
}

extension DisassociateConfigurationItemsFromApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateConfigurationItemsFromApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateConfigurationItemsFromApplicationOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateConfigurationItemsFromApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateConfigurationItemsFromApplicationOutputResponse: Swift.Equatable {

    public init () { }
}

extension ExportConfigurationsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ExportConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ExportConfigurationsInput: Swift.Equatable {

    public init () { }
}

struct ExportConfigurationsInputBody: Swift.Equatable {
}

extension ExportConfigurationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ExportConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ExportConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportId = output.exportId
        } else {
            self.exportId = nil
        }
    }
}

public struct ExportConfigurationsOutputResponse: Swift.Equatable {
    /// A unique identifier that you can use to query the export status.
    public var exportId: Swift.String?

    public init (
        exportId: Swift.String? = nil
    )
    {
        self.exportId = exportId
    }
}

struct ExportConfigurationsOutputResponseBody: Swift.Equatable {
    let exportId: Swift.String?
}

extension ExportConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    public enum ExportDataFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case graphml
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportDataFormat] {
            return [
                .csv,
                .graphml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .graphml: return "GRAPHML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExportDataFormat(rawValue: rawValue) ?? ExportDataFormat.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationDiscoveryClientTypes.ExportFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = self.condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Used to select which agent's data is to be exported. A single agent ID may be selected for export using the [StartExportTask](http://docs.aws.amazon.com/application-discovery/latest/APIReference/API_StartExportTask.html) action.
    public struct ExportFilter: Swift.Equatable {
        /// Supported condition: EQUALS
        /// This member is required.
        public var condition: Swift.String?
        /// A single ExportFilter name. Supported filters: agentIds.
        /// This member is required.
        public var name: Swift.String?
        /// A single agent ID for a Discovery Agent. An agent ID can be found using the [DescribeAgents](http://docs.aws.amazon.com/application-discovery/latest/APIReference/API_DescribeAgents.html) action. Typically an ADS agent ID is in the form o-0123456789abcdef0.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            condition: Swift.String? = nil,
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }

}

extension ApplicationDiscoveryClientTypes.ExportInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationsDownloadUrl
        case exportId
        case exportRequestTime
        case exportStatus
        case isTruncated
        case requestedEndTime
        case requestedStartTime
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationsDownloadUrl = self.configurationsDownloadUrl {
            try encodeContainer.encode(configurationsDownloadUrl, forKey: .configurationsDownloadUrl)
        }
        if let exportId = self.exportId {
            try encodeContainer.encode(exportId, forKey: .exportId)
        }
        if let exportRequestTime = self.exportRequestTime {
            try encodeContainer.encodeTimestamp(exportRequestTime, format: .epochSeconds, forKey: .exportRequestTime)
        }
        if let exportStatus = self.exportStatus {
            try encodeContainer.encode(exportStatus.rawValue, forKey: .exportStatus)
        }
        if isTruncated != false {
            try encodeContainer.encode(isTruncated, forKey: .isTruncated)
        }
        if let requestedEndTime = self.requestedEndTime {
            try encodeContainer.encodeTimestamp(requestedEndTime, format: .epochSeconds, forKey: .requestedEndTime)
        }
        if let requestedStartTime = self.requestedStartTime {
            try encodeContainer.encodeTimestamp(requestedStartTime, format: .epochSeconds, forKey: .requestedStartTime)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let exportStatusDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.ExportStatus.self, forKey: .exportStatus)
        exportStatus = exportStatusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let configurationsDownloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationsDownloadUrl)
        configurationsDownloadUrl = configurationsDownloadUrlDecoded
        let exportRequestTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .exportRequestTime)
        exportRequestTime = exportRequestTimeDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTruncated) ?? false
        isTruncated = isTruncatedDecoded
        let requestedStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .requestedStartTime)
        requestedStartTime = requestedStartTimeDecoded
        let requestedEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .requestedEndTime)
        requestedEndTime = requestedEndTimeDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Information regarding the export status of discovered data. The value is an array of objects.
    public struct ExportInfo: Swift.Equatable {
        /// A URL for an Amazon S3 bucket where you can review the exported data. The URL is displayed only if the export succeeded.
        public var configurationsDownloadUrl: Swift.String?
        /// A unique identifier used to query an export.
        /// This member is required.
        public var exportId: Swift.String?
        /// The time that the data export was initiated.
        /// This member is required.
        public var exportRequestTime: ClientRuntime.Date?
        /// The status of the data export job.
        /// This member is required.
        public var exportStatus: ApplicationDiscoveryClientTypes.ExportStatus?
        /// If true, the export of agent information exceeded the size limit for a single export and the exported data is incomplete for the requested time range. To address this, select a smaller time range for the export by using startDate and endDate.
        public var isTruncated: Swift.Bool
        /// The endTime used in the StartExportTask request. If no endTime was requested, this result does not appear in ExportInfo.
        public var requestedEndTime: ClientRuntime.Date?
        /// The value of startTime parameter in the StartExportTask request. If no startTime was requested, this result does not appear in ExportInfo.
        public var requestedStartTime: ClientRuntime.Date?
        /// A status message provided for API callers.
        /// This member is required.
        public var statusMessage: Swift.String?

        public init (
            configurationsDownloadUrl: Swift.String? = nil,
            exportId: Swift.String? = nil,
            exportRequestTime: ClientRuntime.Date? = nil,
            exportStatus: ApplicationDiscoveryClientTypes.ExportStatus? = nil,
            isTruncated: Swift.Bool = false,
            requestedEndTime: ClientRuntime.Date? = nil,
            requestedStartTime: ClientRuntime.Date? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.configurationsDownloadUrl = configurationsDownloadUrl
            self.exportId = exportId
            self.exportRequestTime = exportRequestTime
            self.exportStatus = exportStatus
            self.isTruncated = isTruncated
            self.requestedEndTime = requestedEndTime
            self.requestedStartTime = requestedStartTime
            self.statusMessage = statusMessage
        }
    }

}

extension ApplicationDiscoveryClientTypes {
    public enum ExportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExportStatus(rawValue: rawValue) ?? ExportStatus.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationDiscoveryClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = self.condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// A filter that can use conditional operators. For more information about filters, see [Querying Discovered Configuration Items](https://docs.aws.amazon.com/application-discovery/latest/userguide/discovery-api-queries.html) in the Amazon Web Services Application Discovery Service User Guide.
    public struct Filter: Swift.Equatable {
        /// A conditional operator. The following operators are valid: EQUALS, NOT_EQUALS, CONTAINS, NOT_CONTAINS. If you specify multiple filters, the system utilizes all filters as though concatenated by AND. If you specify multiple values for a particular filter, the system differentiates the values using OR. Calling either DescribeConfigurations or ListConfigurations returns attributes of matching configuration items.
        /// This member is required.
        public var condition: Swift.String?
        /// The name of the filter.
        /// This member is required.
        public var name: Swift.String?
        /// A string value on which to filter. For example, if you choose the destinationServer.osVersion filter name, you could specify Ubuntu for the value.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            condition: Swift.String? = nil,
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }

}

extension GetDiscoverySummaryInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetDiscoverySummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDiscoverySummaryInput: Swift.Equatable {

    public init () { }
}

struct GetDiscoverySummaryInputBody: Swift.Equatable {
}

extension GetDiscoverySummaryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDiscoverySummaryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDiscoverySummaryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDiscoverySummaryOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDiscoverySummaryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDiscoverySummaryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agentSummary = output.agentSummary
            self.agentlessCollectorSummary = output.agentlessCollectorSummary
            self.applications = output.applications
            self.connectorSummary = output.connectorSummary
            self.meCollectorSummary = output.meCollectorSummary
            self.servers = output.servers
            self.serversMappedToApplications = output.serversMappedToApplications
            self.serversMappedtoTags = output.serversMappedtoTags
        } else {
            self.agentSummary = nil
            self.agentlessCollectorSummary = nil
            self.applications = 0
            self.connectorSummary = nil
            self.meCollectorSummary = nil
            self.servers = 0
            self.serversMappedToApplications = 0
            self.serversMappedtoTags = 0
        }
    }
}

public struct GetDiscoverySummaryOutputResponse: Swift.Equatable {
    /// Details about discovered agents, including agent status and health.
    public var agentSummary: ApplicationDiscoveryClientTypes.CustomerAgentInfo?
    public var agentlessCollectorSummary: ApplicationDiscoveryClientTypes.CustomerAgentlessCollectorInfo?
    /// The number of applications discovered.
    public var applications: Swift.Int
    /// Details about discovered connectors, including connector status and health.
    public var connectorSummary: ApplicationDiscoveryClientTypes.CustomerConnectorInfo?
    /// Details about Migration Evaluator collectors, including collector status and health.
    public var meCollectorSummary: ApplicationDiscoveryClientTypes.CustomerMeCollectorInfo?
    /// The number of servers discovered.
    public var servers: Swift.Int
    /// The number of servers mapped to applications.
    public var serversMappedToApplications: Swift.Int
    /// The number of servers mapped to tags.
    public var serversMappedtoTags: Swift.Int

    public init (
        agentSummary: ApplicationDiscoveryClientTypes.CustomerAgentInfo? = nil,
        agentlessCollectorSummary: ApplicationDiscoveryClientTypes.CustomerAgentlessCollectorInfo? = nil,
        applications: Swift.Int = 0,
        connectorSummary: ApplicationDiscoveryClientTypes.CustomerConnectorInfo? = nil,
        meCollectorSummary: ApplicationDiscoveryClientTypes.CustomerMeCollectorInfo? = nil,
        servers: Swift.Int = 0,
        serversMappedToApplications: Swift.Int = 0,
        serversMappedtoTags: Swift.Int = 0
    )
    {
        self.agentSummary = agentSummary
        self.agentlessCollectorSummary = agentlessCollectorSummary
        self.applications = applications
        self.connectorSummary = connectorSummary
        self.meCollectorSummary = meCollectorSummary
        self.servers = servers
        self.serversMappedToApplications = serversMappedToApplications
        self.serversMappedtoTags = serversMappedtoTags
    }
}

struct GetDiscoverySummaryOutputResponseBody: Swift.Equatable {
    let servers: Swift.Int
    let applications: Swift.Int
    let serversMappedToApplications: Swift.Int
    let serversMappedtoTags: Swift.Int
    let agentSummary: ApplicationDiscoveryClientTypes.CustomerAgentInfo?
    let connectorSummary: ApplicationDiscoveryClientTypes.CustomerConnectorInfo?
    let meCollectorSummary: ApplicationDiscoveryClientTypes.CustomerMeCollectorInfo?
    let agentlessCollectorSummary: ApplicationDiscoveryClientTypes.CustomerAgentlessCollectorInfo?
}

extension GetDiscoverySummaryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentSummary
        case agentlessCollectorSummary
        case applications
        case connectorSummary
        case meCollectorSummary
        case servers
        case serversMappedToApplications
        case serversMappedtoTags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serversDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .servers) ?? 0
        servers = serversDecoded
        let applicationsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applications) ?? 0
        applications = applicationsDecoded
        let serversMappedToApplicationsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serversMappedToApplications) ?? 0
        serversMappedToApplications = serversMappedToApplicationsDecoded
        let serversMappedtoTagsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serversMappedtoTags) ?? 0
        serversMappedtoTags = serversMappedtoTagsDecoded
        let agentSummaryDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.CustomerAgentInfo.self, forKey: .agentSummary)
        agentSummary = agentSummaryDecoded
        let connectorSummaryDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.CustomerConnectorInfo.self, forKey: .connectorSummary)
        connectorSummary = connectorSummaryDecoded
        let meCollectorSummaryDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.CustomerMeCollectorInfo.self, forKey: .meCollectorSummary)
        meCollectorSummary = meCollectorSummaryDecoded
        let agentlessCollectorSummaryDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.CustomerAgentlessCollectorInfo.self, forKey: .agentlessCollectorSummary)
        agentlessCollectorSummary = agentlessCollectorSummaryDecoded
    }
}

extension HomeRegionNotSetException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: HomeRegionNotSetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The home region is not set. Set the home region to continue.
public struct HomeRegionNotSetException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct HomeRegionNotSetExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension HomeRegionNotSetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    public enum ImportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleteComplete
        case deleteFailed
        case deleteFailedLimitExceeded
        case deleteInProgress
        case importComplete
        case importCompleteWithErrors
        case importFailed
        case importFailedRecordLimitExceeded
        case importFailedServerLimitExceeded
        case importInProgress
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportStatus] {
            return [
                .deleteComplete,
                .deleteFailed,
                .deleteFailedLimitExceeded,
                .deleteInProgress,
                .importComplete,
                .importCompleteWithErrors,
                .importFailed,
                .importFailedRecordLimitExceeded,
                .importFailedServerLimitExceeded,
                .importInProgress,
                .internalError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleteComplete: return "DELETE_COMPLETE"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteFailedLimitExceeded: return "DELETE_FAILED_LIMIT_EXCEEDED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .importComplete: return "IMPORT_COMPLETE"
            case .importCompleteWithErrors: return "IMPORT_COMPLETE_WITH_ERRORS"
            case .importFailed: return "IMPORT_FAILED"
            case .importFailedRecordLimitExceeded: return "IMPORT_FAILED_RECORD_LIMIT_EXCEEDED"
            case .importFailedServerLimitExceeded: return "IMPORT_FAILED_SERVER_LIMIT_EXCEEDED"
            case .importInProgress: return "IMPORT_IN_PROGRESS"
            case .internalError: return "INTERNAL_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportStatus(rawValue: rawValue) ?? ImportStatus.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationDiscoveryClientTypes.ImportTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationImportFailure
        case applicationImportSuccess
        case clientRequestToken
        case errorsAndFailedEntriesZip
        case importCompletionTime
        case importDeletedTime
        case importRequestTime
        case importTaskId
        case importUrl
        case name
        case serverImportFailure
        case serverImportSuccess
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if applicationImportFailure != 0 {
            try encodeContainer.encode(applicationImportFailure, forKey: .applicationImportFailure)
        }
        if applicationImportSuccess != 0 {
            try encodeContainer.encode(applicationImportSuccess, forKey: .applicationImportSuccess)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let errorsAndFailedEntriesZip = self.errorsAndFailedEntriesZip {
            try encodeContainer.encode(errorsAndFailedEntriesZip, forKey: .errorsAndFailedEntriesZip)
        }
        if let importCompletionTime = self.importCompletionTime {
            try encodeContainer.encodeTimestamp(importCompletionTime, format: .epochSeconds, forKey: .importCompletionTime)
        }
        if let importDeletedTime = self.importDeletedTime {
            try encodeContainer.encodeTimestamp(importDeletedTime, format: .epochSeconds, forKey: .importDeletedTime)
        }
        if let importRequestTime = self.importRequestTime {
            try encodeContainer.encodeTimestamp(importRequestTime, format: .epochSeconds, forKey: .importRequestTime)
        }
        if let importTaskId = self.importTaskId {
            try encodeContainer.encode(importTaskId, forKey: .importTaskId)
        }
        if let importUrl = self.importUrl {
            try encodeContainer.encode(importUrl, forKey: .importUrl)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if serverImportFailure != 0 {
            try encodeContainer.encode(serverImportFailure, forKey: .serverImportFailure)
        }
        if serverImportSuccess != 0 {
            try encodeContainer.encode(serverImportSuccess, forKey: .serverImportSuccess)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importTaskId)
        importTaskId = importTaskIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let importUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importUrl)
        importUrl = importUrlDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.ImportStatus.self, forKey: .status)
        status = statusDecoded
        let importRequestTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .importRequestTime)
        importRequestTime = importRequestTimeDecoded
        let importCompletionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .importCompletionTime)
        importCompletionTime = importCompletionTimeDecoded
        let importDeletedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .importDeletedTime)
        importDeletedTime = importDeletedTimeDecoded
        let serverImportSuccessDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serverImportSuccess) ?? 0
        serverImportSuccess = serverImportSuccessDecoded
        let serverImportFailureDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serverImportFailure) ?? 0
        serverImportFailure = serverImportFailureDecoded
        let applicationImportSuccessDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationImportSuccess) ?? 0
        applicationImportSuccess = applicationImportSuccessDecoded
        let applicationImportFailureDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .applicationImportFailure) ?? 0
        applicationImportFailure = applicationImportFailureDecoded
        let errorsAndFailedEntriesZipDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorsAndFailedEntriesZip)
        errorsAndFailedEntriesZip = errorsAndFailedEntriesZipDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// An array of information related to the import task request that includes status information, times, IDs, the Amazon S3 Object URL for the import file, and more.
    public struct ImportTask: Swift.Equatable {
        /// The total number of application records in the import file that failed to be imported.
        public var applicationImportFailure: Swift.Int
        /// The total number of application records in the import file that were successfully imported.
        public var applicationImportSuccess: Swift.Int
        /// A unique token used to prevent the same import request from occurring more than once. If you didn't provide a token, a token was automatically generated when the import task request was sent.
        public var clientRequestToken: Swift.String?
        /// A link to a compressed archive folder (in the ZIP format) that contains an error log and a file of failed records. You can use these two files to quickly identify records that failed, why they failed, and correct those records. Afterward, you can upload the corrected file to your Amazon S3 bucket and create another import task request. This field also includes authorization information so you can confirm the authenticity of the compressed archive before you download it. If some records failed to be imported we recommend that you correct the records in the failed entries file and then imports that failed entries file. This prevents you from having to correct and update the larger original file and attempt importing it again.
        public var errorsAndFailedEntriesZip: Swift.String?
        /// The time that the import task request finished, presented in the Unix time stamp format.
        public var importCompletionTime: ClientRuntime.Date?
        /// The time that the import task request was deleted, presented in the Unix time stamp format.
        public var importDeletedTime: ClientRuntime.Date?
        /// The time that the import task request was made, presented in the Unix time stamp format.
        public var importRequestTime: ClientRuntime.Date?
        /// The unique ID for a specific import task. These IDs aren't globally unique, but they are unique within an Amazon Web Services account.
        public var importTaskId: Swift.String?
        /// The URL for your import file that you've uploaded to Amazon S3.
        public var importUrl: Swift.String?
        /// A descriptive name for an import task. You can use this name to filter future requests related to this import task, such as identifying applications and servers that were included in this import task. We recommend that you use a meaningful name for each import task.
        public var name: Swift.String?
        /// The total number of server records in the import file that failed to be imported.
        public var serverImportFailure: Swift.Int
        /// The total number of server records in the import file that were successfully imported.
        public var serverImportSuccess: Swift.Int
        /// The status of the import task. An import can have the status of IMPORT_COMPLETE and still have some records fail to import from the overall request. More information can be found in the downloadable archive defined in the errorsAndFailedEntriesZip field, or in the Migration Hub management console.
        public var status: ApplicationDiscoveryClientTypes.ImportStatus?

        public init (
            applicationImportFailure: Swift.Int = 0,
            applicationImportSuccess: Swift.Int = 0,
            clientRequestToken: Swift.String? = nil,
            errorsAndFailedEntriesZip: Swift.String? = nil,
            importCompletionTime: ClientRuntime.Date? = nil,
            importDeletedTime: ClientRuntime.Date? = nil,
            importRequestTime: ClientRuntime.Date? = nil,
            importTaskId: Swift.String? = nil,
            importUrl: Swift.String? = nil,
            name: Swift.String? = nil,
            serverImportFailure: Swift.Int = 0,
            serverImportSuccess: Swift.Int = 0,
            status: ApplicationDiscoveryClientTypes.ImportStatus? = nil
        )
        {
            self.applicationImportFailure = applicationImportFailure
            self.applicationImportSuccess = applicationImportSuccess
            self.clientRequestToken = clientRequestToken
            self.errorsAndFailedEntriesZip = errorsAndFailedEntriesZip
            self.importCompletionTime = importCompletionTime
            self.importDeletedTime = importDeletedTime
            self.importRequestTime = importRequestTime
            self.importTaskId = importTaskId
            self.importUrl = importUrl
            self.name = name
            self.serverImportFailure = serverImportFailure
            self.serverImportSuccess = serverImportSuccess
            self.status = status
        }
    }

}

extension ApplicationDiscoveryClientTypes.ImportTaskFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for importtaskfiltervalue0 in values {
                try valuesContainer.encode(importtaskfiltervalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.ImportTaskFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ApplicationDiscoveryClientTypes {
    /// A name-values pair of elements you can use to filter the results when querying your import tasks. Currently, wildcards are not supported for filters. When filtering by import status, all other filter values are ignored.
    public struct ImportTaskFilter: Swift.Equatable {
        /// The name, status, or import task ID for a specific import task.
        public var name: ApplicationDiscoveryClientTypes.ImportTaskFilterName?
        /// An array of strings that you can provide to match against a specific name, status, or import task ID to filter the results for your import task queries.
        public var values: [Swift.String]?

        public init (
            name: ApplicationDiscoveryClientTypes.ImportTaskFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension ApplicationDiscoveryClientTypes {
    public enum ImportTaskFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case importTaskId
        case name
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportTaskFilterName] {
            return [
                .importTaskId,
                .name,
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .importTaskId: return "IMPORT_TASK_ID"
            case .name: return "NAME"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportTaskFilterName(rawValue: rawValue) ?? ImportTaskFilterName.sdkUnknown(rawValue)
        }
    }
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more parameters are not valid. Verify the parameters and try again.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The value of one or more parameters are either invalid or out of range. Verify the parameter values and try again.
public struct InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationType
        case filters
        case maxResults
        case nextToken
        case orderBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationType = self.configurationType {
            try encodeContainer.encode(configurationType.rawValue, forKey: .configurationType)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let orderBy = orderBy {
            var orderByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderBy)
            for orderbyelement0 in orderBy {
                try orderByContainer.encode(orderbyelement0)
            }
        }
    }
}

extension ListConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListConfigurationsInput: Swift.Equatable {
    /// A valid configuration identified by Application Discovery Service.
    /// This member is required.
    public var configurationType: ApplicationDiscoveryClientTypes.ConfigurationItemType?
    /// You can filter the request using various logical operators and a key-value format. For example: {"key": "serverType", "value": "webServer"} For a complete list of filter options and guidance about using them with this action, see [Using the ListConfigurations Action](https://docs.aws.amazon.com/application-discovery/latest/userguide/discovery-api-queries.html#ListConfigurations) in the Amazon Web Services Application Discovery Service User Guide.
    public var filters: [ApplicationDiscoveryClientTypes.Filter]?
    /// The total number of items to return. The maximum value is 100.
    public var maxResults: Swift.Int
    /// Token to retrieve the next set of results. For example, if a previous call to ListConfigurations returned 100 items, but you set ListConfigurationsRequest$maxResults to 10, you received a set of 10 results along with a token. Use that token in this query to get the next set of 10.
    public var nextToken: Swift.String?
    /// Certain filter criteria return output that can be sorted in ascending or descending order. For a list of output characteristics for each filter, see [Using the ListConfigurations Action](https://docs.aws.amazon.com/application-discovery/latest/userguide/discovery-api-queries.html#ListConfigurations) in the Amazon Web Services Application Discovery Service User Guide.
    public var orderBy: [ApplicationDiscoveryClientTypes.OrderByElement]?

    public init (
        configurationType: ApplicationDiscoveryClientTypes.ConfigurationItemType? = nil,
        filters: [ApplicationDiscoveryClientTypes.Filter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        orderBy: [ApplicationDiscoveryClientTypes.OrderByElement]? = nil
    )
    {
        self.configurationType = configurationType
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.orderBy = orderBy
    }
}

struct ListConfigurationsInputBody: Swift.Equatable {
    let configurationType: ApplicationDiscoveryClientTypes.ConfigurationItemType?
    let filters: [ApplicationDiscoveryClientTypes.Filter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
    let orderBy: [ApplicationDiscoveryClientTypes.OrderByElement]?
}

extension ListConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationType
        case filters
        case maxResults
        case nextToken
        case orderBy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationTypeDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.ConfigurationItemType.self, forKey: .configurationType)
        configurationType = configurationTypeDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ApplicationDiscoveryClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ApplicationDiscoveryClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let orderByContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.OrderByElement?].self, forKey: .orderBy)
        var orderByDecoded0:[ApplicationDiscoveryClientTypes.OrderByElement]? = nil
        if let orderByContainer = orderByContainer {
            orderByDecoded0 = [ApplicationDiscoveryClientTypes.OrderByElement]()
            for structure0 in orderByContainer {
                if let structure0 = structure0 {
                    orderByDecoded0?.append(structure0)
                }
            }
        }
        orderBy = orderByDecoded0
    }
}

extension ListConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurations = output.configurations
            self.nextToken = output.nextToken
        } else {
            self.configurations = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfigurationsOutputResponse: Swift.Equatable {
    /// Returns configuration details, including the configuration ID, attribute names, and attribute values.
    public var configurations: [[Swift.String:Swift.String]]?
    /// Token to retrieve the next set of results. For example, if your call to ListConfigurations returned 100 items, but you set ListConfigurationsRequest$maxResults to 10, you received a set of 10 results along with this token. Use this token in the next query to retrieve the next set of 10.
    public var nextToken: Swift.String?

    public init (
        configurations: [[Swift.String:Swift.String]]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurations = configurations
        self.nextToken = nextToken
    }
}

struct ListConfigurationsOutputResponseBody: Swift.Equatable {
    let configurations: [[Swift.String:Swift.String]]?
    let nextToken: Swift.String?
}

extension ListConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationsContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .configurations)
        var configurationsDecoded0:[[Swift.String:Swift.String]]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in configurationsContainer {
                var configurationsContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    configurationsContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in map0 {
                        if let string1 = string1 {
                            configurationsContainerDecoded0?[key1] = string1
                        }
                    }
                }
                if let configurationsContainerDecoded0 = configurationsContainerDecoded0 {
                    configurationsDecoded0?.append(configurationsContainerDecoded0)
                }
            }
        }
        configurations = configurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServerNeighborsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId
        case maxResults
        case neighborConfigurationIds
        case nextToken
        case portInformationNeeded
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationId = self.configurationId {
            try encodeContainer.encode(configurationId, forKey: .configurationId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let neighborConfigurationIds = neighborConfigurationIds {
            var neighborConfigurationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .neighborConfigurationIds)
            for configurationid0 in neighborConfigurationIds {
                try neighborConfigurationIdsContainer.encode(configurationid0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if portInformationNeeded != false {
            try encodeContainer.encode(portInformationNeeded, forKey: .portInformationNeeded)
        }
    }
}

extension ListServerNeighborsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServerNeighborsInput: Swift.Equatable {
    /// Configuration ID of the server for which neighbors are being listed.
    /// This member is required.
    public var configurationId: Swift.String?
    /// Maximum number of results to return in a single page of output.
    public var maxResults: Swift.Int
    /// List of configuration IDs to test for one-hop-away.
    public var neighborConfigurationIds: [Swift.String]?
    /// Token to retrieve the next set of results. For example, if you previously specified 100 IDs for ListServerNeighborsRequest$neighborConfigurationIds but set ListServerNeighborsRequest$maxResults to 10, you received a set of 10 results along with a token. Use that token in this query to get the next set of 10.
    public var nextToken: Swift.String?
    /// Flag to indicate if port and protocol information is needed as part of the response.
    public var portInformationNeeded: Swift.Bool

    public init (
        configurationId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        neighborConfigurationIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        portInformationNeeded: Swift.Bool = false
    )
    {
        self.configurationId = configurationId
        self.maxResults = maxResults
        self.neighborConfigurationIds = neighborConfigurationIds
        self.nextToken = nextToken
        self.portInformationNeeded = portInformationNeeded
    }
}

struct ListServerNeighborsInputBody: Swift.Equatable {
    let configurationId: Swift.String?
    let portInformationNeeded: Swift.Bool
    let neighborConfigurationIds: [Swift.String]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListServerNeighborsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId
        case maxResults
        case neighborConfigurationIds
        case nextToken
        case portInformationNeeded
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let portInformationNeededDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .portInformationNeeded) ?? false
        portInformationNeeded = portInformationNeededDecoded
        let neighborConfigurationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .neighborConfigurationIds)
        var neighborConfigurationIdsDecoded0:[Swift.String]? = nil
        if let neighborConfigurationIdsContainer = neighborConfigurationIdsContainer {
            neighborConfigurationIdsDecoded0 = [Swift.String]()
            for string0 in neighborConfigurationIdsContainer {
                if let string0 = string0 {
                    neighborConfigurationIdsDecoded0?.append(string0)
                }
            }
        }
        neighborConfigurationIds = neighborConfigurationIdsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServerNeighborsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServerNeighborsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListServerNeighborsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServerNeighborsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListServerNeighborsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.knownDependencyCount = output.knownDependencyCount
            self.neighbors = output.neighbors
            self.nextToken = output.nextToken
        } else {
            self.knownDependencyCount = 0
            self.neighbors = nil
            self.nextToken = nil
        }
    }
}

public struct ListServerNeighborsOutputResponse: Swift.Equatable {
    /// Count of distinct servers that are one hop away from the given server.
    public var knownDependencyCount: Swift.Int
    /// List of distinct servers that are one hop away from the given server.
    /// This member is required.
    public var neighbors: [ApplicationDiscoveryClientTypes.NeighborConnectionDetail]?
    /// Token to retrieve the next set of results. For example, if you specified 100 IDs for ListServerNeighborsRequest$neighborConfigurationIds but set ListServerNeighborsRequest$maxResults to 10, you received a set of 10 results along with this token. Use this token in the next query to retrieve the next set of 10.
    public var nextToken: Swift.String?

    public init (
        knownDependencyCount: Swift.Int = 0,
        neighbors: [ApplicationDiscoveryClientTypes.NeighborConnectionDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knownDependencyCount = knownDependencyCount
        self.neighbors = neighbors
        self.nextToken = nextToken
    }
}

struct ListServerNeighborsOutputResponseBody: Swift.Equatable {
    let neighbors: [ApplicationDiscoveryClientTypes.NeighborConnectionDetail]?
    let nextToken: Swift.String?
    let knownDependencyCount: Swift.Int
}

extension ListServerNeighborsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knownDependencyCount
        case neighbors
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let neighborsContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.NeighborConnectionDetail?].self, forKey: .neighbors)
        var neighborsDecoded0:[ApplicationDiscoveryClientTypes.NeighborConnectionDetail]? = nil
        if let neighborsContainer = neighborsContainer {
            neighborsDecoded0 = [ApplicationDiscoveryClientTypes.NeighborConnectionDetail]()
            for structure0 in neighborsContainer {
                if let structure0 = structure0 {
                    neighborsDecoded0?.append(structure0)
                }
            }
        }
        neighbors = neighborsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let knownDependencyCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .knownDependencyCount) ?? 0
        knownDependencyCount = knownDependencyCountDecoded
    }
}

extension ApplicationDiscoveryClientTypes.NeighborConnectionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionsCount
        case destinationPort
        case destinationServerId
        case sourceServerId
        case transportProtocol
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if connectionsCount != 0 {
            try encodeContainer.encode(connectionsCount, forKey: .connectionsCount)
        }
        if let destinationPort = self.destinationPort {
            try encodeContainer.encode(destinationPort, forKey: .destinationPort)
        }
        if let destinationServerId = self.destinationServerId {
            try encodeContainer.encode(destinationServerId, forKey: .destinationServerId)
        }
        if let sourceServerId = self.sourceServerId {
            try encodeContainer.encode(sourceServerId, forKey: .sourceServerId)
        }
        if let transportProtocol = self.transportProtocol {
            try encodeContainer.encode(transportProtocol, forKey: .transportProtocol)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerId)
        sourceServerId = sourceServerIdDecoded
        let destinationServerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationServerId)
        destinationServerId = destinationServerIdDecoded
        let destinationPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
        let transportProtocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transportProtocol)
        transportProtocol = transportProtocolDecoded
        let connectionsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .connectionsCount) ?? 0
        connectionsCount = connectionsCountDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Details about neighboring servers.
    public struct NeighborConnectionDetail: Swift.Equatable {
        /// The number of open network connections with the neighboring server.
        /// This member is required.
        public var connectionsCount: Swift.Int
        /// The destination network port for the connection.
        public var destinationPort: Swift.Int?
        /// The ID of the server that accepted the network connection.
        /// This member is required.
        public var destinationServerId: Swift.String?
        /// The ID of the server that opened the network connection.
        /// This member is required.
        public var sourceServerId: Swift.String?
        /// The network protocol used for the connection.
        public var transportProtocol: Swift.String?

        public init (
            connectionsCount: Swift.Int = 0,
            destinationPort: Swift.Int? = nil,
            destinationServerId: Swift.String? = nil,
            sourceServerId: Swift.String? = nil,
            transportProtocol: Swift.String? = nil
        )
        {
            self.connectionsCount = connectionsCount
            self.destinationPort = destinationPort
            self.destinationServerId = destinationServerId
            self.sourceServerId = sourceServerId
            self.transportProtocol = transportProtocol
        }
    }

}

extension OperationNotPermittedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OperationNotPermittedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This operation is not permitted.
public struct OperationNotPermittedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotPermittedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationNotPermittedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationDiscoveryClientTypes.OrderByElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldName
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldName = self.fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.OrderString.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// A field and direction for ordered output.
    public struct OrderByElement: Swift.Equatable {
        /// The field on which to order.
        /// This member is required.
        public var fieldName: Swift.String?
        /// Ordering direction.
        public var sortOrder: ApplicationDiscoveryClientTypes.OrderString?

        public init (
            fieldName: Swift.String? = nil,
            sortOrder: ApplicationDiscoveryClientTypes.OrderString? = nil
        )
        {
            self.fieldName = fieldName
            self.sortOrder = sortOrder
        }
    }

}

extension ApplicationDiscoveryClientTypes {
    public enum OrderString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderString] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderString(rawValue: rawValue) ?? OrderString.sdkUnknown(rawValue)
        }
    }
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This issue occurs when the same clientRequestToken is used with the StartImportTask action, but with different parameters. For example, you use the same request token but have two different import URLs, you can encounter this issue. If the import tasks are meant to be different, use a different clientRequestToken, and try again.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified configuration ID was not located. Verify the configuration ID and try again.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServerInternalErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServerInternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The server experienced an internal error. Try again.
public struct ServerInternalErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServerInternalErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServerInternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartContinuousExportInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension StartContinuousExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartContinuousExportInput: Swift.Equatable {

    public init () { }
}

struct StartContinuousExportInputBody: Swift.Equatable {
}

extension StartContinuousExportInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StartContinuousExportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartContinuousExportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictErrorException" : self = .conflictErrorException(try ConflictErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartContinuousExportOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case conflictErrorException(ConflictErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartContinuousExportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartContinuousExportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
            self.exportId = output.exportId
            self.s3Bucket = output.s3Bucket
            self.schemaStorageConfig = output.schemaStorageConfig
            self.startTime = output.startTime
        } else {
            self.dataSource = nil
            self.exportId = nil
            self.s3Bucket = nil
            self.schemaStorageConfig = nil
            self.startTime = nil
        }
    }
}

public struct StartContinuousExportOutputResponse: Swift.Equatable {
    /// The type of data collector used to gather this data (currently only offered for AGENT).
    public var dataSource: ApplicationDiscoveryClientTypes.DataSource?
    /// The unique ID assigned to this export.
    public var exportId: Swift.String?
    /// The name of the s3 bucket where the export data parquet files are stored.
    public var s3Bucket: Swift.String?
    /// A dictionary which describes how the data is stored.
    ///
    /// * databaseName - the name of the Glue database used to store the schema.
    public var schemaStorageConfig: [Swift.String:Swift.String]?
    /// The timestamp representing when the continuous export was started.
    public var startTime: ClientRuntime.Date?

    public init (
        dataSource: ApplicationDiscoveryClientTypes.DataSource? = nil,
        exportId: Swift.String? = nil,
        s3Bucket: Swift.String? = nil,
        schemaStorageConfig: [Swift.String:Swift.String]? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.dataSource = dataSource
        self.exportId = exportId
        self.s3Bucket = s3Bucket
        self.schemaStorageConfig = schemaStorageConfig
        self.startTime = startTime
    }
}

struct StartContinuousExportOutputResponseBody: Swift.Equatable {
    let exportId: Swift.String?
    let s3Bucket: Swift.String?
    let startTime: ClientRuntime.Date?
    let dataSource: ApplicationDiscoveryClientTypes.DataSource?
    let schemaStorageConfig: [Swift.String:Swift.String]?
}

extension StartContinuousExportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case exportId
        case s3Bucket
        case schemaStorageConfig
        case startTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let schemaStorageConfigContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .schemaStorageConfig)
        var schemaStorageConfigDecoded0: [Swift.String:Swift.String]? = nil
        if let schemaStorageConfigContainer = schemaStorageConfigContainer {
            schemaStorageConfigDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in schemaStorageConfigContainer {
                if let string0 = string0 {
                    schemaStorageConfigDecoded0?[key0] = string0
                }
            }
        }
        schemaStorageConfig = schemaStorageConfigDecoded0
    }
}

extension StartDataCollectionByAgentIdsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentIds = agentIds {
            var agentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentIds)
            for agentid0 in agentIds {
                try agentIdsContainer.encode(agentid0)
            }
        }
    }
}

extension StartDataCollectionByAgentIdsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartDataCollectionByAgentIdsInput: Swift.Equatable {
    /// The IDs of the agents or connectors from which to start collecting data. If you send a request to an agent/connector ID that you do not have permission to contact, according to your Amazon Web Services account, the service does not throw an exception. Instead, it returns the error in the Description field. If you send a request to multiple agents/connectors and you do not have permission to contact some of those agents/connectors, the system does not throw an exception. Instead, the system shows Failed in the Description field.
    /// This member is required.
    public var agentIds: [Swift.String]?

    public init (
        agentIds: [Swift.String]? = nil
    )
    {
        self.agentIds = agentIds
    }
}

struct StartDataCollectionByAgentIdsInputBody: Swift.Equatable {
    let agentIds: [Swift.String]?
}

extension StartDataCollectionByAgentIdsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .agentIds)
        var agentIdsDecoded0:[Swift.String]? = nil
        if let agentIdsContainer = agentIdsContainer {
            agentIdsDecoded0 = [Swift.String]()
            for string0 in agentIdsContainer {
                if let string0 = string0 {
                    agentIdsDecoded0?.append(string0)
                }
            }
        }
        agentIds = agentIdsDecoded0
    }
}

extension StartDataCollectionByAgentIdsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDataCollectionByAgentIdsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartDataCollectionByAgentIdsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDataCollectionByAgentIdsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartDataCollectionByAgentIdsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agentsConfigurationStatus = output.agentsConfigurationStatus
        } else {
            self.agentsConfigurationStatus = nil
        }
    }
}

public struct StartDataCollectionByAgentIdsOutputResponse: Swift.Equatable {
    /// Information about agents or the connector that were instructed to start collecting data. Information includes the agent/connector ID, a description of the operation performed, and whether the agent/connector configuration was updated.
    public var agentsConfigurationStatus: [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]?

    public init (
        agentsConfigurationStatus: [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]? = nil
    )
    {
        self.agentsConfigurationStatus = agentsConfigurationStatus
    }
}

struct StartDataCollectionByAgentIdsOutputResponseBody: Swift.Equatable {
    let agentsConfigurationStatus: [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]?
}

extension StartDataCollectionByAgentIdsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentsConfigurationStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentsConfigurationStatusContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.AgentConfigurationStatus?].self, forKey: .agentsConfigurationStatus)
        var agentsConfigurationStatusDecoded0:[ApplicationDiscoveryClientTypes.AgentConfigurationStatus]? = nil
        if let agentsConfigurationStatusContainer = agentsConfigurationStatusContainer {
            agentsConfigurationStatusDecoded0 = [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]()
            for structure0 in agentsConfigurationStatusContainer {
                if let structure0 = structure0 {
                    agentsConfigurationStatusDecoded0?.append(structure0)
                }
            }
        }
        agentsConfigurationStatus = agentsConfigurationStatusDecoded0
    }
}

extension StartExportTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case exportDataFormat
        case filters
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let exportDataFormat = exportDataFormat {
            var exportDataFormatContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exportDataFormat)
            for exportdataformat0 in exportDataFormat {
                try exportDataFormatContainer.encode(exportdataformat0.rawValue)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for exportfilter0 in filters {
                try filtersContainer.encode(exportfilter0)
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension StartExportTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartExportTaskInput: Swift.Equatable {
    /// The end timestamp for exported data from the single Application Discovery Agent selected in the filters. If no value is specified, exported data includes the most recent data collected by the agent.
    public var endTime: ClientRuntime.Date?
    /// The file format for the returned export data. Default value is CSV. Note: The GRAPHML option has been deprecated.
    public var exportDataFormat: [ApplicationDiscoveryClientTypes.ExportDataFormat]?
    /// If a filter is present, it selects the single agentId of the Application Discovery Agent for which data is exported. The agentId can be found in the results of the DescribeAgents API or CLI. If no filter is present, startTime and endTime are ignored and exported data includes both Agentless Discovery Connector data and summary data from Application Discovery agents.
    public var filters: [ApplicationDiscoveryClientTypes.ExportFilter]?
    /// The start timestamp for exported data from the single Application Discovery Agent selected in the filters. If no value is specified, data is exported starting from the first data collected by the agent.
    public var startTime: ClientRuntime.Date?

    public init (
        endTime: ClientRuntime.Date? = nil,
        exportDataFormat: [ApplicationDiscoveryClientTypes.ExportDataFormat]? = nil,
        filters: [ApplicationDiscoveryClientTypes.ExportFilter]? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.exportDataFormat = exportDataFormat
        self.filters = filters
        self.startTime = startTime
    }
}

struct StartExportTaskInputBody: Swift.Equatable {
    let exportDataFormat: [ApplicationDiscoveryClientTypes.ExportDataFormat]?
    let filters: [ApplicationDiscoveryClientTypes.ExportFilter]?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
}

extension StartExportTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case exportDataFormat
        case filters
        case startTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportDataFormatContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.ExportDataFormat?].self, forKey: .exportDataFormat)
        var exportDataFormatDecoded0:[ApplicationDiscoveryClientTypes.ExportDataFormat]? = nil
        if let exportDataFormatContainer = exportDataFormatContainer {
            exportDataFormatDecoded0 = [ApplicationDiscoveryClientTypes.ExportDataFormat]()
            for string0 in exportDataFormatContainer {
                if let string0 = string0 {
                    exportDataFormatDecoded0?.append(string0)
                }
            }
        }
        exportDataFormat = exportDataFormatDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.ExportFilter?].self, forKey: .filters)
        var filtersDecoded0:[ApplicationDiscoveryClientTypes.ExportFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ApplicationDiscoveryClientTypes.ExportFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension StartExportTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartExportTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartExportTaskOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartExportTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartExportTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportId = output.exportId
        } else {
            self.exportId = nil
        }
    }
}

public struct StartExportTaskOutputResponse: Swift.Equatable {
    /// A unique identifier used to query the status of an export request.
    public var exportId: Swift.String?

    public init (
        exportId: Swift.String? = nil
    )
    {
        self.exportId = exportId
    }
}

struct StartExportTaskOutputResponseBody: Swift.Equatable {
    let exportId: Swift.String?
}

extension StartExportTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
    }
}

extension StartImportTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case importUrl
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let importUrl = self.importUrl {
            try encodeContainer.encode(importUrl, forKey: .importUrl)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StartImportTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartImportTaskInput: Swift.Equatable {
    /// Optional. A unique token that you can provide to prevent the same import request from occurring more than once. If you don't provide a token, a token is automatically generated. Sending more than one StartImportTask request with the same client request token will return information about the original import task with that client request token.
    public var clientRequestToken: Swift.String?
    /// The URL for your import file that you've uploaded to Amazon S3. If you're using the Amazon Web Services CLI, this URL is structured as follows: s3://BucketName/ImportFileName.CSV
    /// This member is required.
    public var importUrl: Swift.String?
    /// A descriptive name for this request. You can use this name to filter future requests related to this import task, such as identifying applications and servers that were included in this import task. We recommend that you use a meaningful name for each import task.
    /// This member is required.
    public var name: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        importUrl: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.importUrl = importUrl
        self.name = name
    }
}

struct StartImportTaskInputBody: Swift.Equatable {
    let clientRequestToken: Swift.String?
    let name: Swift.String?
    let importUrl: Swift.String?
}

extension StartImportTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case importUrl
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let importUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importUrl)
        importUrl = importUrlDecoded
    }
}

extension StartImportTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartImportTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartImportTaskOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceInUseException(ResourceInUseException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartImportTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartImportTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.task = output.task
        } else {
            self.task = nil
        }
    }
}

public struct StartImportTaskOutputResponse: Swift.Equatable {
    /// An array of information related to the import task request including status information, times, IDs, the Amazon S3 Object URL for the import file, and more.
    public var task: ApplicationDiscoveryClientTypes.ImportTask?

    public init (
        task: ApplicationDiscoveryClientTypes.ImportTask? = nil
    )
    {
        self.task = task
    }
}

struct StartImportTaskOutputResponseBody: Swift.Equatable {
    let task: ApplicationDiscoveryClientTypes.ImportTask?
}

extension StartImportTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case task
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskDecoded = try containerValues.decodeIfPresent(ApplicationDiscoveryClientTypes.ImportTask.self, forKey: .task)
        task = taskDecoded
    }
}

extension StopContinuousExportInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportId = self.exportId {
            try encodeContainer.encode(exportId, forKey: .exportId)
        }
    }
}

extension StopContinuousExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopContinuousExportInput: Swift.Equatable {
    /// The unique ID assigned to this export.
    /// This member is required.
    public var exportId: Swift.String?

    public init (
        exportId: Swift.String? = nil
    )
    {
        self.exportId = exportId
    }
}

struct StopContinuousExportInputBody: Swift.Equatable {
    let exportId: Swift.String?
}

extension StopContinuousExportInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
    }
}

extension StopContinuousExportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopContinuousExportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopContinuousExportOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopContinuousExportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopContinuousExportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.startTime = output.startTime
            self.stopTime = output.stopTime
        } else {
            self.startTime = nil
            self.stopTime = nil
        }
    }
}

public struct StopContinuousExportOutputResponse: Swift.Equatable {
    /// Timestamp that represents when this continuous export started collecting data.
    public var startTime: ClientRuntime.Date?
    /// Timestamp that represents when this continuous export was stopped.
    public var stopTime: ClientRuntime.Date?

    public init (
        startTime: ClientRuntime.Date? = nil,
        stopTime: ClientRuntime.Date? = nil
    )
    {
        self.startTime = startTime
        self.stopTime = stopTime
    }
}

struct StopContinuousExportOutputResponseBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let stopTime: ClientRuntime.Date?
}

extension StopContinuousExportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startTime
        case stopTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stopTime)
        stopTime = stopTimeDecoded
    }
}

extension StopDataCollectionByAgentIdsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentIds = agentIds {
            var agentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentIds)
            for agentid0 in agentIds {
                try agentIdsContainer.encode(agentid0)
            }
        }
    }
}

extension StopDataCollectionByAgentIdsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopDataCollectionByAgentIdsInput: Swift.Equatable {
    /// The IDs of the agents or connectors from which to stop collecting data.
    /// This member is required.
    public var agentIds: [Swift.String]?

    public init (
        agentIds: [Swift.String]? = nil
    )
    {
        self.agentIds = agentIds
    }
}

struct StopDataCollectionByAgentIdsInputBody: Swift.Equatable {
    let agentIds: [Swift.String]?
}

extension StopDataCollectionByAgentIdsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .agentIds)
        var agentIdsDecoded0:[Swift.String]? = nil
        if let agentIdsContainer = agentIdsContainer {
            agentIdsDecoded0 = [Swift.String]()
            for string0 in agentIdsContainer {
                if let string0 = string0 {
                    agentIdsDecoded0?.append(string0)
                }
            }
        }
        agentIds = agentIdsDecoded0
    }
}

extension StopDataCollectionByAgentIdsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopDataCollectionByAgentIdsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopDataCollectionByAgentIdsOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDataCollectionByAgentIdsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopDataCollectionByAgentIdsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.agentsConfigurationStatus = output.agentsConfigurationStatus
        } else {
            self.agentsConfigurationStatus = nil
        }
    }
}

public struct StopDataCollectionByAgentIdsOutputResponse: Swift.Equatable {
    /// Information about the agents or connector that were instructed to stop collecting data. Information includes the agent/connector ID, a description of the operation performed, and whether the agent/connector configuration was updated.
    public var agentsConfigurationStatus: [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]?

    public init (
        agentsConfigurationStatus: [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]? = nil
    )
    {
        self.agentsConfigurationStatus = agentsConfigurationStatus
    }
}

struct StopDataCollectionByAgentIdsOutputResponseBody: Swift.Equatable {
    let agentsConfigurationStatus: [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]?
}

extension StopDataCollectionByAgentIdsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentsConfigurationStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentsConfigurationStatusContainer = try containerValues.decodeIfPresent([ApplicationDiscoveryClientTypes.AgentConfigurationStatus?].self, forKey: .agentsConfigurationStatus)
        var agentsConfigurationStatusDecoded0:[ApplicationDiscoveryClientTypes.AgentConfigurationStatus]? = nil
        if let agentsConfigurationStatusContainer = agentsConfigurationStatusContainer {
            agentsConfigurationStatusDecoded0 = [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]()
            for structure0 in agentsConfigurationStatusContainer {
                if let structure0 = structure0 {
                    agentsConfigurationStatusDecoded0?.append(structure0)
                }
            }
        }
        agentsConfigurationStatus = agentsConfigurationStatusDecoded0
    }
}

extension ApplicationDiscoveryClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ApplicationDiscoveryClientTypes {
    /// Metadata that help you categorize IT assets. Do not store sensitive information (like personal data) in tags.
    public struct Tag: Swift.Equatable {
        /// The type of tag on which to filter.
        /// This member is required.
        public var key: Swift.String?
        /// A value for a tag key on which to filter.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ApplicationDiscoveryClientTypes.TagFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ApplicationDiscoveryClientTypes {
    /// The tag filter. Valid names are: tagKey, tagValue, configurationId.
    public struct TagFilter: Swift.Equatable {
        /// A name of the tag filter.
        /// This member is required.
        public var name: Swift.String?
        /// Values for the tag filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationId = self.configurationId {
            try encodeContainer.encode(configurationId, forKey: .configurationId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// Configuration ID of the application to be updated.
    /// This member is required.
    public var configurationId: Swift.String?
    /// New description of the application to be updated.
    public var description: Swift.String?
    /// New name of the application to be updated.
    public var name: Swift.String?

    public init (
        configurationId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.description = description
        self.name = name
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let configurationId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId
        case description
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AuthorizationErrorException" : self = .authorizationErrorException(try AuthorizationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerInternalErrorException" : self = .serverInternalErrorException(try ServerInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateApplicationOutputError: Swift.Error, Swift.Equatable {
    case authorizationErrorException(AuthorizationErrorException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case invalidParameterException(InvalidParameterException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serverInternalErrorException(ServerInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateApplicationOutputResponse: Swift.Equatable {

    public init () { }
}
