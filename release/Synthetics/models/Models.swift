// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension Canary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactS3Location = "ArtifactS3Location"
        case code = "Code"
        case engineArn = "EngineArn"
        case executionRoleArn = "ExecutionRoleArn"
        case failureRetentionPeriodInDays = "FailureRetentionPeriodInDays"
        case id = "Id"
        case name = "Name"
        case runConfig = "RunConfig"
        case runtimeVersion = "RuntimeVersion"
        case schedule = "Schedule"
        case status = "Status"
        case successRetentionPeriodInDays = "SuccessRetentionPeriodInDays"
        case tags = "Tags"
        case timeline = "Timeline"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactS3Location = artifactS3Location {
            try encodeContainer.encode(artifactS3Location, forKey: .artifactS3Location)
        }
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let engineArn = engineArn {
            try encodeContainer.encode(engineArn, forKey: .engineArn)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let failureRetentionPeriodInDays = failureRetentionPeriodInDays {
            try encodeContainer.encode(failureRetentionPeriodInDays, forKey: .failureRetentionPeriodInDays)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runConfig = runConfig {
            try encodeContainer.encode(runConfig, forKey: .runConfig)
        }
        if let runtimeVersion = runtimeVersion {
            try encodeContainer.encode(runtimeVersion, forKey: .runtimeVersion)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let successRetentionPeriodInDays = successRetentionPeriodInDays {
            try encodeContainer.encode(successRetentionPeriodInDays, forKey: .successRetentionPeriodInDays)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let timeline = timeline {
            try encodeContainer.encode(timeline, forKey: .timeline)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(CanaryCodeOutput.self, forKey: .code)
        code = codeDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(CanaryScheduleOutput.self, forKey: .schedule)
        schedule = scheduleDecoded
        let runConfigDecoded = try containerValues.decodeIfPresent(CanaryRunConfigOutput.self, forKey: .runConfig)
        runConfig = runConfigDecoded
        let successRetentionPeriodInDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .successRetentionPeriodInDays)
        successRetentionPeriodInDays = successRetentionPeriodInDaysDecoded
        let failureRetentionPeriodInDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .failureRetentionPeriodInDays)
        failureRetentionPeriodInDays = failureRetentionPeriodInDaysDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CanaryStatus.self, forKey: .status)
        status = statusDecoded
        let timelineDecoded = try containerValues.decodeIfPresent(CanaryTimeline.self, forKey: .timeline)
        timeline = timelineDecoded
        let artifactS3LocationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .artifactS3Location)
        artifactS3Location = artifactS3LocationDecoded
        let engineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineArn)
        engineArn = engineArnDecoded
        let runtimeVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runtimeVersion)
        runtimeVersion = runtimeVersionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfigOutput.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Canary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Canary(artifactS3Location: \(String(describing: artifactS3Location)), code: \(String(describing: code)), engineArn: \(String(describing: engineArn)), executionRoleArn: \(String(describing: executionRoleArn)), failureRetentionPeriodInDays: \(String(describing: failureRetentionPeriodInDays)), id: \(String(describing: id)), name: \(String(describing: name)), runConfig: \(String(describing: runConfig)), runtimeVersion: \(String(describing: runtimeVersion)), schedule: \(String(describing: schedule)), status: \(String(describing: status)), successRetentionPeriodInDays: \(String(describing: successRetentionPeriodInDays)), tags: \(String(describing: tags)), timeline: \(String(describing: timeline)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>This structure contains all information about one canary in your account.</p>
public struct Canary: Equatable {
    /// <p>The location in Amazon S3 where Synthetics stores artifacts from the runs of this
    ///          canary. Artifacts include the log file, screenshots, and HAR files.</p>
    public let artifactS3Location: String?
    /// <p>This structure contains information about the canary's Lambda handler and
    ///       where its code is stored by CloudWatch Synthetics.</p>
    public let code: CanaryCodeOutput?
    /// <p>The ARN of the Lambda function that is used as your canary's engine. For more information
    ///          about Lambda ARN format, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-api-permissions-ref.html">Resources and Conditions for Lambda Actions</a>.</p>
    public let engineArn: String?
    /// <p>The ARN of the IAM role used to run the canary. This role must include <code>lambda.amazonaws.com</code> as a principal in the trust
    ///          policy.</p>
    public let executionRoleArn: String?
    /// <p>The number of days to retain data about failed runs of this canary.</p>
    public let failureRetentionPeriodInDays: Int?
    /// <p>The unique ID of this canary.</p>
    public let id: String?
    /// <p>The name of the canary.</p>
    public let name: String?
    /// <p>A structure that contains information about a canary run.</p>
    public let runConfig: CanaryRunConfigOutput?
    /// <p>Specifies the runtime version to use for the canary. For more information about
    ///          runtime versions, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_Library.html">
    ///             Canary Runtime Versions</a>.</p>
    public let runtimeVersion: String?
    /// <p>A structure that contains information about how often the canary is to run, and when
    ///          these runs are to stop.</p>
    public let schedule: CanaryScheduleOutput?
    /// <p>A structure that contains information about the canary's status.</p>
    public let status: CanaryStatus?
    /// <p>The number of days to retain data about successful runs of this canary.</p>
    public let successRetentionPeriodInDays: Int?
    /// <p>The list of key-value pairs that are associated with the canary.</p>
    public let tags: [String:String]?
    /// <p>A structure that contains information about when the canary was created, modified, and
    ///          most recently run.</p>
    public let timeline: CanaryTimeline?
    /// <p>If this canary is to test an endpoint in a VPC, this structure contains
    ///          information about the subnets and security groups of the VPC endpoint.
    ///          For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_VPC.html">
    ///             Running a Canary in a VPC</a>.</p>
    public let vpcConfig: VpcConfigOutput?

    public init (
        artifactS3Location: String? = nil,
        code: CanaryCodeOutput? = nil,
        engineArn: String? = nil,
        executionRoleArn: String? = nil,
        failureRetentionPeriodInDays: Int? = nil,
        id: String? = nil,
        name: String? = nil,
        runConfig: CanaryRunConfigOutput? = nil,
        runtimeVersion: String? = nil,
        schedule: CanaryScheduleOutput? = nil,
        status: CanaryStatus? = nil,
        successRetentionPeriodInDays: Int? = nil,
        tags: [String:String]? = nil,
        timeline: CanaryTimeline? = nil,
        vpcConfig: VpcConfigOutput? = nil
    )
    {
        self.artifactS3Location = artifactS3Location
        self.code = code
        self.engineArn = engineArn
        self.executionRoleArn = executionRoleArn
        self.failureRetentionPeriodInDays = failureRetentionPeriodInDays
        self.id = id
        self.name = name
        self.runConfig = runConfig
        self.runtimeVersion = runtimeVersion
        self.schedule = schedule
        self.status = status
        self.successRetentionPeriodInDays = successRetentionPeriodInDays
        self.tags = tags
        self.timeline = timeline
        self.vpcConfig = vpcConfig
    }
}

extension CanaryCodeInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case handler = "Handler"
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3Version = "S3Version"
        case zipFile = "ZipFile"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let handler = handler {
            try encodeContainer.encode(handler, forKey: .handler)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
        if let s3Version = s3Version {
            try encodeContainer.encode(s3Version, forKey: .s3Version)
        }
        if let zipFile = zipFile {
            try encodeContainer.encode(zipFile.base64EncodedString(), forKey: .zipFile)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3VersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Version)
        s3Version = s3VersionDecoded
        let zipFileDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .zipFile)
        zipFile = zipFileDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .handler)
        handler = handlerDecoded
    }
}

extension CanaryCodeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CanaryCodeInput(handler: \(String(describing: handler)), s3Bucket: \(String(describing: s3Bucket)), s3Key: \(String(describing: s3Key)), s3Version: \(String(describing: s3Version)), zipFile: \(String(describing: zipFile)))"}
}

/// <p>Use this structure to input your script code for the canary. This structure contains the
///          Lambda handler with the location where the canary should start running the script. If the
///          script is stored in an S3 bucket, the bucket name, key, and version are also included. If
///          the script was passed into the canary directly, the script code is contained in the value
///          of <code>Zipfile</code>. </p>
public struct CanaryCodeInput: Equatable {
    /// <p>The entry point to use for the source code when running the canary. This value must end
    ///          with the string <code>.handler</code>.</p>
    public let handler: String?
    /// <p>If your canary script is located in S3, specify the full bucket name here. The bucket
    ///          must already exist. Specify the full bucket name, including <code>s3://</code> as the
    ///          start of the bucket name.</p>
    public let s3Bucket: String?
    /// <p>The S3 key of your script. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingObjects.html">Working with Amazon S3 Objects</a>.</p>
    public let s3Key: String?
    /// <p>The S3 version ID of your script.</p>
    public let s3Version: String?
    /// <p>If you input your canary script directly into the canary instead of referring to an S3
    ///          location, the value of this parameter is the .zip file that contains the script. It can be
    ///          up to 5 MB.</p>
    public let zipFile: Data?

    public init (
        handler: String? = nil,
        s3Bucket: String? = nil,
        s3Key: String? = nil,
        s3Version: String? = nil,
        zipFile: Data? = nil
    )
    {
        self.handler = handler
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
        self.s3Version = s3Version
        self.zipFile = zipFile
    }
}

extension CanaryCodeOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case handler = "Handler"
        case sourceLocationArn = "SourceLocationArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let handler = handler {
            try encodeContainer.encode(handler, forKey: .handler)
        }
        if let sourceLocationArn = sourceLocationArn {
            try encodeContainer.encode(sourceLocationArn, forKey: .sourceLocationArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceLocationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceLocationArn)
        sourceLocationArn = sourceLocationArnDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .handler)
        handler = handlerDecoded
    }
}

extension CanaryCodeOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CanaryCodeOutput(handler: \(String(describing: handler)), sourceLocationArn: \(String(describing: sourceLocationArn)))"}
}

/// <p>This structure contains information about the canary's Lambda handler and
///       where its code is stored by CloudWatch Synthetics.</p>
public struct CanaryCodeOutput: Equatable {
    /// <p>The entry point to use for the source code when running the canary.</p>
    public let handler: String?
    /// <p>The ARN of the Lambda layer where Synthetics stores the canary script code.</p>
    public let sourceLocationArn: String?

    public init (
        handler: String? = nil,
        sourceLocationArn: String? = nil
    )
    {
        self.handler = handler
        self.sourceLocationArn = sourceLocationArn
    }
}

extension CanaryLastRun: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case canaryName = "CanaryName"
        case lastRun = "LastRun"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let canaryName = canaryName {
            try encodeContainer.encode(canaryName, forKey: .canaryName)
        }
        if let lastRun = lastRun {
            try encodeContainer.encode(lastRun, forKey: .lastRun)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canaryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .canaryName)
        canaryName = canaryNameDecoded
        let lastRunDecoded = try containerValues.decodeIfPresent(CanaryRun.self, forKey: .lastRun)
        lastRun = lastRunDecoded
    }
}

extension CanaryLastRun: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CanaryLastRun(canaryName: \(String(describing: canaryName)), lastRun: \(String(describing: lastRun)))"}
}

/// <p>This structure contains information about the most recent run of a single canary.</p>
public struct CanaryLastRun: Equatable {
    /// <p>The name of the canary.</p>
    public let canaryName: String?
    /// <p>The results from this canary's most recent run.</p>
    public let lastRun: CanaryRun?

    public init (
        canaryName: String? = nil,
        lastRun: CanaryRun? = nil
    )
    {
        self.canaryName = canaryName
        self.lastRun = lastRun
    }
}

extension CanaryRun: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactS3Location = "ArtifactS3Location"
        case id = "Id"
        case name = "Name"
        case status = "Status"
        case timeline = "Timeline"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactS3Location = artifactS3Location {
            try encodeContainer.encode(artifactS3Location, forKey: .artifactS3Location)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let timeline = timeline {
            try encodeContainer.encode(timeline, forKey: .timeline)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CanaryRunStatus.self, forKey: .status)
        status = statusDecoded
        let timelineDecoded = try containerValues.decodeIfPresent(CanaryRunTimeline.self, forKey: .timeline)
        timeline = timelineDecoded
        let artifactS3LocationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .artifactS3Location)
        artifactS3Location = artifactS3LocationDecoded
    }
}

extension CanaryRun: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CanaryRun(artifactS3Location: \(String(describing: artifactS3Location)), id: \(String(describing: id)), name: \(String(describing: name)), status: \(String(describing: status)), timeline: \(String(describing: timeline)))"}
}

/// <p>This structure contains the details about one run of one canary.</p>
public struct CanaryRun: Equatable {
    /// <p>The location where the canary stored artifacts from the run. Artifacts include
    ///          the log file, screenshots, and HAR files.</p>
    public let artifactS3Location: String?
    /// <p>A unique ID that identifies this canary run.</p>
    public let id: String?
    /// <p>The name of the canary.</p>
    public let name: String?
    /// <p>The status of this run.</p>
    public let status: CanaryRunStatus?
    /// <p>A structure that contains the start and end times of this run.</p>
    public let timeline: CanaryRunTimeline?

    public init (
        artifactS3Location: String? = nil,
        id: String? = nil,
        name: String? = nil,
        status: CanaryRunStatus? = nil,
        timeline: CanaryRunTimeline? = nil
    )
    {
        self.artifactS3Location = artifactS3Location
        self.id = id
        self.name = name
        self.status = status
        self.timeline = timeline
    }
}

extension CanaryRunConfigInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activeTracing = "ActiveTracing"
        case environmentVariables = "EnvironmentVariables"
        case memoryInMB = "MemoryInMB"
        case timeoutInSeconds = "TimeoutInSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeTracing = activeTracing {
            try encodeContainer.encode(activeTracing, forKey: .activeTracing)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .environmentVariables)
            for (dictKey0, environmentvariablesmap0) in environmentVariables {
                try environmentVariablesContainer.encode(environmentvariablesmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let memoryInMB = memoryInMB {
            try encodeContainer.encode(memoryInMB, forKey: .memoryInMB)
        }
        if let timeoutInSeconds = timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let memoryInMBDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .memoryInMB)
        memoryInMB = memoryInMBDecoded
        let activeTracingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .activeTracing)
        activeTracing = activeTracingDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0: [String:String]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [String:String]()
            for (key0, environmentvariablevalue0) in environmentVariablesContainer {
                if let environmentvariablevalue0 = environmentvariablevalue0 {
                    environmentVariablesDecoded0?[key0] = environmentvariablevalue0
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
    }
}

extension CanaryRunConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CanaryRunConfigInput(activeTracing: \(String(describing: activeTracing)), environmentVariables: \(String(describing: environmentVariables)), memoryInMB: \(String(describing: memoryInMB)), timeoutInSeconds: \(String(describing: timeoutInSeconds)))"}
}

/// <p>A structure that contains input information for a canary run.</p>
public struct CanaryRunConfigInput: Equatable {
    /// <p>Specifies whether this canary is to use active AWS X-Ray tracing when it runs. Active tracing
    ///          enables
    ///       this canary run to be displayed in the ServiceLens and X-Ray service maps even if the canary does
    ///       not hit an endpoint that has X-ray tracing enabled. Using X-Ray tracing incurs charges.
    ///       For more information, see  <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_tracing.html">
    ///          Canaries and X-Ray tracing</a>.</p>
    ///          <p>You can enable active tracing only for canaries that use version <code>syn-nodejs-2.0</code>
    ///       or later for their canary runtime.</p>
    public let activeTracing: Bool?
    /// <p>Specifies the keys and values to use for any environment variables
    ///       used in the canary script. Use the following format:</p>
    ///          <p>{ "key1" : "value1", "key2" : "value2", ...}</p>
    ///          <p>Keys must start with a letter and be at least two characters. The total size
    ///          of your environment variables cannot exceed 4 KB. You can't specify any Lambda
    ///          reserved environment variables as the keys for your environment variables. For
    ///          more information about reserved keys, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-runtime">
    ///             Runtime environment variables</a>.</p>
    public let environmentVariables: [String:String]?
    /// <p>The maximum amount of memory available to the canary while it is running, in MB. This value must be a multiple of 64.</p>
    public let memoryInMB: Int?
    /// <p>How long the canary is allowed to run before it must stop. You can't set this time to be longer
    ///          than the frequency of the runs of this canary.</p>
    ///          <p>If you omit this field, the
    ///          frequency of the canary is used as this value, up to a maximum of 14 minutes.</p>
    public let timeoutInSeconds: Int?

    public init (
        activeTracing: Bool? = nil,
        environmentVariables: [String:String]? = nil,
        memoryInMB: Int? = nil,
        timeoutInSeconds: Int? = nil
    )
    {
        self.activeTracing = activeTracing
        self.environmentVariables = environmentVariables
        self.memoryInMB = memoryInMB
        self.timeoutInSeconds = timeoutInSeconds
    }
}

extension CanaryRunConfigOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activeTracing = "ActiveTracing"
        case memoryInMB = "MemoryInMB"
        case timeoutInSeconds = "TimeoutInSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeTracing = activeTracing {
            try encodeContainer.encode(activeTracing, forKey: .activeTracing)
        }
        if let memoryInMB = memoryInMB {
            try encodeContainer.encode(memoryInMB, forKey: .memoryInMB)
        }
        if let timeoutInSeconds = timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
        let memoryInMBDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .memoryInMB)
        memoryInMB = memoryInMBDecoded
        let activeTracingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .activeTracing)
        activeTracing = activeTracingDecoded
    }
}

extension CanaryRunConfigOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CanaryRunConfigOutput(activeTracing: \(String(describing: activeTracing)), memoryInMB: \(String(describing: memoryInMB)), timeoutInSeconds: \(String(describing: timeoutInSeconds)))"}
}

/// <p>A structure that contains information about a canary run.</p>
public struct CanaryRunConfigOutput: Equatable {
    /// <p>Displays whether this canary run used active AWS X-Ray tracing. </p>
    public let activeTracing: Bool?
    /// <p>The maximum amount of memory available to the canary while it is running, in MB. This value
    ///          must be a multiple of 64.</p>
    public let memoryInMB: Int?
    /// <p>How long the canary is allowed to run before it must stop.</p>
    public let timeoutInSeconds: Int?

    public init (
        activeTracing: Bool? = nil,
        memoryInMB: Int? = nil,
        timeoutInSeconds: Int? = nil
    )
    {
        self.activeTracing = activeTracing
        self.memoryInMB = memoryInMB
        self.timeoutInSeconds = timeoutInSeconds
    }
}

public enum CanaryRunState {
    case failed
    case passed
    case running
    case sdkUnknown(String)
}

extension CanaryRunState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CanaryRunState] {
        return [
            .failed,
            .passed,
            .running,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .passed: return "PASSED"
        case .running: return "RUNNING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CanaryRunState(rawValue: rawValue) ?? CanaryRunState.sdkUnknown(rawValue)
    }
}

public enum CanaryRunStateReasonCode {
    case canaryFailure
    case executionFailure
    case sdkUnknown(String)
}

extension CanaryRunStateReasonCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CanaryRunStateReasonCode] {
        return [
            .canaryFailure,
            .executionFailure,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canaryFailure: return "CANARY_FAILURE"
        case .executionFailure: return "EXECUTION_FAILURE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CanaryRunStateReasonCode(rawValue: rawValue) ?? CanaryRunStateReasonCode.sdkUnknown(rawValue)
    }
}

extension CanaryRunStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
        if let stateReasonCode = stateReasonCode {
            try encodeContainer.encode(stateReasonCode.rawValue, forKey: .stateReasonCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(CanaryRunState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(CanaryRunStateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
    }
}

extension CanaryRunStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CanaryRunStatus(state: \(String(describing: state)), stateReason: \(String(describing: stateReason)), stateReasonCode: \(String(describing: stateReasonCode)))"}
}

/// <p>This structure contains the status information about a canary run.</p>
public struct CanaryRunStatus: Equatable {
    /// <p>The current state of the run.</p>
    public let state: CanaryRunState?
    /// <p>If run of the canary failed, this field contains the reason for the error.</p>
    public let stateReason: String?
    /// <p>If this value is <code>CANARY_FAILURE</code>, an exception occurred in the
    ///          canary code. If this value is <code>EXECUTION_FAILURE</code>, an exception occurred in
    ///          CloudWatch Synthetics.</p>
    public let stateReasonCode: CanaryRunStateReasonCode?

    public init (
        state: CanaryRunState? = nil,
        stateReason: String? = nil,
        stateReasonCode: CanaryRunStateReasonCode? = nil
    )
    {
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
    }
}

extension CanaryRunTimeline: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case completed = "Completed"
        case started = "Started"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completed = completed {
            try encodeContainer.encode(completed.timeIntervalSince1970, forKey: .completed)
        }
        if let started = started {
            try encodeContainer.encode(started.timeIntervalSince1970, forKey: .started)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .started)
        started = startedDecoded
        let completedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completed)
        completed = completedDecoded
    }
}

extension CanaryRunTimeline: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CanaryRunTimeline(completed: \(String(describing: completed)), started: \(String(describing: started)))"}
}

/// <p>This structure contains the start and end times of a single canary run.</p>
public struct CanaryRunTimeline: Equatable {
    /// <p>The end time of the run.</p>
    public let completed: Date?
    /// <p>The start time of the run.</p>
    public let started: Date?

    public init (
        completed: Date? = nil,
        started: Date? = nil
    )
    {
        self.completed = completed
        self.started = started
    }
}

extension CanaryScheduleInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case durationInSeconds = "DurationInSeconds"
        case expression = "Expression"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInSeconds = durationInSeconds {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
    }
}

extension CanaryScheduleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CanaryScheduleInput(durationInSeconds: \(String(describing: durationInSeconds)), expression: \(String(describing: expression)))"}
}

/// <p>This structure specifies how often a canary is to make runs and the date and time
///          when it should stop making runs.</p>
public struct CanaryScheduleInput: Equatable {
    /// <p>How long, in seconds, for the canary to continue making regular runs according to
    ///          the schedule in the <code>Expression</code> value. If you specify 0, the canary continues
    ///          making runs until you stop it. If you omit this field, the default of 0 is used.</p>
    public let durationInSeconds: Int?
    /// <p>A rate expression that defines how often the canary is to run. The syntax is
    ///                <code>rate(<i>number unit</i>)</code>. <i>unit</i>
    ///          can be <code>minute</code>, <code>minutes</code>, or <code>hour</code>. </p>
    ///          <p>For example, <code>rate(1 minute)</code> runs the canary once a minute, <code>rate(10 minutes)</code> runs it once every
    ///       10 minutes, and <code>rate(1 hour)</code> runs it once every hour. You can
    ///          specify a frequency between <code>rate(1 minute)</code> and <code>rate(1 hour)</code>.</p>
    ///          <p>Specifying <code>rate(0 minute)</code> or <code>rate(0 hour)</code> is a special value
    ///          that causes the
    ///          canary to run only once when it is started.</p>
    public let expression: String?

    public init (
        durationInSeconds: Int? = nil,
        expression: String? = nil
    )
    {
        self.durationInSeconds = durationInSeconds
        self.expression = expression
    }
}

extension CanaryScheduleOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case durationInSeconds = "DurationInSeconds"
        case expression = "Expression"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInSeconds = durationInSeconds {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
    }
}

extension CanaryScheduleOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CanaryScheduleOutput(durationInSeconds: \(String(describing: durationInSeconds)), expression: \(String(describing: expression)))"}
}

/// <p>How long, in seconds, for the canary to continue making regular runs according to the schedule in the
///          <code>Expression</code> value.</p>
public struct CanaryScheduleOutput: Equatable {
    /// <p>How long, in seconds, for the canary to continue making regular runs after it
    ///          was created. The runs are performed according to the schedule in the
    ///          <code>Expression</code> value.</p>
    public let durationInSeconds: Int?
    /// <p>A rate expression that defines how often the canary is to run. The syntax is
    ///          <code>rate(<i>number unit</i>)</code>. <i>unit</i>
    ///          can be <code>minute</code>, <code>minutes</code>, or <code>hour</code>. </p>
    ///          <p>For example, <code>rate(1 minute)</code> runs the canary once a minute, <code>rate(10 minutes)</code> runs it once every
    ///          10 minutes, and <code>rate(1 hour)</code> runs it once every hour.</p>
    ///          <p>Specifying <code>rate(0 minute)</code> or <code>rate(0 hour)</code> is a special value
    ///          that causes the
    ///          canary to run only once when it is started.</p>
    public let expression: String?

    public init (
        durationInSeconds: Int? = nil,
        expression: String? = nil
    )
    {
        self.durationInSeconds = durationInSeconds
        self.expression = expression
    }
}

public enum CanaryState {
    case creating
    case deleting
    case error
    case ready
    case running
    case starting
    case stopped
    case stopping
    case updating
    case sdkUnknown(String)
}

extension CanaryState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CanaryState] {
        return [
            .creating,
            .deleting,
            .error,
            .ready,
            .running,
            .starting,
            .stopped,
            .stopping,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .error: return "ERROR"
        case .ready: return "READY"
        case .running: return "RUNNING"
        case .starting: return "STARTING"
        case .stopped: return "STOPPED"
        case .stopping: return "STOPPING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CanaryState(rawValue: rawValue) ?? CanaryState.sdkUnknown(rawValue)
    }
}

public enum CanaryStateReasonCode {
    case invalidPermissions
    case sdkUnknown(String)
}

extension CanaryStateReasonCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CanaryStateReasonCode] {
        return [
            .invalidPermissions,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .invalidPermissions: return "INVALID_PERMISSIONS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CanaryStateReasonCode(rawValue: rawValue) ?? CanaryStateReasonCode.sdkUnknown(rawValue)
    }
}

extension CanaryStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
        if let stateReasonCode = stateReasonCode {
            try encodeContainer.encode(stateReasonCode.rawValue, forKey: .stateReasonCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(CanaryState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(CanaryStateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
    }
}

extension CanaryStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CanaryStatus(state: \(String(describing: state)), stateReason: \(String(describing: stateReason)), stateReasonCode: \(String(describing: stateReasonCode)))"}
}

/// <p>A structure that contains the current state of the canary.</p>
public struct CanaryStatus: Equatable {
    /// <p>The current state of the canary.</p>
    public let state: CanaryState?
    /// <p>If the canary has insufficient permissions to run, this field provides more details.</p>
    public let stateReason: String?
    /// <p>If the canary cannot run or has failed, this field displays the reason.</p>
    public let stateReasonCode: CanaryStateReasonCode?

    public init (
        state: CanaryState? = nil,
        stateReason: String? = nil,
        stateReasonCode: CanaryStateReasonCode? = nil
    )
    {
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
    }
}

extension CanaryTimeline: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case created = "Created"
        case lastModified = "LastModified"
        case lastStarted = "LastStarted"
        case lastStopped = "LastStopped"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified.timeIntervalSince1970, forKey: .lastModified)
        }
        if let lastStarted = lastStarted {
            try encodeContainer.encode(lastStarted.timeIntervalSince1970, forKey: .lastStarted)
        }
        if let lastStopped = lastStopped {
            try encodeContainer.encode(lastStopped.timeIntervalSince1970, forKey: .lastStopped)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastStartedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastStarted)
        lastStarted = lastStartedDecoded
        let lastStoppedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastStopped)
        lastStopped = lastStoppedDecoded
    }
}

extension CanaryTimeline: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CanaryTimeline(created: \(String(describing: created)), lastModified: \(String(describing: lastModified)), lastStarted: \(String(describing: lastStarted)), lastStopped: \(String(describing: lastStopped)))"}
}

/// <p>This structure contains information about when the canary was created and modified.</p>
public struct CanaryTimeline: Equatable {
    /// <p>The date and time the canary was created.</p>
    public let created: Date?
    /// <p>The date and time the canary was most recently modified.</p>
    public let lastModified: Date?
    /// <p>The date and time that the canary's most recent run started.</p>
    public let lastStarted: Date?
    /// <p>The date and time that the canary's most recent run ended.</p>
    public let lastStopped: Date?

    public init (
        created: Date? = nil,
        lastModified: Date? = nil,
        lastStarted: Date? = nil,
        lastStopped: Date? = nil
    )
    {
        self.created = created
        self.lastModified = lastModified
        self.lastStarted = lastStarted
        self.lastStopped = lastStopped
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A conflicting operation is already in progress.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateCanaryInputBodyMiddleware: Middleware {
    public let id: String = "CreateCanaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCanaryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCanaryInput>
    public typealias MOutput = OperationOutput<CreateCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCanaryOutputError>
}

extension CreateCanaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCanaryInput(artifactS3Location: \(String(describing: artifactS3Location)), code: \(String(describing: code)), executionRoleArn: \(String(describing: executionRoleArn)), failureRetentionPeriodInDays: \(String(describing: failureRetentionPeriodInDays)), name: \(String(describing: name)), runConfig: \(String(describing: runConfig)), runtimeVersion: \(String(describing: runtimeVersion)), schedule: \(String(describing: schedule)), successRetentionPeriodInDays: \(String(describing: successRetentionPeriodInDays)), tags: \(String(describing: tags)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension CreateCanaryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactS3Location = "ArtifactS3Location"
        case code = "Code"
        case executionRoleArn = "ExecutionRoleArn"
        case failureRetentionPeriodInDays = "FailureRetentionPeriodInDays"
        case name = "Name"
        case runConfig = "RunConfig"
        case runtimeVersion = "RuntimeVersion"
        case schedule = "Schedule"
        case successRetentionPeriodInDays = "SuccessRetentionPeriodInDays"
        case tags = "Tags"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactS3Location = artifactS3Location {
            try encodeContainer.encode(artifactS3Location, forKey: .artifactS3Location)
        }
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let failureRetentionPeriodInDays = failureRetentionPeriodInDays {
            try encodeContainer.encode(failureRetentionPeriodInDays, forKey: .failureRetentionPeriodInDays)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runConfig = runConfig {
            try encodeContainer.encode(runConfig, forKey: .runConfig)
        }
        if let runtimeVersion = runtimeVersion {
            try encodeContainer.encode(runtimeVersion, forKey: .runtimeVersion)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let successRetentionPeriodInDays = successRetentionPeriodInDays {
            try encodeContainer.encode(successRetentionPeriodInDays, forKey: .successRetentionPeriodInDays)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct CreateCanaryInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCanaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCanaryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCanaryInput>
    public typealias MOutput = OperationOutput<CreateCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCanaryOutputError>
}

public struct CreateCanaryInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCanaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCanaryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCanaryInput>
    public typealias MOutput = OperationOutput<CreateCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCanaryOutputError>
}

public struct CreateCanaryInput: Equatable {
    /// <p>The location in Amazon S3 where Synthetics stores artifacts from the test runs of this
    ///          canary. Artifacts include the log file, screenshots, and HAR files.</p>
    public let artifactS3Location: String?
    /// <p>A structure that includes the entry point from which the canary should start
    ///          running your script. If the script is stored in
    ///          an S3 bucket, the bucket name, key, and version are also included.
    ///       </p>
    public let code: CanaryCodeInput?
    /// <p>The ARN of the IAM role to be used to run the canary. This role must already exist,
    ///          and must include <code>lambda.amazonaws.com</code> as a principal in the trust
    ///          policy. The role must also have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>s3:PutObject</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>s3:GetBucketLocation</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>s3:ListAllMyBuckets</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>cloudwatch:PutMetricData</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>logs:CreateLogGroup</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>logs:CreateLogStream</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>logs:PutLogEvents</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let executionRoleArn: String?
    /// <p>The number of days to retain data about failed runs of this canary. If you omit
    ///          this field, the default of 31 days is used. The valid range is 1 to 455 days.</p>
    public let failureRetentionPeriodInDays: Int?
    /// <p>The name for this canary. Be sure to give it a descriptive name
    ///          that distinguishes it from other canaries in your account.</p>
    ///          <p>Do not include secrets or proprietary information in your canary names. The canary name
    ///          makes up part of the canary ARN, and the ARN is included in outbound calls over the
    ///          internet. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/servicelens_canaries_security.html">Security
    ///             Considerations for Synthetics Canaries</a>.</p>
    public let name: String?
    /// <p>A structure that contains the configuration for individual canary runs,
    ///          such as timeout value.</p>
    public let runConfig: CanaryRunConfigInput?
    /// <p>Specifies the runtime version to use for the canary. For a list of valid
    ///          runtime versions and more information about
    ///          runtime versions, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_Library.html">
    ///             Canary Runtime Versions</a>.</p>
    public let runtimeVersion: String?
    /// <p>A structure that contains information about how often the canary is to run and when
    ///          these test runs are to stop.</p>
    public let schedule: CanaryScheduleInput?
    /// <p>The number of days to retain data about successful runs of this canary. If you omit
    ///          this field, the default of 31 days is used. The valid range is 1 to 455 days.</p>
    public let successRetentionPeriodInDays: Int?
    /// <p>A list of key-value pairs to associate with the canary.
    ///          You can associate as many as 50 tags with a canary.</p>
    ///          <p>Tags can help you organize and categorize your
    ///          resources. You can also use them to scope user permissions, by
    ///          granting a user permission to access or change only the resources that have
    ///          certain tag values.</p>
    public let tags: [String:String]?
    /// <p>If this canary is to test an endpoint in a VPC, this structure contains
    ///       information about the subnet and security groups of the VPC endpoint.
    ///       For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_VPC.html">
    ///          Running a Canary in a VPC</a>.</p>
    public let vpcConfig: VpcConfigInput?

    public init (
        artifactS3Location: String? = nil,
        code: CanaryCodeInput? = nil,
        executionRoleArn: String? = nil,
        failureRetentionPeriodInDays: Int? = nil,
        name: String? = nil,
        runConfig: CanaryRunConfigInput? = nil,
        runtimeVersion: String? = nil,
        schedule: CanaryScheduleInput? = nil,
        successRetentionPeriodInDays: Int? = nil,
        tags: [String:String]? = nil,
        vpcConfig: VpcConfigInput? = nil
    )
    {
        self.artifactS3Location = artifactS3Location
        self.code = code
        self.executionRoleArn = executionRoleArn
        self.failureRetentionPeriodInDays = failureRetentionPeriodInDays
        self.name = name
        self.runConfig = runConfig
        self.runtimeVersion = runtimeVersion
        self.schedule = schedule
        self.successRetentionPeriodInDays = successRetentionPeriodInDays
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct CreateCanaryInputBody: Equatable {
    public let name: String?
    public let code: CanaryCodeInput?
    public let artifactS3Location: String?
    public let executionRoleArn: String?
    public let schedule: CanaryScheduleInput?
    public let runConfig: CanaryRunConfigInput?
    public let successRetentionPeriodInDays: Int?
    public let failureRetentionPeriodInDays: Int?
    public let runtimeVersion: String?
    public let vpcConfig: VpcConfigInput?
    public let tags: [String:String]?
}

extension CreateCanaryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case artifactS3Location = "ArtifactS3Location"
        case code = "Code"
        case executionRoleArn = "ExecutionRoleArn"
        case failureRetentionPeriodInDays = "FailureRetentionPeriodInDays"
        case name = "Name"
        case runConfig = "RunConfig"
        case runtimeVersion = "RuntimeVersion"
        case schedule = "Schedule"
        case successRetentionPeriodInDays = "SuccessRetentionPeriodInDays"
        case tags = "Tags"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(CanaryCodeInput.self, forKey: .code)
        code = codeDecoded
        let artifactS3LocationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .artifactS3Location)
        artifactS3Location = artifactS3LocationDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(CanaryScheduleInput.self, forKey: .schedule)
        schedule = scheduleDecoded
        let runConfigDecoded = try containerValues.decodeIfPresent(CanaryRunConfigInput.self, forKey: .runConfig)
        runConfig = runConfigDecoded
        let successRetentionPeriodInDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .successRetentionPeriodInDays)
        successRetentionPeriodInDays = successRetentionPeriodInDaysDecoded
        let failureRetentionPeriodInDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .failureRetentionPeriodInDays)
        failureRetentionPeriodInDays = failureRetentionPeriodInDaysDecoded
        let runtimeVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runtimeVersion)
        runtimeVersion = runtimeVersionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfigInput.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCanaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCanaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCanaryOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCanaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCanaryOutputResponse(canary: \(String(describing: canary)))"}
}

extension CreateCanaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCanaryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.canary = output.canary
        } else {
            self.canary = nil
        }
    }
}

public struct CreateCanaryOutputResponse: Equatable {
    /// <p>The full details about the canary you have created.</p>
    public let canary: Canary?

    public init (
        canary: Canary? = nil
    )
    {
        self.canary = canary
    }
}

struct CreateCanaryOutputResponseBody: Equatable {
    public let canary: Canary?
}

extension CreateCanaryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case canary = "Canary"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canaryDecoded = try containerValues.decodeIfPresent(Canary.self, forKey: .canary)
        canary = canaryDecoded
    }
}

extension DeleteCanaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCanaryInput(name: \(String(describing: name)))"}
}

extension DeleteCanaryInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteCanaryInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCanaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCanaryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCanaryInput>
    public typealias MOutput = OperationOutput<DeleteCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCanaryOutputError>
}

public struct DeleteCanaryInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCanaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCanaryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCanaryInput>
    public typealias MOutput = OperationOutput<DeleteCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCanaryOutputError>
}

public struct DeleteCanaryInput: Equatable {
    /// <p>The name of the canary that you want to delete. To find the names of your canaries, use <a href="https://docs.aws.amazon.com/AmazonSynthetics/latest/APIReference/API_DescribeCanaries.html">DescribeCanaries</a>.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteCanaryInputBody: Equatable {
}

extension DeleteCanaryInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCanaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCanaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCanaryOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCanaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCanaryOutputResponse()"}
}

extension DeleteCanaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCanaryOutputResponse: Equatable {

    public init() {}
}

struct DeleteCanaryOutputResponseBody: Equatable {
}

extension DeleteCanaryOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeCanariesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCanariesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCanariesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCanariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCanariesInput>
    public typealias MOutput = OperationOutput<DescribeCanariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCanariesOutputError>
}

extension DescribeCanariesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCanariesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeCanariesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeCanariesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCanariesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCanariesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCanariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCanariesInput>
    public typealias MOutput = OperationOutput<DescribeCanariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCanariesOutputError>
}

public struct DescribeCanariesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCanariesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCanariesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCanariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCanariesInput>
    public typealias MOutput = OperationOutput<DescribeCanariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCanariesOutputError>
}

public struct DescribeCanariesInput: Equatable {
    /// <p>Specify this parameter to limit how many canaries are returned each time you use
    ///       the <code>DescribeCanaries</code> operation. If you omit this parameter, the default of 100 is used.</p>
    public let maxResults: Int?
    /// <p>A token that indicates that there is more data
    ///          available. You can use this token in a subsequent operation to retrieve the next
    ///          set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeCanariesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeCanariesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

public struct DescribeCanariesLastRunInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCanariesLastRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCanariesLastRunInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCanariesLastRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCanariesLastRunInput>
    public typealias MOutput = OperationOutput<DescribeCanariesLastRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCanariesLastRunOutputError>
}

extension DescribeCanariesLastRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCanariesLastRunInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeCanariesLastRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeCanariesLastRunInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCanariesLastRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCanariesLastRunInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCanariesLastRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCanariesLastRunInput>
    public typealias MOutput = OperationOutput<DescribeCanariesLastRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCanariesLastRunOutputError>
}

public struct DescribeCanariesLastRunInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCanariesLastRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCanariesLastRunInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCanariesLastRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCanariesLastRunInput>
    public typealias MOutput = OperationOutput<DescribeCanariesLastRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCanariesLastRunOutputError>
}

public struct DescribeCanariesLastRunInput: Equatable {
    /// <p>Specify this parameter to limit how many runs are returned each time you use
    ///          the <code>DescribeLastRun</code> operation. If you omit this parameter, the default of 100 is used.</p>
    public let maxResults: Int?
    /// <p>A token that indicates that there is more data
    ///          available. You can use this token in a subsequent <code>DescribeCanaries</code> operation to retrieve the next
    ///          set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeCanariesLastRunInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeCanariesLastRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeCanariesLastRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCanariesLastRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCanariesLastRunOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCanariesLastRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCanariesLastRunOutputResponse(canariesLastRun: \(String(describing: canariesLastRun)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeCanariesLastRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCanariesLastRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.canariesLastRun = output.canariesLastRun
            self.nextToken = output.nextToken
        } else {
            self.canariesLastRun = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeCanariesLastRunOutputResponse: Equatable {
    /// <p>An array that contains the information from the most recent run of each
    ///          canary.</p>
    public let canariesLastRun: [CanaryLastRun]?
    /// <p>A token that indicates that there is more data
    ///          available. You can use this token in a subsequent <code>DescribeCanariesLastRun</code> operation to retrieve the next
    ///          set of results.</p>
    public let nextToken: String?

    public init (
        canariesLastRun: [CanaryLastRun]? = nil,
        nextToken: String? = nil
    )
    {
        self.canariesLastRun = canariesLastRun
        self.nextToken = nextToken
    }
}

struct DescribeCanariesLastRunOutputResponseBody: Equatable {
    public let canariesLastRun: [CanaryLastRun]?
    public let nextToken: String?
}

extension DescribeCanariesLastRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case canariesLastRun = "CanariesLastRun"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canariesLastRunContainer = try containerValues.decodeIfPresent([CanaryLastRun?].self, forKey: .canariesLastRun)
        var canariesLastRunDecoded0:[CanaryLastRun]? = nil
        if let canariesLastRunContainer = canariesLastRunContainer {
            canariesLastRunDecoded0 = [CanaryLastRun]()
            for structure0 in canariesLastRunContainer {
                if let structure0 = structure0 {
                    canariesLastRunDecoded0?.append(structure0)
                }
            }
        }
        canariesLastRun = canariesLastRunDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeCanariesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCanariesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCanariesOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCanariesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCanariesOutputResponse(canaries: \(String(describing: canaries)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeCanariesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCanariesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.canaries = output.canaries
            self.nextToken = output.nextToken
        } else {
            self.canaries = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeCanariesOutputResponse: Equatable {
    /// <p>Returns an array. Each item in the array contains the full information about
    ///          one canary.</p>
    public let canaries: [Canary]?
    /// <p>A token that indicates that there is more data
    ///          available. You can use this token in a subsequent <code>DescribeCanaries</code> operation to retrieve the next
    ///          set of results.</p>
    public let nextToken: String?

    public init (
        canaries: [Canary]? = nil,
        nextToken: String? = nil
    )
    {
        self.canaries = canaries
        self.nextToken = nextToken
    }
}

struct DescribeCanariesOutputResponseBody: Equatable {
    public let canaries: [Canary]?
    public let nextToken: String?
}

extension DescribeCanariesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case canaries = "Canaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canariesContainer = try containerValues.decodeIfPresent([Canary?].self, forKey: .canaries)
        var canariesDecoded0:[Canary]? = nil
        if let canariesContainer = canariesContainer {
            canariesDecoded0 = [Canary]()
            for structure0 in canariesContainer {
                if let structure0 = structure0 {
                    canariesDecoded0?.append(structure0)
                }
            }
        }
        canaries = canariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeRuntimeVersionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRuntimeVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRuntimeVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRuntimeVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRuntimeVersionsInput>
    public typealias MOutput = OperationOutput<DescribeRuntimeVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRuntimeVersionsOutputError>
}

extension DescribeRuntimeVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRuntimeVersionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeRuntimeVersionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeRuntimeVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRuntimeVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRuntimeVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRuntimeVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRuntimeVersionsInput>
    public typealias MOutput = OperationOutput<DescribeRuntimeVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRuntimeVersionsOutputError>
}

public struct DescribeRuntimeVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRuntimeVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRuntimeVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRuntimeVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRuntimeVersionsInput>
    public typealias MOutput = OperationOutput<DescribeRuntimeVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRuntimeVersionsOutputError>
}

public struct DescribeRuntimeVersionsInput: Equatable {
    /// <p>Specify this parameter to limit how many runs are returned each time you use
    ///          the <code>DescribeRuntimeVersions</code> operation. If you omit this parameter, the default of 100 is used.</p>
    public let maxResults: Int?
    /// <p>A token that indicates that there is more data
    ///          available. You can use this token in a subsequent <code>DescribeRuntimeVersions</code> operation to retrieve the next
    ///          set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeRuntimeVersionsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeRuntimeVersionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRuntimeVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRuntimeVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRuntimeVersionsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRuntimeVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRuntimeVersionsOutputResponse(nextToken: \(String(describing: nextToken)), runtimeVersions: \(String(describing: runtimeVersions)))"}
}

extension DescribeRuntimeVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRuntimeVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.runtimeVersions = output.runtimeVersions
        } else {
            self.nextToken = nil
            self.runtimeVersions = nil
        }
    }
}

public struct DescribeRuntimeVersionsOutputResponse: Equatable {
    /// <p>A token that indicates that there is more data
    ///          available. You can use this token in a subsequent <code>DescribeRuntimeVersions</code> operation to retrieve the next
    ///          set of results.</p>
    public let nextToken: String?
    /// <p>An array of objects that display the details about each Synthetics canary runtime
    ///          version.</p>
    public let runtimeVersions: [RuntimeVersion]?

    public init (
        nextToken: String? = nil,
        runtimeVersions: [RuntimeVersion]? = nil
    )
    {
        self.nextToken = nextToken
        self.runtimeVersions = runtimeVersions
    }
}

struct DescribeRuntimeVersionsOutputResponseBody: Equatable {
    public let runtimeVersions: [RuntimeVersion]?
    public let nextToken: String?
}

extension DescribeRuntimeVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case runtimeVersions = "RuntimeVersions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeVersionsContainer = try containerValues.decodeIfPresent([RuntimeVersion?].self, forKey: .runtimeVersions)
        var runtimeVersionsDecoded0:[RuntimeVersion]? = nil
        if let runtimeVersionsContainer = runtimeVersionsContainer {
            runtimeVersionsDecoded0 = [RuntimeVersion]()
            for structure0 in runtimeVersionsContainer {
                if let structure0 = structure0 {
                    runtimeVersionsDecoded0?.append(structure0)
                }
            }
        }
        runtimeVersions = runtimeVersionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetCanaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCanaryInput(name: \(String(describing: name)))"}
}

extension GetCanaryInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCanaryInputHeadersMiddleware: Middleware {
    public let id: String = "GetCanaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCanaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCanaryInput>
    public typealias MOutput = OperationOutput<GetCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCanaryOutputError>
}

public struct GetCanaryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCanaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCanaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCanaryInput>
    public typealias MOutput = OperationOutput<GetCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCanaryOutputError>
}

public struct GetCanaryInput: Equatable {
    /// <p>The name of the canary that you want details for.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct GetCanaryInputBody: Equatable {
}

extension GetCanaryInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCanaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCanaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCanaryOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCanaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCanaryOutputResponse(canary: \(String(describing: canary)))"}
}

extension GetCanaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCanaryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.canary = output.canary
        } else {
            self.canary = nil
        }
    }
}

public struct GetCanaryOutputResponse: Equatable {
    /// <p>A strucure that contains the full information about the canary.</p>
    public let canary: Canary?

    public init (
        canary: Canary? = nil
    )
    {
        self.canary = canary
    }
}

struct GetCanaryOutputResponseBody: Equatable {
    public let canary: Canary?
}

extension GetCanaryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case canary = "Canary"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canaryDecoded = try containerValues.decodeIfPresent(Canary.self, forKey: .canary)
        canary = canaryDecoded
    }
}

public struct GetCanaryRunsInputBodyMiddleware: Middleware {
    public let id: String = "GetCanaryRunsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCanaryRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCanaryRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCanaryRunsInput>
    public typealias MOutput = OperationOutput<GetCanaryRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCanaryRunsOutputError>
}

extension GetCanaryRunsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCanaryRunsInput(maxResults: \(String(describing: maxResults)), name: \(String(describing: name)), nextToken: \(String(describing: nextToken)))"}
}

extension GetCanaryRunsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetCanaryRunsInputHeadersMiddleware: Middleware {
    public let id: String = "GetCanaryRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCanaryRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCanaryRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCanaryRunsInput>
    public typealias MOutput = OperationOutput<GetCanaryRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCanaryRunsOutputError>
}

public struct GetCanaryRunsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCanaryRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCanaryRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCanaryRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCanaryRunsInput>
    public typealias MOutput = OperationOutput<GetCanaryRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCanaryRunsOutputError>
}

public struct GetCanaryRunsInput: Equatable {
    /// <p>Specify this parameter to limit how many runs are returned each time you use
    ///          the <code>GetCanaryRuns</code> operation. If you omit this parameter, the default of 100 is used.</p>
    public let maxResults: Int?
    /// <p>The name of the canary that you want to see runs for.</p>
    public let name: String?
    /// <p>A token that indicates that there is more data
    ///          available. You can use this token in a subsequent <code>GetCanaryRuns</code> operation to retrieve the next
    ///          set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        name: String? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetCanaryRunsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetCanaryRunsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetCanaryRunsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCanaryRunsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCanaryRunsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCanaryRunsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCanaryRunsOutputResponse(canaryRuns: \(String(describing: canaryRuns)), nextToken: \(String(describing: nextToken)))"}
}

extension GetCanaryRunsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCanaryRunsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.canaryRuns = output.canaryRuns
            self.nextToken = output.nextToken
        } else {
            self.canaryRuns = nil
            self.nextToken = nil
        }
    }
}

public struct GetCanaryRunsOutputResponse: Equatable {
    /// <p>An array of structures. Each structure contains the details of one of the
    ///          retrieved canary runs.</p>
    public let canaryRuns: [CanaryRun]?
    /// <p>A token that indicates that there is more data
    ///          available. You can use this token in a subsequent <code>GetCanaryRuns</code>
    ///          operation to retrieve the next
    ///          set of results.</p>
    public let nextToken: String?

    public init (
        canaryRuns: [CanaryRun]? = nil,
        nextToken: String? = nil
    )
    {
        self.canaryRuns = canaryRuns
        self.nextToken = nextToken
    }
}

struct GetCanaryRunsOutputResponseBody: Equatable {
    public let canaryRuns: [CanaryRun]?
    public let nextToken: String?
}

extension GetCanaryRunsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case canaryRuns = "CanaryRuns"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canaryRunsContainer = try containerValues.decodeIfPresent([CanaryRun?].self, forKey: .canaryRuns)
        var canaryRunsDecoded0:[CanaryRun]? = nil
        if let canaryRunsContainer = canaryRunsContainer {
            canaryRunsDecoded0 = [CanaryRun]()
            for structure0 in canaryRunsContainer {
                if let structure0 = structure0 {
                    canaryRunsDecoded0?.append(structure0)
                }
            }
        }
        canaryRuns = canaryRunsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An unknown internal error occurred.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of the canary that you want to view tags for.</p>
    ///          <p>The ARN format of a canary is
    ///                <code>arn:aws:synthetics:<i>Region</i>:<i>account-id</i>:canary:<i>canary-name</i>
    ///             </code>.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The list of tag keys and values associated with the canary that you specified.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One of the specified resources was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RuntimeVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deprecationDate = "DeprecationDate"
        case description = "Description"
        case releaseDate = "ReleaseDate"
        case versionName = "VersionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deprecationDate = deprecationDate {
            try encodeContainer.encode(deprecationDate.timeIntervalSince1970, forKey: .deprecationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let releaseDate = releaseDate {
            try encodeContainer.encode(releaseDate.timeIntervalSince1970, forKey: .releaseDate)
        }
        if let versionName = versionName {
            try encodeContainer.encode(versionName, forKey: .versionName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionName)
        versionName = versionNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let releaseDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .releaseDate)
        releaseDate = releaseDateDecoded
        let deprecationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .deprecationDate)
        deprecationDate = deprecationDateDecoded
    }
}

extension RuntimeVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuntimeVersion(deprecationDate: \(String(describing: deprecationDate)), description: \(String(describing: description)), releaseDate: \(String(describing: releaseDate)), versionName: \(String(describing: versionName)))"}
}

/// <p>This structure contains information about one canary runtime version. For more information about
///          runtime versions, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_Library.html">
///             Canary Runtime Versions</a>.</p>
public struct RuntimeVersion: Equatable {
    /// <p>If this runtime version is deprecated, this value is the date of deprecation.</p>
    public let deprecationDate: Date?
    /// <p>A description of the runtime version, created by Amazon.</p>
    public let description: String?
    /// <p>The date that the runtime version was released.</p>
    public let releaseDate: Date?
    /// <p>The name of the runtime version. For a list of valid runtime versions,
    ///          see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_Library.html">
    ///             Canary Runtime Versions</a>.</p>
    public let versionName: String?

    public init (
        deprecationDate: Date? = nil,
        description: String? = nil,
        releaseDate: Date? = nil,
        versionName: String? = nil
    )
    {
        self.deprecationDate = deprecationDate
        self.description = description
        self.releaseDate = releaseDate
        self.versionName = versionName
    }
}

extension StartCanaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartCanaryInput(name: \(String(describing: name)))"}
}

extension StartCanaryInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StartCanaryInputHeadersMiddleware: Middleware {
    public let id: String = "StartCanaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartCanaryInput>,
                  next: H) -> Swift.Result<OperationOutput<StartCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartCanaryInput>
    public typealias MOutput = OperationOutput<StartCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartCanaryOutputError>
}

public struct StartCanaryInputQueryItemMiddleware: Middleware {
    public let id: String = "StartCanaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartCanaryInput>,
                  next: H) -> Swift.Result<OperationOutput<StartCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartCanaryInput>
    public typealias MOutput = OperationOutput<StartCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartCanaryOutputError>
}

public struct StartCanaryInput: Equatable {
    /// <p>The name of the canary that you want to run. To find
    ///          canary names, use <a href="https://docs.aws.amazon.com/AmazonSynthetics/latest/APIReference/API_DescribeCanaries.html">DescribeCanaries</a>.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct StartCanaryInputBody: Equatable {
}

extension StartCanaryInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StartCanaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartCanaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartCanaryOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartCanaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartCanaryOutputResponse()"}
}

extension StartCanaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartCanaryOutputResponse: Equatable {

    public init() {}
}

struct StartCanaryOutputResponseBody: Equatable {
}

extension StartCanaryOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StopCanaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopCanaryInput(name: \(String(describing: name)))"}
}

extension StopCanaryInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StopCanaryInputHeadersMiddleware: Middleware {
    public let id: String = "StopCanaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopCanaryInput>,
                  next: H) -> Swift.Result<OperationOutput<StopCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopCanaryInput>
    public typealias MOutput = OperationOutput<StopCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopCanaryOutputError>
}

public struct StopCanaryInputQueryItemMiddleware: Middleware {
    public let id: String = "StopCanaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopCanaryInput>,
                  next: H) -> Swift.Result<OperationOutput<StopCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopCanaryInput>
    public typealias MOutput = OperationOutput<StopCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopCanaryOutputError>
}

public struct StopCanaryInput: Equatable {
    /// <p>The name of the canary that you want to stop. To find the names of your
    ///          canaries, use <a href="https://docs.aws.amazon.com/AmazonSynthetics/latest/APIReference/API_DescribeCanaries.html">DescribeCanaries</a>.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct StopCanaryInputBody: Equatable {
}

extension StopCanaryInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StopCanaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopCanaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopCanaryOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopCanaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopCanaryOutputResponse()"}
}

extension StopCanaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopCanaryOutputResponse: Equatable {

    public init() {}
}

struct StopCanaryOutputResponseBody: Equatable {
}

extension StopCanaryOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the canary that you're adding tags to.</p>
    ///          <p>The ARN format of a canary is
    ///                <code>arn:aws:synthetics:<i>Region</i>:<i>account-id</i>:canary:<i>canary-name</i>
    ///             </code>.</p>
    public let resourceArn: String?
    /// <p>The list of key-value pairs to associate with the canary.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the canary that you're removing tags from.</p>
    ///          <p>The ARN format of a canary is
    ///                <code>arn:aws:synthetics:<i>Region</i>:<i>account-id</i>:canary:<i>canary-name</i>
    ///             </code>.</p>
    public let resourceArn: String?
    /// <p>The list of tag keys to remove from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateCanaryInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCanaryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCanaryInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCanaryInput>
    public typealias MOutput = OperationOutput<UpdateCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCanaryOutputError>
}

extension UpdateCanaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCanaryInput(code: \(String(describing: code)), executionRoleArn: \(String(describing: executionRoleArn)), failureRetentionPeriodInDays: \(String(describing: failureRetentionPeriodInDays)), name: \(String(describing: name)), runConfig: \(String(describing: runConfig)), runtimeVersion: \(String(describing: runtimeVersion)), schedule: \(String(describing: schedule)), successRetentionPeriodInDays: \(String(describing: successRetentionPeriodInDays)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension UpdateCanaryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case executionRoleArn = "ExecutionRoleArn"
        case failureRetentionPeriodInDays = "FailureRetentionPeriodInDays"
        case runConfig = "RunConfig"
        case runtimeVersion = "RuntimeVersion"
        case schedule = "Schedule"
        case successRetentionPeriodInDays = "SuccessRetentionPeriodInDays"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let failureRetentionPeriodInDays = failureRetentionPeriodInDays {
            try encodeContainer.encode(failureRetentionPeriodInDays, forKey: .failureRetentionPeriodInDays)
        }
        if let runConfig = runConfig {
            try encodeContainer.encode(runConfig, forKey: .runConfig)
        }
        if let runtimeVersion = runtimeVersion {
            try encodeContainer.encode(runtimeVersion, forKey: .runtimeVersion)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let successRetentionPeriodInDays = successRetentionPeriodInDays {
            try encodeContainer.encode(successRetentionPeriodInDays, forKey: .successRetentionPeriodInDays)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct UpdateCanaryInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCanaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCanaryInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCanaryInput>
    public typealias MOutput = OperationOutput<UpdateCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCanaryOutputError>
}

public struct UpdateCanaryInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCanaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCanaryInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCanaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCanaryInput>
    public typealias MOutput = OperationOutput<UpdateCanaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCanaryOutputError>
}

public struct UpdateCanaryInput: Equatable {
    /// <p>A structure that includes the entry point from which the canary should start
    ///          running your script. If the script is stored in
    ///          an S3 bucket, the bucket name, key, and version are also included.
    ///       </p>
    public let code: CanaryCodeInput?
    /// <p>The ARN of the IAM role to be used to run the canary. This role must already exist,
    ///          and must include <code>lambda.amazonaws.com</code> as a principal in the trust
    ///          policy. The role must also have the following permissions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>s3:PutObject</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>s3:GetBucketLocation</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>s3:ListAllMyBuckets</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>cloudwatch:PutMetricData</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>logs:CreateLogGroup</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>logs:CreateLogStream</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>logs:CreateLogStream</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let executionRoleArn: String?
    /// <p>The number of days to retain data about failed runs of this canary.</p>
    public let failureRetentionPeriodInDays: Int?
    /// <p>The name of the canary that you want to update. To find the names of your
    ///          canaries, use <a href="https://docs.aws.amazon.com/AmazonSynthetics/latest/APIReference/API_DescribeCanaries.html">DescribeCanaries</a>.</p>
    ///          <p>You cannot change the name of a canary that has already been created.</p>
    public let name: String?
    /// <p>A structure that contains the timeout value that is used for each individual run of the
    ///          canary.</p>
    public let runConfig: CanaryRunConfigInput?
    /// <p>Specifies the runtime version to use for the canary.
    ///          For a list of valid runtime versions and for more information about
    ///          runtime versions, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_Library.html">
    ///             Canary Runtime Versions</a>.</p>
    public let runtimeVersion: String?
    /// <p>A structure that contains information about how often the canary is to run, and when
    ///          these runs are to stop.</p>
    public let schedule: CanaryScheduleInput?
    /// <p>The number of days to retain data about successful runs of this canary.</p>
    public let successRetentionPeriodInDays: Int?
    /// <p>If this canary is to test an endpoint in a VPC, this structure contains
    ///          information about the subnet and security groups of the VPC endpoint.
    ///          For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_VPC.html">
    ///             Running a Canary in a VPC</a>.</p>
    public let vpcConfig: VpcConfigInput?

    public init (
        code: CanaryCodeInput? = nil,
        executionRoleArn: String? = nil,
        failureRetentionPeriodInDays: Int? = nil,
        name: String? = nil,
        runConfig: CanaryRunConfigInput? = nil,
        runtimeVersion: String? = nil,
        schedule: CanaryScheduleInput? = nil,
        successRetentionPeriodInDays: Int? = nil,
        vpcConfig: VpcConfigInput? = nil
    )
    {
        self.code = code
        self.executionRoleArn = executionRoleArn
        self.failureRetentionPeriodInDays = failureRetentionPeriodInDays
        self.name = name
        self.runConfig = runConfig
        self.runtimeVersion = runtimeVersion
        self.schedule = schedule
        self.successRetentionPeriodInDays = successRetentionPeriodInDays
        self.vpcConfig = vpcConfig
    }
}

struct UpdateCanaryInputBody: Equatable {
    public let code: CanaryCodeInput?
    public let executionRoleArn: String?
    public let runtimeVersion: String?
    public let schedule: CanaryScheduleInput?
    public let runConfig: CanaryRunConfigInput?
    public let successRetentionPeriodInDays: Int?
    public let failureRetentionPeriodInDays: Int?
    public let vpcConfig: VpcConfigInput?
}

extension UpdateCanaryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case executionRoleArn = "ExecutionRoleArn"
        case failureRetentionPeriodInDays = "FailureRetentionPeriodInDays"
        case runConfig = "RunConfig"
        case runtimeVersion = "RuntimeVersion"
        case schedule = "Schedule"
        case successRetentionPeriodInDays = "SuccessRetentionPeriodInDays"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(CanaryCodeInput.self, forKey: .code)
        code = codeDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let runtimeVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .runtimeVersion)
        runtimeVersion = runtimeVersionDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(CanaryScheduleInput.self, forKey: .schedule)
        schedule = scheduleDecoded
        let runConfigDecoded = try containerValues.decodeIfPresent(CanaryRunConfigInput.self, forKey: .runConfig)
        runConfig = runConfigDecoded
        let successRetentionPeriodInDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .successRetentionPeriodInDays)
        successRetentionPeriodInDays = successRetentionPeriodInDaysDecoded
        let failureRetentionPeriodInDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .failureRetentionPeriodInDays)
        failureRetentionPeriodInDays = failureRetentionPeriodInDaysDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfigInput.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
    }
}

extension UpdateCanaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCanaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCanaryOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCanaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCanaryOutputResponse()"}
}

extension UpdateCanaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateCanaryOutputResponse: Equatable {

    public init() {}
}

struct UpdateCanaryOutputResponseBody: Equatable {
}

extension UpdateCanaryOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A parameter could not be validated.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VpcConfigInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension VpcConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcConfigInput(securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)))"}
}

/// <p>If this canary is to test an endpoint in a VPC, this structure contains
///          information about the subnets and security groups of the VPC endpoint.
///          For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_VPC.html">
///             Running a Canary in a VPC</a>.</p>
public struct VpcConfigInput: Equatable {
    /// <p>The IDs of the security groups for this canary.</p>
    public let securityGroupIds: [String]?
    /// <p>The IDs of the subnets where this canary is to run.</p>
    public let subnetIds: [String]?

    public init (
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
    }
}

extension VpcConfigOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension VpcConfigOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcConfigOutput(securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>If this canary is to test an endpoint in a VPC, this structure contains
///          information about the subnets and security groups of the VPC endpoint.
///          For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_VPC.html">
///             Running a Canary in a VPC</a>.</p>
public struct VpcConfigOutput: Equatable {
    /// <p>The IDs of the security groups for this canary.</p>
    public let securityGroupIds: [String]?
    /// <p>The IDs of the subnets where this canary is to run.</p>
    public let subnetIds: [String]?
    /// <p>The IDs of the VPC where this canary is to run.</p>
    public let vpcId: String?

    public init (
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil,
        vpcId: String? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}
