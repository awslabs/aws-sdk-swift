// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ChimeSdkIdentityClientTypes {
    public enum AllowMessages: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AllowMessages] {
            return [
                .all,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AllowMessages(rawValue: rawValue) ?? AllowMessages.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkIdentityClientTypes.AppInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case createdTimestamp = "CreatedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ChimeSdkIdentityClientTypes {
    /// The details of an AppInstance, an instance of an Amazon Chime SDK messaging application.
    public struct AppInstance: Swift.Equatable {
        /// The ARN of the messaging instance.
        public var appInstanceArn: Swift.String?
        /// The time at which an AppInstance was created. In epoch milliseconds.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time an AppInstance was last updated. In epoch milliseconds.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The metadata of an AppInstance.
        public var metadata: Swift.String?
        /// The name of an AppInstance.
        public var name: Swift.String?

        public init (
            appInstanceArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceArn = appInstanceArn
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeSdkIdentityClientTypes.AppInstanceAdmin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case admin = "Admin"
        case appInstanceArn = "AppInstanceArn"
        case createdTimestamp = "CreatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let admin = admin {
            try encodeContainer.encode(admin, forKey: .admin)
        }
        if let appInstanceArn = appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.Identity.self, forKey: .admin)
        admin = adminDecoded
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension ChimeSdkIdentityClientTypes {
    /// The details of an AppInstanceAdmin.
    public struct AppInstanceAdmin: Swift.Equatable {
        /// The AppInstanceAdmin data.
        public var admin: ChimeSdkIdentityClientTypes.Identity?
        /// The ARN of the AppInstance for which the user is an administrator.
        public var appInstanceArn: Swift.String?
        /// The time at which an administrator was created.
        public var createdTimestamp: ClientRuntime.Date?

        public init (
            admin: ChimeSdkIdentityClientTypes.Identity? = nil,
            appInstanceArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.admin = admin
            self.appInstanceArn = appInstanceArn
            self.createdTimestamp = createdTimestamp
        }
    }

}

extension ChimeSdkIdentityClientTypes.AppInstanceAdminSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case admin = "Admin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let admin = admin {
            try encodeContainer.encode(admin, forKey: .admin)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.Identity.self, forKey: .admin)
        admin = adminDecoded
    }
}

extension ChimeSdkIdentityClientTypes {
    /// Summary of the details of an AppInstanceAdmin.
    public struct AppInstanceAdminSummary: Swift.Equatable {
        /// The details of the AppInstanceAdmin.
        public var admin: ChimeSdkIdentityClientTypes.Identity?

        public init (
            admin: ChimeSdkIdentityClientTypes.Identity? = nil
        )
        {
            self.admin = admin
        }
    }

}

extension ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelRetentionSettings = "ChannelRetentionSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelRetentionSettings = channelRetentionSettings {
            try encodeContainer.encode(channelRetentionSettings, forKey: .channelRetentionSettings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.ChannelRetentionSettings.self, forKey: .channelRetentionSettings)
        channelRetentionSettings = channelRetentionSettingsDecoded
    }
}

extension ChimeSdkIdentityClientTypes {
    /// The details of the data-retention settings for an AppInstance.
    public struct AppInstanceRetentionSettings: Swift.Equatable {
        /// The length of time in days to retain the messages in a channel.
        public var channelRetentionSettings: ChimeSdkIdentityClientTypes.ChannelRetentionSettings?

        public init (
            channelRetentionSettings: ChimeSdkIdentityClientTypes.ChannelRetentionSettings? = nil
        )
        {
            self.channelRetentionSettings = channelRetentionSettings
        }
    }

}

extension ChimeSdkIdentityClientTypes.AppInstanceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ChimeSdkIdentityClientTypes {
    /// Summary of the data for an AppInstance.
    public struct AppInstanceSummary: Swift.Equatable {
        /// The AppInstance ARN.
        public var appInstanceArn: Swift.String?
        /// The metadata of the AppInstance.
        public var metadata: Swift.String?
        /// The name of the AppInstance.
        public var name: Swift.String?

        public init (
            appInstanceArn: Swift.String? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceArn = appInstanceArn
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeSdkIdentityClientTypes.AppInstanceUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
        case createdTimestamp = "CreatedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceUserArn = appInstanceUserArn {
            try encodeContainer.encode(appInstanceUserArn, forKey: .appInstanceUserArn)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
    }
}

extension ChimeSdkIdentityClientTypes {
    /// The details of an AppInstanceUser.
    public struct AppInstanceUser: Swift.Equatable {
        /// The ARN of the AppInstanceUser.
        public var appInstanceUserArn: Swift.String?
        /// The time at which the AppInstanceUser was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which the AppInstanceUser was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The metadata of the AppInstanceUser.
        public var metadata: Swift.String?
        /// The name of the AppInstanceUser.
        public var name: Swift.String?

        public init (
            appInstanceUserArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceUserArn = appInstanceUserArn
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeSdkIdentityClientTypes.AppInstanceUserEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMessages = "AllowMessages"
        case appInstanceUserArn = "AppInstanceUserArn"
        case createdTimestamp = "CreatedTimestamp"
        case endpointAttributes = "EndpointAttributes"
        case endpointId = "EndpointId"
        case endpointState = "EndpointState"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case name = "Name"
        case resourceArn = "ResourceArn"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowMessages = allowMessages {
            try encodeContainer.encode(allowMessages.rawValue, forKey: .allowMessages)
        }
        if let appInstanceUserArn = appInstanceUserArn {
            try encodeContainer.encode(appInstanceUserArn, forKey: .appInstanceUserArn)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let endpointAttributes = endpointAttributes {
            try encodeContainer.encode(endpointAttributes, forKey: .endpointAttributes)
        }
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let endpointState = endpointState {
            try encodeContainer.encode(endpointState, forKey: .endpointState)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType.self, forKey: .type)
        type = typeDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let endpointAttributesDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.EndpointAttributes.self, forKey: .endpointAttributes)
        endpointAttributes = endpointAttributesDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let allowMessagesDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AllowMessages.self, forKey: .allowMessages)
        allowMessages = allowMessagesDecoded
        let endpointStateDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.EndpointState.self, forKey: .endpointState)
        endpointState = endpointStateDecoded
    }
}

extension ChimeSdkIdentityClientTypes {
    /// An endpoint under an Amazon Chime AppInstanceUser that receives messages for a user. For push notifications, the endpoint is a mobile device used to receive mobile push notifications for a user.
    public struct AppInstanceUserEndpoint: Swift.Equatable {
        /// Boolean that controls whether the AppInstanceUserEndpoint is opted in to receive messages. ALL indicates the endpoint will receive all messages. NONE indicates the endpoint will receive no messages.
        public var allowMessages: ChimeSdkIdentityClientTypes.AllowMessages?
        /// The ARN of the AppInstanceUser.
        public var appInstanceUserArn: Swift.String?
        /// The time at which an AppInstanceUserEndpoint was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The attributes of an Endpoint.
        public var endpointAttributes: ChimeSdkIdentityClientTypes.EndpointAttributes?
        /// The unique identifier of the AppInstanceUserEndpoint.
        public var endpointId: Swift.String?
        /// A read-only field that represents the state of an AppInstanceUserEndpoint. Supported values:
        ///
        /// * ACTIVE: The AppInstanceUserEndpoint is active and able to receive messages. When ACTIVE, the EndpointStatusReason remains empty.
        ///
        /// * INACTIVE: The AppInstanceUserEndpoint is inactive and can't receive message. When INACTIVE, the corresponding reason will be conveyed through EndpointStatusReason.
        ///
        /// * INVALID_DEVICE_TOKEN indicates that an AppInstanceUserEndpoint is INACTIVE due to invalid device token
        ///
        /// * INVALID_PINPOINT_ARN indicates that an AppInstanceUserEndpoint is INACTIVE due to an invalid pinpoint ARN that was input through the ResourceArn field.
        public var endpointState: ChimeSdkIdentityClientTypes.EndpointState?
        /// The time at which an AppInstanceUserEndpoint was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The name of the AppInstanceUserEndpoint.
        public var name: Swift.String?
        /// The ARN of the resource to which the endpoint belongs.
        public var resourceArn: Swift.String?
        /// The type of the AppInstanceUserEndpoint.
        public var type: ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType?

        public init (
            allowMessages: ChimeSdkIdentityClientTypes.AllowMessages? = nil,
            appInstanceUserArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            endpointAttributes: ChimeSdkIdentityClientTypes.EndpointAttributes? = nil,
            endpointId: Swift.String? = nil,
            endpointState: ChimeSdkIdentityClientTypes.EndpointState? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            type: ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType? = nil
        )
        {
            self.allowMessages = allowMessages
            self.appInstanceUserArn = appInstanceUserArn
            self.createdTimestamp = createdTimestamp
            self.endpointAttributes = endpointAttributes
            self.endpointId = endpointId
            self.endpointState = endpointState
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.name = name
            self.resourceArn = resourceArn
            self.type = type
        }
    }

}

extension ChimeSdkIdentityClientTypes.AppInstanceUserEndpointSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMessages = "AllowMessages"
        case appInstanceUserArn = "AppInstanceUserArn"
        case endpointId = "EndpointId"
        case endpointState = "EndpointState"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowMessages = allowMessages {
            try encodeContainer.encode(allowMessages.rawValue, forKey: .allowMessages)
        }
        if let appInstanceUserArn = appInstanceUserArn {
            try encodeContainer.encode(appInstanceUserArn, forKey: .appInstanceUserArn)
        }
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let endpointState = endpointState {
            try encodeContainer.encode(endpointState, forKey: .endpointState)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType.self, forKey: .type)
        type = typeDecoded
        let allowMessagesDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AllowMessages.self, forKey: .allowMessages)
        allowMessages = allowMessagesDecoded
        let endpointStateDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.EndpointState.self, forKey: .endpointState)
        endpointState = endpointStateDecoded
    }
}

extension ChimeSdkIdentityClientTypes {
    /// Summary of the details of an AppInstanceUserEndpoint.
    public struct AppInstanceUserEndpointSummary: Swift.Equatable {
        /// BBoolean that controls whether the AppInstanceUserEndpoint is opted in to receive messages. ALL indicates the endpoint will receive all messages. NONE indicates the endpoint will receive no messages.
        public var allowMessages: ChimeSdkIdentityClientTypes.AllowMessages?
        /// The ARN of the AppInstanceUser.
        public var appInstanceUserArn: Swift.String?
        /// The unique identifier of the AppInstanceUserEndpoint.
        public var endpointId: Swift.String?
        /// A read-only field that represent the state of an AppInstanceUserEndpoint.
        public var endpointState: ChimeSdkIdentityClientTypes.EndpointState?
        /// The name of the AppInstanceUserEndpoint.
        public var name: Swift.String?
        /// The type of the AppInstanceUserEndpoint.
        public var type: ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType?

        public init (
            allowMessages: ChimeSdkIdentityClientTypes.AllowMessages? = nil,
            appInstanceUserArn: Swift.String? = nil,
            endpointId: Swift.String? = nil,
            endpointState: ChimeSdkIdentityClientTypes.EndpointState? = nil,
            name: Swift.String? = nil,
            type: ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType? = nil
        )
        {
            self.allowMessages = allowMessages
            self.appInstanceUserArn = appInstanceUserArn
            self.endpointId = endpointId
            self.endpointState = endpointState
            self.name = name
            self.type = type
        }
    }

}

extension ChimeSdkIdentityClientTypes {
    public enum AppInstanceUserEndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apns
        case apnsSandbox
        case gcm
        case sdkUnknown(Swift.String)

        public static var allCases: [AppInstanceUserEndpointType] {
            return [
                .apns,
                .apnsSandbox,
                .gcm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apns: return "APNS"
            case .apnsSandbox: return "APNS_SANDBOX"
            case .gcm: return "GCM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppInstanceUserEndpointType(rawValue: rawValue) ?? AppInstanceUserEndpointType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkIdentityClientTypes.AppInstanceUserSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceUserArn = appInstanceUserArn {
            try encodeContainer.encode(appInstanceUserArn, forKey: .appInstanceUserArn)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ChimeSdkIdentityClientTypes {
    /// Summary of the details of an AppInstanceUser.
    public struct AppInstanceUserSummary: Swift.Equatable {
        /// The ARN of the AppInstanceUser.
        public var appInstanceUserArn: Swift.String?
        /// The metadata of the AppInstanceUser.
        public var metadata: Swift.String?
        /// The name of an AppInstanceUser.
        public var name: Swift.String?

        public init (
            appInstanceUserArn: Swift.String? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceUserArn = appInstanceUserArn
            self.metadata = metadata
            self.name = name
        }
    }

}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkIdentityClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let code: ChimeSdkIdentityClientTypes.ErrorCode?
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSdkIdentityClientTypes.ChannelRetentionSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionDays = "RetentionDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionDays = retentionDays {
            try encodeContainer.encode(retentionDays, forKey: .retentionDays)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
    }
}

extension ChimeSdkIdentityClientTypes {
    /// The details of the retention settings for a channel.
    public struct ChannelRetentionSettings: Swift.Equatable {
        /// The time in days to retain the messages in a channel.
        public var retentionDays: Swift.Int?

        public init (
            retentionDays: Swift.Int? = nil
        )
        {
            self.retentionDays = retentionDays
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkIdentityClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let code: ChimeSdkIdentityClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAppInstanceAdminInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdminArn = "AppInstanceAdminArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceAdminArn = appInstanceAdminArn {
            try encodeContainer.encode(appInstanceAdminArn, forKey: .appInstanceAdminArn)
        }
    }
}

extension CreateAppInstanceAdminInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins"
    }
}

public struct CreateAppInstanceAdminInput: Swift.Equatable {
    /// The ARN of the administrator of the current AppInstance.
    /// This member is required.
    public var appInstanceAdminArn: Swift.String?
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceAdminArn: Swift.String? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdminArn = appInstanceAdminArn
        self.appInstanceArn = appInstanceArn
    }
}

struct CreateAppInstanceAdminInputBody: Swift.Equatable {
    let appInstanceAdminArn: Swift.String?
}

extension CreateAppInstanceAdminInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdminArn = "AppInstanceAdminArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceAdminArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceAdminArn)
        appInstanceAdminArn = appInstanceAdminArnDecoded
    }
}

extension CreateAppInstanceAdminOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAppInstanceAdminOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppInstanceAdminOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppInstanceAdminOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAppInstanceAdminOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceAdmin = output.appInstanceAdmin
            self.appInstanceArn = output.appInstanceArn
        } else {
            self.appInstanceAdmin = nil
            self.appInstanceArn = nil
        }
    }
}

public struct CreateAppInstanceAdminOutputResponse: Swift.Equatable {
    /// The name and ARN of the admin for the AppInstance.
    public var appInstanceAdmin: ChimeSdkIdentityClientTypes.Identity?
    /// The ARN of the of the admin for the AppInstance.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceAdmin: ChimeSdkIdentityClientTypes.Identity? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdmin = appInstanceAdmin
        self.appInstanceArn = appInstanceArn
    }
}

struct CreateAppInstanceAdminOutputResponseBody: Swift.Equatable {
    let appInstanceAdmin: ChimeSdkIdentityClientTypes.Identity?
    let appInstanceArn: Swift.String?
}

extension CreateAppInstanceAdminOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdmin = "AppInstanceAdmin"
        case appInstanceArn = "AppInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceAdminDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.Identity.self, forKey: .appInstanceAdmin)
        appInstanceAdmin = appInstanceAdminDecoded
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
    }
}

extension CreateAppInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateAppInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/app-instances"
    }
}

public struct CreateAppInstanceInput: Swift.Equatable {
    /// The ClientRequestToken of the AppInstance.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The metadata of the AppInstance. Limited to a 1KB string in UTF-8.
    public var metadata: Swift.String?
    /// The name of the AppInstance.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to the AppInstanceUser.
    public var tags: [ChimeSdkIdentityClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ChimeSdkIdentityClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.metadata = metadata
        self.name = name
        self.tags = tags
    }
}

struct CreateAppInstanceInputBody: Swift.Equatable {
    let name: Swift.String?
    let metadata: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [ChimeSdkIdentityClientTypes.Tag]?
}

extension CreateAppInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSdkIdentityClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSdkIdentityClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSdkIdentityClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAppInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAppInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppInstanceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAppInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceArn = output.appInstanceArn
        } else {
            self.appInstanceArn = nil
        }
    }
}

public struct CreateAppInstanceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the AppInstance.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct CreateAppInstanceOutputResponseBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
}

extension CreateAppInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
    }
}

extension CreateAppInstanceUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case appInstanceUserId = "AppInstanceUserId"
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let appInstanceUserId = appInstanceUserId {
            try encodeContainer.encode(appInstanceUserId, forKey: .appInstanceUserId)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/app-instance-users"
    }
}

public struct CreateAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstance request.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The user ID of the AppInstance.
    /// This member is required.
    public var appInstanceUserId: Swift.String?
    /// The token assigned to the user requesting an AppInstance.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The request's metadata. Limited to a 1KB string in UTF-8.
    public var metadata: Swift.String?
    /// The user's name.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to the AppInstanceUser.
    public var tags: [ChimeSdkIdentityClientTypes.Tag]?

    public init (
        appInstanceArn: Swift.String? = nil,
        appInstanceUserId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ChimeSdkIdentityClientTypes.Tag]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceUserId = appInstanceUserId
        self.clientRequestToken = clientRequestToken
        self.metadata = metadata
        self.name = name
        self.tags = tags
    }
}

struct CreateAppInstanceUserInputBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
    let appInstanceUserId: Swift.String?
    let name: Swift.String?
    let metadata: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [ChimeSdkIdentityClientTypes.Tag]?
}

extension CreateAppInstanceUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case appInstanceUserId = "AppInstanceUserId"
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let appInstanceUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserId)
        appInstanceUserId = appInstanceUserIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSdkIdentityClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSdkIdentityClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSdkIdentityClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserArn = output.appInstanceUserArn
        } else {
            self.appInstanceUserArn = nil
        }
    }
}

public struct CreateAppInstanceUserOutputResponse: Swift.Equatable {
    /// The user's ARN.
    public var appInstanceUserArn: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct CreateAppInstanceUserOutputResponseBody: Swift.Equatable {
    let appInstanceUserArn: Swift.String?
}

extension CreateAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
    }
}

extension DeleteAppInstanceAdminInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        guard let appInstanceAdminArn = appInstanceAdminArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins/\(appInstanceAdminArn.urlPercentEncoding())"
    }
}

public struct DeleteAppInstanceAdminInput: Swift.Equatable {
    /// The ARN of the AppInstance's administrator.
    /// This member is required.
    public var appInstanceAdminArn: Swift.String?
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceAdminArn: Swift.String? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdminArn = appInstanceAdminArn
        self.appInstanceArn = appInstanceArn
    }
}

struct DeleteAppInstanceAdminInputBody: Swift.Equatable {
}

extension DeleteAppInstanceAdminInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceAdminOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppInstanceAdminOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppInstanceAdminOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppInstanceAdminOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppInstanceAdminOutputResponse: Swift.Equatable {

}

extension DeleteAppInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())"
    }
}

public struct DeleteAppInstanceInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct DeleteAppInstanceInputBody: Swift.Equatable {
}

extension DeleteAppInstanceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppInstanceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppInstanceOutputResponse: Swift.Equatable {

}

extension DeleteAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())"
    }
}

public struct DeleteAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the user request being deleted.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct DeleteAppInstanceUserInputBody: Swift.Equatable {
}

extension DeleteAppInstanceUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppInstanceUserOutputResponse: Swift.Equatable {

}

extension DeregisterAppInstanceUserEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        guard let endpointId = endpointId else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())/endpoints/\(endpointId.urlPercentEncoding())"
    }
}

public struct DeregisterAppInstanceUserEndpointInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The unique identifier of the AppInstanceUserEndpoint.
    /// This member is required.
    public var endpointId: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.endpointId = endpointId
    }
}

struct DeregisterAppInstanceUserEndpointInputBody: Swift.Equatable {
}

extension DeregisterAppInstanceUserEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeregisterAppInstanceUserEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterAppInstanceUserEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterAppInstanceUserEndpointOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterAppInstanceUserEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterAppInstanceUserEndpointOutputResponse: Swift.Equatable {

}

extension DescribeAppInstanceAdminInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        guard let appInstanceAdminArn = appInstanceAdminArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins/\(appInstanceAdminArn.urlPercentEncoding())"
    }
}

public struct DescribeAppInstanceAdminInput: Swift.Equatable {
    /// The ARN of the AppInstanceAdmin.
    /// This member is required.
    public var appInstanceAdminArn: Swift.String?
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceAdminArn: Swift.String? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdminArn = appInstanceAdminArn
        self.appInstanceArn = appInstanceArn
    }
}

struct DescribeAppInstanceAdminInputBody: Swift.Equatable {
}

extension DescribeAppInstanceAdminInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceAdminOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppInstanceAdminOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppInstanceAdminOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppInstanceAdminOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppInstanceAdminOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceAdmin = output.appInstanceAdmin
        } else {
            self.appInstanceAdmin = nil
        }
    }
}

public struct DescribeAppInstanceAdminOutputResponse: Swift.Equatable {
    /// The ARN and name of the AppInstanceUser, the ARN of the AppInstance, and the created and last-updated timestamps. All timestamps use epoch milliseconds.
    public var appInstanceAdmin: ChimeSdkIdentityClientTypes.AppInstanceAdmin?

    public init (
        appInstanceAdmin: ChimeSdkIdentityClientTypes.AppInstanceAdmin? = nil
    )
    {
        self.appInstanceAdmin = appInstanceAdmin
    }
}

struct DescribeAppInstanceAdminOutputResponseBody: Swift.Equatable {
    let appInstanceAdmin: ChimeSdkIdentityClientTypes.AppInstanceAdmin?
}

extension DescribeAppInstanceAdminOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdmin = "AppInstanceAdmin"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceAdminDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstanceAdmin.self, forKey: .appInstanceAdmin)
        appInstanceAdmin = appInstanceAdminDecoded
    }
}

extension DescribeAppInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())"
    }
}

public struct DescribeAppInstanceInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct DescribeAppInstanceInputBody: Swift.Equatable {
}

extension DescribeAppInstanceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppInstanceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstance = output.appInstance
        } else {
            self.appInstance = nil
        }
    }
}

public struct DescribeAppInstanceOutputResponse: Swift.Equatable {
    /// The ARN, metadata, created and last-updated timestamps, and the name of the AppInstance. All timestamps use epoch milliseconds.
    public var appInstance: ChimeSdkIdentityClientTypes.AppInstance?

    public init (
        appInstance: ChimeSdkIdentityClientTypes.AppInstance? = nil
    )
    {
        self.appInstance = appInstance
    }
}

struct DescribeAppInstanceOutputResponseBody: Swift.Equatable {
    let appInstance: ChimeSdkIdentityClientTypes.AppInstance?
}

extension DescribeAppInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstance = "AppInstance"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstance.self, forKey: .appInstance)
        appInstance = appInstanceDecoded
    }
}

extension DescribeAppInstanceUserEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        guard let endpointId = endpointId else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())/endpoints/\(endpointId.urlPercentEncoding())"
    }
}

public struct DescribeAppInstanceUserEndpointInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The unique identifier of the AppInstanceUserEndpoint.
    /// This member is required.
    public var endpointId: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.endpointId = endpointId
    }
}

struct DescribeAppInstanceUserEndpointInputBody: Swift.Equatable {
}

extension DescribeAppInstanceUserEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceUserEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppInstanceUserEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppInstanceUserEndpointOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppInstanceUserEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppInstanceUserEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserEndpoint = output.appInstanceUserEndpoint
        } else {
            self.appInstanceUserEndpoint = nil
        }
    }
}

public struct DescribeAppInstanceUserEndpointOutputResponse: Swift.Equatable {
    /// The full details of an AppInstanceUserEndpoint: the AppInstanceUserArn, ID, name, type, resource ARN, attributes, allow messages, state, and created and last updated timestamps. All timestamps use epoch milliseconds.
    public var appInstanceUserEndpoint: ChimeSdkIdentityClientTypes.AppInstanceUserEndpoint?

    public init (
        appInstanceUserEndpoint: ChimeSdkIdentityClientTypes.AppInstanceUserEndpoint? = nil
    )
    {
        self.appInstanceUserEndpoint = appInstanceUserEndpoint
    }
}

struct DescribeAppInstanceUserEndpointOutputResponseBody: Swift.Equatable {
    let appInstanceUserEndpoint: ChimeSdkIdentityClientTypes.AppInstanceUserEndpoint?
}

extension DescribeAppInstanceUserEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserEndpoint = "AppInstanceUserEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserEndpointDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstanceUserEndpoint.self, forKey: .appInstanceUserEndpoint)
        appInstanceUserEndpoint = appInstanceUserEndpointDecoded
    }
}

extension DescribeAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())"
    }
}

public struct DescribeAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct DescribeAppInstanceUserInputBody: Swift.Equatable {
}

extension DescribeAppInstanceUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUser = output.appInstanceUser
        } else {
            self.appInstanceUser = nil
        }
    }
}

public struct DescribeAppInstanceUserOutputResponse: Swift.Equatable {
    /// The name of the AppInstanceUser.
    public var appInstanceUser: ChimeSdkIdentityClientTypes.AppInstanceUser?

    public init (
        appInstanceUser: ChimeSdkIdentityClientTypes.AppInstanceUser? = nil
    )
    {
        self.appInstanceUser = appInstanceUser
    }
}

struct DescribeAppInstanceUserOutputResponseBody: Swift.Equatable {
    let appInstanceUser: ChimeSdkIdentityClientTypes.AppInstanceUser?
}

extension DescribeAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUser = "AppInstanceUser"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstanceUser.self, forKey: .appInstanceUser)
        appInstanceUser = appInstanceUserDecoded
    }
}

extension ChimeSdkIdentityClientTypes.EndpointAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceToken = "DeviceToken"
        case voipDeviceToken = "VoipDeviceToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceToken = deviceToken {
            try encodeContainer.encode(deviceToken, forKey: .deviceToken)
        }
        if let voipDeviceToken = voipDeviceToken {
            try encodeContainer.encode(voipDeviceToken, forKey: .voipDeviceToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceToken)
        deviceToken = deviceTokenDecoded
        let voipDeviceTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voipDeviceToken)
        voipDeviceToken = voipDeviceTokenDecoded
    }
}

extension ChimeSdkIdentityClientTypes {
    /// The attributes of an Endpoint.
    public struct EndpointAttributes: Swift.Equatable {
        /// The device token for the GCM, APNS, and APNS_SANDBOX endpoint types.
        /// This member is required.
        public var deviceToken: Swift.String?
        /// The VOIP device token for the APNS and APNS_SANDBOX endpoint types.
        public var voipDeviceToken: Swift.String?

        public init (
            deviceToken: Swift.String? = nil,
            voipDeviceToken: Swift.String? = nil
        )
        {
            self.deviceToken = deviceToken
            self.voipDeviceToken = voipDeviceToken
        }
    }

}

extension ChimeSdkIdentityClientTypes.EndpointState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason.rawValue, forKey: .statusReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.EndpointStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.EndpointStatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension ChimeSdkIdentityClientTypes {
    /// A read-only field that represents the state of an AppInstanceUserEndpoint. Supported values:
    ///
    /// * ACTIVE: The AppInstanceUserEndpoint is active and able to receive messages. When ACTIVE, the EndpointStatusReason remains empty.
    ///
    /// * INACTIVE: The AppInstanceUserEndpoint is inactive and can't receive message. When INACTIVE, the corresponding reason will be conveyed through EndpointStatusReason.
    ///
    /// * INVALID_DEVICE_TOKEN indicates that an AppInstanceUserEndpoint is INACTIVE due to invalid device token
    ///
    /// * INVALID_PINPOINT_ARN indicates that an AppInstanceUserEndpoint is INACTIVE due to an invalid pinpoint ARN that was input through the ResourceArn field.
    public struct EndpointState: Swift.Equatable {
        /// Enum that indicates the Status of an AppInstanceUserEndpoint.
        /// This member is required.
        public var status: ChimeSdkIdentityClientTypes.EndpointStatus?
        /// The reason for the EndpointStatus.
        public var statusReason: ChimeSdkIdentityClientTypes.EndpointStatusReason?

        public init (
            status: ChimeSdkIdentityClientTypes.EndpointStatus? = nil,
            statusReason: ChimeSdkIdentityClientTypes.EndpointStatusReason? = nil
        )
        {
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension ChimeSdkIdentityClientTypes {
    public enum EndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointStatus(rawValue: rawValue) ?? EndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkIdentityClientTypes {
    public enum EndpointStatusReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidDeviceToken
        case invalidPinpointArn
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointStatusReason] {
            return [
                .invalidDeviceToken,
                .invalidPinpointArn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidDeviceToken: return "INVALID_DEVICE_TOKEN"
            case .invalidPinpointArn: return "INVALID_PINPOINT_ARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointStatusReason(rawValue: rawValue) ?? EndpointStatusReason.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkIdentityClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdenied
        case badrequest
        case conflict
        case forbidden
        case notfound
        case phonenumberassociationsexist
        case preconditionfailed
        case resourcelimitexceeded
        case servicefailure
        case serviceunavailable
        case throttled
        case throttling
        case unauthorized
        case unprocessable
        case voiceconnectorgroupassociationsexist
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessdenied,
                .badrequest,
                .conflict,
                .forbidden,
                .notfound,
                .phonenumberassociationsexist,
                .preconditionfailed,
                .resourcelimitexceeded,
                .servicefailure,
                .serviceunavailable,
                .throttled,
                .throttling,
                .unauthorized,
                .unprocessable,
                .voiceconnectorgroupassociationsexist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "AccessDenied"
            case .badrequest: return "BadRequest"
            case .conflict: return "Conflict"
            case .forbidden: return "Forbidden"
            case .notfound: return "NotFound"
            case .phonenumberassociationsexist: return "PhoneNumberAssociationsExist"
            case .preconditionfailed: return "PreconditionFailed"
            case .resourcelimitexceeded: return "ResourceLimitExceeded"
            case .servicefailure: return "ServiceFailure"
            case .serviceunavailable: return "ServiceUnavailable"
            case .throttled: return "Throttled"
            case .throttling: return "Throttling"
            case .unauthorized: return "Unauthorized"
            case .unprocessable: return "Unprocessable"
            case .voiceconnectorgroupassociationsexist: return "VoiceConnectorGroupAssociationsExist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkIdentityClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let code: ChimeSdkIdentityClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetAppInstanceRetentionSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/retention-settings"
    }
}

public struct GetAppInstanceRetentionSettingsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct GetAppInstanceRetentionSettingsInputBody: Swift.Equatable {
}

extension GetAppInstanceRetentionSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAppInstanceRetentionSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppInstanceRetentionSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAppInstanceRetentionSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppInstanceRetentionSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAppInstanceRetentionSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceRetentionSettings = output.appInstanceRetentionSettings
            self.initiateDeletionTimestamp = output.initiateDeletionTimestamp
        } else {
            self.appInstanceRetentionSettings = nil
            self.initiateDeletionTimestamp = nil
        }
    }
}

public struct GetAppInstanceRetentionSettingsOutputResponse: Swift.Equatable {
    /// The retention settings for the AppInstance.
    public var appInstanceRetentionSettings: ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings?
    /// The timestamp representing the time at which the specified items are retained, in Epoch Seconds.
    public var initiateDeletionTimestamp: ClientRuntime.Date?

    public init (
        appInstanceRetentionSettings: ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings? = nil,
        initiateDeletionTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.appInstanceRetentionSettings = appInstanceRetentionSettings
        self.initiateDeletionTimestamp = initiateDeletionTimestamp
    }
}

struct GetAppInstanceRetentionSettingsOutputResponseBody: Swift.Equatable {
    let appInstanceRetentionSettings: ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings?
    let initiateDeletionTimestamp: ClientRuntime.Date?
}

extension GetAppInstanceRetentionSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
        case initiateDeletionTimestamp = "InitiateDeletionTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings.self, forKey: .appInstanceRetentionSettings)
        appInstanceRetentionSettings = appInstanceRetentionSettingsDecoded
        let initiateDeletionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .initiateDeletionTimestamp)
        initiateDeletionTimestamp = initiateDeletionTimestampDecoded
    }
}

extension ChimeSdkIdentityClientTypes.Identity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ChimeSdkIdentityClientTypes {
    /// The details of a user.
    public struct Identity: Swift.Equatable {
        /// The ARN in an Identity.
        public var arn: Swift.String?
        /// The name in an Identity.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension ListAppInstanceAdminsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAppInstanceAdminsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins"
    }
}

public struct ListAppInstanceAdminsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The maximum number of administrators that you want to return.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of administrators is reached.
    public var nextToken: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstanceAdminsInputBody: Swift.Equatable {
}

extension ListAppInstanceAdminsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstanceAdminsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppInstanceAdminsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppInstanceAdminsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppInstanceAdminsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppInstanceAdminsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceAdmins = output.appInstanceAdmins
            self.appInstanceArn = output.appInstanceArn
            self.nextToken = output.nextToken
        } else {
            self.appInstanceAdmins = nil
            self.appInstanceArn = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstanceAdminsOutputResponse: Swift.Equatable {
    /// The information for each administrator.
    public var appInstanceAdmins: [ChimeSdkIdentityClientTypes.AppInstanceAdminSummary]?
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?
    /// The token returned from previous API requests until the number of administrators is reached.
    public var nextToken: Swift.String?

    public init (
        appInstanceAdmins: [ChimeSdkIdentityClientTypes.AppInstanceAdminSummary]? = nil,
        appInstanceArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceAdmins = appInstanceAdmins
        self.appInstanceArn = appInstanceArn
        self.nextToken = nextToken
    }
}

struct ListAppInstanceAdminsOutputResponseBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
    let appInstanceAdmins: [ChimeSdkIdentityClientTypes.AppInstanceAdminSummary]?
    let nextToken: Swift.String?
}

extension ListAppInstanceAdminsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdmins = "AppInstanceAdmins"
        case appInstanceArn = "AppInstanceArn"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let appInstanceAdminsContainer = try containerValues.decodeIfPresent([ChimeSdkIdentityClientTypes.AppInstanceAdminSummary?].self, forKey: .appInstanceAdmins)
        var appInstanceAdminsDecoded0:[ChimeSdkIdentityClientTypes.AppInstanceAdminSummary]? = nil
        if let appInstanceAdminsContainer = appInstanceAdminsContainer {
            appInstanceAdminsDecoded0 = [ChimeSdkIdentityClientTypes.AppInstanceAdminSummary]()
            for structure0 in appInstanceAdminsContainer {
                if let structure0 = structure0 {
                    appInstanceAdminsDecoded0?.append(structure0)
                }
            }
        }
        appInstanceAdmins = appInstanceAdminsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAppInstanceUserEndpointsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAppInstanceUserEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())/endpoints"
    }
}

public struct ListAppInstanceUserEndpointsInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The maximum number of endpoints that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested endpoints are returned.
    public var nextToken: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstanceUserEndpointsInputBody: Swift.Equatable {
}

extension ListAppInstanceUserEndpointsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstanceUserEndpointsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppInstanceUserEndpointsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppInstanceUserEndpointsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppInstanceUserEndpointsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppInstanceUserEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserEndpoints = output.appInstanceUserEndpoints
            self.nextToken = output.nextToken
        } else {
            self.appInstanceUserEndpoints = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstanceUserEndpointsOutputResponse: Swift.Equatable {
    /// The information for each requested AppInstanceUserEndpoint.
    public var appInstanceUserEndpoints: [ChimeSdkIdentityClientTypes.AppInstanceUserEndpointSummary]?
    /// The token passed by previous API calls until all requested endpoints are returned.
    public var nextToken: Swift.String?

    public init (
        appInstanceUserEndpoints: [ChimeSdkIdentityClientTypes.AppInstanceUserEndpointSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserEndpoints = appInstanceUserEndpoints
        self.nextToken = nextToken
    }
}

struct ListAppInstanceUserEndpointsOutputResponseBody: Swift.Equatable {
    let appInstanceUserEndpoints: [ChimeSdkIdentityClientTypes.AppInstanceUserEndpointSummary]?
    let nextToken: Swift.String?
}

extension ListAppInstanceUserEndpointsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserEndpoints = "AppInstanceUserEndpoints"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserEndpointsContainer = try containerValues.decodeIfPresent([ChimeSdkIdentityClientTypes.AppInstanceUserEndpointSummary?].self, forKey: .appInstanceUserEndpoints)
        var appInstanceUserEndpointsDecoded0:[ChimeSdkIdentityClientTypes.AppInstanceUserEndpointSummary]? = nil
        if let appInstanceUserEndpointsContainer = appInstanceUserEndpointsContainer {
            appInstanceUserEndpointsDecoded0 = [ChimeSdkIdentityClientTypes.AppInstanceUserEndpointSummary]()
            for structure0 in appInstanceUserEndpointsContainer {
                if let structure0 = structure0 {
                    appInstanceUserEndpointsDecoded0?.append(structure0)
                }
            }
        }
        appInstanceUserEndpoints = appInstanceUserEndpointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAppInstanceUsersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let appInstanceArn = appInstanceArn {
            let appInstanceArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-arn".urlPercentEncoding(), value: Swift.String(appInstanceArn).urlPercentEncoding())
            items.append(appInstanceArnQueryItem)
        }
        return items
    }
}

extension ListAppInstanceUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/app-instance-users"
    }
}

public struct ListAppInstanceUsersInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The maximum number of requests that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested users are returned.
    public var nextToken: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstanceUsersInputBody: Swift.Equatable {
}

extension ListAppInstanceUsersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstanceUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppInstanceUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppInstanceUsersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppInstanceUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppInstanceUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceArn = output.appInstanceArn
            self.appInstanceUsers = output.appInstanceUsers
            self.nextToken = output.nextToken
        } else {
            self.appInstanceArn = nil
            self.appInstanceUsers = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstanceUsersOutputResponse: Swift.Equatable {
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?
    /// The information for each requested AppInstanceUser.
    public var appInstanceUsers: [ChimeSdkIdentityClientTypes.AppInstanceUserSummary]?
    /// The token passed by previous API calls until all requested users are returned.
    public var nextToken: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil,
        appInstanceUsers: [ChimeSdkIdentityClientTypes.AppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceUsers = appInstanceUsers
        self.nextToken = nextToken
    }
}

struct ListAppInstanceUsersOutputResponseBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
    let appInstanceUsers: [ChimeSdkIdentityClientTypes.AppInstanceUserSummary]?
    let nextToken: Swift.String?
}

extension ListAppInstanceUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case appInstanceUsers = "AppInstanceUsers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let appInstanceUsersContainer = try containerValues.decodeIfPresent([ChimeSdkIdentityClientTypes.AppInstanceUserSummary?].self, forKey: .appInstanceUsers)
        var appInstanceUsersDecoded0:[ChimeSdkIdentityClientTypes.AppInstanceUserSummary]? = nil
        if let appInstanceUsersContainer = appInstanceUsersContainer {
            appInstanceUsersDecoded0 = [ChimeSdkIdentityClientTypes.AppInstanceUserSummary]()
            for structure0 in appInstanceUsersContainer {
                if let structure0 = structure0 {
                    appInstanceUsersDecoded0?.append(structure0)
                }
            }
        }
        appInstanceUsers = appInstanceUsersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAppInstancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAppInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/app-instances"
    }
}

public struct ListAppInstancesInput: Swift.Equatable {
    /// The maximum number of AppInstances that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API requests until you reach the maximum number of AppInstances.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstancesInputBody: Swift.Equatable {
}

extension ListAppInstancesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppInstancesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAppInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstances = output.appInstances
            self.nextToken = output.nextToken
        } else {
            self.appInstances = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstancesOutputResponse: Swift.Equatable {
    /// The information for each AppInstance.
    public var appInstances: [ChimeSdkIdentityClientTypes.AppInstanceSummary]?
    /// The token passed by previous API requests until the maximum number of AppInstances is reached.
    public var nextToken: Swift.String?

    public init (
        appInstances: [ChimeSdkIdentityClientTypes.AppInstanceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstances = appInstances
        self.nextToken = nextToken
    }
}

struct ListAppInstancesOutputResponseBody: Swift.Equatable {
    let appInstances: [ChimeSdkIdentityClientTypes.AppInstanceSummary]?
    let nextToken: Swift.String?
}

extension ListAppInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstances = "AppInstances"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstancesContainer = try containerValues.decodeIfPresent([ChimeSdkIdentityClientTypes.AppInstanceSummary?].self, forKey: .appInstances)
        var appInstancesDecoded0:[ChimeSdkIdentityClientTypes.AppInstanceSummary]? = nil
        if let appInstancesContainer = appInstancesContainer {
            appInstancesDecoded0 = [ChimeSdkIdentityClientTypes.AppInstanceSummary]()
            for structure0 in appInstancesContainer {
                if let structure0 = structure0 {
                    appInstancesDecoded0?.append(structure0)
                }
            }
        }
        appInstances = appInstancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let resourceARN = resourceARN {
            let resourceARNQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
            items.append(resourceARNQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tag key-value pairs.
    public var tags: [ChimeSdkIdentityClientTypes.Tag]?

    public init (
        tags: [ChimeSdkIdentityClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [ChimeSdkIdentityClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSdkIdentityClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSdkIdentityClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSdkIdentityClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutAppInstanceRetentionSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceRetentionSettings = appInstanceRetentionSettings {
            try encodeContainer.encode(appInstanceRetentionSettings, forKey: .appInstanceRetentionSettings)
        }
    }
}

extension PutAppInstanceRetentionSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/retention-settings"
    }
}

public struct PutAppInstanceRetentionSettingsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The time in days to retain data. Data type: number.
    /// This member is required.
    public var appInstanceRetentionSettings: ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings?

    public init (
        appInstanceArn: Swift.String? = nil,
        appInstanceRetentionSettings: ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceRetentionSettings = appInstanceRetentionSettings
    }
}

struct PutAppInstanceRetentionSettingsInputBody: Swift.Equatable {
    let appInstanceRetentionSettings: ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings?
}

extension PutAppInstanceRetentionSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings.self, forKey: .appInstanceRetentionSettings)
        appInstanceRetentionSettings = appInstanceRetentionSettingsDecoded
    }
}

extension PutAppInstanceRetentionSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAppInstanceRetentionSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAppInstanceRetentionSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAppInstanceRetentionSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutAppInstanceRetentionSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceRetentionSettings = output.appInstanceRetentionSettings
            self.initiateDeletionTimestamp = output.initiateDeletionTimestamp
        } else {
            self.appInstanceRetentionSettings = nil
            self.initiateDeletionTimestamp = nil
        }
    }
}

public struct PutAppInstanceRetentionSettingsOutputResponse: Swift.Equatable {
    /// The time in days to retain data. Data type: number.
    public var appInstanceRetentionSettings: ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings?
    /// The time at which the API deletes data.
    public var initiateDeletionTimestamp: ClientRuntime.Date?

    public init (
        appInstanceRetentionSettings: ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings? = nil,
        initiateDeletionTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.appInstanceRetentionSettings = appInstanceRetentionSettings
        self.initiateDeletionTimestamp = initiateDeletionTimestamp
    }
}

struct PutAppInstanceRetentionSettingsOutputResponseBody: Swift.Equatable {
    let appInstanceRetentionSettings: ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings?
    let initiateDeletionTimestamp: ClientRuntime.Date?
}

extension PutAppInstanceRetentionSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
        case initiateDeletionTimestamp = "InitiateDeletionTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstanceRetentionSettings.self, forKey: .appInstanceRetentionSettings)
        appInstanceRetentionSettings = appInstanceRetentionSettingsDecoded
        let initiateDeletionTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .initiateDeletionTimestamp)
        initiateDeletionTimestamp = initiateDeletionTimestampDecoded
    }
}

extension RegisterAppInstanceUserEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMessages = "AllowMessages"
        case clientRequestToken = "ClientRequestToken"
        case endpointAttributes = "EndpointAttributes"
        case name = "Name"
        case resourceArn = "ResourceArn"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowMessages = allowMessages {
            try encodeContainer.encode(allowMessages.rawValue, forKey: .allowMessages)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let endpointAttributes = endpointAttributes {
            try encodeContainer.encode(endpointAttributes, forKey: .endpointAttributes)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension RegisterAppInstanceUserEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())/endpoints"
    }
}

public struct RegisterAppInstanceUserEndpointInput: Swift.Equatable {
    /// Boolean that controls whether the AppInstanceUserEndpoint is opted in to receive messages. ALL indicates the endpoint receives all messages. NONE indicates the endpoint receives no messages.
    public var allowMessages: ChimeSdkIdentityClientTypes.AllowMessages?
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The idempotency token for each client request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The attributes of an Endpoint.
    /// This member is required.
    public var endpointAttributes: ChimeSdkIdentityClientTypes.EndpointAttributes?
    /// The name of the AppInstanceUserEndpoint.
    public var name: Swift.String?
    /// The ARN of the resource to which the endpoint belongs.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The type of the AppInstanceUserEndpoint. Supported types:
    ///
    /// * APNS: The mobile notification service for an Apple device.
    ///
    /// * APNS_SANDBOX: The sandbox environment of the mobile notification service for an Apple device.
    ///
    /// * GCM: The mobile notification service for an Android device.
    ///
    ///
    /// Populate the ResourceArn value of each type as PinpointAppArn.
    /// This member is required.
    public var type: ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType?

    public init (
        allowMessages: ChimeSdkIdentityClientTypes.AllowMessages? = nil,
        appInstanceUserArn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        endpointAttributes: ChimeSdkIdentityClientTypes.EndpointAttributes? = nil,
        name: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        type: ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType? = nil
    )
    {
        self.allowMessages = allowMessages
        self.appInstanceUserArn = appInstanceUserArn
        self.clientRequestToken = clientRequestToken
        self.endpointAttributes = endpointAttributes
        self.name = name
        self.resourceArn = resourceArn
        self.type = type
    }
}

struct RegisterAppInstanceUserEndpointInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType?
    let resourceArn: Swift.String?
    let endpointAttributes: ChimeSdkIdentityClientTypes.EndpointAttributes?
    let clientRequestToken: Swift.String?
    let allowMessages: ChimeSdkIdentityClientTypes.AllowMessages?
}

extension RegisterAppInstanceUserEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMessages = "AllowMessages"
        case clientRequestToken = "ClientRequestToken"
        case endpointAttributes = "EndpointAttributes"
        case name = "Name"
        case resourceArn = "ResourceArn"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AppInstanceUserEndpointType.self, forKey: .type)
        type = typeDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let endpointAttributesDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.EndpointAttributes.self, forKey: .endpointAttributes)
        endpointAttributes = endpointAttributesDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let allowMessagesDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AllowMessages.self, forKey: .allowMessages)
        allowMessages = allowMessagesDecoded
    }
}

extension RegisterAppInstanceUserEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterAppInstanceUserEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterAppInstanceUserEndpointOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterAppInstanceUserEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterAppInstanceUserEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserArn = output.appInstanceUserArn
            self.endpointId = output.endpointId
        } else {
            self.appInstanceUserArn = nil
            self.endpointId = nil
        }
    }
}

public struct RegisterAppInstanceUserEndpointOutputResponse: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    public var appInstanceUserArn: Swift.String?
    /// The unique identifier of the AppInstanceUserEndpoint.
    public var endpointId: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.endpointId = endpointId
    }
}

struct RegisterAppInstanceUserEndpointOutputResponseBody: Swift.Equatable {
    let appInstanceUserArn: Swift.String?
    let endpointId: Swift.String?
}

extension RegisterAppInstanceUserEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
        case endpointId = "EndpointId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
    }
}

extension ResourceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeds the resource limit.
public struct ResourceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkIdentityClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    let code: ChimeSdkIdentityClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service encountered an unexpected error.
public struct ServiceFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: ChimeSdkIdentityClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceFailureExceptionBody: Swift.Equatable {
    let code: ChimeSdkIdentityClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: ChimeSdkIdentityClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let code: ChimeSdkIdentityClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSdkIdentityClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ChimeSdkIdentityClientTypes {
    /// A tag object containing a key-value pair.
    public struct Tag: Swift.Equatable {
        /// The key in a tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value in a tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "operation", value: "tag-resource"))
        return items
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [ChimeSdkIdentityClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [ChimeSdkIdentityClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [ChimeSdkIdentityClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSdkIdentityClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSdkIdentityClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSdkIdentityClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension ThrottledClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottledClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client exceeded its request rate limit.
public struct ThrottledClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkIdentityClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ThrottledClientExceptionBody: Swift.Equatable {
    let code: ChimeSdkIdentityClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ThrottledClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is not currently authorized to make the request.
public struct UnauthorizedClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkIdentityClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSdkIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UnauthorizedClientExceptionBody: Swift.Equatable {
    let code: ChimeSdkIdentityClientTypes.ErrorCode?
    let message: Swift.String?
}

extension UnauthorizedClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "operation", value: "untag-resource"))
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateAppInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAppInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())"
    }
}

public struct UpdateAppInstanceInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The metadata that you want to change.
    /// This member is required.
    public var metadata: Swift.String?
    /// The name that you want to change.
    /// This member is required.
    public var name: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.metadata = metadata
        self.name = name
    }
}

struct UpdateAppInstanceInputBody: Swift.Equatable {
    let name: Swift.String?
    let metadata: Swift.String?
}

extension UpdateAppInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension UpdateAppInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAppInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAppInstanceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAppInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAppInstanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceArn = output.appInstanceArn
        } else {
            self.appInstanceArn = nil
        }
    }
}

public struct UpdateAppInstanceOutputResponse: Swift.Equatable {
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?

    public init (
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct UpdateAppInstanceOutputResponseBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
}

extension UpdateAppInstanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
    }
}

extension UpdateAppInstanceUserEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMessages = "AllowMessages"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowMessages = allowMessages {
            try encodeContainer.encode(allowMessages.rawValue, forKey: .allowMessages)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAppInstanceUserEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        guard let endpointId = endpointId else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())/endpoints/\(endpointId.urlPercentEncoding())"
    }
}

public struct UpdateAppInstanceUserEndpointInput: Swift.Equatable {
    /// Boolean that controls whether the AppInstanceUserEndpoint is opted in to receive messages. ALL indicates the endpoint will receive all messages. NONE indicates the endpoint will receive no messages.
    public var allowMessages: ChimeSdkIdentityClientTypes.AllowMessages?
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The unique identifier of the AppInstanceUserEndpoint.
    /// This member is required.
    public var endpointId: Swift.String?
    /// The name of the AppInstanceUserEndpoint.
    public var name: Swift.String?

    public init (
        allowMessages: ChimeSdkIdentityClientTypes.AllowMessages? = nil,
        appInstanceUserArn: Swift.String? = nil,
        endpointId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.allowMessages = allowMessages
        self.appInstanceUserArn = appInstanceUserArn
        self.endpointId = endpointId
        self.name = name
    }
}

struct UpdateAppInstanceUserEndpointInputBody: Swift.Equatable {
    let name: Swift.String?
    let allowMessages: ChimeSdkIdentityClientTypes.AllowMessages?
}

extension UpdateAppInstanceUserEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMessages = "AllowMessages"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let allowMessagesDecoded = try containerValues.decodeIfPresent(ChimeSdkIdentityClientTypes.AllowMessages.self, forKey: .allowMessages)
        allowMessages = allowMessagesDecoded
    }
}

extension UpdateAppInstanceUserEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAppInstanceUserEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAppInstanceUserEndpointOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAppInstanceUserEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAppInstanceUserEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserArn = output.appInstanceUserArn
            self.endpointId = output.endpointId
        } else {
            self.appInstanceUserArn = nil
            self.endpointId = nil
        }
    }
}

public struct UpdateAppInstanceUserEndpointOutputResponse: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    public var appInstanceUserArn: Swift.String?
    /// The unique identifier of the AppInstanceUserEndpoint.
    public var endpointId: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.endpointId = endpointId
    }
}

struct UpdateAppInstanceUserEndpointOutputResponseBody: Swift.Equatable {
    let appInstanceUserArn: Swift.String?
    let endpointId: Swift.String?
}

extension UpdateAppInstanceUserEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
        case endpointId = "EndpointId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
    }
}

extension UpdateAppInstanceUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())"
    }
}

public struct UpdateAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The metadata of the AppInstanceUser.
    /// This member is required.
    public var metadata: Swift.String?
    /// The name of the AppInstanceUser.
    /// This member is required.
    public var name: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.metadata = metadata
        self.name = name
    }
}

struct UpdateAppInstanceUserInputBody: Swift.Equatable {
    let name: Swift.String?
    let metadata: Swift.String?
}

extension UpdateAppInstanceUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension UpdateAppInstanceUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAppInstanceUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAppInstanceUserOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAppInstanceUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAppInstanceUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserArn = output.appInstanceUserArn
        } else {
            self.appInstanceUserArn = nil
        }
    }
}

public struct UpdateAppInstanceUserOutputResponse: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    public var appInstanceUserArn: Swift.String?

    public init (
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct UpdateAppInstanceUserOutputResponseBody: Swift.Equatable {
    let appInstanceUserArn: Swift.String?
}

extension UpdateAppInstanceUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
    }
}
