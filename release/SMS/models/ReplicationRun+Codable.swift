// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ReplicationRun: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amiId
        case completedTime
        case description
        case encrypted
        case kmsKeyId
        case replicationRunId
        case scheduledStartTime
        case stageDetails
        case state
        case statusMessage
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiId = amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let completedTime = completedTime {
            try encodeContainer.encode(completedTime.timeIntervalSince1970, forKey: .completedTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let replicationRunId = replicationRunId {
            try encodeContainer.encode(replicationRunId, forKey: .replicationRunId)
        }
        if let scheduledStartTime = scheduledStartTime {
            try encodeContainer.encode(scheduledStartTime.timeIntervalSince1970, forKey: .scheduledStartTime)
        }
        if let stageDetails = stageDetails {
            try encodeContainer.encode(stageDetails, forKey: .stageDetails)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationRunId)
        replicationRunId = replicationRunIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ReplicationRunState.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ReplicationRunType.self, forKey: .type)
        type = typeDecoded
        let stageDetailsDecoded = try containerValues.decodeIfPresent(ReplicationRunStageDetails.self, forKey: .stageDetails)
        stageDetails = stageDetailsDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let amiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let scheduledStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .scheduledStartTime)
        scheduledStartTime = scheduledStartTimeDecoded
        let completedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedTime)
        completedTime = completedTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}
