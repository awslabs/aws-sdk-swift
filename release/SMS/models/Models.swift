// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum AppLaunchConfigurationStatus {
    case configured
    case notconfigured
    case sdkUnknown(String)
}

extension AppLaunchConfigurationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AppLaunchConfigurationStatus] {
        return [
            .configured,
            .notconfigured,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .configured: return "CONFIGURED"
        case .notconfigured: return "NOT_CONFIGURED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AppLaunchConfigurationStatus(rawValue: rawValue) ?? AppLaunchConfigurationStatus.sdkUnknown(rawValue)
    }
}

public enum AppLaunchStatus {
    case configurationinprogress
    case configurationinvalid
    case deltalaunchfailed
    case deltalaunchinprogress
    case launchfailed
    case launchinprogress
    case launchpending
    case launched
    case partiallylaunched
    case readyforconfiguration
    case readyforlaunch
    case terminatefailed
    case terminateinprogress
    case terminated
    case validationinprogress
    case sdkUnknown(String)
}

extension AppLaunchStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AppLaunchStatus] {
        return [
            .configurationinprogress,
            .configurationinvalid,
            .deltalaunchfailed,
            .deltalaunchinprogress,
            .launchfailed,
            .launchinprogress,
            .launchpending,
            .launched,
            .partiallylaunched,
            .readyforconfiguration,
            .readyforlaunch,
            .terminatefailed,
            .terminateinprogress,
            .terminated,
            .validationinprogress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .configurationinprogress: return "CONFIGURATION_IN_PROGRESS"
        case .configurationinvalid: return "CONFIGURATION_INVALID"
        case .deltalaunchfailed: return "DELTA_LAUNCH_FAILED"
        case .deltalaunchinprogress: return "DELTA_LAUNCH_IN_PROGRESS"
        case .launchfailed: return "LAUNCH_FAILED"
        case .launchinprogress: return "LAUNCH_IN_PROGRESS"
        case .launchpending: return "LAUNCH_PENDING"
        case .launched: return "LAUNCHED"
        case .partiallylaunched: return "PARTIALLY_LAUNCHED"
        case .readyforconfiguration: return "READY_FOR_CONFIGURATION"
        case .readyforlaunch: return "READY_FOR_LAUNCH"
        case .terminatefailed: return "TERMINATE_FAILED"
        case .terminateinprogress: return "TERMINATE_IN_PROGRESS"
        case .terminated: return "TERMINATED"
        case .validationinprogress: return "VALIDATION_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AppLaunchStatus(rawValue: rawValue) ?? AppLaunchStatus.sdkUnknown(rawValue)
    }
}

public enum AppReplicationConfigurationStatus {
    case configured
    case notconfigured
    case sdkUnknown(String)
}

extension AppReplicationConfigurationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AppReplicationConfigurationStatus] {
        return [
            .configured,
            .notconfigured,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .configured: return "CONFIGURED"
        case .notconfigured: return "NOT_CONFIGURED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AppReplicationConfigurationStatus(rawValue: rawValue) ?? AppReplicationConfigurationStatus.sdkUnknown(rawValue)
    }
}

public enum AppReplicationStatus {
    case configurationinprogress
    case configurationinvalid
    case deltareplicated
    case deltareplicationfailed
    case deltareplicationinprogress
    case partiallyreplicated
    case readyforconfiguration
    case readyforreplication
    case replicated
    case replicationfailed
    case replicationinprogress
    case replicationpending
    case replicationstopfailed
    case replicationstopped
    case replicationstopping
    case validationinprogress
    case sdkUnknown(String)
}

extension AppReplicationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AppReplicationStatus] {
        return [
            .configurationinprogress,
            .configurationinvalid,
            .deltareplicated,
            .deltareplicationfailed,
            .deltareplicationinprogress,
            .partiallyreplicated,
            .readyforconfiguration,
            .readyforreplication,
            .replicated,
            .replicationfailed,
            .replicationinprogress,
            .replicationpending,
            .replicationstopfailed,
            .replicationstopped,
            .replicationstopping,
            .validationinprogress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .configurationinprogress: return "CONFIGURATION_IN_PROGRESS"
        case .configurationinvalid: return "CONFIGURATION_INVALID"
        case .deltareplicated: return "DELTA_REPLICATED"
        case .deltareplicationfailed: return "DELTA_REPLICATION_FAILED"
        case .deltareplicationinprogress: return "DELTA_REPLICATION_IN_PROGRESS"
        case .partiallyreplicated: return "PARTIALLY_REPLICATED"
        case .readyforconfiguration: return "READY_FOR_CONFIGURATION"
        case .readyforreplication: return "READY_FOR_REPLICATION"
        case .replicated: return "REPLICATED"
        case .replicationfailed: return "REPLICATION_FAILED"
        case .replicationinprogress: return "REPLICATION_IN_PROGRESS"
        case .replicationpending: return "REPLICATION_PENDING"
        case .replicationstopfailed: return "REPLICATION_STOP_FAILED"
        case .replicationstopped: return "REPLICATION_STOPPED"
        case .replicationstopping: return "REPLICATION_STOPPING"
        case .validationinprogress: return "VALIDATION_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AppReplicationStatus(rawValue: rawValue) ?? AppReplicationStatus.sdkUnknown(rawValue)
    }
}

public enum AppStatus {
    case active
    case creating
    case deleteFailed
    case deleted
    case deleting
    case updating
    case sdkUnknown(String)
}

extension AppStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AppStatus] {
        return [
            .active,
            .creating,
            .deleteFailed,
            .deleted,
            .deleting,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleted: return "DELETED"
        case .deleting: return "DELETING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AppStatus(rawValue: rawValue) ?? AppStatus.sdkUnknown(rawValue)
    }
}

extension AppSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
        case creationTime
        case description
        case importedAppId
        case lastModified
        case latestReplicationTime
        case launchConfigurationStatus
        case launchDetails
        case launchStatus
        case launchStatusMessage
        case name
        case replicationConfigurationStatus
        case replicationStatus
        case replicationStatusMessage
        case roleName
        case status
        case statusMessage
        case totalServerGroups
        case totalServers
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let importedAppId = importedAppId {
            try encodeContainer.encode(importedAppId, forKey: .importedAppId)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified.timeIntervalSince1970, forKey: .lastModified)
        }
        if let latestReplicationTime = latestReplicationTime {
            try encodeContainer.encode(latestReplicationTime.timeIntervalSince1970, forKey: .latestReplicationTime)
        }
        if let launchConfigurationStatus = launchConfigurationStatus {
            try encodeContainer.encode(launchConfigurationStatus.rawValue, forKey: .launchConfigurationStatus)
        }
        if let launchDetails = launchDetails {
            try encodeContainer.encode(launchDetails, forKey: .launchDetails)
        }
        if let launchStatus = launchStatus {
            try encodeContainer.encode(launchStatus.rawValue, forKey: .launchStatus)
        }
        if let launchStatusMessage = launchStatusMessage {
            try encodeContainer.encode(launchStatusMessage, forKey: .launchStatusMessage)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let replicationConfigurationStatus = replicationConfigurationStatus {
            try encodeContainer.encode(replicationConfigurationStatus.rawValue, forKey: .replicationConfigurationStatus)
        }
        if let replicationStatus = replicationStatus {
            try encodeContainer.encode(replicationStatus.rawValue, forKey: .replicationStatus)
        }
        if let replicationStatusMessage = replicationStatusMessage {
            try encodeContainer.encode(replicationStatusMessage, forKey: .replicationStatusMessage)
        }
        if let roleName = roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let totalServerGroups = totalServerGroups {
            try encodeContainer.encode(totalServerGroups, forKey: .totalServerGroups)
        }
        if let totalServers = totalServers {
            try encodeContainer.encode(totalServers, forKey: .totalServers)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let importedAppIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .importedAppId)
        importedAppId = importedAppIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let replicationConfigurationStatusDecoded = try containerValues.decodeIfPresent(AppReplicationConfigurationStatus.self, forKey: .replicationConfigurationStatus)
        replicationConfigurationStatus = replicationConfigurationStatusDecoded
        let replicationStatusDecoded = try containerValues.decodeIfPresent(AppReplicationStatus.self, forKey: .replicationStatus)
        replicationStatus = replicationStatusDecoded
        let replicationStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationStatusMessage)
        replicationStatusMessage = replicationStatusMessageDecoded
        let latestReplicationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .latestReplicationTime)
        latestReplicationTime = latestReplicationTimeDecoded
        let launchConfigurationStatusDecoded = try containerValues.decodeIfPresent(AppLaunchConfigurationStatus.self, forKey: .launchConfigurationStatus)
        launchConfigurationStatus = launchConfigurationStatusDecoded
        let launchStatusDecoded = try containerValues.decodeIfPresent(AppLaunchStatus.self, forKey: .launchStatus)
        launchStatus = launchStatusDecoded
        let launchStatusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchStatusMessage)
        launchStatusMessage = launchStatusMessageDecoded
        let launchDetailsDecoded = try containerValues.decodeIfPresent(LaunchDetails.self, forKey: .launchDetails)
        launchDetails = launchDetailsDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let totalServerGroupsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalServerGroups)
        totalServerGroups = totalServerGroupsDecoded
        let totalServersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalServers)
        totalServers = totalServersDecoded
    }
}

extension AppSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AppSummary(appId: \(String(describing: appId)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), importedAppId: \(String(describing: importedAppId)), lastModified: \(String(describing: lastModified)), latestReplicationTime: \(String(describing: latestReplicationTime)), launchConfigurationStatus: \(String(describing: launchConfigurationStatus)), launchDetails: \(String(describing: launchDetails)), launchStatus: \(String(describing: launchStatus)), launchStatusMessage: \(String(describing: launchStatusMessage)), name: \(String(describing: name)), replicationConfigurationStatus: \(String(describing: replicationConfigurationStatus)), replicationStatus: \(String(describing: replicationStatus)), replicationStatusMessage: \(String(describing: replicationStatusMessage)), roleName: \(String(describing: roleName)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), totalServerGroups: \(String(describing: totalServerGroups)), totalServers: \(String(describing: totalServers)))"}
}

/// <p>Information about the application.</p>
public struct AppSummary: Equatable {
    /// <p>The unique ID of the application.</p>
    public let appId: String?
    /// <p>The creation time of the application.</p>
    public let creationTime: Date?
    /// <p>The description of the application.</p>
    public let description: String?
    /// <p>The ID of the application.</p>
    public let importedAppId: String?
    /// <p>The last modified time of the application.</p>
    public let lastModified: Date?
    /// <p>The timestamp of the application's most recent successful replication.</p>
    public let latestReplicationTime: Date?
    /// <p>Status of the launch configuration.</p>
    public let launchConfigurationStatus: AppLaunchConfigurationStatus?
    /// <p>Details about the latest launch of the application.</p>
    public let launchDetails: LaunchDetails?
    /// <p>The launch status of the application.</p>
    public let launchStatus: AppLaunchStatus?
    /// <p>A message related to the launch status of the application.</p>
    public let launchStatusMessage: String?
    /// <p>The name of the application.</p>
    public let name: String?
    /// <p>Status of the replication configuration.</p>
    public let replicationConfigurationStatus: AppReplicationConfigurationStatus?
    /// <p>The replication status of the application.</p>
    public let replicationStatus: AppReplicationStatus?
    /// <p>A message related to the replication status of the application.</p>
    public let replicationStatusMessage: String?
    /// <p>The name of the service role in the customer's account used by AWS SMS.</p>
    public let roleName: String?
    /// <p>Status of the application.</p>
    public let status: AppStatus?
    /// <p>A message related to the status of the application</p>
    public let statusMessage: String?
    /// <p>The number of server groups present in the application.</p>
    public let totalServerGroups: Int?
    /// <p>The number of servers present in the application.</p>
    public let totalServers: Int?

    public init (
        appId: String? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        importedAppId: String? = nil,
        lastModified: Date? = nil,
        latestReplicationTime: Date? = nil,
        launchConfigurationStatus: AppLaunchConfigurationStatus? = nil,
        launchDetails: LaunchDetails? = nil,
        launchStatus: AppLaunchStatus? = nil,
        launchStatusMessage: String? = nil,
        name: String? = nil,
        replicationConfigurationStatus: AppReplicationConfigurationStatus? = nil,
        replicationStatus: AppReplicationStatus? = nil,
        replicationStatusMessage: String? = nil,
        roleName: String? = nil,
        status: AppStatus? = nil,
        statusMessage: String? = nil,
        totalServerGroups: Int? = nil,
        totalServers: Int? = nil
    )
    {
        self.appId = appId
        self.creationTime = creationTime
        self.description = description
        self.importedAppId = importedAppId
        self.lastModified = lastModified
        self.latestReplicationTime = latestReplicationTime
        self.launchConfigurationStatus = launchConfigurationStatus
        self.launchDetails = launchDetails
        self.launchStatus = launchStatus
        self.launchStatusMessage = launchStatusMessage
        self.name = name
        self.replicationConfigurationStatus = replicationConfigurationStatus
        self.replicationStatus = replicationStatus
        self.replicationStatusMessage = replicationStatusMessage
        self.roleName = roleName
        self.status = status
        self.statusMessage = statusMessage
        self.totalServerGroups = totalServerGroups
        self.totalServers = totalServers
    }
}

extension AppValidationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appValidationStrategy
        case name
        case ssmValidationParameters
        case validationId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appValidationStrategy = appValidationStrategy {
            try encodeContainer.encode(appValidationStrategy.rawValue, forKey: .appValidationStrategy)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ssmValidationParameters = ssmValidationParameters {
            try encodeContainer.encode(ssmValidationParameters, forKey: .ssmValidationParameters)
        }
        if let validationId = validationId {
            try encodeContainer.encode(validationId, forKey: .validationId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validationId)
        validationId = validationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let appValidationStrategyDecoded = try containerValues.decodeIfPresent(AppValidationStrategy.self, forKey: .appValidationStrategy)
        appValidationStrategy = appValidationStrategyDecoded
        let ssmValidationParametersDecoded = try containerValues.decodeIfPresent(SSMValidationParameters.self, forKey: .ssmValidationParameters)
        ssmValidationParameters = ssmValidationParametersDecoded
    }
}

extension AppValidationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AppValidationConfiguration(appValidationStrategy: \(String(describing: appValidationStrategy)), name: \(String(describing: name)), ssmValidationParameters: \(String(describing: ssmValidationParameters)), validationId: \(String(describing: validationId)))"}
}

/// <p>Configuration for validating an application.</p>
public struct AppValidationConfiguration: Equatable {
    /// <p>The validation strategy.</p>
    public let appValidationStrategy: AppValidationStrategy?
    /// <p>The name of the configuration.</p>
    public let name: String?
    /// <p>The validation parameters.</p>
    public let ssmValidationParameters: SSMValidationParameters?
    /// <p>The ID of the validation.</p>
    public let validationId: String?

    public init (
        appValidationStrategy: AppValidationStrategy? = nil,
        name: String? = nil,
        ssmValidationParameters: SSMValidationParameters? = nil,
        validationId: String? = nil
    )
    {
        self.appValidationStrategy = appValidationStrategy
        self.name = name
        self.ssmValidationParameters = ssmValidationParameters
        self.validationId = validationId
    }
}

extension AppValidationOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ssmOutput
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ssmOutput = ssmOutput {
            try encodeContainer.encode(ssmOutput, forKey: .ssmOutput)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ssmOutputDecoded = try containerValues.decodeIfPresent(SSMOutput.self, forKey: .ssmOutput)
        ssmOutput = ssmOutputDecoded
    }
}

extension AppValidationOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AppValidationOutput(ssmOutput: \(String(describing: ssmOutput)))"}
}

/// <p>Output from validating an application.</p>
public struct AppValidationOutput: Equatable {
    /// <p>Output from using SSM to validate the application.</p>
    public let ssmOutput: SSMOutput?

    public init (
        ssmOutput: SSMOutput? = nil
    )
    {
        self.ssmOutput = ssmOutput
    }
}

public enum AppValidationStrategy {
    case ssm
    case sdkUnknown(String)
}

extension AppValidationStrategy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AppValidationStrategy] {
        return [
            .ssm,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ssm: return "SSM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AppValidationStrategy(rawValue: rawValue) ?? AppValidationStrategy.sdkUnknown(rawValue)
    }
}

extension Connector: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associatedOn
        case capabilityList
        case connectorId
        case ipAddress
        case macAddress
        case status
        case version
        case vmManagerId
        case vmManagerName
        case vmManagerType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedOn = associatedOn {
            try encodeContainer.encode(associatedOn.timeIntervalSince1970, forKey: .associatedOn)
        }
        if let capabilityList = capabilityList {
            var capabilityListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilityList)
            for connectorcapabilitylist0 in capabilityList {
                try capabilityListContainer.encode(connectorcapabilitylist0.rawValue)
            }
        }
        if let connectorId = connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let macAddress = macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let vmManagerId = vmManagerId {
            try encodeContainer.encode(vmManagerId, forKey: .vmManagerId)
        }
        if let vmManagerName = vmManagerName {
            try encodeContainer.encode(vmManagerName, forKey: .vmManagerName)
        }
        if let vmManagerType = vmManagerType {
            try encodeContainer.encode(vmManagerType.rawValue, forKey: .vmManagerType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectorStatus.self, forKey: .status)
        status = statusDecoded
        let capabilityListContainer = try containerValues.decodeIfPresent([ConnectorCapability?].self, forKey: .capabilityList)
        var capabilityListDecoded0:[ConnectorCapability]? = nil
        if let capabilityListContainer = capabilityListContainer {
            capabilityListDecoded0 = [ConnectorCapability]()
            for string0 in capabilityListContainer {
                if let string0 = string0 {
                    capabilityListDecoded0?.append(string0)
                }
            }
        }
        capabilityList = capabilityListDecoded0
        let vmManagerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vmManagerName)
        vmManagerName = vmManagerNameDecoded
        let vmManagerTypeDecoded = try containerValues.decodeIfPresent(VmManagerType.self, forKey: .vmManagerType)
        vmManagerType = vmManagerTypeDecoded
        let vmManagerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vmManagerId)
        vmManagerId = vmManagerIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let macAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let associatedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .associatedOn)
        associatedOn = associatedOnDecoded
    }
}

extension Connector: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Connector(associatedOn: \(String(describing: associatedOn)), capabilityList: \(String(describing: capabilityList)), connectorId: \(String(describing: connectorId)), ipAddress: \(String(describing: ipAddress)), macAddress: \(String(describing: macAddress)), status: \(String(describing: status)), version: \(String(describing: version)), vmManagerId: \(String(describing: vmManagerId)), vmManagerName: \(String(describing: vmManagerName)), vmManagerType: \(String(describing: vmManagerType)))"}
}

/// <p>Represents a connector.</p>
public struct Connector: Equatable {
    /// <p>The time the connector was associated.</p>
    public let associatedOn: Date?
    /// <p>The capabilities of the connector.</p>
    public let capabilityList: [ConnectorCapability]?
    /// <p>The ID of the connector.</p>
    public let connectorId: String?
    /// <p>The IP address of the connector.</p>
    public let ipAddress: String?
    /// <p>The MAC address of the connector.</p>
    public let macAddress: String?
    /// <p>The status of the connector.</p>
    public let status: ConnectorStatus?
    /// <p>The connector version.</p>
    public let version: String?
    /// <p>The ID of the VM manager.</p>
    public let vmManagerId: String?
    /// <p>The name of the VM manager.</p>
    public let vmManagerName: String?
    /// <p>The VM management product.</p>
    public let vmManagerType: VmManagerType?

    public init (
        associatedOn: Date? = nil,
        capabilityList: [ConnectorCapability]? = nil,
        connectorId: String? = nil,
        ipAddress: String? = nil,
        macAddress: String? = nil,
        status: ConnectorStatus? = nil,
        version: String? = nil,
        vmManagerId: String? = nil,
        vmManagerName: String? = nil,
        vmManagerType: VmManagerType? = nil
    )
    {
        self.associatedOn = associatedOn
        self.capabilityList = capabilityList
        self.connectorId = connectorId
        self.ipAddress = ipAddress
        self.macAddress = macAddress
        self.status = status
        self.version = version
        self.vmManagerId = vmManagerId
        self.vmManagerName = vmManagerName
        self.vmManagerType = vmManagerType
    }
}

public enum ConnectorCapability {
    case hypervmanager
    case scvmm
    case smsoptimized
    case snapshotbatching
    case vsphere
    case sdkUnknown(String)
}

extension ConnectorCapability : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectorCapability] {
        return [
            .hypervmanager,
            .scvmm,
            .smsoptimized,
            .snapshotbatching,
            .vsphere,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .hypervmanager: return "HYPERV-MANAGER"
        case .scvmm: return "SCVMM"
        case .smsoptimized: return "SMS_OPTIMIZED"
        case .snapshotbatching: return "SNAPSHOT_BATCHING"
        case .vsphere: return "VSPHERE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectorCapability(rawValue: rawValue) ?? ConnectorCapability.sdkUnknown(rawValue)
    }
}

public enum ConnectorStatus {
    case healthy
    case unhealthy
    case sdkUnknown(String)
}

extension ConnectorStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectorStatus] {
        return [
            .healthy,
            .unhealthy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .healthy: return "HEALTHY"
        case .unhealthy: return "UNHEALTHY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectorStatus(rawValue: rawValue) ?? ConnectorStatus.sdkUnknown(rawValue)
    }
}

public struct CreateAppInputBodyMiddleware: Middleware {
    public let id: String = "CreateAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAppInput>
    public typealias MOutput = OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAppOutputError>
}

extension CreateAppInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAppInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), name: \(String(describing: name)), roleName: \(String(describing: roleName)), serverGroups: \(String(describing: serverGroups)), tags: \(String(describing: tags)))"}
}

extension CreateAppInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case description
        case name
        case roleName
        case serverGroups
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleName = roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let serverGroups = serverGroups {
            var serverGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverGroups)
            for servergroups0 in serverGroups {
                try serverGroupsContainer.encode(servergroups0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateAppInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAppInput>
    public typealias MOutput = OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAppOutputError>
}

public struct CreateAppInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAppInput>
    public typealias MOutput = OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAppOutputError>
}

public struct CreateAppInput: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of
    ///             application creation.</p>
    public let clientToken: String?
    /// <p>The description of the new application</p>
    public let description: String?
    /// <p>The name of the new application.</p>
    public let name: String?
    /// <p>The name of the service role in the customer's account to be used by AWS SMS.</p>
    public let roleName: String?
    /// <p>The server groups to include in the application.</p>
    public let serverGroups: [ServerGroup]?
    /// <p>The tags to be associated with the application.</p>
    public let tags: [Tag]?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        name: String? = nil,
        roleName: String? = nil,
        serverGroups: [ServerGroup]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.roleName = roleName
        self.serverGroups = serverGroups
        self.tags = tags
    }
}

struct CreateAppInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let roleName: String?
    public let clientToken: String?
    public let serverGroups: [ServerGroup]?
    public let tags: [Tag]?
}

extension CreateAppInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case description
        case name
        case roleName
        case serverGroups
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let serverGroupsContainer = try containerValues.decodeIfPresent([ServerGroup?].self, forKey: .serverGroups)
        var serverGroupsDecoded0:[ServerGroup]? = nil
        if let serverGroupsContainer = serverGroupsContainer {
            serverGroupsDecoded0 = [ServerGroup]()
            for structure0 in serverGroupsContainer {
                if let structure0 = structure0 {
                    serverGroupsDecoded0?.append(structure0)
                }
            }
        }
        serverGroups = serverGroupsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAppOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAppOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAppOutputResponse(appSummary: \(String(describing: appSummary)), serverGroups: \(String(describing: serverGroups)), tags: \(String(describing: tags)))"}
}

extension CreateAppOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAppOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appSummary = output.appSummary
            self.serverGroups = output.serverGroups
            self.tags = output.tags
        } else {
            self.appSummary = nil
            self.serverGroups = nil
            self.tags = nil
        }
    }
}

public struct CreateAppOutputResponse: Equatable {
    /// <p>A summary description of the application.</p>
    public let appSummary: AppSummary?
    /// <p>The server groups included in the application.</p>
    public let serverGroups: [ServerGroup]?
    /// <p>The tags associated with the application.</p>
    public let tags: [Tag]?

    public init (
        appSummary: AppSummary? = nil,
        serverGroups: [ServerGroup]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.appSummary = appSummary
        self.serverGroups = serverGroups
        self.tags = tags
    }
}

struct CreateAppOutputResponseBody: Equatable {
    public let appSummary: AppSummary?
    public let serverGroups: [ServerGroup]?
    public let tags: [Tag]?
}

extension CreateAppOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appSummary
        case serverGroups
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appSummaryDecoded = try containerValues.decodeIfPresent(AppSummary.self, forKey: .appSummary)
        appSummary = appSummaryDecoded
        let serverGroupsContainer = try containerValues.decodeIfPresent([ServerGroup?].self, forKey: .serverGroups)
        var serverGroupsDecoded0:[ServerGroup]? = nil
        if let serverGroupsContainer = serverGroupsContainer {
            serverGroupsDecoded0 = [ServerGroup]()
            for structure0 in serverGroupsContainer {
                if let structure0 = structure0 {
                    serverGroupsDecoded0?.append(structure0)
                }
            }
        }
        serverGroups = serverGroupsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateReplicationJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateReplicationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReplicationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReplicationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReplicationJobInput>
    public typealias MOutput = OperationOutput<CreateReplicationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReplicationJobOutputError>
}

extension CreateReplicationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReplicationJobInput(description: \(String(describing: description)), encrypted: \(String(describing: encrypted)), frequency: \(String(describing: frequency)), kmsKeyId: \(String(describing: kmsKeyId)), licenseType: \(String(describing: licenseType)), numberOfRecentAmisToKeep: \(String(describing: numberOfRecentAmisToKeep)), roleName: \(String(describing: roleName)), runOnce: \(String(describing: runOnce)), seedReplicationTime: \(String(describing: seedReplicationTime)), serverId: \(String(describing: serverId)))"}
}

extension CreateReplicationJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case encrypted
        case frequency
        case kmsKeyId
        case licenseType
        case numberOfRecentAmisToKeep
        case roleName
        case runOnce
        case seedReplicationTime
        case serverId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency, forKey: .frequency)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let licenseType = licenseType {
            try encodeContainer.encode(licenseType.rawValue, forKey: .licenseType)
        }
        if let numberOfRecentAmisToKeep = numberOfRecentAmisToKeep {
            try encodeContainer.encode(numberOfRecentAmisToKeep, forKey: .numberOfRecentAmisToKeep)
        }
        if let roleName = roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let runOnce = runOnce {
            try encodeContainer.encode(runOnce, forKey: .runOnce)
        }
        if let seedReplicationTime = seedReplicationTime {
            try encodeContainer.encode(seedReplicationTime.timeIntervalSince1970, forKey: .seedReplicationTime)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct CreateReplicationJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateReplicationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReplicationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReplicationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReplicationJobInput>
    public typealias MOutput = OperationOutput<CreateReplicationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReplicationJobOutputError>
}

public struct CreateReplicationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateReplicationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReplicationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReplicationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReplicationJobInput>
    public typealias MOutput = OperationOutput<CreateReplicationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReplicationJobOutputError>
}

public struct CreateReplicationJobInput: Equatable {
    /// <p>The description of the replication job.</p>
    public let description: String?
    /// <p>Indicates whether the replication job produces encrypted AMIs.</p>
    public let encrypted: Bool?
    /// <p>The time between consecutive replication runs, in hours.</p>
    public let frequency: Int?
    /// <p>The ID of the KMS key for replication jobs that produce encrypted AMIs.
    ///             This value can be any of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>KMS key ID</p>
    ///             </li>
    ///             <li>
    ///                 <p>KMS key alias</p>
    ///             </li>
    ///             <li>
    ///                 <p>ARN referring to the KMS key ID</p>
    ///             </li>
    ///             <li>
    ///                 <p>ARN referring to the KMS key alias</p>
    ///             </li>
    ///          </ul>
    ///         <p> If encrypted is <i>true</i> but a KMS key ID is not specified, the
    ///             customer's default KMS key for Amazon EBS is used. </p>
    public let kmsKeyId: String?
    /// <p>The license type to be used for the AMI created by a successful replication
    ///             run.</p>
    public let licenseType: LicenseType?
    /// <p>The maximum number of SMS-created AMIs to retain. The oldest is deleted after the
    ///             maximum number is reached and a new AMI is created.</p>
    public let numberOfRecentAmisToKeep: Int?
    /// <p>The name of the IAM role to be used by the AWS SMS.</p>
    public let roleName: String?
    /// <p>Indicates whether to run the replication job one time.</p>
    public let runOnce: Bool?
    /// <p>The seed replication time.</p>
    public let seedReplicationTime: Date?
    /// <p>The ID of the server.</p>
    public let serverId: String?

    public init (
        description: String? = nil,
        encrypted: Bool? = nil,
        frequency: Int? = nil,
        kmsKeyId: String? = nil,
        licenseType: LicenseType? = nil,
        numberOfRecentAmisToKeep: Int? = nil,
        roleName: String? = nil,
        runOnce: Bool? = nil,
        seedReplicationTime: Date? = nil,
        serverId: String? = nil
    )
    {
        self.description = description
        self.encrypted = encrypted
        self.frequency = frequency
        self.kmsKeyId = kmsKeyId
        self.licenseType = licenseType
        self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
        self.roleName = roleName
        self.runOnce = runOnce
        self.seedReplicationTime = seedReplicationTime
        self.serverId = serverId
    }
}

struct CreateReplicationJobInputBody: Equatable {
    public let serverId: String?
    public let seedReplicationTime: Date?
    public let frequency: Int?
    public let runOnce: Bool?
    public let licenseType: LicenseType?
    public let roleName: String?
    public let description: String?
    public let numberOfRecentAmisToKeep: Int?
    public let encrypted: Bool?
    public let kmsKeyId: String?
}

extension CreateReplicationJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case encrypted
        case frequency
        case kmsKeyId
        case licenseType
        case numberOfRecentAmisToKeep
        case roleName
        case runOnce
        case seedReplicationTime
        case serverId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let seedReplicationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .seedReplicationTime)
        seedReplicationTime = seedReplicationTimeDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .frequency)
        frequency = frequencyDecoded
        let runOnceDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .runOnce)
        runOnce = runOnceDecoded
        let licenseTypeDecoded = try containerValues.decodeIfPresent(LicenseType.self, forKey: .licenseType)
        licenseType = licenseTypeDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let numberOfRecentAmisToKeepDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfRecentAmisToKeep)
        numberOfRecentAmisToKeep = numberOfRecentAmisToKeepDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension CreateReplicationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReplicationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoConnectorsAvailableException" : self = .noConnectorsAvailableException(try NoConnectorsAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplicationJobAlreadyExistsException" : self = .replicationJobAlreadyExistsException(try ReplicationJobAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerCannotBeReplicatedException" : self = .serverCannotBeReplicatedException(try ServerCannotBeReplicatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemporarilyUnavailableException" : self = .temporarilyUnavailableException(try TemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReplicationJobOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case noConnectorsAvailableException(NoConnectorsAvailableException)
    case operationNotPermittedException(OperationNotPermittedException)
    case replicationJobAlreadyExistsException(ReplicationJobAlreadyExistsException)
    case serverCannotBeReplicatedException(ServerCannotBeReplicatedException)
    case temporarilyUnavailableException(TemporarilyUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReplicationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReplicationJobOutputResponse(replicationJobId: \(String(describing: replicationJobId)))"}
}

extension CreateReplicationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateReplicationJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationJobId = output.replicationJobId
        } else {
            self.replicationJobId = nil
        }
    }
}

public struct CreateReplicationJobOutputResponse: Equatable {
    /// <p>The unique identifier of the replication job.</p>
    public let replicationJobId: String?

    public init (
        replicationJobId: String? = nil
    )
    {
        self.replicationJobId = replicationJobId
    }
}

struct CreateReplicationJobOutputResponseBody: Equatable {
    public let replicationJobId: String?
}

extension CreateReplicationJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationJobId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationJobId)
        replicationJobId = replicationJobIdDecoded
    }
}

public struct DeleteAppInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppInput>
    public typealias MOutput = OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppOutputError>
}

extension DeleteAppInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAppInput(appId: \(String(describing: appId)), forceStopAppReplication: \(String(describing: forceStopAppReplication)), forceTerminateApp: \(String(describing: forceTerminateApp)))"}
}

extension DeleteAppInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
        case forceStopAppReplication
        case forceTerminateApp
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let forceStopAppReplication = forceStopAppReplication {
            try encodeContainer.encode(forceStopAppReplication, forKey: .forceStopAppReplication)
        }
        if let forceTerminateApp = forceTerminateApp {
            try encodeContainer.encode(forceTerminateApp, forKey: .forceTerminateApp)
        }
    }
}

public struct DeleteAppInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppInput>
    public typealias MOutput = OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppOutputError>
}

public struct DeleteAppInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppInput>
    public typealias MOutput = OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppOutputError>
}

public struct DeleteAppInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?
    /// <p>Indicates whether to stop all replication jobs corresponding to the servers
    ///             in the application while deleting the application.</p>
    public let forceStopAppReplication: Bool?
    /// <p>Indicates whether to terminate the stack corresponding to the
    ///             application while deleting the application.</p>
    public let forceTerminateApp: Bool?

    public init (
        appId: String? = nil,
        forceStopAppReplication: Bool? = nil,
        forceTerminateApp: Bool? = nil
    )
    {
        self.appId = appId
        self.forceStopAppReplication = forceStopAppReplication
        self.forceTerminateApp = forceTerminateApp
    }
}

struct DeleteAppInputBody: Equatable {
    public let appId: String?
    public let forceStopAppReplication: Bool?
    public let forceTerminateApp: Bool?
}

extension DeleteAppInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
        case forceStopAppReplication
        case forceTerminateApp
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let forceStopAppReplicationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .forceStopAppReplication)
        forceStopAppReplication = forceStopAppReplicationDecoded
        let forceTerminateAppDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .forceTerminateApp)
        forceTerminateApp = forceTerminateAppDecoded
    }
}

public struct DeleteAppLaunchConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAppLaunchConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppLaunchConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppLaunchConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppLaunchConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteAppLaunchConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppLaunchConfigurationOutputError>
}

extension DeleteAppLaunchConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAppLaunchConfigurationInput(appId: \(String(describing: appId)))"}
}

extension DeleteAppLaunchConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

public struct DeleteAppLaunchConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAppLaunchConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppLaunchConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppLaunchConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppLaunchConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteAppLaunchConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppLaunchConfigurationOutputError>
}

public struct DeleteAppLaunchConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAppLaunchConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppLaunchConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppLaunchConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppLaunchConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteAppLaunchConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppLaunchConfigurationOutputError>
}

public struct DeleteAppLaunchConfigurationInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?

    public init (
        appId: String? = nil
    )
    {
        self.appId = appId
    }
}

struct DeleteAppLaunchConfigurationInputBody: Equatable {
    public let appId: String?
}

extension DeleteAppLaunchConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension DeleteAppLaunchConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppLaunchConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppLaunchConfigurationOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppLaunchConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAppLaunchConfigurationOutputResponse()"}
}

extension DeleteAppLaunchConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppLaunchConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteAppLaunchConfigurationOutputResponseBody: Equatable {
}

extension DeleteAppLaunchConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAppOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAppOutputResponse()"}
}

extension DeleteAppOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppOutputResponse: Equatable {

    public init() {}
}

struct DeleteAppOutputResponseBody: Equatable {
}

extension DeleteAppOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteAppReplicationConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAppReplicationConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppReplicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppReplicationConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteAppReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppReplicationConfigurationOutputError>
}

extension DeleteAppReplicationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAppReplicationConfigurationInput(appId: \(String(describing: appId)))"}
}

extension DeleteAppReplicationConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

public struct DeleteAppReplicationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAppReplicationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppReplicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppReplicationConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteAppReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppReplicationConfigurationOutputError>
}

public struct DeleteAppReplicationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAppReplicationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppReplicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppReplicationConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteAppReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppReplicationConfigurationOutputError>
}

public struct DeleteAppReplicationConfigurationInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?

    public init (
        appId: String? = nil
    )
    {
        self.appId = appId
    }
}

struct DeleteAppReplicationConfigurationInputBody: Equatable {
    public let appId: String?
}

extension DeleteAppReplicationConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension DeleteAppReplicationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppReplicationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppReplicationConfigurationOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppReplicationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAppReplicationConfigurationOutputResponse()"}
}

extension DeleteAppReplicationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppReplicationConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteAppReplicationConfigurationOutputResponseBody: Equatable {
}

extension DeleteAppReplicationConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteAppValidationConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAppValidationConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppValidationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppValidationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppValidationConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteAppValidationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppValidationConfigurationOutputError>
}

extension DeleteAppValidationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAppValidationConfigurationInput(appId: \(String(describing: appId)))"}
}

extension DeleteAppValidationConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

public struct DeleteAppValidationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAppValidationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppValidationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppValidationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppValidationConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteAppValidationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppValidationConfigurationOutputError>
}

public struct DeleteAppValidationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAppValidationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppValidationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppValidationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppValidationConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteAppValidationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppValidationConfigurationOutputError>
}

public struct DeleteAppValidationConfigurationInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?

    public init (
        appId: String? = nil
    )
    {
        self.appId = appId
    }
}

struct DeleteAppValidationConfigurationInputBody: Equatable {
    public let appId: String?
}

extension DeleteAppValidationConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension DeleteAppValidationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppValidationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppValidationConfigurationOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppValidationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAppValidationConfigurationOutputResponse()"}
}

extension DeleteAppValidationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppValidationConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteAppValidationConfigurationOutputResponseBody: Equatable {
}

extension DeleteAppValidationConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteReplicationJobInputBodyMiddleware: Middleware {
    public let id: String = "DeleteReplicationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationJobInput>
    public typealias MOutput = OperationOutput<DeleteReplicationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationJobOutputError>
}

extension DeleteReplicationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReplicationJobInput(replicationJobId: \(String(describing: replicationJobId)))"}
}

extension DeleteReplicationJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicationJobId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationJobId = replicationJobId {
            try encodeContainer.encode(replicationJobId, forKey: .replicationJobId)
        }
    }
}

public struct DeleteReplicationJobInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteReplicationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationJobInput>
    public typealias MOutput = OperationOutput<DeleteReplicationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationJobOutputError>
}

public struct DeleteReplicationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteReplicationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationJobInput>
    public typealias MOutput = OperationOutput<DeleteReplicationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationJobOutputError>
}

public struct DeleteReplicationJobInput: Equatable {
    /// <p>The ID of the replication job.</p>
    public let replicationJobId: String?

    public init (
        replicationJobId: String? = nil
    )
    {
        self.replicationJobId = replicationJobId
    }
}

struct DeleteReplicationJobInputBody: Equatable {
    public let replicationJobId: String?
}

extension DeleteReplicationJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationJobId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationJobId)
        replicationJobId = replicationJobIdDecoded
    }
}

extension DeleteReplicationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplicationJobNotFoundException" : self = .replicationJobNotFoundException(try ReplicationJobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReplicationJobOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case replicationJobNotFoundException(ReplicationJobNotFoundException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReplicationJobOutputResponse()"}
}

extension DeleteReplicationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteReplicationJobOutputResponse: Equatable {

    public init() {}
}

struct DeleteReplicationJobOutputResponseBody: Equatable {
}

extension DeleteReplicationJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteServerCatalogInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServerCatalogInput()"}
}

extension DeleteServerCatalogInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteServerCatalogInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteServerCatalogInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServerCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServerCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServerCatalogInput>
    public typealias MOutput = OperationOutput<DeleteServerCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServerCatalogOutputError>
}

public struct DeleteServerCatalogInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteServerCatalogInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServerCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServerCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServerCatalogInput>
    public typealias MOutput = OperationOutput<DeleteServerCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServerCatalogOutputError>
}

public struct DeleteServerCatalogInput: Equatable {

    public init() {}
}

struct DeleteServerCatalogInputBody: Equatable {
}

extension DeleteServerCatalogInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteServerCatalogOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServerCatalogOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServerCatalogOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServerCatalogOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServerCatalogOutputResponse()"}
}

extension DeleteServerCatalogOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServerCatalogOutputResponse: Equatable {

    public init() {}
}

struct DeleteServerCatalogOutputResponseBody: Equatable {
}

extension DeleteServerCatalogOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateConnectorInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateConnectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateConnectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateConnectorInput>
    public typealias MOutput = OperationOutput<DisassociateConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateConnectorOutputError>
}

extension DisassociateConnectorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateConnectorInput(connectorId: \(String(describing: connectorId)))"}
}

extension DisassociateConnectorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectorId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorId = connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
    }
}

public struct DisassociateConnectorInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateConnectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateConnectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateConnectorInput>
    public typealias MOutput = OperationOutput<DisassociateConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateConnectorOutputError>
}

public struct DisassociateConnectorInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateConnectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateConnectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateConnectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateConnectorInput>
    public typealias MOutput = OperationOutput<DisassociateConnectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateConnectorOutputError>
}

public struct DisassociateConnectorInput: Equatable {
    /// <p>The ID of the connector.</p>
    public let connectorId: String?

    public init (
        connectorId: String? = nil
    )
    {
        self.connectorId = connectorId
    }
}

struct DisassociateConnectorInputBody: Equatable {
    public let connectorId: String?
}

extension DisassociateConnectorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectorId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
    }
}

extension DisassociateConnectorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateConnectorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateConnectorOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateConnectorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateConnectorOutputResponse()"}
}

extension DisassociateConnectorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateConnectorOutputResponse: Equatable {

    public init() {}
}

struct DisassociateConnectorOutputResponseBody: Equatable {
}

extension DisassociateConnectorOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DryRunOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DryRunOperationException(message: \(String(describing: message)))"}
}

extension DryRunOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DryRunOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user has the required permissions, so the request would have succeeded,
///             but a dry run was performed.</p>
public struct DryRunOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DryRunOperationExceptionBody: Equatable {
    public let message: String?
}

extension DryRunOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GenerateChangeSetInputBodyMiddleware: Middleware {
    public let id: String = "GenerateChangeSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateChangeSetInput>
    public typealias MOutput = OperationOutput<GenerateChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateChangeSetOutputError>
}

extension GenerateChangeSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateChangeSetInput(appId: \(String(describing: appId)), changesetFormat: \(String(describing: changesetFormat)))"}
}

extension GenerateChangeSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
        case changesetFormat
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let changesetFormat = changesetFormat {
            try encodeContainer.encode(changesetFormat.rawValue, forKey: .changesetFormat)
        }
    }
}

public struct GenerateChangeSetInputHeadersMiddleware: Middleware {
    public let id: String = "GenerateChangeSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateChangeSetInput>
    public typealias MOutput = OperationOutput<GenerateChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateChangeSetOutputError>
}

public struct GenerateChangeSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GenerateChangeSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateChangeSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateChangeSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateChangeSetInput>
    public typealias MOutput = OperationOutput<GenerateChangeSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateChangeSetOutputError>
}

public struct GenerateChangeSetInput: Equatable {
    /// <p>The ID of the application associated with the change set.</p>
    public let appId: String?
    /// <p>The format for the change set.</p>
    public let changesetFormat: OutputFormat?

    public init (
        appId: String? = nil,
        changesetFormat: OutputFormat? = nil
    )
    {
        self.appId = appId
        self.changesetFormat = changesetFormat
    }
}

struct GenerateChangeSetInputBody: Equatable {
    public let appId: String?
    public let changesetFormat: OutputFormat?
}

extension GenerateChangeSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
        case changesetFormat
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let changesetFormatDecoded = try containerValues.decodeIfPresent(OutputFormat.self, forKey: .changesetFormat)
        changesetFormat = changesetFormatDecoded
    }
}

extension GenerateChangeSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GenerateChangeSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GenerateChangeSetOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateChangeSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateChangeSetOutputResponse(s3Location: \(String(describing: s3Location)))"}
}

extension GenerateChangeSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GenerateChangeSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.s3Location = output.s3Location
        } else {
            self.s3Location = nil
        }
    }
}

public struct GenerateChangeSetOutputResponse: Equatable {
    /// <p>The location of the Amazon S3 object.</p>
    public let s3Location: S3Location?

    public init (
        s3Location: S3Location? = nil
    )
    {
        self.s3Location = s3Location
    }
}

struct GenerateChangeSetOutputResponseBody: Equatable {
    public let s3Location: S3Location?
}

extension GenerateChangeSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case s3Location
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

public struct GenerateTemplateInputBodyMiddleware: Middleware {
    public let id: String = "GenerateTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateTemplateInput>
    public typealias MOutput = OperationOutput<GenerateTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateTemplateOutputError>
}

extension GenerateTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateTemplateInput(appId: \(String(describing: appId)), templateFormat: \(String(describing: templateFormat)))"}
}

extension GenerateTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
        case templateFormat
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let templateFormat = templateFormat {
            try encodeContainer.encode(templateFormat.rawValue, forKey: .templateFormat)
        }
    }
}

public struct GenerateTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GenerateTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateTemplateInput>
    public typealias MOutput = OperationOutput<GenerateTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateTemplateOutputError>
}

public struct GenerateTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GenerateTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GenerateTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GenerateTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GenerateTemplateInput>
    public typealias MOutput = OperationOutput<GenerateTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GenerateTemplateOutputError>
}

public struct GenerateTemplateInput: Equatable {
    /// <p>The ID of the application associated with the AWS CloudFormation template.</p>
    public let appId: String?
    /// <p>The format for generating the AWS CloudFormation template.</p>
    public let templateFormat: OutputFormat?

    public init (
        appId: String? = nil,
        templateFormat: OutputFormat? = nil
    )
    {
        self.appId = appId
        self.templateFormat = templateFormat
    }
}

struct GenerateTemplateInputBody: Equatable {
    public let appId: String?
    public let templateFormat: OutputFormat?
}

extension GenerateTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
        case templateFormat
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let templateFormatDecoded = try containerValues.decodeIfPresent(OutputFormat.self, forKey: .templateFormat)
        templateFormat = templateFormatDecoded
    }
}

extension GenerateTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GenerateTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GenerateTemplateOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GenerateTemplateOutputResponse(s3Location: \(String(describing: s3Location)))"}
}

extension GenerateTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GenerateTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.s3Location = output.s3Location
        } else {
            self.s3Location = nil
        }
    }
}

public struct GenerateTemplateOutputResponse: Equatable {
    /// <p>The location of the Amazon S3 object.</p>
    public let s3Location: S3Location?

    public init (
        s3Location: S3Location? = nil
    )
    {
        self.s3Location = s3Location
    }
}

struct GenerateTemplateOutputResponseBody: Equatable {
    public let s3Location: S3Location?
}

extension GenerateTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case s3Location
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

public struct GetAppInputBodyMiddleware: Middleware {
    public let id: String = "GetAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppInput>
    public typealias MOutput = OperationOutput<GetAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppOutputError>
}

extension GetAppInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppInput(appId: \(String(describing: appId)))"}
}

extension GetAppInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

public struct GetAppInputHeadersMiddleware: Middleware {
    public let id: String = "GetAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppInput>
    public typealias MOutput = OperationOutput<GetAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppOutputError>
}

public struct GetAppInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppInput>
    public typealias MOutput = OperationOutput<GetAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppOutputError>
}

public struct GetAppInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?

    public init (
        appId: String? = nil
    )
    {
        self.appId = appId
    }
}

struct GetAppInputBody: Equatable {
    public let appId: String?
}

extension GetAppInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

public struct GetAppLaunchConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "GetAppLaunchConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppLaunchConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppLaunchConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppLaunchConfigurationInput>
    public typealias MOutput = OperationOutput<GetAppLaunchConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppLaunchConfigurationOutputError>
}

extension GetAppLaunchConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppLaunchConfigurationInput(appId: \(String(describing: appId)))"}
}

extension GetAppLaunchConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

public struct GetAppLaunchConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetAppLaunchConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppLaunchConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppLaunchConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppLaunchConfigurationInput>
    public typealias MOutput = OperationOutput<GetAppLaunchConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppLaunchConfigurationOutputError>
}

public struct GetAppLaunchConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAppLaunchConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppLaunchConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppLaunchConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppLaunchConfigurationInput>
    public typealias MOutput = OperationOutput<GetAppLaunchConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppLaunchConfigurationOutputError>
}

public struct GetAppLaunchConfigurationInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?

    public init (
        appId: String? = nil
    )
    {
        self.appId = appId
    }
}

struct GetAppLaunchConfigurationInputBody: Equatable {
    public let appId: String?
}

extension GetAppLaunchConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension GetAppLaunchConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppLaunchConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAppLaunchConfigurationOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppLaunchConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppLaunchConfigurationOutputResponse(appId: \(String(describing: appId)), autoLaunch: \(String(describing: autoLaunch)), roleName: \(String(describing: roleName)), serverGroupLaunchConfigurations: \(String(describing: serverGroupLaunchConfigurations)))"}
}

extension GetAppLaunchConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAppLaunchConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appId = output.appId
            self.autoLaunch = output.autoLaunch
            self.roleName = output.roleName
            self.serverGroupLaunchConfigurations = output.serverGroupLaunchConfigurations
        } else {
            self.appId = nil
            self.autoLaunch = nil
            self.roleName = nil
            self.serverGroupLaunchConfigurations = nil
        }
    }
}

public struct GetAppLaunchConfigurationOutputResponse: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?
    /// <p>Indicates whether the application is configured to launch automatically after replication is complete.</p>
    public let autoLaunch: Bool?
    /// <p>The name of the service role in the customer's account that AWS CloudFormation uses to launch the
    ///             application.</p>
    public let roleName: String?
    /// <p>The launch configurations for server groups in this application.</p>
    public let serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]?

    public init (
        appId: String? = nil,
        autoLaunch: Bool? = nil,
        roleName: String? = nil,
        serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]? = nil
    )
    {
        self.appId = appId
        self.autoLaunch = autoLaunch
        self.roleName = roleName
        self.serverGroupLaunchConfigurations = serverGroupLaunchConfigurations
    }
}

struct GetAppLaunchConfigurationOutputResponseBody: Equatable {
    public let appId: String?
    public let roleName: String?
    public let autoLaunch: Bool?
    public let serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]?
}

extension GetAppLaunchConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
        case autoLaunch
        case roleName
        case serverGroupLaunchConfigurations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let autoLaunchDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoLaunch)
        autoLaunch = autoLaunchDecoded
        let serverGroupLaunchConfigurationsContainer = try containerValues.decodeIfPresent([ServerGroupLaunchConfiguration?].self, forKey: .serverGroupLaunchConfigurations)
        var serverGroupLaunchConfigurationsDecoded0:[ServerGroupLaunchConfiguration]? = nil
        if let serverGroupLaunchConfigurationsContainer = serverGroupLaunchConfigurationsContainer {
            serverGroupLaunchConfigurationsDecoded0 = [ServerGroupLaunchConfiguration]()
            for structure0 in serverGroupLaunchConfigurationsContainer {
                if let structure0 = structure0 {
                    serverGroupLaunchConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        serverGroupLaunchConfigurations = serverGroupLaunchConfigurationsDecoded0
    }
}

extension GetAppOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAppOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppOutputResponse(appSummary: \(String(describing: appSummary)), serverGroups: \(String(describing: serverGroups)), tags: \(String(describing: tags)))"}
}

extension GetAppOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAppOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appSummary = output.appSummary
            self.serverGroups = output.serverGroups
            self.tags = output.tags
        } else {
            self.appSummary = nil
            self.serverGroups = nil
            self.tags = nil
        }
    }
}

public struct GetAppOutputResponse: Equatable {
    /// <p>Information about the application.</p>
    public let appSummary: AppSummary?
    /// <p>The server groups that belong to the application.</p>
    public let serverGroups: [ServerGroup]?
    /// <p>The tags associated with the application.</p>
    public let tags: [Tag]?

    public init (
        appSummary: AppSummary? = nil,
        serverGroups: [ServerGroup]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.appSummary = appSummary
        self.serverGroups = serverGroups
        self.tags = tags
    }
}

struct GetAppOutputResponseBody: Equatable {
    public let appSummary: AppSummary?
    public let serverGroups: [ServerGroup]?
    public let tags: [Tag]?
}

extension GetAppOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appSummary
        case serverGroups
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appSummaryDecoded = try containerValues.decodeIfPresent(AppSummary.self, forKey: .appSummary)
        appSummary = appSummaryDecoded
        let serverGroupsContainer = try containerValues.decodeIfPresent([ServerGroup?].self, forKey: .serverGroups)
        var serverGroupsDecoded0:[ServerGroup]? = nil
        if let serverGroupsContainer = serverGroupsContainer {
            serverGroupsDecoded0 = [ServerGroup]()
            for structure0 in serverGroupsContainer {
                if let structure0 = structure0 {
                    serverGroupsDecoded0?.append(structure0)
                }
            }
        }
        serverGroups = serverGroupsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct GetAppReplicationConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "GetAppReplicationConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppReplicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppReplicationConfigurationInput>
    public typealias MOutput = OperationOutput<GetAppReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppReplicationConfigurationOutputError>
}

extension GetAppReplicationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppReplicationConfigurationInput(appId: \(String(describing: appId)))"}
}

extension GetAppReplicationConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

public struct GetAppReplicationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetAppReplicationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppReplicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppReplicationConfigurationInput>
    public typealias MOutput = OperationOutput<GetAppReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppReplicationConfigurationOutputError>
}

public struct GetAppReplicationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAppReplicationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppReplicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppReplicationConfigurationInput>
    public typealias MOutput = OperationOutput<GetAppReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppReplicationConfigurationOutputError>
}

public struct GetAppReplicationConfigurationInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?

    public init (
        appId: String? = nil
    )
    {
        self.appId = appId
    }
}

struct GetAppReplicationConfigurationInputBody: Equatable {
    public let appId: String?
}

extension GetAppReplicationConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension GetAppReplicationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppReplicationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAppReplicationConfigurationOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppReplicationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppReplicationConfigurationOutputResponse(serverGroupReplicationConfigurations: \(String(describing: serverGroupReplicationConfigurations)))"}
}

extension GetAppReplicationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAppReplicationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serverGroupReplicationConfigurations = output.serverGroupReplicationConfigurations
        } else {
            self.serverGroupReplicationConfigurations = nil
        }
    }
}

public struct GetAppReplicationConfigurationOutputResponse: Equatable {
    /// <p>The replication configurations associated with server groups in this application.</p>
    public let serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]?

    public init (
        serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]? = nil
    )
    {
        self.serverGroupReplicationConfigurations = serverGroupReplicationConfigurations
    }
}

struct GetAppReplicationConfigurationOutputResponseBody: Equatable {
    public let serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]?
}

extension GetAppReplicationConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverGroupReplicationConfigurations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverGroupReplicationConfigurationsContainer = try containerValues.decodeIfPresent([ServerGroupReplicationConfiguration?].self, forKey: .serverGroupReplicationConfigurations)
        var serverGroupReplicationConfigurationsDecoded0:[ServerGroupReplicationConfiguration]? = nil
        if let serverGroupReplicationConfigurationsContainer = serverGroupReplicationConfigurationsContainer {
            serverGroupReplicationConfigurationsDecoded0 = [ServerGroupReplicationConfiguration]()
            for structure0 in serverGroupReplicationConfigurationsContainer {
                if let structure0 = structure0 {
                    serverGroupReplicationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        serverGroupReplicationConfigurations = serverGroupReplicationConfigurationsDecoded0
    }
}

public struct GetAppValidationConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "GetAppValidationConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppValidationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppValidationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppValidationConfigurationInput>
    public typealias MOutput = OperationOutput<GetAppValidationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppValidationConfigurationOutputError>
}

extension GetAppValidationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppValidationConfigurationInput(appId: \(String(describing: appId)))"}
}

extension GetAppValidationConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

public struct GetAppValidationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetAppValidationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppValidationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppValidationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppValidationConfigurationInput>
    public typealias MOutput = OperationOutput<GetAppValidationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppValidationConfigurationOutputError>
}

public struct GetAppValidationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAppValidationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppValidationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppValidationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppValidationConfigurationInput>
    public typealias MOutput = OperationOutput<GetAppValidationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppValidationConfigurationOutputError>
}

public struct GetAppValidationConfigurationInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?

    public init (
        appId: String? = nil
    )
    {
        self.appId = appId
    }
}

struct GetAppValidationConfigurationInputBody: Equatable {
    public let appId: String?
}

extension GetAppValidationConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension GetAppValidationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppValidationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAppValidationConfigurationOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppValidationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppValidationConfigurationOutputResponse(appValidationConfigurations: \(String(describing: appValidationConfigurations)), serverGroupValidationConfigurations: \(String(describing: serverGroupValidationConfigurations)))"}
}

extension GetAppValidationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAppValidationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appValidationConfigurations = output.appValidationConfigurations
            self.serverGroupValidationConfigurations = output.serverGroupValidationConfigurations
        } else {
            self.appValidationConfigurations = nil
            self.serverGroupValidationConfigurations = nil
        }
    }
}

public struct GetAppValidationConfigurationOutputResponse: Equatable {
    /// <p>The configuration for application validation.</p>
    public let appValidationConfigurations: [AppValidationConfiguration]?
    /// <p>The configuration for instance validation.</p>
    public let serverGroupValidationConfigurations: [ServerGroupValidationConfiguration]?

    public init (
        appValidationConfigurations: [AppValidationConfiguration]? = nil,
        serverGroupValidationConfigurations: [ServerGroupValidationConfiguration]? = nil
    )
    {
        self.appValidationConfigurations = appValidationConfigurations
        self.serverGroupValidationConfigurations = serverGroupValidationConfigurations
    }
}

struct GetAppValidationConfigurationOutputResponseBody: Equatable {
    public let appValidationConfigurations: [AppValidationConfiguration]?
    public let serverGroupValidationConfigurations: [ServerGroupValidationConfiguration]?
}

extension GetAppValidationConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appValidationConfigurations
        case serverGroupValidationConfigurations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appValidationConfigurationsContainer = try containerValues.decodeIfPresent([AppValidationConfiguration?].self, forKey: .appValidationConfigurations)
        var appValidationConfigurationsDecoded0:[AppValidationConfiguration]? = nil
        if let appValidationConfigurationsContainer = appValidationConfigurationsContainer {
            appValidationConfigurationsDecoded0 = [AppValidationConfiguration]()
            for structure0 in appValidationConfigurationsContainer {
                if let structure0 = structure0 {
                    appValidationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        appValidationConfigurations = appValidationConfigurationsDecoded0
        let serverGroupValidationConfigurationsContainer = try containerValues.decodeIfPresent([ServerGroupValidationConfiguration?].self, forKey: .serverGroupValidationConfigurations)
        var serverGroupValidationConfigurationsDecoded0:[ServerGroupValidationConfiguration]? = nil
        if let serverGroupValidationConfigurationsContainer = serverGroupValidationConfigurationsContainer {
            serverGroupValidationConfigurationsDecoded0 = [ServerGroupValidationConfiguration]()
            for structure0 in serverGroupValidationConfigurationsContainer {
                if let structure0 = structure0 {
                    serverGroupValidationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        serverGroupValidationConfigurations = serverGroupValidationConfigurationsDecoded0
    }
}

public struct GetAppValidationOutputInputBodyMiddleware: Middleware {
    public let id: String = "GetAppValidationOutputInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppValidationOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppValidationOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppValidationOutputInput>
    public typealias MOutput = OperationOutput<GetAppValidationOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppValidationOutputOutputError>
}

extension GetAppValidationOutputInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppValidationOutputInput(appId: \(String(describing: appId)))"}
}

extension GetAppValidationOutputInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

public struct GetAppValidationOutputInputHeadersMiddleware: Middleware {
    public let id: String = "GetAppValidationOutputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppValidationOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppValidationOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppValidationOutputInput>
    public typealias MOutput = OperationOutput<GetAppValidationOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppValidationOutputOutputError>
}

public struct GetAppValidationOutputInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAppValidationOutputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppValidationOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppValidationOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppValidationOutputInput>
    public typealias MOutput = OperationOutput<GetAppValidationOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppValidationOutputOutputError>
}

public struct GetAppValidationOutputInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?

    public init (
        appId: String? = nil
    )
    {
        self.appId = appId
    }
}

struct GetAppValidationOutputInputBody: Equatable {
    public let appId: String?
}

extension GetAppValidationOutputInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension GetAppValidationOutputOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppValidationOutputOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAppValidationOutputOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppValidationOutputOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppValidationOutputOutputResponse(validationOutputList: \(String(describing: validationOutputList)))"}
}

extension GetAppValidationOutputOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAppValidationOutputOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.validationOutputList = output.validationOutputList
        } else {
            self.validationOutputList = nil
        }
    }
}

public struct GetAppValidationOutputOutputResponse: Equatable {
    /// <p>The validation output.</p>
    public let validationOutputList: [ValidationOutput]?

    public init (
        validationOutputList: [ValidationOutput]? = nil
    )
    {
        self.validationOutputList = validationOutputList
    }
}

struct GetAppValidationOutputOutputResponseBody: Equatable {
    public let validationOutputList: [ValidationOutput]?
}

extension GetAppValidationOutputOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case validationOutputList
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validationOutputListContainer = try containerValues.decodeIfPresent([ValidationOutput?].self, forKey: .validationOutputList)
        var validationOutputListDecoded0:[ValidationOutput]? = nil
        if let validationOutputListContainer = validationOutputListContainer {
            validationOutputListDecoded0 = [ValidationOutput]()
            for structure0 in validationOutputListContainer {
                if let structure0 = structure0 {
                    validationOutputListDecoded0?.append(structure0)
                }
            }
        }
        validationOutputList = validationOutputListDecoded0
    }
}

public struct GetConnectorsInputBodyMiddleware: Middleware {
    public let id: String = "GetConnectorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectorsInput>
    public typealias MOutput = OperationOutput<GetConnectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectorsOutputError>
}

extension GetConnectorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectorsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetConnectorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetConnectorsInputHeadersMiddleware: Middleware {
    public let id: String = "GetConnectorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectorsInput>
    public typealias MOutput = OperationOutput<GetConnectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectorsOutputError>
}

public struct GetConnectorsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConnectorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectorsInput>
    public typealias MOutput = OperationOutput<GetConnectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectorsOutputError>
}

public struct GetConnectorsInput: Equatable {
    /// <p>The maximum number of results to return in a single call. The default value is 50.
    ///             To retrieve the remaining results, make another call with the returned
    ///                 <code>NextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetConnectorsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetConnectorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetConnectorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConnectorsOutputError: Equatable {
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectorsOutputResponse(connectorList: \(String(describing: connectorList)), nextToken: \(String(describing: nextToken)))"}
}

extension GetConnectorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConnectorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connectorList = output.connectorList
            self.nextToken = output.nextToken
        } else {
            self.connectorList = nil
            self.nextToken = nil
        }
    }
}

public struct GetConnectorsOutputResponse: Equatable {
    /// <p>Information about the registered connectors.</p>
    public let connectorList: [Connector]?
    /// <p>The token required to retrieve the next set of results. This value is null when
    ///             there are no more results to return.</p>
    public let nextToken: String?

    public init (
        connectorList: [Connector]? = nil,
        nextToken: String? = nil
    )
    {
        self.connectorList = connectorList
        self.nextToken = nextToken
    }
}

struct GetConnectorsOutputResponseBody: Equatable {
    public let connectorList: [Connector]?
    public let nextToken: String?
}

extension GetConnectorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectorList
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorListContainer = try containerValues.decodeIfPresent([Connector?].self, forKey: .connectorList)
        var connectorListDecoded0:[Connector]? = nil
        if let connectorListContainer = connectorListContainer {
            connectorListDecoded0 = [Connector]()
            for structure0 in connectorListContainer {
                if let structure0 = structure0 {
                    connectorListDecoded0?.append(structure0)
                }
            }
        }
        connectorList = connectorListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetReplicationJobsInputBodyMiddleware: Middleware {
    public let id: String = "GetReplicationJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReplicationJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReplicationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReplicationJobsInput>
    public typealias MOutput = OperationOutput<GetReplicationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReplicationJobsOutputError>
}

extension GetReplicationJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReplicationJobsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), replicationJobId: \(String(describing: replicationJobId)))"}
}

extension GetReplicationJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case replicationJobId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let replicationJobId = replicationJobId {
            try encodeContainer.encode(replicationJobId, forKey: .replicationJobId)
        }
    }
}

public struct GetReplicationJobsInputHeadersMiddleware: Middleware {
    public let id: String = "GetReplicationJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReplicationJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReplicationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReplicationJobsInput>
    public typealias MOutput = OperationOutput<GetReplicationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReplicationJobsOutputError>
}

public struct GetReplicationJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetReplicationJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReplicationJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReplicationJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReplicationJobsInput>
    public typealias MOutput = OperationOutput<GetReplicationJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReplicationJobsOutputError>
}

public struct GetReplicationJobsInput: Equatable {
    /// <p>The maximum number of results to return in a single call. The default value is 50.
    ///             To retrieve the remaining results, make another call with the returned
    ///                 <code>NextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?
    /// <p>The ID of the replication job.</p>
    public let replicationJobId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        replicationJobId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.replicationJobId = replicationJobId
    }
}

struct GetReplicationJobsInputBody: Equatable {
    public let replicationJobId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetReplicationJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case replicationJobId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationJobId)
        replicationJobId = replicationJobIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetReplicationJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReplicationJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReplicationJobsOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReplicationJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReplicationJobsOutputResponse(nextToken: \(String(describing: nextToken)), replicationJobList: \(String(describing: replicationJobList)))"}
}

extension GetReplicationJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetReplicationJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.replicationJobList = output.replicationJobList
        } else {
            self.nextToken = nil
            self.replicationJobList = nil
        }
    }
}

public struct GetReplicationJobsOutputResponse: Equatable {
    /// <p>The token required to retrieve the next set of results. This value is null when
    ///             there are no more results to return.</p>
    public let nextToken: String?
    /// <p>Information about the replication jobs.</p>
    public let replicationJobList: [ReplicationJob]?

    public init (
        nextToken: String? = nil,
        replicationJobList: [ReplicationJob]? = nil
    )
    {
        self.nextToken = nextToken
        self.replicationJobList = replicationJobList
    }
}

struct GetReplicationJobsOutputResponseBody: Equatable {
    public let replicationJobList: [ReplicationJob]?
    public let nextToken: String?
}

extension GetReplicationJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case replicationJobList
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationJobListContainer = try containerValues.decodeIfPresent([ReplicationJob?].self, forKey: .replicationJobList)
        var replicationJobListDecoded0:[ReplicationJob]? = nil
        if let replicationJobListContainer = replicationJobListContainer {
            replicationJobListDecoded0 = [ReplicationJob]()
            for structure0 in replicationJobListContainer {
                if let structure0 = structure0 {
                    replicationJobListDecoded0?.append(structure0)
                }
            }
        }
        replicationJobList = replicationJobListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetReplicationRunsInputBodyMiddleware: Middleware {
    public let id: String = "GetReplicationRunsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReplicationRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReplicationRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReplicationRunsInput>
    public typealias MOutput = OperationOutput<GetReplicationRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReplicationRunsOutputError>
}

extension GetReplicationRunsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReplicationRunsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), replicationJobId: \(String(describing: replicationJobId)))"}
}

extension GetReplicationRunsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case replicationJobId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let replicationJobId = replicationJobId {
            try encodeContainer.encode(replicationJobId, forKey: .replicationJobId)
        }
    }
}

public struct GetReplicationRunsInputHeadersMiddleware: Middleware {
    public let id: String = "GetReplicationRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReplicationRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReplicationRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReplicationRunsInput>
    public typealias MOutput = OperationOutput<GetReplicationRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReplicationRunsOutputError>
}

public struct GetReplicationRunsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetReplicationRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReplicationRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReplicationRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReplicationRunsInput>
    public typealias MOutput = OperationOutput<GetReplicationRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReplicationRunsOutputError>
}

public struct GetReplicationRunsInput: Equatable {
    /// <p>The maximum number of results to return in a single call. The default value is 50.
    ///             To retrieve the remaining results, make another call with the returned
    ///                 <code>NextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?
    /// <p>The ID of the replication job.</p>
    public let replicationJobId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        replicationJobId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.replicationJobId = replicationJobId
    }
}

struct GetReplicationRunsInputBody: Equatable {
    public let replicationJobId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetReplicationRunsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case replicationJobId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationJobId)
        replicationJobId = replicationJobIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetReplicationRunsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReplicationRunsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReplicationRunsOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReplicationRunsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReplicationRunsOutputResponse(nextToken: \(String(describing: nextToken)), replicationJob: \(String(describing: replicationJob)), replicationRunList: \(String(describing: replicationRunList)))"}
}

extension GetReplicationRunsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetReplicationRunsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.replicationJob = output.replicationJob
            self.replicationRunList = output.replicationRunList
        } else {
            self.nextToken = nil
            self.replicationJob = nil
            self.replicationRunList = nil
        }
    }
}

public struct GetReplicationRunsOutputResponse: Equatable {
    /// <p>The token required to retrieve the next set of results. This value is null when
    ///             there are no more results to return.</p>
    public let nextToken: String?
    /// <p>Information about the replication job.</p>
    public let replicationJob: ReplicationJob?
    /// <p>Information about the replication runs.</p>
    public let replicationRunList: [ReplicationRun]?

    public init (
        nextToken: String? = nil,
        replicationJob: ReplicationJob? = nil,
        replicationRunList: [ReplicationRun]? = nil
    )
    {
        self.nextToken = nextToken
        self.replicationJob = replicationJob
        self.replicationRunList = replicationRunList
    }
}

struct GetReplicationRunsOutputResponseBody: Equatable {
    public let replicationJob: ReplicationJob?
    public let replicationRunList: [ReplicationRun]?
    public let nextToken: String?
}

extension GetReplicationRunsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case replicationJob
        case replicationRunList
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationJobDecoded = try containerValues.decodeIfPresent(ReplicationJob.self, forKey: .replicationJob)
        replicationJob = replicationJobDecoded
        let replicationRunListContainer = try containerValues.decodeIfPresent([ReplicationRun?].self, forKey: .replicationRunList)
        var replicationRunListDecoded0:[ReplicationRun]? = nil
        if let replicationRunListContainer = replicationRunListContainer {
            replicationRunListDecoded0 = [ReplicationRun]()
            for structure0 in replicationRunListContainer {
                if let structure0 = structure0 {
                    replicationRunListDecoded0?.append(structure0)
                }
            }
        }
        replicationRunList = replicationRunListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetServersInputBodyMiddleware: Middleware {
    public let id: String = "GetServersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServersInput>
    public typealias MOutput = OperationOutput<GetServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServersOutputError>
}

extension GetServersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), vmServerAddressList: \(String(describing: vmServerAddressList)))"}
}

extension GetServersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case vmServerAddressList
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let vmServerAddressList = vmServerAddressList {
            var vmServerAddressListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vmServerAddressList)
            for vmserveraddresslist0 in vmServerAddressList {
                try vmServerAddressListContainer.encode(vmserveraddresslist0)
            }
        }
    }
}

public struct GetServersInputHeadersMiddleware: Middleware {
    public let id: String = "GetServersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServersInput>
    public typealias MOutput = OperationOutput<GetServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServersOutputError>
}

public struct GetServersInputQueryItemMiddleware: Middleware {
    public let id: String = "GetServersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServersInput>
    public typealias MOutput = OperationOutput<GetServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServersOutputError>
}

public struct GetServersInput: Equatable {
    /// <p>The maximum number of results to return in a single call. The default value is 50.
    ///             To retrieve the remaining results, make another call with the returned
    ///                 <code>NextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?
    /// <p>The server addresses.</p>
    public let vmServerAddressList: [VmServerAddress]?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        vmServerAddressList: [VmServerAddress]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vmServerAddressList = vmServerAddressList
    }
}

struct GetServersInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let vmServerAddressList: [VmServerAddress]?
}

extension GetServersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case vmServerAddressList
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let vmServerAddressListContainer = try containerValues.decodeIfPresent([VmServerAddress?].self, forKey: .vmServerAddressList)
        var vmServerAddressListDecoded0:[VmServerAddress]? = nil
        if let vmServerAddressListContainer = vmServerAddressListContainer {
            vmServerAddressListDecoded0 = [VmServerAddress]()
            for structure0 in vmServerAddressListContainer {
                if let structure0 = structure0 {
                    vmServerAddressListDecoded0?.append(structure0)
                }
            }
        }
        vmServerAddressList = vmServerAddressListDecoded0
    }
}

extension GetServersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServersOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServersOutputResponse(lastModifiedOn: \(String(describing: lastModifiedOn)), nextToken: \(String(describing: nextToken)), serverCatalogStatus: \(String(describing: serverCatalogStatus)), serverList: \(String(describing: serverList)))"}
}

extension GetServersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetServersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lastModifiedOn = output.lastModifiedOn
            self.nextToken = output.nextToken
            self.serverCatalogStatus = output.serverCatalogStatus
            self.serverList = output.serverList
        } else {
            self.lastModifiedOn = nil
            self.nextToken = nil
            self.serverCatalogStatus = nil
            self.serverList = nil
        }
    }
}

public struct GetServersOutputResponse: Equatable {
    /// <p>The time when the server was last modified.</p>
    public let lastModifiedOn: Date?
    /// <p>The token required to retrieve the next set of results. This value is null when
    ///             there are no more results to return.</p>
    public let nextToken: String?
    /// <p>The status of the server catalog.</p>
    public let serverCatalogStatus: ServerCatalogStatus?
    /// <p>Information about the servers.</p>
    public let serverList: [Server]?

    public init (
        lastModifiedOn: Date? = nil,
        nextToken: String? = nil,
        serverCatalogStatus: ServerCatalogStatus? = nil,
        serverList: [Server]? = nil
    )
    {
        self.lastModifiedOn = lastModifiedOn
        self.nextToken = nextToken
        self.serverCatalogStatus = serverCatalogStatus
        self.serverList = serverList
    }
}

struct GetServersOutputResponseBody: Equatable {
    public let lastModifiedOn: Date?
    public let serverCatalogStatus: ServerCatalogStatus?
    public let serverList: [Server]?
    public let nextToken: String?
}

extension GetServersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lastModifiedOn
        case nextToken
        case serverCatalogStatus
        case serverList
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedOn)
        lastModifiedOn = lastModifiedOnDecoded
        let serverCatalogStatusDecoded = try containerValues.decodeIfPresent(ServerCatalogStatus.self, forKey: .serverCatalogStatus)
        serverCatalogStatus = serverCatalogStatusDecoded
        let serverListContainer = try containerValues.decodeIfPresent([Server?].self, forKey: .serverList)
        var serverListDecoded0:[Server]? = nil
        if let serverListContainer = serverListContainer {
            serverListDecoded0 = [Server]()
            for structure0 in serverListContainer {
                if let structure0 = structure0 {
                    serverListDecoded0?.append(structure0)
                }
            }
        }
        serverList = serverListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ImportAppCatalogInputBodyMiddleware: Middleware {
    public let id: String = "ImportAppCatalogInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportAppCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportAppCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportAppCatalogInput>
    public typealias MOutput = OperationOutput<ImportAppCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportAppCatalogOutputError>
}

extension ImportAppCatalogInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportAppCatalogInput(roleName: \(String(describing: roleName)))"}
}

extension ImportAppCatalogInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleName = roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
    }
}

public struct ImportAppCatalogInputHeadersMiddleware: Middleware {
    public let id: String = "ImportAppCatalogInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportAppCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportAppCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportAppCatalogInput>
    public typealias MOutput = OperationOutput<ImportAppCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportAppCatalogOutputError>
}

public struct ImportAppCatalogInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportAppCatalogInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportAppCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportAppCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportAppCatalogInput>
    public typealias MOutput = OperationOutput<ImportAppCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportAppCatalogOutputError>
}

public struct ImportAppCatalogInput: Equatable {
    /// <p>The name of the service role. If you omit this parameter, we create a service-linked role
    ///             for AWS Migration Hub in your account. Otherwise, the role that you provide must have the <a href="https://docs.aws.amazon.com/migrationhub/latest/ug/new-customer-setup.html#sms-managed">policy
    ///             and trust policy</a> described in the <i>AWS Migration Hub User Guide</i>.</p>
    public let roleName: String?

    public init (
        roleName: String? = nil
    )
    {
        self.roleName = roleName
    }
}

struct ImportAppCatalogInputBody: Equatable {
    public let roleName: String?
}

extension ImportAppCatalogInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roleName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleName)
        roleName = roleNameDecoded
    }
}

extension ImportAppCatalogOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportAppCatalogOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportAppCatalogOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportAppCatalogOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportAppCatalogOutputResponse()"}
}

extension ImportAppCatalogOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ImportAppCatalogOutputResponse: Equatable {

    public init() {}
}

struct ImportAppCatalogOutputResponseBody: Equatable {
}

extension ImportAppCatalogOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ImportServerCatalogInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportServerCatalogInput()"}
}

extension ImportServerCatalogInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ImportServerCatalogInputHeadersMiddleware: Middleware {
    public let id: String = "ImportServerCatalogInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportServerCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportServerCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportServerCatalogInput>
    public typealias MOutput = OperationOutput<ImportServerCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportServerCatalogOutputError>
}

public struct ImportServerCatalogInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportServerCatalogInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportServerCatalogInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportServerCatalogOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportServerCatalogInput>
    public typealias MOutput = OperationOutput<ImportServerCatalogOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportServerCatalogOutputError>
}

public struct ImportServerCatalogInput: Equatable {

    public init() {}
}

struct ImportServerCatalogInputBody: Equatable {
}

extension ImportServerCatalogInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ImportServerCatalogOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportServerCatalogOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoConnectorsAvailableException" : self = .noConnectorsAvailableException(try NoConnectorsAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportServerCatalogOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case noConnectorsAvailableException(NoConnectorsAvailableException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportServerCatalogOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportServerCatalogOutputResponse()"}
}

extension ImportServerCatalogOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ImportServerCatalogOutputResponse: Equatable {

    public init() {}
}

struct ImportServerCatalogOutputResponseBody: Equatable {
}

extension ImportServerCatalogOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension InternalError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalError(message: \(String(describing: message)))"}
}

extension InternalError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal error occurred.</p>
public struct InternalError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorBody: Equatable {
    public let message: String?
}

extension InternalErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A specified parameter is not valid.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct LaunchAppInputBodyMiddleware: Middleware {
    public let id: String = "LaunchAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<LaunchAppInput>,
                  next: H) -> Swift.Result<OperationOutput<LaunchAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<LaunchAppInput>
    public typealias MOutput = OperationOutput<LaunchAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<LaunchAppOutputError>
}

extension LaunchAppInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LaunchAppInput(appId: \(String(describing: appId)))"}
}

extension LaunchAppInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

public struct LaunchAppInputHeadersMiddleware: Middleware {
    public let id: String = "LaunchAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<LaunchAppInput>,
                  next: H) -> Swift.Result<OperationOutput<LaunchAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<LaunchAppInput>
    public typealias MOutput = OperationOutput<LaunchAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<LaunchAppOutputError>
}

public struct LaunchAppInputQueryItemMiddleware: Middleware {
    public let id: String = "LaunchAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<LaunchAppInput>,
                  next: H) -> Swift.Result<OperationOutput<LaunchAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<LaunchAppInput>
    public typealias MOutput = OperationOutput<LaunchAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<LaunchAppOutputError>
}

public struct LaunchAppInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?

    public init (
        appId: String? = nil
    )
    {
        self.appId = appId
    }
}

struct LaunchAppInputBody: Equatable {
    public let appId: String?
}

extension LaunchAppInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension LaunchAppOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension LaunchAppOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum LaunchAppOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension LaunchAppOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LaunchAppOutputResponse()"}
}

extension LaunchAppOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct LaunchAppOutputResponse: Equatable {

    public init() {}
}

struct LaunchAppOutputResponseBody: Equatable {
}

extension LaunchAppOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension LaunchDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case latestLaunchTime
        case stackId
        case stackName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latestLaunchTime = latestLaunchTime {
            try encodeContainer.encode(latestLaunchTime.timeIntervalSince1970, forKey: .latestLaunchTime)
        }
        if let stackId = stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latestLaunchTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .latestLaunchTime)
        latestLaunchTime = latestLaunchTimeDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension LaunchDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LaunchDetails(latestLaunchTime: \(String(describing: latestLaunchTime)), stackId: \(String(describing: stackId)), stackName: \(String(describing: stackName)))"}
}

/// <p>Details about the latest launch of an application.</p>
public struct LaunchDetails: Equatable {
    /// <p>The latest time that this application was launched successfully.</p>
    public let latestLaunchTime: Date?
    /// <p>The ID of the latest stack launched for this application.</p>
    public let stackId: String?
    /// <p>The name of the latest stack launched for this application.</p>
    public let stackName: String?

    public init (
        latestLaunchTime: Date? = nil,
        stackId: String? = nil,
        stackName: String? = nil
    )
    {
        self.latestLaunchTime = latestLaunchTime
        self.stackId = stackId
        self.stackName = stackName
    }
}

public enum LicenseType {
    case aws
    case byol
    case sdkUnknown(String)
}

extension LicenseType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LicenseType] {
        return [
            .aws,
            .byol,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aws: return "AWS"
        case .byol: return "BYOL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LicenseType(rawValue: rawValue) ?? LicenseType.sdkUnknown(rawValue)
    }
}

public struct ListAppsInputBodyMiddleware: Middleware {
    public let id: String = "ListAppsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAppsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAppsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAppsInput>
    public typealias MOutput = OperationOutput<ListAppsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAppsOutputError>
}

extension ListAppsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAppsInput(appIds: \(String(describing: appIds)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAppsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appIds
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appIds = appIds {
            var appIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appIds)
            for appids0 in appIds {
                try appIdsContainer.encode(appids0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAppsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAppsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAppsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAppsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAppsInput>
    public typealias MOutput = OperationOutput<ListAppsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAppsOutputError>
}

public struct ListAppsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAppsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAppsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAppsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAppsInput>
    public typealias MOutput = OperationOutput<ListAppsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAppsOutputError>
}

public struct ListAppsInput: Equatable {
    /// <p>The unique application IDs.</p>
    public let appIds: [String]?
    /// <p>The maximum number of results to return in a single call. The default value is 100. To
    ///             retrieve the remaining results, make another call with the returned
    ///                 <code>NextToken</code> value. </p>
    public let maxResults: Int?
    /// <p>The token for the next set of results.</p>
    public let nextToken: String?

    public init (
        appIds: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.appIds = appIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppsInputBody: Equatable {
    public let appIds: [String]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListAppsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appIds
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .appIds)
        var appIdsDecoded0:[String]? = nil
        if let appIdsContainer = appIdsContainer {
            appIdsDecoded0 = [String]()
            for string0 in appIdsContainer {
                if let string0 = string0 {
                    appIdsDecoded0?.append(string0)
                }
            }
        }
        appIds = appIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAppsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAppsOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAppsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAppsOutputResponse(apps: \(String(describing: apps)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAppsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAppsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apps = output.apps
            self.nextToken = output.nextToken
        } else {
            self.apps = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppsOutputResponse: Equatable {
    /// <p>The application summaries.</p>
    public let apps: [AppSummary]?
    /// <p>The token required to retrieve the next set of results. This value is null when there
    ///             are no more results to return.</p>
    public let nextToken: String?

    public init (
        apps: [AppSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.apps = apps
        self.nextToken = nextToken
    }
}

struct ListAppsOutputResponseBody: Equatable {
    public let apps: [AppSummary]?
    public let nextToken: String?
}

extension ListAppsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apps
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsContainer = try containerValues.decodeIfPresent([AppSummary?].self, forKey: .apps)
        var appsDecoded0:[AppSummary]? = nil
        if let appsContainer = appsContainer {
            appsDecoded0 = [AppSummary]()
            for structure0 in appsContainer {
                if let structure0 = structure0 {
                    appsDecoded0?.append(structure0)
                }
            }
        }
        apps = appsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MissingRequiredParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MissingRequiredParameterException(message: \(String(describing: message)))"}
}

extension MissingRequiredParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MissingRequiredParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A required parameter is missing.</p>
public struct MissingRequiredParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MissingRequiredParameterExceptionBody: Equatable {
    public let message: String?
}

extension MissingRequiredParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoConnectorsAvailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoConnectorsAvailableException(message: \(String(describing: message)))"}
}

extension NoConnectorsAvailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoConnectorsAvailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There are no connectors available.</p>
public struct NoConnectorsAvailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoConnectorsAvailableExceptionBody: Equatable {
    public let message: String?
}

extension NoConnectorsAvailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotificationContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status
        case statusMessage
        case validationId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let validationId = validationId {
            try encodeContainer.encode(validationId, forKey: .validationId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validationId)
        validationId = validationIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ValidationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension NotificationContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotificationContext(status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), validationId: \(String(describing: validationId)))"}
}

/// <p>Contains the status of validating an application.</p>
public struct NotificationContext: Equatable {
    /// <p>The status of the validation.</p>
    public let status: ValidationStatus?
    /// <p>The status message.</p>
    public let statusMessage: String?
    /// <p>The ID of the validation.</p>
    public let validationId: String?

    public init (
        status: ValidationStatus? = nil,
        statusMessage: String? = nil,
        validationId: String? = nil
    )
    {
        self.status = status
        self.statusMessage = statusMessage
        self.validationId = validationId
    }
}

public struct NotifyAppValidationOutputInputBodyMiddleware: Middleware {
    public let id: String = "NotifyAppValidationOutputInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<NotifyAppValidationOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<NotifyAppValidationOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<NotifyAppValidationOutputInput>
    public typealias MOutput = OperationOutput<NotifyAppValidationOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<NotifyAppValidationOutputOutputError>
}

extension NotifyAppValidationOutputInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotifyAppValidationOutputInput(appId: \(String(describing: appId)), notificationContext: \(String(describing: notificationContext)))"}
}

extension NotifyAppValidationOutputInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
        case notificationContext
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let notificationContext = notificationContext {
            try encodeContainer.encode(notificationContext, forKey: .notificationContext)
        }
    }
}

public struct NotifyAppValidationOutputInputHeadersMiddleware: Middleware {
    public let id: String = "NotifyAppValidationOutputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<NotifyAppValidationOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<NotifyAppValidationOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<NotifyAppValidationOutputInput>
    public typealias MOutput = OperationOutput<NotifyAppValidationOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<NotifyAppValidationOutputOutputError>
}

public struct NotifyAppValidationOutputInputQueryItemMiddleware: Middleware {
    public let id: String = "NotifyAppValidationOutputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<NotifyAppValidationOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<NotifyAppValidationOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<NotifyAppValidationOutputInput>
    public typealias MOutput = OperationOutput<NotifyAppValidationOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<NotifyAppValidationOutputOutputError>
}

public struct NotifyAppValidationOutputInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?
    /// <p>The notification information.</p>
    public let notificationContext: NotificationContext?

    public init (
        appId: String? = nil,
        notificationContext: NotificationContext? = nil
    )
    {
        self.appId = appId
        self.notificationContext = notificationContext
    }
}

struct NotifyAppValidationOutputInputBody: Equatable {
    public let appId: String?
    public let notificationContext: NotificationContext?
}

extension NotifyAppValidationOutputInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
        case notificationContext
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let notificationContextDecoded = try containerValues.decodeIfPresent(NotificationContext.self, forKey: .notificationContext)
        notificationContext = notificationContextDecoded
    }
}

extension NotifyAppValidationOutputOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension NotifyAppValidationOutputOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum NotifyAppValidationOutputOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension NotifyAppValidationOutputOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotifyAppValidationOutputOutputResponse()"}
}

extension NotifyAppValidationOutputOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct NotifyAppValidationOutputOutputResponse: Equatable {

    public init() {}
}

struct NotifyAppValidationOutputOutputResponseBody: Equatable {
}

extension NotifyAppValidationOutputOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension OperationNotPermittedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationNotPermittedException(message: \(String(describing: message)))"}
}

extension OperationNotPermittedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OperationNotPermittedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This operation is not allowed.</p>
public struct OperationNotPermittedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotPermittedExceptionBody: Equatable {
    public let message: String?
}

extension OperationNotPermittedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum OutputFormat {
    case json
    case yaml
    case sdkUnknown(String)
}

extension OutputFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OutputFormat] {
        return [
            .json,
            .yaml,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .json: return "JSON"
        case .yaml: return "YAML"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OutputFormat(rawValue: rawValue) ?? OutputFormat.sdkUnknown(rawValue)
    }
}

public struct PutAppLaunchConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutAppLaunchConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAppLaunchConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAppLaunchConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAppLaunchConfigurationInput>
    public typealias MOutput = OperationOutput<PutAppLaunchConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAppLaunchConfigurationOutputError>
}

extension PutAppLaunchConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAppLaunchConfigurationInput(appId: \(String(describing: appId)), autoLaunch: \(String(describing: autoLaunch)), roleName: \(String(describing: roleName)), serverGroupLaunchConfigurations: \(String(describing: serverGroupLaunchConfigurations)))"}
}

extension PutAppLaunchConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
        case autoLaunch
        case roleName
        case serverGroupLaunchConfigurations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let autoLaunch = autoLaunch {
            try encodeContainer.encode(autoLaunch, forKey: .autoLaunch)
        }
        if let roleName = roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let serverGroupLaunchConfigurations = serverGroupLaunchConfigurations {
            var serverGroupLaunchConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverGroupLaunchConfigurations)
            for servergrouplaunchconfigurations0 in serverGroupLaunchConfigurations {
                try serverGroupLaunchConfigurationsContainer.encode(servergrouplaunchconfigurations0)
            }
        }
    }
}

public struct PutAppLaunchConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutAppLaunchConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAppLaunchConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAppLaunchConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAppLaunchConfigurationInput>
    public typealias MOutput = OperationOutput<PutAppLaunchConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAppLaunchConfigurationOutputError>
}

public struct PutAppLaunchConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutAppLaunchConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAppLaunchConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAppLaunchConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAppLaunchConfigurationInput>
    public typealias MOutput = OperationOutput<PutAppLaunchConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAppLaunchConfigurationOutputError>
}

public struct PutAppLaunchConfigurationInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?
    /// <p>Indicates whether the application is configured to launch automatically after replication is complete.</p>
    public let autoLaunch: Bool?
    /// <p>The name of service role in the customer's account that AWS CloudFormation uses to launch the
    ///             application.</p>
    public let roleName: String?
    /// <p>Information about the launch configurations for server groups in the application.</p>
    public let serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]?

    public init (
        appId: String? = nil,
        autoLaunch: Bool? = nil,
        roleName: String? = nil,
        serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]? = nil
    )
    {
        self.appId = appId
        self.autoLaunch = autoLaunch
        self.roleName = roleName
        self.serverGroupLaunchConfigurations = serverGroupLaunchConfigurations
    }
}

struct PutAppLaunchConfigurationInputBody: Equatable {
    public let appId: String?
    public let roleName: String?
    public let autoLaunch: Bool?
    public let serverGroupLaunchConfigurations: [ServerGroupLaunchConfiguration]?
}

extension PutAppLaunchConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
        case autoLaunch
        case roleName
        case serverGroupLaunchConfigurations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let autoLaunchDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .autoLaunch)
        autoLaunch = autoLaunchDecoded
        let serverGroupLaunchConfigurationsContainer = try containerValues.decodeIfPresent([ServerGroupLaunchConfiguration?].self, forKey: .serverGroupLaunchConfigurations)
        var serverGroupLaunchConfigurationsDecoded0:[ServerGroupLaunchConfiguration]? = nil
        if let serverGroupLaunchConfigurationsContainer = serverGroupLaunchConfigurationsContainer {
            serverGroupLaunchConfigurationsDecoded0 = [ServerGroupLaunchConfiguration]()
            for structure0 in serverGroupLaunchConfigurationsContainer {
                if let structure0 = structure0 {
                    serverGroupLaunchConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        serverGroupLaunchConfigurations = serverGroupLaunchConfigurationsDecoded0
    }
}

extension PutAppLaunchConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAppLaunchConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAppLaunchConfigurationOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAppLaunchConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAppLaunchConfigurationOutputResponse()"}
}

extension PutAppLaunchConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutAppLaunchConfigurationOutputResponse: Equatable {

    public init() {}
}

struct PutAppLaunchConfigurationOutputResponseBody: Equatable {
}

extension PutAppLaunchConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutAppReplicationConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutAppReplicationConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAppReplicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAppReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAppReplicationConfigurationInput>
    public typealias MOutput = OperationOutput<PutAppReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAppReplicationConfigurationOutputError>
}

extension PutAppReplicationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAppReplicationConfigurationInput(appId: \(String(describing: appId)), serverGroupReplicationConfigurations: \(String(describing: serverGroupReplicationConfigurations)))"}
}

extension PutAppReplicationConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
        case serverGroupReplicationConfigurations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let serverGroupReplicationConfigurations = serverGroupReplicationConfigurations {
            var serverGroupReplicationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverGroupReplicationConfigurations)
            for servergroupreplicationconfigurations0 in serverGroupReplicationConfigurations {
                try serverGroupReplicationConfigurationsContainer.encode(servergroupreplicationconfigurations0)
            }
        }
    }
}

public struct PutAppReplicationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutAppReplicationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAppReplicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAppReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAppReplicationConfigurationInput>
    public typealias MOutput = OperationOutput<PutAppReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAppReplicationConfigurationOutputError>
}

public struct PutAppReplicationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutAppReplicationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAppReplicationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAppReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAppReplicationConfigurationInput>
    public typealias MOutput = OperationOutput<PutAppReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAppReplicationConfigurationOutputError>
}

public struct PutAppReplicationConfigurationInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?
    /// <p>Information about the replication configurations for server groups in the application.</p>
    public let serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]?

    public init (
        appId: String? = nil,
        serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]? = nil
    )
    {
        self.appId = appId
        self.serverGroupReplicationConfigurations = serverGroupReplicationConfigurations
    }
}

struct PutAppReplicationConfigurationInputBody: Equatable {
    public let appId: String?
    public let serverGroupReplicationConfigurations: [ServerGroupReplicationConfiguration]?
}

extension PutAppReplicationConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
        case serverGroupReplicationConfigurations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let serverGroupReplicationConfigurationsContainer = try containerValues.decodeIfPresent([ServerGroupReplicationConfiguration?].self, forKey: .serverGroupReplicationConfigurations)
        var serverGroupReplicationConfigurationsDecoded0:[ServerGroupReplicationConfiguration]? = nil
        if let serverGroupReplicationConfigurationsContainer = serverGroupReplicationConfigurationsContainer {
            serverGroupReplicationConfigurationsDecoded0 = [ServerGroupReplicationConfiguration]()
            for structure0 in serverGroupReplicationConfigurationsContainer {
                if let structure0 = structure0 {
                    serverGroupReplicationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        serverGroupReplicationConfigurations = serverGroupReplicationConfigurationsDecoded0
    }
}

extension PutAppReplicationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAppReplicationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAppReplicationConfigurationOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAppReplicationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAppReplicationConfigurationOutputResponse()"}
}

extension PutAppReplicationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutAppReplicationConfigurationOutputResponse: Equatable {

    public init() {}
}

struct PutAppReplicationConfigurationOutputResponseBody: Equatable {
}

extension PutAppReplicationConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutAppValidationConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutAppValidationConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAppValidationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAppValidationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAppValidationConfigurationInput>
    public typealias MOutput = OperationOutput<PutAppValidationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAppValidationConfigurationOutputError>
}

extension PutAppValidationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAppValidationConfigurationInput(appId: \(String(describing: appId)), appValidationConfigurations: \(String(describing: appValidationConfigurations)), serverGroupValidationConfigurations: \(String(describing: serverGroupValidationConfigurations)))"}
}

extension PutAppValidationConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
        case appValidationConfigurations
        case serverGroupValidationConfigurations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let appValidationConfigurations = appValidationConfigurations {
            var appValidationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appValidationConfigurations)
            for appvalidationconfigurations0 in appValidationConfigurations {
                try appValidationConfigurationsContainer.encode(appvalidationconfigurations0)
            }
        }
        if let serverGroupValidationConfigurations = serverGroupValidationConfigurations {
            var serverGroupValidationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverGroupValidationConfigurations)
            for servergroupvalidationconfigurations0 in serverGroupValidationConfigurations {
                try serverGroupValidationConfigurationsContainer.encode(servergroupvalidationconfigurations0)
            }
        }
    }
}

public struct PutAppValidationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutAppValidationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAppValidationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAppValidationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAppValidationConfigurationInput>
    public typealias MOutput = OperationOutput<PutAppValidationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAppValidationConfigurationOutputError>
}

public struct PutAppValidationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutAppValidationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAppValidationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAppValidationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAppValidationConfigurationInput>
    public typealias MOutput = OperationOutput<PutAppValidationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAppValidationConfigurationOutputError>
}

public struct PutAppValidationConfigurationInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?
    /// <p>The configuration for application validation.</p>
    public let appValidationConfigurations: [AppValidationConfiguration]?
    /// <p>The configuration for instance validation.</p>
    public let serverGroupValidationConfigurations: [ServerGroupValidationConfiguration]?

    public init (
        appId: String? = nil,
        appValidationConfigurations: [AppValidationConfiguration]? = nil,
        serverGroupValidationConfigurations: [ServerGroupValidationConfiguration]? = nil
    )
    {
        self.appId = appId
        self.appValidationConfigurations = appValidationConfigurations
        self.serverGroupValidationConfigurations = serverGroupValidationConfigurations
    }
}

struct PutAppValidationConfigurationInputBody: Equatable {
    public let appId: String?
    public let appValidationConfigurations: [AppValidationConfiguration]?
    public let serverGroupValidationConfigurations: [ServerGroupValidationConfiguration]?
}

extension PutAppValidationConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
        case appValidationConfigurations
        case serverGroupValidationConfigurations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let appValidationConfigurationsContainer = try containerValues.decodeIfPresent([AppValidationConfiguration?].self, forKey: .appValidationConfigurations)
        var appValidationConfigurationsDecoded0:[AppValidationConfiguration]? = nil
        if let appValidationConfigurationsContainer = appValidationConfigurationsContainer {
            appValidationConfigurationsDecoded0 = [AppValidationConfiguration]()
            for structure0 in appValidationConfigurationsContainer {
                if let structure0 = structure0 {
                    appValidationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        appValidationConfigurations = appValidationConfigurationsDecoded0
        let serverGroupValidationConfigurationsContainer = try containerValues.decodeIfPresent([ServerGroupValidationConfiguration?].self, forKey: .serverGroupValidationConfigurations)
        var serverGroupValidationConfigurationsDecoded0:[ServerGroupValidationConfiguration]? = nil
        if let serverGroupValidationConfigurationsContainer = serverGroupValidationConfigurationsContainer {
            serverGroupValidationConfigurationsDecoded0 = [ServerGroupValidationConfiguration]()
            for structure0 in serverGroupValidationConfigurationsContainer {
                if let structure0 = structure0 {
                    serverGroupValidationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        serverGroupValidationConfigurations = serverGroupValidationConfigurationsDecoded0
    }
}

extension PutAppValidationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAppValidationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAppValidationConfigurationOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAppValidationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAppValidationConfigurationOutputResponse()"}
}

extension PutAppValidationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutAppValidationConfigurationOutputResponse: Equatable {

    public init() {}
}

struct PutAppValidationConfigurationOutputResponseBody: Equatable {
}

extension PutAppValidationConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ReplicationJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case encrypted
        case frequency
        case kmsKeyId
        case latestAmiId
        case licenseType
        case nextReplicationRunStartTime
        case numberOfRecentAmisToKeep
        case replicationJobId
        case replicationRunList
        case roleName
        case runOnce
        case seedReplicationTime
        case serverId
        case serverType
        case state
        case statusMessage
        case vmServer
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency, forKey: .frequency)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let latestAmiId = latestAmiId {
            try encodeContainer.encode(latestAmiId, forKey: .latestAmiId)
        }
        if let licenseType = licenseType {
            try encodeContainer.encode(licenseType.rawValue, forKey: .licenseType)
        }
        if let nextReplicationRunStartTime = nextReplicationRunStartTime {
            try encodeContainer.encode(nextReplicationRunStartTime.timeIntervalSince1970, forKey: .nextReplicationRunStartTime)
        }
        if let numberOfRecentAmisToKeep = numberOfRecentAmisToKeep {
            try encodeContainer.encode(numberOfRecentAmisToKeep, forKey: .numberOfRecentAmisToKeep)
        }
        if let replicationJobId = replicationJobId {
            try encodeContainer.encode(replicationJobId, forKey: .replicationJobId)
        }
        if let replicationRunList = replicationRunList {
            var replicationRunListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationRunList)
            for replicationrunlist0 in replicationRunList {
                try replicationRunListContainer.encode(replicationrunlist0)
            }
        }
        if let roleName = roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let runOnce = runOnce {
            try encodeContainer.encode(runOnce, forKey: .runOnce)
        }
        if let seedReplicationTime = seedReplicationTime {
            try encodeContainer.encode(seedReplicationTime.timeIntervalSince1970, forKey: .seedReplicationTime)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let serverType = serverType {
            try encodeContainer.encode(serverType.rawValue, forKey: .serverType)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let vmServer = vmServer {
            try encodeContainer.encode(vmServer, forKey: .vmServer)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationJobId)
        replicationJobId = replicationJobIdDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let serverTypeDecoded = try containerValues.decodeIfPresent(ServerType.self, forKey: .serverType)
        serverType = serverTypeDecoded
        let vmServerDecoded = try containerValues.decodeIfPresent(VmServer.self, forKey: .vmServer)
        vmServer = vmServerDecoded
        let seedReplicationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .seedReplicationTime)
        seedReplicationTime = seedReplicationTimeDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .frequency)
        frequency = frequencyDecoded
        let runOnceDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .runOnce)
        runOnce = runOnceDecoded
        let nextReplicationRunStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .nextReplicationRunStartTime)
        nextReplicationRunStartTime = nextReplicationRunStartTimeDecoded
        let licenseTypeDecoded = try containerValues.decodeIfPresent(LicenseType.self, forKey: .licenseType)
        licenseType = licenseTypeDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let latestAmiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestAmiId)
        latestAmiId = latestAmiIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ReplicationJobState.self, forKey: .state)
        state = stateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let numberOfRecentAmisToKeepDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfRecentAmisToKeep)
        numberOfRecentAmisToKeep = numberOfRecentAmisToKeepDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let replicationRunListContainer = try containerValues.decodeIfPresent([ReplicationRun?].self, forKey: .replicationRunList)
        var replicationRunListDecoded0:[ReplicationRun]? = nil
        if let replicationRunListContainer = replicationRunListContainer {
            replicationRunListDecoded0 = [ReplicationRun]()
            for structure0 in replicationRunListContainer {
                if let structure0 = structure0 {
                    replicationRunListDecoded0?.append(structure0)
                }
            }
        }
        replicationRunList = replicationRunListDecoded0
    }
}

extension ReplicationJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationJob(description: \(String(describing: description)), encrypted: \(String(describing: encrypted)), frequency: \(String(describing: frequency)), kmsKeyId: \(String(describing: kmsKeyId)), latestAmiId: \(String(describing: latestAmiId)), licenseType: \(String(describing: licenseType)), nextReplicationRunStartTime: \(String(describing: nextReplicationRunStartTime)), numberOfRecentAmisToKeep: \(String(describing: numberOfRecentAmisToKeep)), replicationJobId: \(String(describing: replicationJobId)), replicationRunList: \(String(describing: replicationRunList)), roleName: \(String(describing: roleName)), runOnce: \(String(describing: runOnce)), seedReplicationTime: \(String(describing: seedReplicationTime)), serverId: \(String(describing: serverId)), serverType: \(String(describing: serverType)), state: \(String(describing: state)), statusMessage: \(String(describing: statusMessage)), vmServer: \(String(describing: vmServer)))"}
}

/// <p>Represents a replication job.</p>
public struct ReplicationJob: Equatable {
    /// <p>The description of the replication job.</p>
    public let description: String?
    /// <p>Indicates whether the replication job should produce encrypted AMIs.</p>
    public let encrypted: Bool?
    /// <p>The time between consecutive replication runs, in hours.</p>
    public let frequency: Int?
    /// <p>The ID of the KMS key for replication jobs that produce encrypted AMIs.
    ///             This value can be any of the following: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>KMS key ID</p>
    ///             </li>
    ///             <li>
    ///                 <p>KMS key alias</p>
    ///             </li>
    ///             <li>
    ///                 <p>ARN referring to the KMS key ID</p>
    ///             </li>
    ///             <li>
    ///                 <p>ARN referring to the KMS key alias</p>
    ///             </li>
    ///          </ul>
    ///         <p>If encrypted is enabled but a KMS key ID is not specified, the
    ///             customer's default KMS key for Amazon EBS is used.</p>
    public let kmsKeyId: String?
    /// <p>The ID of the latest Amazon Machine Image (AMI).</p>
    public let latestAmiId: String?
    /// <p>The license type to be used for the AMI created by a successful replication
    ///             run.</p>
    public let licenseType: LicenseType?
    /// <p>The start time of the next replication run.</p>
    public let nextReplicationRunStartTime: Date?
    /// <p>The number of recent AMIs to keep in the customer's account for a replication job. By
    ///             default, the value is set to zero, meaning that all AMIs are kept.</p>
    public let numberOfRecentAmisToKeep: Int?
    /// <p>The ID of the replication job.</p>
    public let replicationJobId: String?
    /// <p>Information about the replication runs.</p>
    public let replicationRunList: [ReplicationRun]?
    /// <p>The name of the IAM role to be used by AWS SMS.</p>
    public let roleName: String?
    /// <p>Indicates whether to run the replication job one time.</p>
    public let runOnce: Bool?
    /// <p>The seed replication time.</p>
    public let seedReplicationTime: Date?
    /// <p>The ID of the server.</p>
    public let serverId: String?
    /// <p>The type of server.</p>
    public let serverType: ServerType?
    /// <p>The state of the replication job.</p>
    public let state: ReplicationJobState?
    /// <p>The description of the current status of the replication job.</p>
    public let statusMessage: String?
    /// <p>Information about the VM server.</p>
    public let vmServer: VmServer?

    public init (
        description: String? = nil,
        encrypted: Bool? = nil,
        frequency: Int? = nil,
        kmsKeyId: String? = nil,
        latestAmiId: String? = nil,
        licenseType: LicenseType? = nil,
        nextReplicationRunStartTime: Date? = nil,
        numberOfRecentAmisToKeep: Int? = nil,
        replicationJobId: String? = nil,
        replicationRunList: [ReplicationRun]? = nil,
        roleName: String? = nil,
        runOnce: Bool? = nil,
        seedReplicationTime: Date? = nil,
        serverId: String? = nil,
        serverType: ServerType? = nil,
        state: ReplicationJobState? = nil,
        statusMessage: String? = nil,
        vmServer: VmServer? = nil
    )
    {
        self.description = description
        self.encrypted = encrypted
        self.frequency = frequency
        self.kmsKeyId = kmsKeyId
        self.latestAmiId = latestAmiId
        self.licenseType = licenseType
        self.nextReplicationRunStartTime = nextReplicationRunStartTime
        self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
        self.replicationJobId = replicationJobId
        self.replicationRunList = replicationRunList
        self.roleName = roleName
        self.runOnce = runOnce
        self.seedReplicationTime = seedReplicationTime
        self.serverId = serverId
        self.serverType = serverType
        self.state = state
        self.statusMessage = statusMessage
        self.vmServer = vmServer
    }
}

extension ReplicationJobAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationJobAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ReplicationJobAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReplicationJobAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified replication job already exists.</p>
public struct ReplicationJobAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReplicationJobAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ReplicationJobAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReplicationJobNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationJobNotFoundException(message: \(String(describing: message)))"}
}

extension ReplicationJobNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReplicationJobNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified replication job does not exist.</p>
public struct ReplicationJobNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReplicationJobNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ReplicationJobNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ReplicationJobState {
    case active
    case completed
    case deleted
    case deleting
    case failed
    case failing
    case pausedonfailure
    case pending
    case sdkUnknown(String)
}

extension ReplicationJobState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReplicationJobState] {
        return [
            .active,
            .completed,
            .deleted,
            .deleting,
            .failed,
            .failing,
            .pausedonfailure,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .completed: return "COMPLETED"
        case .deleted: return "DELETED"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .failing: return "FAILING"
        case .pausedonfailure: return "PAUSED_ON_FAILURE"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReplicationJobState(rawValue: rawValue) ?? ReplicationJobState.sdkUnknown(rawValue)
    }
}

extension ReplicationRun: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amiId
        case completedTime
        case description
        case encrypted
        case kmsKeyId
        case replicationRunId
        case scheduledStartTime
        case stageDetails
        case state
        case statusMessage
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiId = amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let completedTime = completedTime {
            try encodeContainer.encode(completedTime.timeIntervalSince1970, forKey: .completedTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let replicationRunId = replicationRunId {
            try encodeContainer.encode(replicationRunId, forKey: .replicationRunId)
        }
        if let scheduledStartTime = scheduledStartTime {
            try encodeContainer.encode(scheduledStartTime.timeIntervalSince1970, forKey: .scheduledStartTime)
        }
        if let stageDetails = stageDetails {
            try encodeContainer.encode(stageDetails, forKey: .stageDetails)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationRunId)
        replicationRunId = replicationRunIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ReplicationRunState.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ReplicationRunType.self, forKey: .type)
        type = typeDecoded
        let stageDetailsDecoded = try containerValues.decodeIfPresent(ReplicationRunStageDetails.self, forKey: .stageDetails)
        stageDetails = stageDetailsDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let amiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let scheduledStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .scheduledStartTime)
        scheduledStartTime = scheduledStartTimeDecoded
        let completedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedTime)
        completedTime = completedTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension ReplicationRun: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationRun(amiId: \(String(describing: amiId)), completedTime: \(String(describing: completedTime)), description: \(String(describing: description)), encrypted: \(String(describing: encrypted)), kmsKeyId: \(String(describing: kmsKeyId)), replicationRunId: \(String(describing: replicationRunId)), scheduledStartTime: \(String(describing: scheduledStartTime)), stageDetails: \(String(describing: stageDetails)), state: \(String(describing: state)), statusMessage: \(String(describing: statusMessage)), type: \(String(describing: type)))"}
}

/// <p>Represents a replication run.</p>
public struct ReplicationRun: Equatable {
    /// <p>The ID of the Amazon Machine Image (AMI) from the replication
    ///             run.</p>
    public let amiId: String?
    /// <p>The completion time of the last replication run.</p>
    public let completedTime: Date?
    /// <p>The description of the replication run.</p>
    public let description: String?
    /// <p>Indicates whether the replication run should produce an encrypted AMI.</p>
    public let encrypted: Bool?
    /// <p>The ID of the KMS key for replication jobs that produce encrypted AMIs.
    ///             This value can be any of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>KMS key ID</p>
    ///             </li>
    ///             <li>
    ///                 <p>KMS key alias</p>
    ///             </li>
    ///             <li>
    ///                 <p>ARN referring to the KMS key ID</p>
    ///             </li>
    ///             <li>
    ///                 <p>ARN referring to the KMS key alias</p>
    ///             </li>
    ///          </ul>
    ///         <p> If encrypted is <i>true</i> but a KMS key ID is not specified, the
    ///             customer's default KMS key for Amazon EBS is used. </p>
    public let kmsKeyId: String?
    /// <p>The ID of the replication run.</p>
    public let replicationRunId: String?
    /// <p>The start time of the next replication run.</p>
    public let scheduledStartTime: Date?
    /// <p>Details about the current stage of the replication run.</p>
    public let stageDetails: ReplicationRunStageDetails?
    /// <p>The state of the replication run.</p>
    public let state: ReplicationRunState?
    /// <p>The description of the current status of the replication job.</p>
    public let statusMessage: String?
    /// <p>The type of replication run.</p>
    public let type: ReplicationRunType?

    public init (
        amiId: String? = nil,
        completedTime: Date? = nil,
        description: String? = nil,
        encrypted: Bool? = nil,
        kmsKeyId: String? = nil,
        replicationRunId: String? = nil,
        scheduledStartTime: Date? = nil,
        stageDetails: ReplicationRunStageDetails? = nil,
        state: ReplicationRunState? = nil,
        statusMessage: String? = nil,
        type: ReplicationRunType? = nil
    )
    {
        self.amiId = amiId
        self.completedTime = completedTime
        self.description = description
        self.encrypted = encrypted
        self.kmsKeyId = kmsKeyId
        self.replicationRunId = replicationRunId
        self.scheduledStartTime = scheduledStartTime
        self.stageDetails = stageDetails
        self.state = state
        self.statusMessage = statusMessage
        self.type = type
    }
}

extension ReplicationRunLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationRunLimitExceededException(message: \(String(describing: message)))"}
}

extension ReplicationRunLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReplicationRunLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the number of on-demand replication runs you can request in a
///             24-hour period.</p>
public struct ReplicationRunLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReplicationRunLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ReplicationRunLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReplicationRunStageDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case stage
        case stageProgress
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
        if let stageProgress = stageProgress {
            try encodeContainer.encode(stageProgress, forKey: .stageProgress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stage)
        stage = stageDecoded
        let stageProgressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageProgress)
        stageProgress = stageProgressDecoded
    }
}

extension ReplicationRunStageDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationRunStageDetails(stage: \(String(describing: stage)), stageProgress: \(String(describing: stageProgress)))"}
}

/// <p>Details of the current stage of a replication run.</p>
public struct ReplicationRunStageDetails: Equatable {
    /// <p>The current stage of a replication run.</p>
    public let stage: String?
    /// <p>The progress of the current stage of a replication run.</p>
    public let stageProgress: String?

    public init (
        stage: String? = nil,
        stageProgress: String? = nil
    )
    {
        self.stage = stage
        self.stageProgress = stageProgress
    }
}

public enum ReplicationRunState {
    case active
    case completed
    case deleted
    case deleting
    case failed
    case missed
    case pending
    case sdkUnknown(String)
}

extension ReplicationRunState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReplicationRunState] {
        return [
            .active,
            .completed,
            .deleted,
            .deleting,
            .failed,
            .missed,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .completed: return "COMPLETED"
        case .deleted: return "DELETED"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .missed: return "MISSED"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReplicationRunState(rawValue: rawValue) ?? ReplicationRunState.sdkUnknown(rawValue)
    }
}

public enum ReplicationRunType {
    case automatic
    case ondemand
    case sdkUnknown(String)
}

extension ReplicationRunType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReplicationRunType] {
        return [
            .automatic,
            .ondemand,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .automatic: return "AUTOMATIC"
        case .ondemand: return "ON_DEMAND"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReplicationRunType(rawValue: rawValue) ?? ReplicationRunType.sdkUnknown(rawValue)
    }
}

extension S3Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket
        case key
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
    }
}

extension S3Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Location(bucket: \(String(describing: bucket)), key: \(String(describing: key)))"}
}

/// <p>Location of an Amazon S3 object.</p>
public struct S3Location: Equatable {
    /// <p>The Amazon S3 bucket name.</p>
    public let bucket: String?
    /// <p>The Amazon S3 bucket key.</p>
    public let key: String?

    public init (
        bucket: String? = nil,
        key: String? = nil
    )
    {
        self.bucket = bucket
        self.key = key
    }
}

extension SSMOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Location
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension SSMOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SSMOutput(s3Location: \(String(describing: s3Location)))"}
}

/// <p>Contains the location of validation output.</p>
public struct SSMOutput: Equatable {
    /// <p>Location of an Amazon S3 object.</p>
    public let s3Location: S3Location?

    public init (
        s3Location: S3Location? = nil
    )
    {
        self.s3Location = s3Location
    }
}

extension SSMValidationParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case command
        case executionTimeoutSeconds
        case instanceId
        case outputS3BucketName
        case scriptType
        case source
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if executionTimeoutSeconds != 0 {
            try encodeContainer.encode(executionTimeoutSeconds, forKey: .executionTimeoutSeconds)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let outputS3BucketName = outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let scriptType = scriptType {
            try encodeContainer.encode(scriptType.rawValue, forKey: .scriptType)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .source)
        source = sourceDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let scriptTypeDecoded = try containerValues.decodeIfPresent(ScriptType.self, forKey: .scriptType)
        scriptType = scriptTypeDecoded
        let commandDecoded = try containerValues.decodeIfPresent(String.self, forKey: .command)
        command = commandDecoded
        let executionTimeoutSecondsDecoded = try containerValues.decode(Int.self, forKey: .executionTimeoutSeconds)
        executionTimeoutSeconds = executionTimeoutSecondsDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
    }
}

extension SSMValidationParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SSMValidationParameters(command: \(String(describing: command)), executionTimeoutSeconds: \(String(describing: executionTimeoutSeconds)), instanceId: \(String(describing: instanceId)), outputS3BucketName: \(String(describing: outputS3BucketName)), scriptType: \(String(describing: scriptType)), source: \(String(describing: source)))"}
}

/// <p>Contains validation parameters.</p>
public struct SSMValidationParameters: Equatable {
    /// <p>The command to run the validation script</p>
    public let command: String?
    /// <p>The timeout interval, in seconds.</p>
    public let executionTimeoutSeconds: Int
    /// <p>The ID of the instance. The instance must have the following tag: UserForSMSApplicationValidation=true.</p>
    public let instanceId: String?
    /// <p>The name of the S3 bucket for output.</p>
    public let outputS3BucketName: String?
    /// <p>The type of validation script.</p>
    public let scriptType: ScriptType?
    /// <p>The location of the validation script.</p>
    public let source: Source?

    public init (
        command: String? = nil,
        executionTimeoutSeconds: Int = 0,
        instanceId: String? = nil,
        outputS3BucketName: String? = nil,
        scriptType: ScriptType? = nil,
        source: Source? = nil
    )
    {
        self.command = command
        self.executionTimeoutSeconds = executionTimeoutSeconds
        self.instanceId = instanceId
        self.outputS3BucketName = outputS3BucketName
        self.scriptType = scriptType
        self.source = source
    }
}

public enum ScriptType {
    case powershellScript
    case shellScript
    case sdkUnknown(String)
}

extension ScriptType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScriptType] {
        return [
            .powershellScript,
            .shellScript,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .powershellScript: return "POWERSHELL_SCRIPT"
        case .shellScript: return "SHELL_SCRIPT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScriptType(rawValue: rawValue) ?? ScriptType.sdkUnknown(rawValue)
    }
}

extension Server: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replicationJobId
        case replicationJobTerminated
        case serverId
        case serverType
        case vmServer
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationJobId = replicationJobId {
            try encodeContainer.encode(replicationJobId, forKey: .replicationJobId)
        }
        if let replicationJobTerminated = replicationJobTerminated {
            try encodeContainer.encode(replicationJobTerminated, forKey: .replicationJobTerminated)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let serverType = serverType {
            try encodeContainer.encode(serverType.rawValue, forKey: .serverType)
        }
        if let vmServer = vmServer {
            try encodeContainer.encode(vmServer, forKey: .vmServer)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let serverTypeDecoded = try containerValues.decodeIfPresent(ServerType.self, forKey: .serverType)
        serverType = serverTypeDecoded
        let vmServerDecoded = try containerValues.decodeIfPresent(VmServer.self, forKey: .vmServer)
        vmServer = vmServerDecoded
        let replicationJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationJobId)
        replicationJobId = replicationJobIdDecoded
        let replicationJobTerminatedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .replicationJobTerminated)
        replicationJobTerminated = replicationJobTerminatedDecoded
    }
}

extension Server: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Server(replicationJobId: \(String(describing: replicationJobId)), replicationJobTerminated: \(String(describing: replicationJobTerminated)), serverId: \(String(describing: serverId)), serverType: \(String(describing: serverType)), vmServer: \(String(describing: vmServer)))"}
}

/// <p>Represents a server.</p>
public struct Server: Equatable {
    /// <p>The ID of the replication job.</p>
    public let replicationJobId: String?
    /// <p>Indicates whether the replication job is deleted or failed.</p>
    public let replicationJobTerminated: Bool?
    /// <p>The ID of the server.</p>
    public let serverId: String?
    /// <p>The type of server.</p>
    public let serverType: ServerType?
    /// <p>Information about the VM server.</p>
    public let vmServer: VmServer?

    public init (
        replicationJobId: String? = nil,
        replicationJobTerminated: Bool? = nil,
        serverId: String? = nil,
        serverType: ServerType? = nil,
        vmServer: VmServer? = nil
    )
    {
        self.replicationJobId = replicationJobId
        self.replicationJobTerminated = replicationJobTerminated
        self.serverId = serverId
        self.serverType = serverType
        self.vmServer = vmServer
    }
}

extension ServerCannotBeReplicatedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerCannotBeReplicatedException(message: \(String(describing: message)))"}
}

extension ServerCannotBeReplicatedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServerCannotBeReplicatedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified server cannot be replicated.</p>
public struct ServerCannotBeReplicatedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServerCannotBeReplicatedExceptionBody: Equatable {
    public let message: String?
}

extension ServerCannotBeReplicatedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ServerCatalogStatus {
    case available
    case deleted
    case expired
    case importing
    case notimported
    case sdkUnknown(String)
}

extension ServerCatalogStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServerCatalogStatus] {
        return [
            .available,
            .deleted,
            .expired,
            .importing,
            .notimported,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .deleted: return "DELETED"
        case .expired: return "EXPIRED"
        case .importing: return "IMPORTING"
        case .notimported: return "NOT_IMPORTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServerCatalogStatus(rawValue: rawValue) ?? ServerCatalogStatus.sdkUnknown(rawValue)
    }
}

extension ServerGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case serverGroupId
        case serverList
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverGroupId = serverGroupId {
            try encodeContainer.encode(serverGroupId, forKey: .serverGroupId)
        }
        if let serverList = serverList {
            var serverListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverList)
            for serverlist0 in serverList {
                try serverListContainer.encode(serverlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverGroupId)
        serverGroupId = serverGroupIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let serverListContainer = try containerValues.decodeIfPresent([Server?].self, forKey: .serverList)
        var serverListDecoded0:[Server]? = nil
        if let serverListContainer = serverListContainer {
            serverListDecoded0 = [Server]()
            for structure0 in serverListContainer {
                if let structure0 = structure0 {
                    serverListDecoded0?.append(structure0)
                }
            }
        }
        serverList = serverListDecoded0
    }
}

extension ServerGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerGroup(name: \(String(describing: name)), serverGroupId: \(String(describing: serverGroupId)), serverList: \(String(describing: serverList)))"}
}

/// <p>Logical grouping of servers.</p>
public struct ServerGroup: Equatable {
    /// <p>The name of a server group.</p>
    public let name: String?
    /// <p>The ID of a server group.</p>
    public let serverGroupId: String?
    /// <p>The servers that belong to a server group.</p>
    public let serverList: [Server]?

    public init (
        name: String? = nil,
        serverGroupId: String? = nil,
        serverList: [Server]? = nil
    )
    {
        self.name = name
        self.serverGroupId = serverGroupId
        self.serverList = serverList
    }
}

extension ServerGroupLaunchConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case launchOrder
        case serverGroupId
        case serverLaunchConfigurations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchOrder = launchOrder {
            try encodeContainer.encode(launchOrder, forKey: .launchOrder)
        }
        if let serverGroupId = serverGroupId {
            try encodeContainer.encode(serverGroupId, forKey: .serverGroupId)
        }
        if let serverLaunchConfigurations = serverLaunchConfigurations {
            var serverLaunchConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverLaunchConfigurations)
            for serverlaunchconfigurations0 in serverLaunchConfigurations {
                try serverLaunchConfigurationsContainer.encode(serverlaunchconfigurations0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverGroupId)
        serverGroupId = serverGroupIdDecoded
        let launchOrderDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .launchOrder)
        launchOrder = launchOrderDecoded
        let serverLaunchConfigurationsContainer = try containerValues.decodeIfPresent([ServerLaunchConfiguration?].self, forKey: .serverLaunchConfigurations)
        var serverLaunchConfigurationsDecoded0:[ServerLaunchConfiguration]? = nil
        if let serverLaunchConfigurationsContainer = serverLaunchConfigurationsContainer {
            serverLaunchConfigurationsDecoded0 = [ServerLaunchConfiguration]()
            for structure0 in serverLaunchConfigurationsContainer {
                if let structure0 = structure0 {
                    serverLaunchConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        serverLaunchConfigurations = serverLaunchConfigurationsDecoded0
    }
}

extension ServerGroupLaunchConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerGroupLaunchConfiguration(launchOrder: \(String(describing: launchOrder)), serverGroupId: \(String(describing: serverGroupId)), serverLaunchConfigurations: \(String(describing: serverLaunchConfigurations)))"}
}

/// <p>Launch configuration for a server group.</p>
public struct ServerGroupLaunchConfiguration: Equatable {
    /// <p>The launch order of servers in the server group.</p>
    public let launchOrder: Int?
    /// <p>The ID of the server group with which the launch configuration is
    ///             associated.</p>
    public let serverGroupId: String?
    /// <p>The launch configuration for servers in the server group.</p>
    public let serverLaunchConfigurations: [ServerLaunchConfiguration]?

    public init (
        launchOrder: Int? = nil,
        serverGroupId: String? = nil,
        serverLaunchConfigurations: [ServerLaunchConfiguration]? = nil
    )
    {
        self.launchOrder = launchOrder
        self.serverGroupId = serverGroupId
        self.serverLaunchConfigurations = serverLaunchConfigurations
    }
}

extension ServerGroupReplicationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serverGroupId
        case serverReplicationConfigurations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverGroupId = serverGroupId {
            try encodeContainer.encode(serverGroupId, forKey: .serverGroupId)
        }
        if let serverReplicationConfigurations = serverReplicationConfigurations {
            var serverReplicationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverReplicationConfigurations)
            for serverreplicationconfigurations0 in serverReplicationConfigurations {
                try serverReplicationConfigurationsContainer.encode(serverreplicationconfigurations0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverGroupId)
        serverGroupId = serverGroupIdDecoded
        let serverReplicationConfigurationsContainer = try containerValues.decodeIfPresent([ServerReplicationConfiguration?].self, forKey: .serverReplicationConfigurations)
        var serverReplicationConfigurationsDecoded0:[ServerReplicationConfiguration]? = nil
        if let serverReplicationConfigurationsContainer = serverReplicationConfigurationsContainer {
            serverReplicationConfigurationsDecoded0 = [ServerReplicationConfiguration]()
            for structure0 in serverReplicationConfigurationsContainer {
                if let structure0 = structure0 {
                    serverReplicationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        serverReplicationConfigurations = serverReplicationConfigurationsDecoded0
    }
}

extension ServerGroupReplicationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerGroupReplicationConfiguration(serverGroupId: \(String(describing: serverGroupId)), serverReplicationConfigurations: \(String(describing: serverReplicationConfigurations)))"}
}

/// <p>Replication configuration for a server group.</p>
public struct ServerGroupReplicationConfiguration: Equatable {
    /// <p>The ID of the server group with which this replication configuration is
    ///             associated.</p>
    public let serverGroupId: String?
    /// <p>The replication configuration for servers in the server group.</p>
    public let serverReplicationConfigurations: [ServerReplicationConfiguration]?

    public init (
        serverGroupId: String? = nil,
        serverReplicationConfigurations: [ServerReplicationConfiguration]? = nil
    )
    {
        self.serverGroupId = serverGroupId
        self.serverReplicationConfigurations = serverReplicationConfigurations
    }
}

extension ServerGroupValidationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serverGroupId
        case serverValidationConfigurations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverGroupId = serverGroupId {
            try encodeContainer.encode(serverGroupId, forKey: .serverGroupId)
        }
        if let serverValidationConfigurations = serverValidationConfigurations {
            var serverValidationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverValidationConfigurations)
            for servervalidationconfigurations0 in serverValidationConfigurations {
                try serverValidationConfigurationsContainer.encode(servervalidationconfigurations0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverGroupId)
        serverGroupId = serverGroupIdDecoded
        let serverValidationConfigurationsContainer = try containerValues.decodeIfPresent([ServerValidationConfiguration?].self, forKey: .serverValidationConfigurations)
        var serverValidationConfigurationsDecoded0:[ServerValidationConfiguration]? = nil
        if let serverValidationConfigurationsContainer = serverValidationConfigurationsContainer {
            serverValidationConfigurationsDecoded0 = [ServerValidationConfiguration]()
            for structure0 in serverValidationConfigurationsContainer {
                if let structure0 = structure0 {
                    serverValidationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        serverValidationConfigurations = serverValidationConfigurationsDecoded0
    }
}

extension ServerGroupValidationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerGroupValidationConfiguration(serverGroupId: \(String(describing: serverGroupId)), serverValidationConfigurations: \(String(describing: serverValidationConfigurations)))"}
}

/// <p>Configuration for validating an instance.</p>
public struct ServerGroupValidationConfiguration: Equatable {
    /// <p>The ID of the server group.</p>
    public let serverGroupId: String?
    /// <p>The validation configuration.</p>
    public let serverValidationConfigurations: [ServerValidationConfiguration]?

    public init (
        serverGroupId: String? = nil,
        serverValidationConfigurations: [ServerValidationConfiguration]? = nil
    )
    {
        self.serverGroupId = serverGroupId
        self.serverValidationConfigurations = serverValidationConfigurations
    }
}

extension ServerLaunchConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associatePublicIpAddress
        case configureScript
        case configureScriptType
        case ec2KeyName
        case iamInstanceProfileName
        case instanceType
        case logicalId
        case securityGroup
        case server
        case subnet
        case userData
        case vpc
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatePublicIpAddress = associatePublicIpAddress {
            try encodeContainer.encode(associatePublicIpAddress, forKey: .associatePublicIpAddress)
        }
        if let configureScript = configureScript {
            try encodeContainer.encode(configureScript, forKey: .configureScript)
        }
        if let configureScriptType = configureScriptType {
            try encodeContainer.encode(configureScriptType.rawValue, forKey: .configureScriptType)
        }
        if let ec2KeyName = ec2KeyName {
            try encodeContainer.encode(ec2KeyName, forKey: .ec2KeyName)
        }
        if let iamInstanceProfileName = iamInstanceProfileName {
            try encodeContainer.encode(iamInstanceProfileName, forKey: .iamInstanceProfileName)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let logicalId = logicalId {
            try encodeContainer.encode(logicalId, forKey: .logicalId)
        }
        if let securityGroup = securityGroup {
            try encodeContainer.encode(securityGroup, forKey: .securityGroup)
        }
        if let server = server {
            try encodeContainer.encode(server, forKey: .server)
        }
        if let subnet = subnet {
            try encodeContainer.encode(subnet, forKey: .subnet)
        }
        if let userData = userData {
            try encodeContainer.encode(userData, forKey: .userData)
        }
        if let vpc = vpc {
            try encodeContainer.encode(vpc, forKey: .vpc)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(Server.self, forKey: .server)
        server = serverDecoded
        let logicalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logicalId)
        logicalId = logicalIdDecoded
        let vpcDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpc)
        vpc = vpcDecoded
        let subnetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnet)
        subnet = subnetDecoded
        let securityGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityGroup)
        securityGroup = securityGroupDecoded
        let ec2KeyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2KeyName)
        ec2KeyName = ec2KeyNameDecoded
        let userDataDecoded = try containerValues.decodeIfPresent(UserData.self, forKey: .userData)
        userData = userDataDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let iamInstanceProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamInstanceProfileName)
        iamInstanceProfileName = iamInstanceProfileNameDecoded
        let configureScriptDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .configureScript)
        configureScript = configureScriptDecoded
        let configureScriptTypeDecoded = try containerValues.decodeIfPresent(ScriptType.self, forKey: .configureScriptType)
        configureScriptType = configureScriptTypeDecoded
    }
}

extension ServerLaunchConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerLaunchConfiguration(associatePublicIpAddress: \(String(describing: associatePublicIpAddress)), configureScript: \(String(describing: configureScript)), configureScriptType: \(String(describing: configureScriptType)), ec2KeyName: \(String(describing: ec2KeyName)), iamInstanceProfileName: \(String(describing: iamInstanceProfileName)), instanceType: \(String(describing: instanceType)), logicalId: \(String(describing: logicalId)), securityGroup: \(String(describing: securityGroup)), server: \(String(describing: server)), subnet: \(String(describing: subnet)), userData: \(String(describing: userData)), vpc: \(String(describing: vpc)))"}
}

/// <p>Launch configuration for a server.</p>
public struct ServerLaunchConfiguration: Equatable {
    /// <p>Indicates whether a publicly accessible IP address is created when launching the server.</p>
    public let associatePublicIpAddress: Bool?
    /// <p>Location of an Amazon S3 object.</p>
    public let configureScript: S3Location?
    /// <p>The type of configuration script.</p>
    public let configureScriptType: ScriptType?
    /// <p>The name of the Amazon EC2 SSH key to be used for connecting to the launched server.</p>
    public let ec2KeyName: String?
    /// <p>The name of the IAM instance profile.</p>
    public let iamInstanceProfileName: String?
    /// <p>The instance type to use when launching the server.</p>
    public let instanceType: String?
    /// <p>The logical ID of the server in the AWS CloudFormation template.</p>
    public let logicalId: String?
    /// <p>The ID of the security group that applies to the launched server.</p>
    public let securityGroup: String?
    /// <p>The ID of the server with which the launch configuration is associated.</p>
    public let server: Server?
    /// <p>The ID of the subnet the server should be launched into.</p>
    public let subnet: String?
    /// <p>Location of the user-data script to be executed when launching the server.</p>
    public let userData: UserData?
    /// <p>The ID of the VPC into which the server should be launched.</p>
    public let vpc: String?

    public init (
        associatePublicIpAddress: Bool? = nil,
        configureScript: S3Location? = nil,
        configureScriptType: ScriptType? = nil,
        ec2KeyName: String? = nil,
        iamInstanceProfileName: String? = nil,
        instanceType: String? = nil,
        logicalId: String? = nil,
        securityGroup: String? = nil,
        server: Server? = nil,
        subnet: String? = nil,
        userData: UserData? = nil,
        vpc: String? = nil
    )
    {
        self.associatePublicIpAddress = associatePublicIpAddress
        self.configureScript = configureScript
        self.configureScriptType = configureScriptType
        self.ec2KeyName = ec2KeyName
        self.iamInstanceProfileName = iamInstanceProfileName
        self.instanceType = instanceType
        self.logicalId = logicalId
        self.securityGroup = securityGroup
        self.server = server
        self.subnet = subnet
        self.userData = userData
        self.vpc = vpc
    }
}

extension ServerReplicationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case server
        case serverReplicationParameters
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let server = server {
            try encodeContainer.encode(server, forKey: .server)
        }
        if let serverReplicationParameters = serverReplicationParameters {
            try encodeContainer.encode(serverReplicationParameters, forKey: .serverReplicationParameters)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(Server.self, forKey: .server)
        server = serverDecoded
        let serverReplicationParametersDecoded = try containerValues.decodeIfPresent(ServerReplicationParameters.self, forKey: .serverReplicationParameters)
        serverReplicationParameters = serverReplicationParametersDecoded
    }
}

extension ServerReplicationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerReplicationConfiguration(server: \(String(describing: server)), serverReplicationParameters: \(String(describing: serverReplicationParameters)))"}
}

/// <p>Replication configuration of a server.</p>
public struct ServerReplicationConfiguration: Equatable {
    /// <p>The ID of the server with which this replication configuration is
    ///             associated.</p>
    public let server: Server?
    /// <p>The parameters for replicating the server.</p>
    public let serverReplicationParameters: ServerReplicationParameters?

    public init (
        server: Server? = nil,
        serverReplicationParameters: ServerReplicationParameters? = nil
    )
    {
        self.server = server
        self.serverReplicationParameters = serverReplicationParameters
    }
}

extension ServerReplicationParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encrypted
        case frequency
        case kmsKeyId
        case licenseType
        case numberOfRecentAmisToKeep
        case runOnce
        case seedTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency, forKey: .frequency)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let licenseType = licenseType {
            try encodeContainer.encode(licenseType.rawValue, forKey: .licenseType)
        }
        if let numberOfRecentAmisToKeep = numberOfRecentAmisToKeep {
            try encodeContainer.encode(numberOfRecentAmisToKeep, forKey: .numberOfRecentAmisToKeep)
        }
        if let runOnce = runOnce {
            try encodeContainer.encode(runOnce, forKey: .runOnce)
        }
        if let seedTime = seedTime {
            try encodeContainer.encode(seedTime.timeIntervalSince1970, forKey: .seedTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let seedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .seedTime)
        seedTime = seedTimeDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .frequency)
        frequency = frequencyDecoded
        let runOnceDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .runOnce)
        runOnce = runOnceDecoded
        let licenseTypeDecoded = try containerValues.decodeIfPresent(LicenseType.self, forKey: .licenseType)
        licenseType = licenseTypeDecoded
        let numberOfRecentAmisToKeepDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfRecentAmisToKeep)
        numberOfRecentAmisToKeep = numberOfRecentAmisToKeepDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension ServerReplicationParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerReplicationParameters(encrypted: \(String(describing: encrypted)), frequency: \(String(describing: frequency)), kmsKeyId: \(String(describing: kmsKeyId)), licenseType: \(String(describing: licenseType)), numberOfRecentAmisToKeep: \(String(describing: numberOfRecentAmisToKeep)), runOnce: \(String(describing: runOnce)), seedTime: \(String(describing: seedTime)))"}
}

/// <p>The replication parameters for replicating a server.</p>
public struct ServerReplicationParameters: Equatable {
    /// <p>Indicates whether the replication job produces encrypted AMIs.</p>
    public let encrypted: Bool?
    /// <p>The frequency of creating replication jobs for the server.</p>
    public let frequency: Int?
    /// <p>The ID of the KMS key for replication jobs that produce encrypted AMIs.
    ///             This value can be any of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>KMS key ID</p>
    ///             </li>
    ///             <li>
    ///                 <p>KMS key alias</p>
    ///             </li>
    ///             <li>
    ///                 <p>ARN referring to the KMS key ID</p>
    ///             </li>
    ///             <li>
    ///                 <p>ARN referring to the KMS key alias</p>
    ///             </li>
    ///          </ul>
    ///         <p>If encrypted is enabled but a KMS key ID is not specified, the
    ///             customer's default KMS key for Amazon EBS is used.</p>
    public let kmsKeyId: String?
    /// <p>The license type for creating a replication job for the server.</p>
    public let licenseType: LicenseType?
    /// <p>The number of recent AMIs to keep when creating a replication job for this server.</p>
    public let numberOfRecentAmisToKeep: Int?
    /// <p>Indicates whether to run the replication job one time.</p>
    public let runOnce: Bool?
    /// <p>The seed time for creating a replication job for the server.</p>
    public let seedTime: Date?

    public init (
        encrypted: Bool? = nil,
        frequency: Int? = nil,
        kmsKeyId: String? = nil,
        licenseType: LicenseType? = nil,
        numberOfRecentAmisToKeep: Int? = nil,
        runOnce: Bool? = nil,
        seedTime: Date? = nil
    )
    {
        self.encrypted = encrypted
        self.frequency = frequency
        self.kmsKeyId = kmsKeyId
        self.licenseType = licenseType
        self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
        self.runOnce = runOnce
        self.seedTime = seedTime
    }
}

public enum ServerType {
    case virtualmachine
    case sdkUnknown(String)
}

extension ServerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServerType] {
        return [
            .virtualmachine,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .virtualmachine: return "VIRTUAL_MACHINE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServerType(rawValue: rawValue) ?? ServerType.sdkUnknown(rawValue)
    }
}

extension ServerValidationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case server
        case serverValidationStrategy
        case userDataValidationParameters
        case validationId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let server = server {
            try encodeContainer.encode(server, forKey: .server)
        }
        if let serverValidationStrategy = serverValidationStrategy {
            try encodeContainer.encode(serverValidationStrategy.rawValue, forKey: .serverValidationStrategy)
        }
        if let userDataValidationParameters = userDataValidationParameters {
            try encodeContainer.encode(userDataValidationParameters, forKey: .userDataValidationParameters)
        }
        if let validationId = validationId {
            try encodeContainer.encode(validationId, forKey: .validationId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(Server.self, forKey: .server)
        server = serverDecoded
        let validationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validationId)
        validationId = validationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let serverValidationStrategyDecoded = try containerValues.decodeIfPresent(ServerValidationStrategy.self, forKey: .serverValidationStrategy)
        serverValidationStrategy = serverValidationStrategyDecoded
        let userDataValidationParametersDecoded = try containerValues.decodeIfPresent(UserDataValidationParameters.self, forKey: .userDataValidationParameters)
        userDataValidationParameters = userDataValidationParametersDecoded
    }
}

extension ServerValidationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerValidationConfiguration(name: \(String(describing: name)), server: \(String(describing: server)), serverValidationStrategy: \(String(describing: serverValidationStrategy)), userDataValidationParameters: \(String(describing: userDataValidationParameters)), validationId: \(String(describing: validationId)))"}
}

/// <p>Configuration for validating an instance.</p>
public struct ServerValidationConfiguration: Equatable {
    /// <p>The name of the configuration.</p>
    public let name: String?
    /// <p>Represents a server.</p>
    public let server: Server?
    /// <p>The validation strategy.</p>
    public let serverValidationStrategy: ServerValidationStrategy?
    /// <p>The validation parameters.</p>
    public let userDataValidationParameters: UserDataValidationParameters?
    /// <p>The ID of the validation.</p>
    public let validationId: String?

    public init (
        name: String? = nil,
        server: Server? = nil,
        serverValidationStrategy: ServerValidationStrategy? = nil,
        userDataValidationParameters: UserDataValidationParameters? = nil,
        validationId: String? = nil
    )
    {
        self.name = name
        self.server = server
        self.serverValidationStrategy = serverValidationStrategy
        self.userDataValidationParameters = userDataValidationParameters
        self.validationId = validationId
    }
}

extension ServerValidationOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case server
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let server = server {
            try encodeContainer.encode(server, forKey: .server)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(Server.self, forKey: .server)
        server = serverDecoded
    }
}

extension ServerValidationOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerValidationOutput(server: \(String(describing: server)))"}
}

/// <p>Contains output from validating an instance.</p>
public struct ServerValidationOutput: Equatable {
    /// <p>Represents a server.</p>
    public let server: Server?

    public init (
        server: Server? = nil
    )
    {
        self.server = server
    }
}

public enum ServerValidationStrategy {
    case userdata
    case sdkUnknown(String)
}

extension ServerValidationStrategy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServerValidationStrategy] {
        return [
            .userdata,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .userdata: return "USERDATA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServerValidationStrategy(rawValue: rawValue) ?? ServerValidationStrategy.sdkUnknown(rawValue)
    }
}

extension Source: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Location
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension Source: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Source(s3Location: \(String(describing: s3Location)))"}
}

/// <p>Contains the location of a validation script.</p>
public struct Source: Equatable {
    /// <p>Location of an Amazon S3 object.</p>
    public let s3Location: S3Location?

    public init (
        s3Location: S3Location? = nil
    )
    {
        self.s3Location = s3Location
    }
}

public struct StartAppReplicationInputBodyMiddleware: Middleware {
    public let id: String = "StartAppReplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAppReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAppReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAppReplicationInput>
    public typealias MOutput = OperationOutput<StartAppReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAppReplicationOutputError>
}

extension StartAppReplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartAppReplicationInput(appId: \(String(describing: appId)))"}
}

extension StartAppReplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

public struct StartAppReplicationInputHeadersMiddleware: Middleware {
    public let id: String = "StartAppReplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAppReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAppReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAppReplicationInput>
    public typealias MOutput = OperationOutput<StartAppReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAppReplicationOutputError>
}

public struct StartAppReplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "StartAppReplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAppReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAppReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAppReplicationInput>
    public typealias MOutput = OperationOutput<StartAppReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAppReplicationOutputError>
}

public struct StartAppReplicationInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?

    public init (
        appId: String? = nil
    )
    {
        self.appId = appId
    }
}

struct StartAppReplicationInputBody: Equatable {
    public let appId: String?
}

extension StartAppReplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension StartAppReplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAppReplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartAppReplicationOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAppReplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartAppReplicationOutputResponse()"}
}

extension StartAppReplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartAppReplicationOutputResponse: Equatable {

    public init() {}
}

struct StartAppReplicationOutputResponseBody: Equatable {
}

extension StartAppReplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StartOnDemandAppReplicationInputBodyMiddleware: Middleware {
    public let id: String = "StartOnDemandAppReplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartOnDemandAppReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartOnDemandAppReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartOnDemandAppReplicationInput>
    public typealias MOutput = OperationOutput<StartOnDemandAppReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartOnDemandAppReplicationOutputError>
}

extension StartOnDemandAppReplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartOnDemandAppReplicationInput(appId: \(String(describing: appId)), description: \(String(describing: description)))"}
}

extension StartOnDemandAppReplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
        case description
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct StartOnDemandAppReplicationInputHeadersMiddleware: Middleware {
    public let id: String = "StartOnDemandAppReplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartOnDemandAppReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartOnDemandAppReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartOnDemandAppReplicationInput>
    public typealias MOutput = OperationOutput<StartOnDemandAppReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartOnDemandAppReplicationOutputError>
}

public struct StartOnDemandAppReplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "StartOnDemandAppReplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartOnDemandAppReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartOnDemandAppReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartOnDemandAppReplicationInput>
    public typealias MOutput = OperationOutput<StartOnDemandAppReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartOnDemandAppReplicationOutputError>
}

public struct StartOnDemandAppReplicationInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?
    /// <p>The description of the replication run.</p>
    public let description: String?

    public init (
        appId: String? = nil,
        description: String? = nil
    )
    {
        self.appId = appId
        self.description = description
    }
}

struct StartOnDemandAppReplicationInputBody: Equatable {
    public let appId: String?
    public let description: String?
}

extension StartOnDemandAppReplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
        case description
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension StartOnDemandAppReplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartOnDemandAppReplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartOnDemandAppReplicationOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartOnDemandAppReplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartOnDemandAppReplicationOutputResponse()"}
}

extension StartOnDemandAppReplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartOnDemandAppReplicationOutputResponse: Equatable {

    public init() {}
}

struct StartOnDemandAppReplicationOutputResponseBody: Equatable {
}

extension StartOnDemandAppReplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StartOnDemandReplicationRunInputBodyMiddleware: Middleware {
    public let id: String = "StartOnDemandReplicationRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartOnDemandReplicationRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartOnDemandReplicationRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartOnDemandReplicationRunInput>
    public typealias MOutput = OperationOutput<StartOnDemandReplicationRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartOnDemandReplicationRunOutputError>
}

extension StartOnDemandReplicationRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartOnDemandReplicationRunInput(description: \(String(describing: description)), replicationJobId: \(String(describing: replicationJobId)))"}
}

extension StartOnDemandReplicationRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case replicationJobId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let replicationJobId = replicationJobId {
            try encodeContainer.encode(replicationJobId, forKey: .replicationJobId)
        }
    }
}

public struct StartOnDemandReplicationRunInputHeadersMiddleware: Middleware {
    public let id: String = "StartOnDemandReplicationRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartOnDemandReplicationRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartOnDemandReplicationRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartOnDemandReplicationRunInput>
    public typealias MOutput = OperationOutput<StartOnDemandReplicationRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartOnDemandReplicationRunOutputError>
}

public struct StartOnDemandReplicationRunInputQueryItemMiddleware: Middleware {
    public let id: String = "StartOnDemandReplicationRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartOnDemandReplicationRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartOnDemandReplicationRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartOnDemandReplicationRunInput>
    public typealias MOutput = OperationOutput<StartOnDemandReplicationRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartOnDemandReplicationRunOutputError>
}

public struct StartOnDemandReplicationRunInput: Equatable {
    /// <p>The description of the replication run.</p>
    public let description: String?
    /// <p>The ID of the replication job.</p>
    public let replicationJobId: String?

    public init (
        description: String? = nil,
        replicationJobId: String? = nil
    )
    {
        self.description = description
        self.replicationJobId = replicationJobId
    }
}

struct StartOnDemandReplicationRunInputBody: Equatable {
    public let replicationJobId: String?
    public let description: String?
}

extension StartOnDemandReplicationRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case replicationJobId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationJobId)
        replicationJobId = replicationJobIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension StartOnDemandReplicationRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartOnDemandReplicationRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DryRunOperationException" : self = .dryRunOperationException(try DryRunOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplicationRunLimitExceededException" : self = .replicationRunLimitExceededException(try ReplicationRunLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartOnDemandReplicationRunOutputError: Equatable {
    case dryRunOperationException(DryRunOperationException)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case replicationRunLimitExceededException(ReplicationRunLimitExceededException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartOnDemandReplicationRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartOnDemandReplicationRunOutputResponse(replicationRunId: \(String(describing: replicationRunId)))"}
}

extension StartOnDemandReplicationRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartOnDemandReplicationRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationRunId = output.replicationRunId
        } else {
            self.replicationRunId = nil
        }
    }
}

public struct StartOnDemandReplicationRunOutputResponse: Equatable {
    /// <p>The ID of the replication run.</p>
    public let replicationRunId: String?

    public init (
        replicationRunId: String? = nil
    )
    {
        self.replicationRunId = replicationRunId
    }
}

struct StartOnDemandReplicationRunOutputResponseBody: Equatable {
    public let replicationRunId: String?
}

extension StartOnDemandReplicationRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationRunId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationRunId)
        replicationRunId = replicationRunIdDecoded
    }
}

public struct StopAppReplicationInputBodyMiddleware: Middleware {
    public let id: String = "StopAppReplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopAppReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StopAppReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopAppReplicationInput>
    public typealias MOutput = OperationOutput<StopAppReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopAppReplicationOutputError>
}

extension StopAppReplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopAppReplicationInput(appId: \(String(describing: appId)))"}
}

extension StopAppReplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

public struct StopAppReplicationInputHeadersMiddleware: Middleware {
    public let id: String = "StopAppReplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopAppReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StopAppReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopAppReplicationInput>
    public typealias MOutput = OperationOutput<StopAppReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopAppReplicationOutputError>
}

public struct StopAppReplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "StopAppReplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopAppReplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<StopAppReplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopAppReplicationInput>
    public typealias MOutput = OperationOutput<StopAppReplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopAppReplicationOutputError>
}

public struct StopAppReplicationInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?

    public init (
        appId: String? = nil
    )
    {
        self.appId = appId
    }
}

struct StopAppReplicationInputBody: Equatable {
    public let appId: String?
}

extension StopAppReplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension StopAppReplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopAppReplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopAppReplicationOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopAppReplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopAppReplicationOutputResponse()"}
}

extension StopAppReplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopAppReplicationOutputResponse: Equatable {

    public init() {}
}

struct StopAppReplicationOutputResponseBody: Equatable {
}

extension StopAppReplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Key/value pair that can be assigned to an application.</p>
public struct Tag: Equatable {
    /// <p>The tag key.</p>
    public let key: String?
    /// <p>The tag value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TemporarilyUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemporarilyUnavailableException()"}
}

extension TemporarilyUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is temporarily unavailable.</p>
public struct TemporarilyUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server

    public init() {}
}

public struct TerminateAppInputBodyMiddleware: Middleware {
    public let id: String = "TerminateAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TerminateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<TerminateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TerminateAppInput>
    public typealias MOutput = OperationOutput<TerminateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TerminateAppOutputError>
}

extension TerminateAppInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TerminateAppInput(appId: \(String(describing: appId)))"}
}

extension TerminateAppInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

public struct TerminateAppInputHeadersMiddleware: Middleware {
    public let id: String = "TerminateAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TerminateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<TerminateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TerminateAppInput>
    public typealias MOutput = OperationOutput<TerminateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TerminateAppOutputError>
}

public struct TerminateAppInputQueryItemMiddleware: Middleware {
    public let id: String = "TerminateAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TerminateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<TerminateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TerminateAppInput>
    public typealias MOutput = OperationOutput<TerminateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TerminateAppOutputError>
}

public struct TerminateAppInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?

    public init (
        appId: String? = nil
    )
    {
        self.appId = appId
    }
}

struct TerminateAppInputBody: Equatable {
    public let appId: String?
}

extension TerminateAppInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension TerminateAppOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TerminateAppOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TerminateAppOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TerminateAppOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TerminateAppOutputResponse()"}
}

extension TerminateAppOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TerminateAppOutputResponse: Equatable {

    public init() {}
}

struct TerminateAppOutputResponseBody: Equatable {
}

extension TerminateAppOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UnauthorizedOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedOperationException(message: \(String(describing: message)))"}
}

extension UnauthorizedOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnauthorizedOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You lack permissions needed to perform this operation. Check your IAM policies,
///             and ensure that you are using the correct access keys.</p>
public struct UnauthorizedOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedOperationExceptionBody: Equatable {
    public let message: String?
}

extension UnauthorizedOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateAppInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAppInput>
    public typealias MOutput = OperationOutput<UpdateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAppOutputError>
}

extension UpdateAppInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAppInput(appId: \(String(describing: appId)), description: \(String(describing: description)), name: \(String(describing: name)), roleName: \(String(describing: roleName)), serverGroups: \(String(describing: serverGroups)), tags: \(String(describing: tags)))"}
}

extension UpdateAppInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
        case description
        case name
        case roleName
        case serverGroups
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleName = roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let serverGroups = serverGroups {
            var serverGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverGroups)
            for servergroups0 in serverGroups {
                try serverGroupsContainer.encode(servergroups0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct UpdateAppInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAppInput>
    public typealias MOutput = OperationOutput<UpdateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAppOutputError>
}

public struct UpdateAppInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAppInput>
    public typealias MOutput = OperationOutput<UpdateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAppOutputError>
}

public struct UpdateAppInput: Equatable {
    /// <p>The ID of the application.</p>
    public let appId: String?
    /// <p>The new description of the application.</p>
    public let description: String?
    /// <p>The new name of the application.</p>
    public let name: String?
    /// <p>The name of the service role in the customer's account used by AWS SMS.</p>
    public let roleName: String?
    /// <p>The server groups in the application to update.</p>
    public let serverGroups: [ServerGroup]?
    /// <p>The tags to associate with the application.</p>
    public let tags: [Tag]?

    public init (
        appId: String? = nil,
        description: String? = nil,
        name: String? = nil,
        roleName: String? = nil,
        serverGroups: [ServerGroup]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.appId = appId
        self.description = description
        self.name = name
        self.roleName = roleName
        self.serverGroups = serverGroups
        self.tags = tags
    }
}

struct UpdateAppInputBody: Equatable {
    public let appId: String?
    public let name: String?
    public let description: String?
    public let roleName: String?
    public let serverGroups: [ServerGroup]?
    public let tags: [Tag]?
}

extension UpdateAppInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
        case description
        case name
        case roleName
        case serverGroups
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let serverGroupsContainer = try containerValues.decodeIfPresent([ServerGroup?].self, forKey: .serverGroups)
        var serverGroupsDecoded0:[ServerGroup]? = nil
        if let serverGroupsContainer = serverGroupsContainer {
            serverGroupsDecoded0 = [ServerGroup]()
            for structure0 in serverGroupsContainer {
                if let structure0 = structure0 {
                    serverGroupsDecoded0?.append(structure0)
                }
            }
        }
        serverGroups = serverGroupsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateAppOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAppOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAppOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAppOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAppOutputResponse(appSummary: \(String(describing: appSummary)), serverGroups: \(String(describing: serverGroups)), tags: \(String(describing: tags)))"}
}

extension UpdateAppOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAppOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.appSummary = output.appSummary
            self.serverGroups = output.serverGroups
            self.tags = output.tags
        } else {
            self.appSummary = nil
            self.serverGroups = nil
            self.tags = nil
        }
    }
}

public struct UpdateAppOutputResponse: Equatable {
    /// <p>A summary description of the application.</p>
    public let appSummary: AppSummary?
    /// <p>The updated server groups in the application.</p>
    public let serverGroups: [ServerGroup]?
    /// <p>The tags associated with the application.</p>
    public let tags: [Tag]?

    public init (
        appSummary: AppSummary? = nil,
        serverGroups: [ServerGroup]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.appSummary = appSummary
        self.serverGroups = serverGroups
        self.tags = tags
    }
}

struct UpdateAppOutputResponseBody: Equatable {
    public let appSummary: AppSummary?
    public let serverGroups: [ServerGroup]?
    public let tags: [Tag]?
}

extension UpdateAppOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appSummary
        case serverGroups
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appSummaryDecoded = try containerValues.decodeIfPresent(AppSummary.self, forKey: .appSummary)
        appSummary = appSummaryDecoded
        let serverGroupsContainer = try containerValues.decodeIfPresent([ServerGroup?].self, forKey: .serverGroups)
        var serverGroupsDecoded0:[ServerGroup]? = nil
        if let serverGroupsContainer = serverGroupsContainer {
            serverGroupsDecoded0 = [ServerGroup]()
            for structure0 in serverGroupsContainer {
                if let structure0 = structure0 {
                    serverGroupsDecoded0?.append(structure0)
                }
            }
        }
        serverGroups = serverGroupsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateReplicationJobInputBodyMiddleware: Middleware {
    public let id: String = "UpdateReplicationJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReplicationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReplicationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReplicationJobInput>
    public typealias MOutput = OperationOutput<UpdateReplicationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReplicationJobOutputError>
}

extension UpdateReplicationJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateReplicationJobInput(description: \(String(describing: description)), encrypted: \(String(describing: encrypted)), frequency: \(String(describing: frequency)), kmsKeyId: \(String(describing: kmsKeyId)), licenseType: \(String(describing: licenseType)), nextReplicationRunStartTime: \(String(describing: nextReplicationRunStartTime)), numberOfRecentAmisToKeep: \(String(describing: numberOfRecentAmisToKeep)), replicationJobId: \(String(describing: replicationJobId)), roleName: \(String(describing: roleName)))"}
}

extension UpdateReplicationJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case encrypted
        case frequency
        case kmsKeyId
        case licenseType
        case nextReplicationRunStartTime
        case numberOfRecentAmisToKeep
        case replicationJobId
        case roleName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency, forKey: .frequency)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let licenseType = licenseType {
            try encodeContainer.encode(licenseType.rawValue, forKey: .licenseType)
        }
        if let nextReplicationRunStartTime = nextReplicationRunStartTime {
            try encodeContainer.encode(nextReplicationRunStartTime.timeIntervalSince1970, forKey: .nextReplicationRunStartTime)
        }
        if let numberOfRecentAmisToKeep = numberOfRecentAmisToKeep {
            try encodeContainer.encode(numberOfRecentAmisToKeep, forKey: .numberOfRecentAmisToKeep)
        }
        if let replicationJobId = replicationJobId {
            try encodeContainer.encode(replicationJobId, forKey: .replicationJobId)
        }
        if let roleName = roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
    }
}

public struct UpdateReplicationJobInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateReplicationJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReplicationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReplicationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReplicationJobInput>
    public typealias MOutput = OperationOutput<UpdateReplicationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReplicationJobOutputError>
}

public struct UpdateReplicationJobInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateReplicationJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReplicationJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReplicationJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReplicationJobInput>
    public typealias MOutput = OperationOutput<UpdateReplicationJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReplicationJobOutputError>
}

public struct UpdateReplicationJobInput: Equatable {
    /// <p>The description of the replication job.</p>
    public let description: String?
    /// <p>When true, the replication job produces encrypted AMIs. For more information,
    ///                 <code>KmsKeyId</code>.</p>
    public let encrypted: Bool?
    /// <p>The time between consecutive replication runs, in hours.</p>
    public let frequency: Int?
    /// <p>The ID of the KMS key for replication jobs that produce encrypted AMIs.
    ///             This value can be any of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>KMS key ID</p>
    ///             </li>
    ///             <li>
    ///                 <p>KMS key alias</p>
    ///             </li>
    ///             <li>
    ///                 <p>ARN referring to the KMS key ID</p>
    ///             </li>
    ///             <li>
    ///                 <p>ARN referring to the KMS key alias</p>
    ///             </li>
    ///          </ul>
    ///         <p>If encrypted is enabled but a KMS key ID is not specified, the
    ///             customer's default KMS key for Amazon EBS is used.</p>
    public let kmsKeyId: String?
    /// <p>The license type to be used for the AMI created by a successful replication
    ///             run.</p>
    public let licenseType: LicenseType?
    /// <p>The start time of the next replication run.</p>
    public let nextReplicationRunStartTime: Date?
    /// <p>The maximum number of SMS-created AMIs to retain. The oldest is deleted after the
    ///             maximum number is reached and a new AMI is created.</p>
    public let numberOfRecentAmisToKeep: Int?
    /// <p>The ID of the replication job.</p>
    public let replicationJobId: String?
    /// <p>The name of the IAM role to be used by AWS SMS.</p>
    public let roleName: String?

    public init (
        description: String? = nil,
        encrypted: Bool? = nil,
        frequency: Int? = nil,
        kmsKeyId: String? = nil,
        licenseType: LicenseType? = nil,
        nextReplicationRunStartTime: Date? = nil,
        numberOfRecentAmisToKeep: Int? = nil,
        replicationJobId: String? = nil,
        roleName: String? = nil
    )
    {
        self.description = description
        self.encrypted = encrypted
        self.frequency = frequency
        self.kmsKeyId = kmsKeyId
        self.licenseType = licenseType
        self.nextReplicationRunStartTime = nextReplicationRunStartTime
        self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
        self.replicationJobId = replicationJobId
        self.roleName = roleName
    }
}

struct UpdateReplicationJobInputBody: Equatable {
    public let replicationJobId: String?
    public let frequency: Int?
    public let nextReplicationRunStartTime: Date?
    public let licenseType: LicenseType?
    public let roleName: String?
    public let description: String?
    public let numberOfRecentAmisToKeep: Int?
    public let encrypted: Bool?
    public let kmsKeyId: String?
}

extension UpdateReplicationJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case encrypted
        case frequency
        case kmsKeyId
        case licenseType
        case nextReplicationRunStartTime
        case numberOfRecentAmisToKeep
        case replicationJobId
        case roleName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationJobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replicationJobId)
        replicationJobId = replicationJobIdDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .frequency)
        frequency = frequencyDecoded
        let nextReplicationRunStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .nextReplicationRunStartTime)
        nextReplicationRunStartTime = nextReplicationRunStartTimeDecoded
        let licenseTypeDecoded = try containerValues.decodeIfPresent(LicenseType.self, forKey: .licenseType)
        licenseType = licenseTypeDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let numberOfRecentAmisToKeepDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfRecentAmisToKeep)
        numberOfRecentAmisToKeep = numberOfRecentAmisToKeepDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension UpdateReplicationJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReplicationJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalError" : self = .internalError(try InternalError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameterException" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplicationJobNotFoundException" : self = .replicationJobNotFoundException(try ReplicationJobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerCannotBeReplicatedException" : self = .serverCannotBeReplicatedException(try ServerCannotBeReplicatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TemporarilyUnavailableException" : self = .temporarilyUnavailableException(try TemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateReplicationJobOutputError: Equatable {
    case internalError(InternalError)
    case invalidParameterException(InvalidParameterException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case replicationJobNotFoundException(ReplicationJobNotFoundException)
    case serverCannotBeReplicatedException(ServerCannotBeReplicatedException)
    case temporarilyUnavailableException(TemporarilyUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReplicationJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateReplicationJobOutputResponse()"}
}

extension UpdateReplicationJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateReplicationJobOutputResponse: Equatable {

    public init() {}
}

struct UpdateReplicationJobOutputResponseBody: Equatable {
}

extension UpdateReplicationJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UserData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Location
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension UserData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserData(s3Location: \(String(describing: s3Location)))"}
}

/// <p>A script that runs on first launch of an Amazon EC2 instance. Used for configuring the
///             server during launch.</p>
public struct UserData: Equatable {
    /// <p>Amazon S3 location of the user-data script.</p>
    public let s3Location: S3Location?

    public init (
        s3Location: S3Location? = nil
    )
    {
        self.s3Location = s3Location
    }
}

extension UserDataValidationParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case scriptType
        case source
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scriptType = scriptType {
            try encodeContainer.encode(scriptType.rawValue, forKey: .scriptType)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Source.self, forKey: .source)
        source = sourceDecoded
        let scriptTypeDecoded = try containerValues.decodeIfPresent(ScriptType.self, forKey: .scriptType)
        scriptType = scriptTypeDecoded
    }
}

extension UserDataValidationParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserDataValidationParameters(scriptType: \(String(describing: scriptType)), source: \(String(describing: source)))"}
}

/// <p>Contains validation parameters.</p>
public struct UserDataValidationParameters: Equatable {
    /// <p>The type of validation script.</p>
    public let scriptType: ScriptType?
    /// <p>The location of the validation script.</p>
    public let source: Source?

    public init (
        scriptType: ScriptType? = nil,
        source: Source? = nil
    )
    {
        self.scriptType = scriptType
        self.source = source
    }
}

extension ValidationOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appValidationOutput
        case latestValidationTime
        case name
        case serverValidationOutput
        case status
        case statusMessage
        case validationId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appValidationOutput = appValidationOutput {
            try encodeContainer.encode(appValidationOutput, forKey: .appValidationOutput)
        }
        if let latestValidationTime = latestValidationTime {
            try encodeContainer.encode(latestValidationTime.timeIntervalSince1970, forKey: .latestValidationTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverValidationOutput = serverValidationOutput {
            try encodeContainer.encode(serverValidationOutput, forKey: .serverValidationOutput)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let validationId = validationId {
            try encodeContainer.encode(validationId, forKey: .validationId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .validationId)
        validationId = validationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ValidationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let latestValidationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .latestValidationTime)
        latestValidationTime = latestValidationTimeDecoded
        let appValidationOutputDecoded = try containerValues.decodeIfPresent(AppValidationOutput.self, forKey: .appValidationOutput)
        appValidationOutput = appValidationOutputDecoded
        let serverValidationOutputDecoded = try containerValues.decodeIfPresent(ServerValidationOutput.self, forKey: .serverValidationOutput)
        serverValidationOutput = serverValidationOutputDecoded
    }
}

extension ValidationOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationOutput(appValidationOutput: \(String(describing: appValidationOutput)), latestValidationTime: \(String(describing: latestValidationTime)), name: \(String(describing: name)), serverValidationOutput: \(String(describing: serverValidationOutput)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), validationId: \(String(describing: validationId)))"}
}

/// <p>Contains validation output.</p>
public struct ValidationOutput: Equatable {
    /// <p>The output from validating an application.</p>
    public let appValidationOutput: AppValidationOutput?
    /// <p>The latest time that the validation was performed.</p>
    public let latestValidationTime: Date?
    /// <p>The name of the validation.</p>
    public let name: String?
    /// <p>The output from validation an instance.</p>
    public let serverValidationOutput: ServerValidationOutput?
    /// <p>The status of the validation.</p>
    public let status: ValidationStatus?
    /// <p>The status message.</p>
    public let statusMessage: String?
    /// <p>The ID of the validation.</p>
    public let validationId: String?

    public init (
        appValidationOutput: AppValidationOutput? = nil,
        latestValidationTime: Date? = nil,
        name: String? = nil,
        serverValidationOutput: ServerValidationOutput? = nil,
        status: ValidationStatus? = nil,
        statusMessage: String? = nil,
        validationId: String? = nil
    )
    {
        self.appValidationOutput = appValidationOutput
        self.latestValidationTime = latestValidationTime
        self.name = name
        self.serverValidationOutput = serverValidationOutput
        self.status = status
        self.statusMessage = statusMessage
        self.validationId = validationId
    }
}

public enum ValidationStatus {
    case failed
    case inprogress
    case pending
    case readyforvalidation
    case succeeded
    case sdkUnknown(String)
}

extension ValidationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidationStatus] {
        return [
            .failed,
            .inprogress,
            .pending,
            .readyforvalidation,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inprogress: return "IN_PROGRESS"
        case .pending: return "PENDING"
        case .readyforvalidation: return "READY_FOR_VALIDATION"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidationStatus(rawValue: rawValue) ?? ValidationStatus.sdkUnknown(rawValue)
    }
}

public enum VmManagerType {
    case hypervmanager
    case scvmm
    case vsphere
    case sdkUnknown(String)
}

extension VmManagerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VmManagerType] {
        return [
            .hypervmanager,
            .scvmm,
            .vsphere,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .hypervmanager: return "HYPERV-MANAGER"
        case .scvmm: return "SCVMM"
        case .vsphere: return "VSPHERE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VmManagerType(rawValue: rawValue) ?? VmManagerType.sdkUnknown(rawValue)
    }
}

extension VmServer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case vmManagerName
        case vmManagerType
        case vmName
        case vmPath
        case vmServerAddress
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vmManagerName = vmManagerName {
            try encodeContainer.encode(vmManagerName, forKey: .vmManagerName)
        }
        if let vmManagerType = vmManagerType {
            try encodeContainer.encode(vmManagerType.rawValue, forKey: .vmManagerType)
        }
        if let vmName = vmName {
            try encodeContainer.encode(vmName, forKey: .vmName)
        }
        if let vmPath = vmPath {
            try encodeContainer.encode(vmPath, forKey: .vmPath)
        }
        if let vmServerAddress = vmServerAddress {
            try encodeContainer.encode(vmServerAddress, forKey: .vmServerAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vmServerAddressDecoded = try containerValues.decodeIfPresent(VmServerAddress.self, forKey: .vmServerAddress)
        vmServerAddress = vmServerAddressDecoded
        let vmNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vmName)
        vmName = vmNameDecoded
        let vmManagerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vmManagerName)
        vmManagerName = vmManagerNameDecoded
        let vmManagerTypeDecoded = try containerValues.decodeIfPresent(VmManagerType.self, forKey: .vmManagerType)
        vmManagerType = vmManagerTypeDecoded
        let vmPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vmPath)
        vmPath = vmPathDecoded
    }
}

extension VmServer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VmServer(vmManagerName: \(String(describing: vmManagerName)), vmManagerType: \(String(describing: vmManagerType)), vmName: \(String(describing: vmName)), vmPath: \(String(describing: vmPath)), vmServerAddress: \(String(describing: vmServerAddress)))"}
}

/// <p>Represents a VM server.</p>
public struct VmServer: Equatable {
    /// <p>The name of the VM manager.</p>
    public let vmManagerName: String?
    /// <p>The type of VM management product.</p>
    public let vmManagerType: VmManagerType?
    /// <p>The name of the VM.</p>
    public let vmName: String?
    /// <p>The VM folder path in the vCenter Server virtual machine inventory tree.</p>
    public let vmPath: String?
    /// <p>The VM server location.</p>
    public let vmServerAddress: VmServerAddress?

    public init (
        vmManagerName: String? = nil,
        vmManagerType: VmManagerType? = nil,
        vmName: String? = nil,
        vmPath: String? = nil,
        vmServerAddress: VmServerAddress? = nil
    )
    {
        self.vmManagerName = vmManagerName
        self.vmManagerType = vmManagerType
        self.vmName = vmName
        self.vmPath = vmPath
        self.vmServerAddress = vmServerAddress
    }
}

extension VmServerAddress: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case vmId
        case vmManagerId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vmId = vmId {
            try encodeContainer.encode(vmId, forKey: .vmId)
        }
        if let vmManagerId = vmManagerId {
            try encodeContainer.encode(vmManagerId, forKey: .vmManagerId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vmManagerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vmManagerId)
        vmManagerId = vmManagerIdDecoded
        let vmIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vmId)
        vmId = vmIdDecoded
    }
}

extension VmServerAddress: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VmServerAddress(vmId: \(String(describing: vmId)), vmManagerId: \(String(describing: vmManagerId)))"}
}

/// <p>Represents a VM server location.</p>
public struct VmServerAddress: Equatable {
    /// <p>The ID of the VM.</p>
    public let vmId: String?
    /// <p>The ID of the VM manager.</p>
    public let vmManagerId: String?

    public init (
        vmId: String? = nil,
        vmManagerId: String? = nil
    )
    {
        self.vmId = vmId
        self.vmManagerId = vmManagerId
    }
}
