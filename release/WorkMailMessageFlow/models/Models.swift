// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension GetRawMessageContentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRawMessageContentInput(messageId: \(String(describing: messageId)))"}
}

extension GetRawMessageContentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRawMessageContentInputHeadersMiddleware: Middleware {
    public let id: String = "GetRawMessageContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRawMessageContentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRawMessageContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRawMessageContentInput>
    public typealias MOutput = OperationOutput<GetRawMessageContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRawMessageContentOutputError>
}

public struct GetRawMessageContentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRawMessageContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRawMessageContentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRawMessageContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRawMessageContentInput>
    public typealias MOutput = OperationOutput<GetRawMessageContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRawMessageContentOutputError>
}

public struct GetRawMessageContentInput: Equatable {
    /// <p>The identifier of the email message to retrieve.</p>
    public let messageId: String?

    public init (
        messageId: String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct GetRawMessageContentInputBody: Equatable {
}

extension GetRawMessageContentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRawMessageContentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRawMessageContentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRawMessageContentOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRawMessageContentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRawMessageContentOutputResponse(messageContent: \(String(describing: messageContent)))"}
}

extension GetRawMessageContentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let data) = httpResponse.body {
            self.messageContent = data
        } else {
            self.messageContent = nil
        }
    }
}

public struct GetRawMessageContentOutputResponse: Equatable {
    /// <p>The raw content of the email message, in MIME format.</p>
    public let messageContent: ByteStream?

    public init (
        messageContent: ByteStream? = nil
    )
    {
        self.messageContent = messageContent
    }
}

struct GetRawMessageContentOutputResponseBody: Equatable {
    public let messageContent: ByteStream?
}

extension GetRawMessageContentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageContent
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageContentDecoded = try containerValues.decodeIfPresent(ByteStream.self, forKey: .messageContent)
        messageContent = messageContentDecoded
    }
}

extension InvalidContentLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidContentLocation(message: \(String(describing: message)))"}
}

extension InvalidContentLocation: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidContentLocationBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>WorkMail could not access the updated email content. Possible reasons:</p>
///          <ul>
///             <li>
///                <p>You made the request in a region other than your S3 bucket region.</p>
///             </li>
///             <li>
///                <p>The <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-owner-condition.html">S3 bucket owner</a> is not the
///         same as the calling AWS account.</p>
///             </li>
///             <li>
///                <p>You have an incomplete or missing S3 bucket policy. For more information about policies, see
///         <a href="https://docs.aws.amazon.com/workmail/latest/adminguide/update-with-lambda.html">
///           Updating message content with AWS Lambda
///         </a> in the <i>WorkMail Administrator
///           Guide</i>.</p>
///             </li>
///          </ul>
public struct InvalidContentLocation: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidContentLocationBody: Equatable {
    public let message: String?
}

extension InvalidContentLocationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MessageFrozen: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MessageFrozen(message: \(String(describing: message)))"}
}

extension MessageFrozen: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MessageFrozenBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested email is not eligible for update. This is usually the case for a redirected email.</p>
public struct MessageFrozen: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MessageFrozenBody: Equatable {
    public let message: String?
}

extension MessageFrozenBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MessageRejected: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MessageRejected(message: \(String(describing: message)))"}
}

extension MessageRejected: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MessageRejectedBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested email could not be updated due to an error in the MIME content. Check the error message for more information about
///       what caused the error.</p>
public struct MessageRejected: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MessageRejectedBody: Equatable {
    public let message: String?
}

extension MessageRejectedBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutRawMessageContentInputBodyMiddleware: Middleware {
    public let id: String = "PutRawMessageContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRawMessageContentInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRawMessageContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRawMessageContentInput>
    public typealias MOutput = OperationOutput<PutRawMessageContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRawMessageContentOutputError>
}

extension PutRawMessageContentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRawMessageContentInput(content: \(String(describing: content)), messageId: \(String(describing: messageId)))"}
}

extension PutRawMessageContentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
    }
}

public struct PutRawMessageContentInputHeadersMiddleware: Middleware {
    public let id: String = "PutRawMessageContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRawMessageContentInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRawMessageContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRawMessageContentInput>
    public typealias MOutput = OperationOutput<PutRawMessageContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRawMessageContentOutputError>
}

public struct PutRawMessageContentInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRawMessageContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRawMessageContentInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRawMessageContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRawMessageContentInput>
    public typealias MOutput = OperationOutput<PutRawMessageContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRawMessageContentOutputError>
}

public struct PutRawMessageContentInput: Equatable {
    /// <p>Describes the raw message content of the updated email message.</p>
    public let content: RawMessageContent?
    /// <p>The identifier of the email message being updated.</p>
    public let messageId: String?

    public init (
        content: RawMessageContent? = nil,
        messageId: String? = nil
    )
    {
        self.content = content
        self.messageId = messageId
    }
}

struct PutRawMessageContentInputBody: Equatable {
    public let content: RawMessageContent?
}

extension PutRawMessageContentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case content
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(RawMessageContent.self, forKey: .content)
        content = contentDecoded
    }
}

extension PutRawMessageContentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRawMessageContentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidContentLocation" : self = .invalidContentLocation(try InvalidContentLocation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MessageFrozen" : self = .messageFrozen(try MessageFrozen(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MessageRejected" : self = .messageRejected(try MessageRejected(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRawMessageContentOutputError: Swift.Error, Equatable {
    case invalidContentLocation(InvalidContentLocation)
    case messageFrozen(MessageFrozen)
    case messageRejected(MessageRejected)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRawMessageContentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRawMessageContentOutputResponse()"}
}

extension PutRawMessageContentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutRawMessageContentOutputResponse: Equatable {

    public init() {}
}

struct PutRawMessageContentOutputResponseBody: Equatable {
}

extension PutRawMessageContentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RawMessageContent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Reference
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Reference = s3Reference {
            try encodeContainer.encode(s3Reference, forKey: .s3Reference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ReferenceDecoded = try containerValues.decodeIfPresent(S3Reference.self, forKey: .s3Reference)
        s3Reference = s3ReferenceDecoded
    }
}

extension RawMessageContent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RawMessageContent(s3Reference: \(String(describing: s3Reference)))"}
}

/// <p>Provides the MIME content of the updated email message as an S3 object. All MIME content must meet the following criteria:</p>
///          <ul>
///             <li>
///                <p>Each part of a multipart MIME message must be formatted properly.</p>
///             </li>
///             <li>
///                <p>Attachments must be of a content type that Amazon SES supports. For more information, see
///         <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/mime-types-appendix.html">Unsupported Attachment Types</a>.</p>
///             </li>
///             <li>
///                <p>If any of the MIME parts in a message contain content that is outside of the 7-bit ASCII character range, we recommend
///         encoding that content.</p>
///             </li>
///             <li>
///                <p>Per <a href="https://tools.ietf.org/html/rfc5321#section-4.5.3.1.6">RFC 5321</a>, the maximum length of each line of
///         text, including the <CRLF>, must not exceed 1,000 characters.</p>
///             </li>
///             <li>
///                <p>The message must contain all the required header fields. Check the returned error message for more information.</p>
///             </li>
///             <li>
///                <p>The value of immutable headers must remain unchanged. Check the returned error message for more information.</p>
///             </li>
///             <li>
///                <p>Certain unique headers can only appear once. Check the returned error message for more information.</p>
///             </li>
///          </ul>
public struct RawMessageContent: Equatable {
    /// <p>The S3 reference of an email message.</p>
    public let s3Reference: S3Reference?

    public init (
        s3Reference: S3Reference? = nil
    )
    {
        self.s3Reference = s3Reference
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested email message is not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3Reference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket
        case key
        case objectVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let objectVersion = objectVersion {
            try encodeContainer.encode(objectVersion, forKey: .objectVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let objectVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectVersion)
        objectVersion = objectVersionDecoded
    }
}

extension S3Reference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Reference(bucket: \(String(describing: bucket)), key: \(String(describing: key)), objectVersion: \(String(describing: objectVersion)))"}
}

/// <p>Amazon S3 object representing the updated message content, in MIME format.</p>
///          <note>
///             <p>The region for the S3 bucket containing the S3 object must match the region used for WorkMail operations. Also, for WorkMail to process
///       an S3 object, it must have permission to access that object. For more information, see
///       <a href="https://docs.aws.amazon.com/workmail/latest/adminguide/update-with-lambda.html">
///         Updating message content with AWS Lambda</a>.</p>
///          </note>
public struct S3Reference: Equatable {
    /// <p>The S3 bucket name.</p>
    public let bucket: String?
    /// <p>The S3 key object name.</p>
    public let key: String?
    /// <p>If you enable versioning for the bucket, you can specify the object version.</p>
    public let objectVersion: String?

    public init (
        bucket: String? = nil,
        key: String? = nil,
        objectVersion: String? = nil
    )
    {
        self.bucket = bucket
        self.key = key
        self.objectVersion = objectVersion
    }
}
