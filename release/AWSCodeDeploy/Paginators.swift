// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListApplicationRevisionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListApplicationRevisionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListApplicationRevisionsOutputResponse`
extension CodeDeployClient {
    public func listApplicationRevisionsPaginated(input: ListApplicationRevisionsInput) -> ClientRuntime.PaginatorSequence<ListApplicationRevisionsInput, ListApplicationRevisionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListApplicationRevisionsInput, ListApplicationRevisionsOutputResponse>(input: input, inputKey: \ListApplicationRevisionsInput.nextToken, outputKey: \ListApplicationRevisionsOutputResponse.nextToken, paginationFunction: self.listApplicationRevisions(input:))
    }
}

extension ListApplicationRevisionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListApplicationRevisionsInput {
        return ListApplicationRevisionsInput(
            applicationName: self.applicationName,
            deployed: self.deployed,
            nextToken: token,
            s3Bucket: self.s3Bucket,
            s3KeyPrefix: self.s3KeyPrefix,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listApplicationRevisionsPaginated`
/// to access the nested member `[CodeDeployClientTypes.RevisionLocation]`
/// - Returns: `[CodeDeployClientTypes.RevisionLocation]`
extension PaginatorSequence where Input == ListApplicationRevisionsInput, Output == ListApplicationRevisionsOutputResponse {
    func revisions() async throws -> [CodeDeployClientTypes.RevisionLocation] {
        return try await self.asyncCompactMap { item in item.revisions }
    }
}

/// Paginate over `[ListApplicationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListApplicationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListApplicationsOutputResponse`
extension CodeDeployClient {
    public func listApplicationsPaginated(input: ListApplicationsInput) -> ClientRuntime.PaginatorSequence<ListApplicationsInput, ListApplicationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListApplicationsInput, ListApplicationsOutputResponse>(input: input, inputKey: \ListApplicationsInput.nextToken, outputKey: \ListApplicationsOutputResponse.nextToken, paginationFunction: self.listApplications(input:))
    }
}

extension ListApplicationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListApplicationsInput {
        return ListApplicationsInput(
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listApplicationsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListApplicationsInput, Output == ListApplicationsOutputResponse {
    func applications() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.applications }
    }
}

/// Paginate over `[ListDeploymentConfigsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDeploymentConfigsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDeploymentConfigsOutputResponse`
extension CodeDeployClient {
    public func listDeploymentConfigsPaginated(input: ListDeploymentConfigsInput) -> ClientRuntime.PaginatorSequence<ListDeploymentConfigsInput, ListDeploymentConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDeploymentConfigsInput, ListDeploymentConfigsOutputResponse>(input: input, inputKey: \ListDeploymentConfigsInput.nextToken, outputKey: \ListDeploymentConfigsOutputResponse.nextToken, paginationFunction: self.listDeploymentConfigs(input:))
    }
}

extension ListDeploymentConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDeploymentConfigsInput {
        return ListDeploymentConfigsInput(
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDeploymentConfigsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListDeploymentConfigsInput, Output == ListDeploymentConfigsOutputResponse {
    func deploymentConfigsList() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.deploymentConfigsList }
    }
}

/// Paginate over `[ListDeploymentGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDeploymentGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDeploymentGroupsOutputResponse`
extension CodeDeployClient {
    public func listDeploymentGroupsPaginated(input: ListDeploymentGroupsInput) -> ClientRuntime.PaginatorSequence<ListDeploymentGroupsInput, ListDeploymentGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDeploymentGroupsInput, ListDeploymentGroupsOutputResponse>(input: input, inputKey: \ListDeploymentGroupsInput.nextToken, outputKey: \ListDeploymentGroupsOutputResponse.nextToken, paginationFunction: self.listDeploymentGroups(input:))
    }
}

extension ListDeploymentGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDeploymentGroupsInput {
        return ListDeploymentGroupsInput(
            applicationName: self.applicationName,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDeploymentGroupsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListDeploymentGroupsInput, Output == ListDeploymentGroupsOutputResponse {
    func deploymentGroups() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.deploymentGroups }
    }
}

/// Paginate over `[ListDeploymentInstancesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDeploymentInstancesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDeploymentInstancesOutputResponse`
extension CodeDeployClient {
    public func listDeploymentInstancesPaginated(input: ListDeploymentInstancesInput) -> ClientRuntime.PaginatorSequence<ListDeploymentInstancesInput, ListDeploymentInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDeploymentInstancesInput, ListDeploymentInstancesOutputResponse>(input: input, inputKey: \ListDeploymentInstancesInput.nextToken, outputKey: \ListDeploymentInstancesOutputResponse.nextToken, paginationFunction: self.listDeploymentInstances(input:))
    }
}

extension ListDeploymentInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDeploymentInstancesInput {
        return ListDeploymentInstancesInput(
            deploymentId: self.deploymentId,
            instanceStatusFilter: self.instanceStatusFilter,
            instanceTypeFilter: self.instanceTypeFilter,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDeploymentInstancesPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListDeploymentInstancesInput, Output == ListDeploymentInstancesOutputResponse {
    func instancesList() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.instancesList }
    }
}

/// Paginate over `[ListDeploymentsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListDeploymentsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListDeploymentsOutputResponse`
extension CodeDeployClient {
    public func listDeploymentsPaginated(input: ListDeploymentsInput) -> ClientRuntime.PaginatorSequence<ListDeploymentsInput, ListDeploymentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDeploymentsInput, ListDeploymentsOutputResponse>(input: input, inputKey: \ListDeploymentsInput.nextToken, outputKey: \ListDeploymentsOutputResponse.nextToken, paginationFunction: self.listDeployments(input:))
    }
}

extension ListDeploymentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDeploymentsInput {
        return ListDeploymentsInput(
            applicationName: self.applicationName,
            createTimeRange: self.createTimeRange,
            deploymentGroupName: self.deploymentGroupName,
            externalId: self.externalId,
            includeOnlyStatuses: self.includeOnlyStatuses,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listDeploymentsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListDeploymentsInput, Output == ListDeploymentsOutputResponse {
    func deployments() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.deployments }
    }
}
