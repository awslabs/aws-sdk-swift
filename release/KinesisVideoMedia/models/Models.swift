// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ClientLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClientLimitExceededException(message: \(String(describing: message)))"}
}

extension ClientLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ClientLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Kinesis Video Streams has throttled the request because you have exceeded the limit of
///       allowed client calls. Try making the call later.</p>
public struct ClientLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClientLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ClientLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectionLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionLimitExceededException(message: \(String(describing: message)))"}
}

extension ConnectionLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConnectionLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Kinesis Video Streams has throttled the request because you have exceeded the limit of
///       allowed client connections.</p>
public struct ConnectionLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConnectionLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ConnectionLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetMediaInputBodyMiddleware: Middleware {
    public let id: String = "GetMediaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMediaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMediaInput>
    public typealias MOutput = OperationOutput<GetMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMediaOutputError>
}

extension GetMediaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMediaInput(startSelector: \(String(describing: startSelector)), streamARN: \(String(describing: streamARN)), streamName: \(String(describing: streamName)))"}
}

extension GetMediaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case startSelector = "StartSelector"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startSelector = startSelector {
            try encodeContainer.encode(startSelector, forKey: .startSelector)
        }
        if let streamARN = streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

public struct GetMediaInputHeadersMiddleware: Middleware {
    public let id: String = "GetMediaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMediaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMediaInput>
    public typealias MOutput = OperationOutput<GetMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMediaOutputError>
}

public struct GetMediaInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMediaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMediaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMediaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMediaInput>
    public typealias MOutput = OperationOutput<GetMediaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMediaOutputError>
}

public struct GetMediaInput: Equatable {
    /// <p>Identifies the starting chunk to get from the specified stream. </p>
    public let startSelector: StartSelector?
    /// <p>The ARN of the stream from where you want to get the media content. If you don't
    ///       specify the <code>streamARN</code>, you must specify the <code>streamName</code>.</p>
    public let streamARN: String?
    /// <p>The Kinesis video stream name from where you want to get the media content. If you
    ///       don't specify the <code>streamName</code>, you must specify the
    ///       <code>streamARN</code>.</p>
    public let streamName: String?

    public init (
        startSelector: StartSelector? = nil,
        streamARN: String? = nil,
        streamName: String? = nil
    )
    {
        self.startSelector = startSelector
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct GetMediaInputBody: Equatable {
    public let streamName: String?
    public let streamARN: String?
    public let startSelector: StartSelector?
}

extension GetMediaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case startSelector = "StartSelector"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let startSelectorDecoded = try containerValues.decodeIfPresent(StartSelector.self, forKey: .startSelector)
        startSelector = startSelectorDecoded
    }
}

extension GetMediaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMediaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConnectionLimitExceededException" : self = .connectionLimitExceededException(try ConnectionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMediaOutputError: Swift.Error, Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case connectionLimitExceededException(ConnectionLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidEndpointException(InvalidEndpointException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMediaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMediaOutputResponse(contentType: \(String(describing: contentType)), payload: \(String(describing: payload)))"}
}

extension GetMediaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader
            self.payload = data
        } else {
            self.payload = nil
        }
    }
}

public struct GetMediaOutputResponse: Equatable {
    /// <p>The content type of the requested media.</p>
    public let contentType: String?
    /// <p> The payload Kinesis Video Streams returns is a sequence of chunks from the specified
    ///       stream. For information about the chunks, see . The
    ///       chunks that Kinesis Video Streams returns in the <code>GetMedia</code> call also include the
    ///       following additional Matroska (MKV) tags: </p>
    ///          <ul>
    ///             <li>
    ///                <p>AWS_KINESISVIDEO_CONTINUATION_TOKEN (UTF-8 string) - In the event your
    ///             <code>GetMedia</code> call terminates, you can use this continuation token in your next
    ///           request to get the next chunk where the last request terminated.</p>
    ///             </li>
    ///             <li>
    ///                <p>AWS_KINESISVIDEO_MILLIS_BEHIND_NOW (UTF-8 string) - Client applications can use
    ///           this tag value to determine how far behind the chunk returned in the response is from the
    ///           latest chunk on the stream. </p>
    ///             </li>
    ///             <li>
    ///                <p>AWS_KINESISVIDEO_FRAGMENT_NUMBER - Fragment number returned in the chunk.</p>
    ///             </li>
    ///             <li>
    ///                <p>AWS_KINESISVIDEO_SERVER_TIMESTAMP - Server timestamp of the fragment.</p>
    ///             </li>
    ///             <li>
    ///                <p>AWS_KINESISVIDEO_PRODUCER_TIMESTAMP - Producer timestamp of the fragment.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The following tags will be present if an error occurs:</p>
    ///          <ul>
    ///             <li>
    ///                <p>AWS_KINESISVIDEO_ERROR_CODE - String description of an error that caused GetMedia
    ///           to stop.</p>
    ///             </li>
    ///             <li>
    ///                <p>AWS_KINESISVIDEO_ERROR_ID: Integer code of the error.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The error codes are as follows:</p>
    ///          <ul>
    ///             <li>
    ///                <p>3002 - Error writing to the stream</p>
    ///             </li>
    ///             <li>
    ///                <p>4000 - Requested fragment is not found</p>
    ///             </li>
    ///             <li>
    ///                <p>4500 - Access denied for the stream's KMS key</p>
    ///             </li>
    ///             <li>
    ///                <p>4501 - Stream's KMS key is disabled</p>
    ///             </li>
    ///             <li>
    ///                <p>4502 - Validation error on the stream's KMS key</p>
    ///             </li>
    ///             <li>
    ///                <p>4503 - KMS key specified in the stream is unavailable</p>
    ///             </li>
    ///             <li>
    ///                <p>4504 - Invalid usage of the KMS key specified in the stream</p>
    ///             </li>
    ///             <li>
    ///                <p>4505 - Invalid state of the KMS key specified in the stream</p>
    ///             </li>
    ///             <li>
    ///                <p>4506 - Unable to find the KMS key specified in the stream</p>
    ///             </li>
    ///             <li>
    ///                <p>5000 - Internal error</p>
    ///             </li>
    ///          </ul>
    public let payload: ByteStream?

    public init (
        contentType: String? = nil,
        payload: ByteStream? = nil
    )
    {
        self.contentType = contentType
        self.payload = payload
    }
}

struct GetMediaOutputResponseBody: Equatable {
    public let payload: ByteStream?
}

extension GetMediaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case payload = "Payload"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(ByteStream.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension InvalidArgumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidArgumentException(message: \(String(describing: message)))"}
}

extension InvalidArgumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value for this input parameter is invalid.</p>
public struct InvalidArgumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Equatable {
    public let message: String?
}

extension InvalidArgumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEndpointException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidEndpointException(message: \(String(describing: message)))"}
}

extension InvalidEndpointException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidEndpointExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> Status Code: 400, Caller used wrong endpoint to write data to a stream. On receiving
///       such an exception, the user must call <code>GetDataEndpoint</code> with
///         <code>AccessMode</code> set to "READ" and use the endpoint Kinesis Video returns in the next
///         <code>GetMedia</code> call. </p>
public struct InvalidEndpointException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEndpointExceptionBody: Equatable {
    public let message: String?
}

extension InvalidEndpointExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotAuthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotAuthorizedException(message: \(String(describing: message)))"}
}

extension NotAuthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Status Code: 403, The caller is not authorized to perform an operation on the given
///       stream, or the token has expired.</p>
public struct NotAuthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotAuthorizedExceptionBody: Equatable {
    public let message: String?
}

extension NotAuthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Status Code: 404, The stream with the given name does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartSelector: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case afterFragmentNumber = "AfterFragmentNumber"
        case continuationToken = "ContinuationToken"
        case startSelectorType = "StartSelectorType"
        case startTimestamp = "StartTimestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterFragmentNumber = afterFragmentNumber {
            try encodeContainer.encode(afterFragmentNumber, forKey: .afterFragmentNumber)
        }
        if let continuationToken = continuationToken {
            try encodeContainer.encode(continuationToken, forKey: .continuationToken)
        }
        if let startSelectorType = startSelectorType {
            try encodeContainer.encode(startSelectorType.rawValue, forKey: .startSelectorType)
        }
        if let startTimestamp = startTimestamp {
            try encodeContainer.encode(startTimestamp.timeIntervalSince1970, forKey: .startTimestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startSelectorTypeDecoded = try containerValues.decodeIfPresent(StartSelectorType.self, forKey: .startSelectorType)
        startSelectorType = startSelectorTypeDecoded
        let afterFragmentNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterFragmentNumber)
        afterFragmentNumber = afterFragmentNumberDecoded
        let startTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTimestamp)
        startTimestamp = startTimestampDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
    }
}

extension StartSelector: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSelector(afterFragmentNumber: \(String(describing: afterFragmentNumber)), continuationToken: \(String(describing: continuationToken)), startSelectorType: \(String(describing: startSelectorType)), startTimestamp: \(String(describing: startTimestamp)))"}
}

/// <p>Identifies the chunk on the Kinesis video stream where you want the
///         <code>GetMedia</code> API to start returning media data. You have the following options to
///       identify the starting chunk: </p>
///          <ul>
///             <li>
///                <p>Choose the latest (or oldest) chunk.</p>
///             </li>
///             <li>
///                <p>Identify a specific chunk. You can identify a specific chunk either by providing a
///           fragment number or timestamp (server or producer). </p>
///             </li>
///             <li>
///                <p>Each chunk's metadata includes a continuation token as a Matroska (MKV) tag
///             (<code>AWS_KINESISVIDEO_CONTINUATION_TOKEN</code>). If your previous
///             <code>GetMedia</code> request terminated, you can use this tag value in your next
///             <code>GetMedia</code> request. The API then starts returning chunks starting where the
///           last API ended.</p>
///             </li>
///          </ul>
public struct StartSelector: Equatable {
    /// <p>Specifies the fragment number from where you want the <code>GetMedia</code> API to
    ///       start returning the fragments. </p>
    public let afterFragmentNumber: String?
    /// <p>Continuation token that Kinesis Video Streams returned in the previous
    ///         <code>GetMedia</code> response. The <code>GetMedia</code> API then starts with the chunk
    ///       identified by the continuation token.</p>
    public let continuationToken: String?
    /// <p>Identifies the fragment on the Kinesis video stream where you want to start getting the
    ///       data from.</p>
    ///          <ul>
    ///             <li>
    ///                <p>NOW - Start with the latest chunk on the stream.</p>
    ///             </li>
    ///             <li>
    ///                <p>EARLIEST - Start with earliest available chunk on the stream.</p>
    ///             </li>
    ///             <li>
    ///                <p>FRAGMENT_NUMBER - Start with the chunk after a specific fragment. You must also
    ///           specify the <code>AfterFragmentNumber</code> parameter.</p>
    ///             </li>
    ///             <li>
    ///                <p>PRODUCER_TIMESTAMP or SERVER_TIMESTAMP - Start with the chunk containing a fragment
    ///           with the specified producer or server timestamp. You specify the timestamp by adding
    ///             <code>StartTimestamp</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p> CONTINUATION_TOKEN - Read using the specified continuation token. </p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>If you choose the NOW, EARLIEST, or CONTINUATION_TOKEN as the
    ///           <code>startSelectorType</code>, you don't provide any additional information in the
    ///           <code>startSelector</code>.</p>
    ///          </note>
    public let startSelectorType: StartSelectorType?
    /// <p>A timestamp value. This value is required if you choose the PRODUCER_TIMESTAMP or the
    ///       SERVER_TIMESTAMP as the <code>startSelectorType</code>. The <code>GetMedia</code> API then
    ///       starts with the chunk containing the fragment that has the specified timestamp.</p>
    public let startTimestamp: Date?

    public init (
        afterFragmentNumber: String? = nil,
        continuationToken: String? = nil,
        startSelectorType: StartSelectorType? = nil,
        startTimestamp: Date? = nil
    )
    {
        self.afterFragmentNumber = afterFragmentNumber
        self.continuationToken = continuationToken
        self.startSelectorType = startSelectorType
        self.startTimestamp = startTimestamp
    }
}

public enum StartSelectorType {
    case continuationToken
    case earliest
    case fragmentNumber
    case now
    case producerTimestamp
    case serverTimestamp
    case sdkUnknown(String)
}

extension StartSelectorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StartSelectorType] {
        return [
            .continuationToken,
            .earliest,
            .fragmentNumber,
            .now,
            .producerTimestamp,
            .serverTimestamp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .continuationToken: return "CONTINUATION_TOKEN"
        case .earliest: return "EARLIEST"
        case .fragmentNumber: return "FRAGMENT_NUMBER"
        case .now: return "NOW"
        case .producerTimestamp: return "PRODUCER_TIMESTAMP"
        case .serverTimestamp: return "SERVER_TIMESTAMP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StartSelectorType(rawValue: rawValue) ?? StartSelectorType.sdkUnknown(rawValue)
    }
}
