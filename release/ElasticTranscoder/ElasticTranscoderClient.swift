// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class ElasticTranscoderClient {
    let client: SdkHttpClient
    let config: ElasticTranscoderClientConfiguration
    let serviceName = "Elastic Transcoder"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: ElasticTranscoderClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class ElasticTranscoderClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> ElasticTranscoderClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try ElasticTranscoderClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension ElasticTranscoderClient: ElasticTranscoderClientProtocol {
    /// <p>The CancelJob operation cancels an unfinished job.</p>
    ///         <note>
    ///             <p>You can only cancel a job that has a status of <code>Submitted</code>. To prevent a
    ///             pipeline from starting to process a job while you're getting the job identifier, use
    ///                 <a>UpdatePipelineStatus</a> to temporarily pause the pipeline.</p>
    ///          </note>
    public func cancelJob(input: CancelJobInput, completion: @escaping (SdkResult<CancelJobOutputResponse, CancelJobOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2012-09-25/jobs/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elastictranscoder.\(config.region).amazonaws.com")
                      .withSigningName(value: "elastictranscoder")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelJobInput, CancelJobOutputResponse, CancelJobOutputError>(id: "cancelJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelJobInput, CancelJobOutputResponse, CancelJobOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>When you create a job, Elastic Transcoder returns JSON data that includes the values that you specified
    ///             plus information about the job that is created.</p>
    ///         <p>If you have specified more than one output for your jobs (for example, one output for the
    ///             Kindle Fire and another output for the Apple iPhone 4s), you currently must use the Elastic Transcoder API to
    ///             list the jobs (as opposed to the AWS Console).</p>
    public func createJob(input: CreateJobInput, completion: @escaping (SdkResult<CreateJobOutputResponse, CreateJobOutputError>) -> Void)
    {
        let urlPath = "/2012-09-25/jobs"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elastictranscoder.\(config.region).amazonaws.com")
                      .withSigningName(value: "elastictranscoder")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateJobInput, CreateJobOutputResponse, CreateJobOutputError>(id: "createJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateJobInput, CreateJobOutputResponse, CreateJobOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateJobInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>The CreatePipeline operation creates a pipeline with settings that you specify.</p>
    public func createPipeline(input: CreatePipelineInput, completion: @escaping (SdkResult<CreatePipelineOutputResponse, CreatePipelineOutputError>) -> Void)
    {
        let urlPath = "/2012-09-25/pipelines"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createPipeline")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elastictranscoder.\(config.region).amazonaws.com")
                      .withSigningName(value: "elastictranscoder")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreatePipelineInput, CreatePipelineOutputResponse, CreatePipelineOutputError>(id: "createPipeline")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreatePipelineInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreatePipelineInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreatePipelineInput, CreatePipelineOutputResponse, CreatePipelineOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreatePipelineInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>The CreatePreset operation creates a preset with settings that you specify.</p>
    ///         <important>
    ///             <p>Elastic Transcoder checks the CreatePreset settings to ensure that they meet Elastic Transcoder requirements
    ///             and to determine whether they comply with H.264 standards. If your settings are not
    ///             valid for Elastic Transcoder, Elastic Transcoder returns an HTTP 400 response (<code>ValidationException</code>) and
    ///             does not create the preset. If the settings are valid for Elastic Transcoder but aren't strictly
    ///             compliant with the H.264 standard, Elastic Transcoder creates the preset and returns a warning message
    ///             in the response. This helps you determine whether your settings comply with the H.264
    ///             standard while giving you greater flexibility with respect to the video that Elastic Transcoder
    ///             produces.</p>
    ///          </important>
    ///         <p>Elastic Transcoder uses the H.264 video-compression format. For more information, see the International
    ///             Telecommunication Union publication <i>Recommendation ITU-T H.264: Advanced video coding
    ///                 for generic audiovisual services</i>.</p>
    public func createPreset(input: CreatePresetInput, completion: @escaping (SdkResult<CreatePresetOutputResponse, CreatePresetOutputError>) -> Void)
    {
        let urlPath = "/2012-09-25/presets"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createPreset")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elastictranscoder.\(config.region).amazonaws.com")
                      .withSigningName(value: "elastictranscoder")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreatePresetInput, CreatePresetOutputResponse, CreatePresetOutputError>(id: "createPreset")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreatePresetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreatePresetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreatePresetInput, CreatePresetOutputResponse, CreatePresetOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreatePresetInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>The DeletePipeline operation removes a pipeline.</p>
    ///         <p> You can only delete a pipeline that has never been used or that is not currently in use
    ///             (doesn't contain any active jobs). If the pipeline is currently in use,
    ///                 <code>DeletePipeline</code> returns an error. </p>
    public func deletePipeline(input: DeletePipelineInput, completion: @escaping (SdkResult<DeletePipelineOutputResponse, DeletePipelineOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2012-09-25/pipelines/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deletePipeline")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elastictranscoder.\(config.region).amazonaws.com")
                      .withSigningName(value: "elastictranscoder")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeletePipelineInput, DeletePipelineOutputResponse, DeletePipelineOutputError>(id: "deletePipeline")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeletePipelineInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeletePipelineInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeletePipelineInput, DeletePipelineOutputResponse, DeletePipelineOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>The DeletePreset operation removes a preset that you've added in an AWS region.</p>
    ///         <note>
    ///             <p>You can't delete the default presets that are included with Elastic Transcoder.</p>
    ///         </note>
    public func deletePreset(input: DeletePresetInput, completion: @escaping (SdkResult<DeletePresetOutputResponse, DeletePresetOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2012-09-25/presets/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deletePreset")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elastictranscoder.\(config.region).amazonaws.com")
                      .withSigningName(value: "elastictranscoder")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeletePresetInput, DeletePresetOutputResponse, DeletePresetOutputError>(id: "deletePreset")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeletePresetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeletePresetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeletePresetInput, DeletePresetOutputResponse, DeletePresetOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>The ListJobsByPipeline operation gets a list of the jobs currently in a pipeline.</p>
    ///         <p>Elastic Transcoder returns all of the jobs currently in the specified pipeline. The response body contains
    ///             one element for each job that satisfies the search criteria.</p>
    public func listJobsByPipeline(input: ListJobsByPipelineInput, completion: @escaping (SdkResult<ListJobsByPipelineOutputResponse, ListJobsByPipelineOutputError>) -> Void)
    {
        guard let pipelineId = input.pipelineId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component pipelineId unexpectedly nil"))))
            return
        }
        let urlPath = "/2012-09-25/jobsByPipeline/\(pipelineId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listJobsByPipeline")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elastictranscoder.\(config.region).amazonaws.com")
                      .withSigningName(value: "elastictranscoder")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListJobsByPipelineInput, ListJobsByPipelineOutputResponse, ListJobsByPipelineOutputError>(id: "listJobsByPipeline")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListJobsByPipelineInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListJobsByPipelineInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListJobsByPipelineInput, ListJobsByPipelineOutputResponse, ListJobsByPipelineOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>The ListJobsByStatus operation gets a list of jobs that have a specified status. The response
    ///             body contains one element for each job that satisfies the search criteria.</p>
    public func listJobsByStatus(input: ListJobsByStatusInput, completion: @escaping (SdkResult<ListJobsByStatusOutputResponse, ListJobsByStatusOutputError>) -> Void)
    {
        guard let status = input.status else {
            completion(.failure(.client(ClientError.serializationFailed("uri component status unexpectedly nil"))))
            return
        }
        let urlPath = "/2012-09-25/jobsByStatus/\(status)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listJobsByStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elastictranscoder.\(config.region).amazonaws.com")
                      .withSigningName(value: "elastictranscoder")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListJobsByStatusInput, ListJobsByStatusOutputResponse, ListJobsByStatusOutputError>(id: "listJobsByStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListJobsByStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListJobsByStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListJobsByStatusInput, ListJobsByStatusOutputResponse, ListJobsByStatusOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>The ListPipelines operation gets a list of the pipelines associated with the current AWS account.</p>
    public func listPipelines(input: ListPipelinesInput, completion: @escaping (SdkResult<ListPipelinesOutputResponse, ListPipelinesOutputError>) -> Void)
    {
        let urlPath = "/2012-09-25/pipelines"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listPipelines")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elastictranscoder.\(config.region).amazonaws.com")
                      .withSigningName(value: "elastictranscoder")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListPipelinesInput, ListPipelinesOutputResponse, ListPipelinesOutputError>(id: "listPipelines")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListPipelinesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListPipelinesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListPipelinesInput, ListPipelinesOutputResponse, ListPipelinesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>The ListPresets operation gets a list of the default presets included with Elastic Transcoder and the presets that
    ///             you've added in an AWS region.</p>
    public func listPresets(input: ListPresetsInput, completion: @escaping (SdkResult<ListPresetsOutputResponse, ListPresetsOutputError>) -> Void)
    {
        let urlPath = "/2012-09-25/presets"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listPresets")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elastictranscoder.\(config.region).amazonaws.com")
                      .withSigningName(value: "elastictranscoder")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListPresetsInput, ListPresetsOutputResponse, ListPresetsOutputError>(id: "listPresets")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListPresetsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListPresetsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListPresetsInput, ListPresetsOutputResponse, ListPresetsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>The ReadJob operation returns detailed information about a job.</p>
    public func readJob(input: ReadJobInput, completion: @escaping (SdkResult<ReadJobOutputResponse, ReadJobOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2012-09-25/jobs/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "readJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elastictranscoder.\(config.region).amazonaws.com")
                      .withSigningName(value: "elastictranscoder")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ReadJobInput, ReadJobOutputResponse, ReadJobOutputError>(id: "readJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ReadJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ReadJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ReadJobInput, ReadJobOutputResponse, ReadJobOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>The ReadPipeline operation gets detailed information about a pipeline.</p>
    public func readPipeline(input: ReadPipelineInput, completion: @escaping (SdkResult<ReadPipelineOutputResponse, ReadPipelineOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2012-09-25/pipelines/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "readPipeline")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elastictranscoder.\(config.region).amazonaws.com")
                      .withSigningName(value: "elastictranscoder")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ReadPipelineInput, ReadPipelineOutputResponse, ReadPipelineOutputError>(id: "readPipeline")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ReadPipelineInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ReadPipelineInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ReadPipelineInput, ReadPipelineOutputResponse, ReadPipelineOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>The ReadPreset operation gets detailed information about a preset.</p>
    public func readPreset(input: ReadPresetInput, completion: @escaping (SdkResult<ReadPresetOutputResponse, ReadPresetOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2012-09-25/presets/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "readPreset")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elastictranscoder.\(config.region).amazonaws.com")
                      .withSigningName(value: "elastictranscoder")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ReadPresetInput, ReadPresetOutputResponse, ReadPresetOutputError>(id: "readPreset")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ReadPresetInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ReadPresetInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ReadPresetInput, ReadPresetOutputResponse, ReadPresetOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>The TestRole operation tests the IAM role used to create the pipeline.</p>
    ///         <p>The <code>TestRole</code> action lets you determine whether the IAM role you are using
    ///             has sufficient permissions to let Elastic Transcoder perform tasks associated with the transcoding
    ///             process. The action attempts to assume the specified IAM role, checks read access to the
    ///             input and output buckets, and tries to send a test notification to Amazon SNS topics
    ///             that you specify.</p>
    @available(*, deprecated)
    public func testRole(input: TestRoleInput, completion: @escaping (SdkResult<TestRoleOutputResponse, TestRoleOutputError>) -> Void)
    {
        let urlPath = "/2012-09-25/roleTests"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "testRole")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elastictranscoder.\(config.region).amazonaws.com")
                      .withSigningName(value: "elastictranscoder")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TestRoleInput, TestRoleOutputResponse, TestRoleOutputError>(id: "testRole")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TestRoleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TestRoleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TestRoleInput, TestRoleOutputResponse, TestRoleOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TestRoleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p> Use the <code>UpdatePipeline</code> operation to update settings for a pipeline.</p>
    ///         <important>
    ///             <p>When you change pipeline settings, your changes take effect immediately.
    ///             Jobs that you have already submitted and that Elastic Transcoder has not started to process are
    ///             affected in addition to jobs that you submit after you change settings. </p>
    ///          </important>
    public func updatePipeline(input: UpdatePipelineInput, completion: @escaping (SdkResult<UpdatePipelineOutputResponse, UpdatePipelineOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2012-09-25/pipelines/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updatePipeline")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elastictranscoder.\(config.region).amazonaws.com")
                      .withSigningName(value: "elastictranscoder")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdatePipelineInput, UpdatePipelineOutputResponse, UpdatePipelineOutputError>(id: "updatePipeline")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdatePipelineInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdatePipelineInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdatePipelineInput, UpdatePipelineOutputResponse, UpdatePipelineOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdatePipelineInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>With the UpdatePipelineNotifications operation, you can update Amazon Simple Notification Service (Amazon SNS) notifications for a pipeline.</p>
    ///         <p>When you update notifications for a pipeline, Elastic Transcoder returns the values that you specified in the request.</p>
    public func updatePipelineNotifications(input: UpdatePipelineNotificationsInput, completion: @escaping (SdkResult<UpdatePipelineNotificationsOutputResponse, UpdatePipelineNotificationsOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2012-09-25/pipelines/\(id)/notifications"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updatePipelineNotifications")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elastictranscoder.\(config.region).amazonaws.com")
                      .withSigningName(value: "elastictranscoder")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdatePipelineNotificationsInput, UpdatePipelineNotificationsOutputResponse, UpdatePipelineNotificationsOutputError>(id: "updatePipelineNotifications")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdatePipelineNotificationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdatePipelineNotificationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdatePipelineNotificationsInput, UpdatePipelineNotificationsOutputResponse, UpdatePipelineNotificationsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdatePipelineNotificationsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>The UpdatePipelineStatus operation pauses or reactivates a pipeline, so that the pipeline
    ///             stops or restarts the processing of jobs.</p>
    ///         <p>Changing the pipeline status is useful if you want to cancel one or more jobs. You can't
    ///             cancel jobs after Elastic Transcoder has started processing them; if you pause the pipeline to which
    ///             you submitted the jobs, you have more time to get the job IDs for the jobs that you want
    ///             to cancel, and to send a <a>CancelJob</a> request. </p>
    public func updatePipelineStatus(input: UpdatePipelineStatusInput, completion: @escaping (SdkResult<UpdatePipelineStatusOutputResponse, UpdatePipelineStatusOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2012-09-25/pipelines/\(id)/status"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updatePipelineStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "elastictranscoder.\(config.region).amazonaws.com")
                      .withSigningName(value: "elastictranscoder")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdatePipelineStatusInput, UpdatePipelineStatusOutputResponse, UpdatePipelineStatusOutputError>(id: "updatePipelineStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdatePipelineStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdatePipelineStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdatePipelineStatusInput, UpdatePipelineStatusOutputResponse, UpdatePipelineStatusOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdatePipelineStatusInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
