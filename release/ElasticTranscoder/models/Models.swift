// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>General authentication failure. The request was not signed correctly.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticTranscoderClientTypes.Artwork: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case albumArtFormat = "AlbumArtFormat"
        case encryption = "Encryption"
        case inputKey = "InputKey"
        case maxHeight = "MaxHeight"
        case maxWidth = "MaxWidth"
        case paddingPolicy = "PaddingPolicy"
        case sizingPolicy = "SizingPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let albumArtFormat = albumArtFormat {
            try encodeContainer.encode(albumArtFormat, forKey: .albumArtFormat)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let inputKey = inputKey {
            try encodeContainer.encode(inputKey, forKey: .inputKey)
        }
        if let maxHeight = maxHeight {
            try encodeContainer.encode(maxHeight, forKey: .maxHeight)
        }
        if let maxWidth = maxWidth {
            try encodeContainer.encode(maxWidth, forKey: .maxWidth)
        }
        if let paddingPolicy = paddingPolicy {
            try encodeContainer.encode(paddingPolicy, forKey: .paddingPolicy)
        }
        if let sizingPolicy = sizingPolicy {
            try encodeContainer.encode(sizingPolicy, forKey: .sizingPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputKey)
        inputKey = inputKeyDecoded
        let maxWidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxWidth)
        maxWidth = maxWidthDecoded
        let maxHeightDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxHeight)
        maxHeight = maxHeightDecoded
        let sizingPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sizingPolicy)
        sizingPolicy = sizingPolicyDecoded
        let paddingPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paddingPolicy)
        paddingPolicy = paddingPolicyDecoded
        let albumArtFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .albumArtFormat)
        albumArtFormat = albumArtFormatDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
    }
}

extension ElasticTranscoderClientTypes.Artwork: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Artwork(albumArtFormat: \(Swift.String(describing: albumArtFormat)), encryption: \(Swift.String(describing: encryption)), inputKey: \(Swift.String(describing: inputKey)), maxHeight: \(Swift.String(describing: maxHeight)), maxWidth: \(Swift.String(describing: maxWidth)), paddingPolicy: \(Swift.String(describing: paddingPolicy)), sizingPolicy: \(Swift.String(describing: sizingPolicy)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>The file to be used as album art. There can be multiple artworks associated with an
    ///             audio file, to a maximum of 20.</p>
    ///         <p>To remove artwork or leave the artwork empty, you can either set <code>Artwork</code>
    ///             to null, or set the <code>Merge Policy</code> to "Replace" and use an empty
    ///             <code>Artwork</code> array.</p>
    ///         <p>To pass through existing artwork unchanged, set the <code>Merge Policy</code> to
    ///             "Prepend", "Append", or "Fallback", and use an empty <code>Artwork</code> array.</p>
    public struct Artwork: Swift.Equatable {
        /// <p>The format of album art, if any. Valid formats are <code>.jpg</code> and <code>.png</code>.</p>
        public let albumArtFormat: Swift.String?
        /// <p>The encryption settings, if any, that you want Elastic Transcoder to apply to your artwork.</p>
        public let encryption: ElasticTranscoderClientTypes.Encryption?
        /// <p>The name of the file to be used as album art. To determine which Amazon S3 bucket contains the
        ///             specified file, Elastic Transcoder checks the pipeline specified by <code>PipelineId</code>; the
        ///             <code>InputBucket</code> object in that pipeline identifies the bucket.</p>
        ///         <p>If the file name includes a prefix, for example, <code>cooking/pie.jpg</code>,
        ///             include the prefix in the key. If the file isn't in the specified bucket,
        ///             Elastic Transcoder returns an error.</p>
        public let inputKey: Swift.String?
        /// <p>The maximum height of the output album art in pixels. If you specify <code>auto</code>, Elastic Transcoder
        ///         uses 600 as the default value. If you specify a numeric value, enter an even integer between 32
        ///         and 3072, inclusive.</p>
        public let maxHeight: Swift.String?
        /// <p>The maximum width of the output album art in pixels. If you specify <code>auto</code>, Elastic Transcoder
        ///         uses 600 as the default value. If you specify a numeric value, enter an even integer between 32
        ///         and 4096, inclusive.</p>
        public let maxWidth: Swift.String?
        /// <p>When you set <code>PaddingPolicy</code> to <code>Pad</code>, Elastic Transcoder may add white bars to the
        ///         top and bottom and/or left and right sides of the output album art to make the total size of
        ///         the output art match the values that you specified for <code>MaxWidth</code> and
        ///         <code>MaxHeight</code>.</p>
        public let paddingPolicy: Swift.String?
        /// <p>Specify one of the following values to control scaling of the output album art:</p>
        ///
        ///             <ul>
        ///             <li>
        ///                <p>
        ///                   <code>Fit:</code> Elastic Transcoder scales the output art so it matches the value that you
        ///                     specified in either <code>MaxWidth</code> or <code>MaxHeight</code> without
        ///                     exceeding the other value.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Fill:</code> Elastic Transcoder scales the output art so it matches the value that you
        ///                     specified in either <code>MaxWidth</code> or <code>MaxHeight</code> and matches or
        ///                     exceeds the other value. Elastic Transcoder centers the output art and then crops it in the
        ///                     dimension (if any) that exceeds the maximum value. </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Stretch:</code> Elastic Transcoder stretches the output art to match the values that you
        ///                     specified for <code>MaxWidth</code> and <code>MaxHeight</code>. If the relative
        ///                     proportions of the input art and the output art are different, the output art will
        ///                     be distorted.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Keep:</code> Elastic Transcoder does not scale the output art. If either dimension of the
        ///                     input art exceeds the values that you specified for <code>MaxWidth</code> and
        ///                     <code>MaxHeight</code>, Elastic Transcoder crops the output art.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>ShrinkToFit:</code> Elastic Transcoder scales the output art down so that its dimensions
        ///                     match the values that you specified for at least one of <code>MaxWidth</code> and
        ///                     <code>MaxHeight</code> without exceeding either value. If you specify this option,
        ///                     Elastic Transcoder does not scale the art up.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>ShrinkToFill</code> Elastic Transcoder scales the output art down so that its dimensions
        ///                     match the values that you specified for at least one of <code>MaxWidth</code> and
        ///                     <code>MaxHeight</code> without dropping below either value. If you specify this
        ///                     option, Elastic Transcoder does not scale the art up.</p>
        ///             </li>
        ///          </ul>
        public let sizingPolicy: Swift.String?

        public init (
            albumArtFormat: Swift.String? = nil,
            encryption: ElasticTranscoderClientTypes.Encryption? = nil,
            inputKey: Swift.String? = nil,
            maxHeight: Swift.String? = nil,
            maxWidth: Swift.String? = nil,
            paddingPolicy: Swift.String? = nil,
            sizingPolicy: Swift.String? = nil
        )
        {
            self.albumArtFormat = albumArtFormat
            self.encryption = encryption
            self.inputKey = inputKey
            self.maxHeight = maxHeight
            self.maxWidth = maxWidth
            self.paddingPolicy = paddingPolicy
            self.sizingPolicy = sizingPolicy
        }
    }

}

extension ElasticTranscoderClientTypes.AudioCodecOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bitDepth = "BitDepth"
        case bitOrder = "BitOrder"
        case profile = "Profile"
        case signed = "Signed"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bitDepth = bitDepth {
            try encodeContainer.encode(bitDepth, forKey: .bitDepth)
        }
        if let bitOrder = bitOrder {
            try encodeContainer.encode(bitOrder, forKey: .bitOrder)
        }
        if let profile = profile {
            try encodeContainer.encode(profile, forKey: .profile)
        }
        if let signed = signed {
            try encodeContainer.encode(signed, forKey: .signed)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profile)
        profile = profileDecoded
        let bitDepthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bitDepth)
        bitDepth = bitDepthDecoded
        let bitOrderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bitOrder)
        bitOrder = bitOrderDecoded
        let signedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signed)
        signed = signedDecoded
    }
}

extension ElasticTranscoderClientTypes.AudioCodecOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AudioCodecOptions(bitDepth: \(Swift.String(describing: bitDepth)), bitOrder: \(Swift.String(describing: bitOrder)), profile: \(Swift.String(describing: profile)), signed: \(Swift.String(describing: signed)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>Options associated with your audio codec.</p>
    public struct AudioCodecOptions: Swift.Equatable {
        /// <p>You can only choose an audio bit depth when you specify <code>flac</code> or
        ///            <code>pcm</code> for the value of Audio:Codec.</p>
        ///         <p>The bit depth of a sample is how many bits of information are included in the
        ///             audio samples. The higher the bit depth, the better the audio, but the larger the file.</p>
        ///             <p>Valid values are <code>16</code> and <code>24</code>.</p>
        ///             <p>The most common bit depth is <code>24</code>.</p>
        public let bitDepth: Swift.String?
        /// <p>You can only choose an audio bit order when you specify
        ///            <code>pcm</code> for the value of Audio:Codec.</p>
        ///          <p>The order the bits of a PCM sample are stored in.</p>
        ///          <p>The supported value is <code>LittleEndian</code>.</p>
        public let bitOrder: Swift.String?
        /// <p>You can only choose an audio profile when you specify AAC for the value of Audio:Codec.</p>
        ///         <p>Specify the AAC profile for the output file. Elastic Transcoder supports the following profiles:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>auto</code>: If you specify <code>auto</code>, Elastic Transcoder selects
        ///                 the profile based on the bit rate selected for the output file.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>AAC-LC</code>: The most common AAC profile. Use for bit rates larger than
        ///                 64 kbps.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>HE-AAC</code>: Not supported on some older players and devices.
        ///                 Use for bit rates between 40 and 80 kbps.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>HE-AACv2</code>: Not supported on some players and devices.
        ///                 Use for bit rates less than 48 kbps.</p>
        ///             </li>
        ///          </ul>
        ///         <p>All outputs in a <code>Smooth</code> playlist must have the same value for <code>Profile</code>.</p>
        ///         <note>
        ///             <p>If you created any presets before AAC profiles were added, Elastic Transcoder automatically updated your
        ///              presets to use AAC-LC. You can change the value as required.</p>
        ///          </note>
        public let profile: Swift.String?
        /// <p>You can only choose whether an audio sample is signed when you specify
        ///            <code>pcm</code> for the value of Audio:Codec.</p>
        ///         <p>Whether audio samples are represented with negative and positive numbers (signed) or
        ///             only positive numbers (unsigned).</p>
        ///         <p>The supported value is <code>Signed</code>.</p>
        public let signed: Swift.String?

        public init (
            bitDepth: Swift.String? = nil,
            bitOrder: Swift.String? = nil,
            profile: Swift.String? = nil,
            signed: Swift.String? = nil
        )
        {
            self.bitDepth = bitDepth
            self.bitOrder = bitOrder
            self.profile = profile
            self.signed = signed
        }
    }

}

extension ElasticTranscoderClientTypes.AudioParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioPackingMode = "AudioPackingMode"
        case bitRate = "BitRate"
        case channels = "Channels"
        case codec = "Codec"
        case codecOptions = "CodecOptions"
        case sampleRate = "SampleRate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioPackingMode = audioPackingMode {
            try encodeContainer.encode(audioPackingMode, forKey: .audioPackingMode)
        }
        if let bitRate = bitRate {
            try encodeContainer.encode(bitRate, forKey: .bitRate)
        }
        if let channels = channels {
            try encodeContainer.encode(channels, forKey: .channels)
        }
        if let codec = codec {
            try encodeContainer.encode(codec, forKey: .codec)
        }
        if let codecOptions = codecOptions {
            try encodeContainer.encode(codecOptions, forKey: .codecOptions)
        }
        if let sampleRate = sampleRate {
            try encodeContainer.encode(sampleRate, forKey: .sampleRate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codec)
        codec = codecDecoded
        let sampleRateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleRate)
        sampleRate = sampleRateDecoded
        let bitRateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bitRate)
        bitRate = bitRateDecoded
        let channelsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channels)
        channels = channelsDecoded
        let audioPackingModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .audioPackingMode)
        audioPackingMode = audioPackingModeDecoded
        let codecOptionsDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.AudioCodecOptions.self, forKey: .codecOptions)
        codecOptions = codecOptionsDecoded
    }
}

extension ElasticTranscoderClientTypes.AudioParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AudioParameters(audioPackingMode: \(Swift.String(describing: audioPackingMode)), bitRate: \(Swift.String(describing: bitRate)), channels: \(Swift.String(describing: channels)), codec: \(Swift.String(describing: codec)), codecOptions: \(Swift.String(describing: codecOptions)), sampleRate: \(Swift.String(describing: sampleRate)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>Parameters required for transcoding audio.</p>
    public struct AudioParameters: Swift.Equatable {
        /// <p>The method of organizing audio channels and tracks. Use <code>Audio:Channels</code> to
        ///             specify the number of channels in your output, and <code>Audio:AudioPackingMode</code>
        ///             to specify the number of tracks and their relation to the channels. If you do not specify
        ///             an <code>Audio:AudioPackingMode</code>, Elastic Transcoder uses <code>SingleTrack</code>.</p>
        ///         <p>The following values are valid:</p>
        ///         <p>
        ///             <code>SingleTrack</code>, <code>OneChannelPerTrack</code>, and <code>OneChannelPerTrackWithMosTo8Tracks</code>
        ///          </p>
        ///
        ///         <p>When you specify <code>SingleTrack</code>, Elastic Transcoder creates a single track for your output.
        ///             The track can have up to eight channels. Use <code>SingleTrack</code> for all non-<code>mxf</code>
        ///             containers.</p>
        ///
        ///         <p>The outputs of <code>SingleTrack</code> for a specific channel value and inputs
        ///             are as follows:</p>
        ///
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>0</code>
        ///                   <b> channels with any input:</b> Audio omitted from the output</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>1, 2, or auto </code>
        ///                   <b>channels with no audio input:</b> Audio omitted from the output</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>1 </code>
        ///                   <b>channel with any input with audio:</b> One track with one channel, downmixed if necessary</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>2 </code>
        ///                   <b>channels with one track with one channel:</b> One track with two identical channels</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>2 or auto </code>
        ///                   <b>channels with two tracks with one channel each:</b> One track with two channels</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>2 or auto </code>
        ///                   <b>channels with one track with two channels:</b> One track with two channels</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>2 </code>
        ///                   <b>channels with one track with multiple channels:</b> One track with two channels</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>auto </code>
        ///                   <b>channels with one track with one channel:</b> One track with one channel</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>auto </code>
        ///                   <b>channels with one track with multiple channels:</b> One track with multiple channels</p>
        ///             </li>
        ///          </ul>
        ///
        ///         <p>When you specify <code>OneChannelPerTrack</code>, Elastic Transcoder creates a new track for every channel in your output. Your output
        ///             can have up to eight single-channel tracks.</p>
        ///         <p>The outputs of <code>OneChannelPerTrack</code> for a specific channel value and inputs
        ///             are as follows:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>0 </code>
        ///                   <b>channels with any input:</b> Audio omitted from the output</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>1, 2, or auto </code>
        ///                   <b>channels with no audio input:</b> Audio omitted from the output</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>1 </code>
        ///                   <b>channel with any input with audio:</b> One track with one channel, downmixed if necessary</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>2 </code>
        ///                   <b>channels with one track with one channel:</b> Two tracks with one identical channel each</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>2 or auto </code>
        ///                   <b>channels with two tracks with one channel each:</b> Two tracks with one channel each</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>2 or auto </code>
        ///                   <b>channels with one track with two channels:</b> Two tracks with one channel each</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>2 </code>
        ///                   <b>channels with one track with multiple channels:</b> Two tracks with one channel each</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>auto </code>
        ///                   <b>channels with one track with one channel:</b> One track with one channel</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>auto </code>
        ///                   <b>channels with one track with multiple channels:</b> Up to eight tracks with one channel each</p>
        ///             </li>
        ///          </ul>
        ///
        ///         <p>When you specify <code>OneChannelPerTrackWithMosTo8Tracks</code>, Elastic Transcoder creates eight single-channel
        ///             tracks for your output. All tracks that do not contain audio data from an input channel are
        ///             MOS, or Mit Out Sound, tracks.</p>
        ///         <p>The outputs of <code>OneChannelPerTrackWithMosTo8Tracks</code> for a specific channel value and inputs
        ///             are as follows:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>0 </code>
        ///                   <b>channels with any input:</b> Audio omitted from the output</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>1, 2, or auto </code>
        ///                   <b>channels with no audio input:</b> Audio omitted from the output</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>1 </code>
        ///                   <b>channel with any input with audio:</b> One track with one channel,
        ///                    downmixed if necessary, plus six MOS tracks</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>2 </code>
        ///                   <b>channels with one track with one channel:</b> Two tracks with one
        ///                    identical channel each, plus six MOS tracks</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>2 or auto </code>
        ///                   <b>channels with two tracks with one channel each:</b> Two tracks with
        ///                    one channel each, plus six MOS tracks</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>2 or auto </code>
        ///                   <b>channels with one track with two channels:</b> Two tracks with one
        ///                    channel each, plus six MOS tracks</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>2 </code>
        ///                   <b>channels with one track with multiple channels:</b> Two tracks with
        ///                    one channel each, plus six MOS tracks</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>auto </code>
        ///                   <b>channels with one track with one channel:</b> One track with one
        ///                    channel, plus seven MOS tracks</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>auto </code>
        ///                   <b>channels with one track with multiple channels:</b> Up to eight
        ///                    tracks with one channel each, plus MOS tracks
        ///                 until there are eight tracks in all</p>
        ///             </li>
        ///          </ul>
        public let audioPackingMode: Swift.String?
        /// <p>The bit rate of the audio stream in the output file, in kilobits/second. Enter an integer
        ///             between 64 and 320, inclusive.</p>
        public let bitRate: Swift.String?
        /// <p>The number of audio channels in the output file. The following values are valid:</p>
        ///         <p>
        ///             <code>auto</code>, <code>0</code>, <code>1</code>, <code>2</code>
        ///          </p>
        ///         <p>One channel carries the information played by a single speaker. For example, a stereo
        ///             track with two channels sends one channel to the left speaker, and the other
        ///             channel to the right speaker. The output channels are organized into tracks.
        ///             If you want Elastic Transcoder to automatically detect the number
        ///             of audio channels in the input file and use that value for the output file, select
        ///             <code>auto</code>.</p>
        ///
        ///         <p>The output of a specific channel value and inputs are as follows:</p>
        ///
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>auto</code>
        ///                   <b> channel specified, with any input:</b> Pass through up to eight input channels.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>0</code>
        ///                   <b> channels specified, with any input:</b> Audio omitted from the output.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>1</code>
        ///                   <b> channel specified, with at least one input channel:</b> Mono sound.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>2</code>
        ///                   <b> channels specified, with any input:</b> Two identical mono channels or stereo. For more
        ///                 information about tracks, see <code>Audio:AudioPackingMode.</code>
        ///                </p>
        ///             </li>
        ///          </ul>
        ///
        ///         <p> For more information about how Elastic Transcoder organizes channels and tracks, see
        ///             <code>Audio:AudioPackingMode</code>.</p>
        public let channels: Swift.String?
        /// <p>The audio codec for the output file. Valid values include <code>aac</code>,
        ///             <code>flac</code>, <code>mp2</code>, <code>mp3</code>, <code>pcm</code>,
        ///             and <code>vorbis</code>.</p>
        public let codec: Swift.String?
        /// <p>If you specified <code>AAC</code> for <code>Audio:Codec</code>, this is the <code>AAC</code>
        ///             compression profile to use. Valid values include:</p>
        ///         <p>
        ///             <code>auto</code>, <code>AAC-LC</code>, <code>HE-AAC</code>, <code>HE-AACv2</code>
        ///          </p>
        ///         <p>If you specify <code>auto</code>, Elastic Transcoder chooses a profile based on the bit rate of the output file.</p>
        public let codecOptions: ElasticTranscoderClientTypes.AudioCodecOptions?
        /// <p>The sample rate of the audio stream in the output file, in Hertz. Valid values include:</p>
        ///         <p>
        ///             <code>auto</code>, <code>22050</code>, <code>32000</code>, <code>44100</code>,
        ///                 <code>48000</code>, <code>96000</code>
        ///          </p>
        ///         <p>If you specify <code>auto</code>, Elastic Transcoder automatically detects the sample rate.</p>
        public let sampleRate: Swift.String?

        public init (
            audioPackingMode: Swift.String? = nil,
            bitRate: Swift.String? = nil,
            channels: Swift.String? = nil,
            codec: Swift.String? = nil,
            codecOptions: ElasticTranscoderClientTypes.AudioCodecOptions? = nil,
            sampleRate: Swift.String? = nil
        )
        {
            self.audioPackingMode = audioPackingMode
            self.bitRate = bitRate
            self.channels = channels
            self.codec = codec
            self.codecOptions = codecOptions
            self.sampleRate = sampleRate
        }
    }

}

extension CancelJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelJobInput(id: \(Swift.String(describing: id)))"}
}

extension CancelJobInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct CancelJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelJobOutputError>
}

public struct CancelJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelJobOutputError>
}

/// <p>The <code>CancelJobRequest</code> structure.</p>
public struct CancelJobInput: Swift.Equatable {
    /// <p>The identifier of the job that you want to cancel.</p>
    ///         <p>To get a list of the jobs (including their <code>jobId</code>) that have a status of
    ///                 <code>Submitted</code>, use the <a>ListJobsByStatus</a> API action.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct CancelJobInputBody: Swift.Equatable {
}

extension CancelJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelJobOutputResponse()"}
}

extension CancelJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p>The response body contains a JSON object. If the job is successfully canceled, the value
///             of <code>Success</code> is <code>true</code>.</p>
public struct CancelJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct CancelJobOutputResponseBody: Swift.Equatable {
}

extension CancelJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ElasticTranscoderClientTypes.CaptionFormat: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryption = "Encryption"
        case format = "Format"
        case pattern = "Pattern"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let pattern = pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let patternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pattern)
        pattern = patternDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
    }
}

extension ElasticTranscoderClientTypes.CaptionFormat: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CaptionFormat(encryption: \(Swift.String(describing: encryption)), format: \(Swift.String(describing: format)), pattern: \(Swift.String(describing: pattern)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>The file format of the output captions. If you leave this value blank, Elastic Transcoder returns an error.</p>
    public struct CaptionFormat: Swift.Equatable {
        /// <p>The encryption settings, if any, that you want Elastic Transcoder to apply to your caption formats.</p>
        public let encryption: ElasticTranscoderClientTypes.Encryption?
        /// <p>The format you specify determines whether Elastic Transcoder generates an embedded or sidecar caption for this output.</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <b>Valid Embedded Caption Formats:</b>
        ///                </p>
        ///                <ul>
        ///                   <li>
        ///                      <p>
        ///                         <b>for FLAC</b>: None</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>
        ///                         <b>For MP3</b>: None</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>
        ///                         <b>For MP4</b>: mov-text</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>
        ///                         <b>For MPEG-TS</b>: None</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>
        ///                         <b>For ogg</b>: None</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>
        ///                         <b>For webm</b>: None</p>
        ///                   </li>
        ///                </ul>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Valid Sidecar Caption Formats:</b> Elastic Transcoder
        ///             supports dfxp (first div element only), scc, srt, and webvtt.
        ///             If you want ttml or smpte-tt
        ///             compatible captions, specify dfxp as your output format.</p>
        ///                <ul>
        ///                   <li>
        ///                      <p>
        ///                         <b>For FMP4</b>: dfxp</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>
        ///                         <b>Non-FMP4 outputs</b>: All sidecar types</p>
        ///                   </li>
        ///                </ul>
        ///                <p>
        ///                   <code>fmp4</code> captions have an extension of <code>.ismt</code>
        ///                </p>
        ///             </li>
        ///          </ul>
        public let format: Swift.String?
        /// <p>The prefix for caption filenames, in the form <i>description</i>-<code>{language}</code>, where:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <i>description</i> is a description of the video.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>{language}</code> is a literal value that Elastic Transcoder replaces with the two- or three-letter
        ///             code for the language of the caption in the output file names.</p>
        ///             </li>
        ///          </ul>
        ///          <p>If you don't include <code>{language}</code> in the file name pattern, Elastic Transcoder automatically
        ///          appends "<code>{language}</code>" to the value that you specify for the description.  In addition,
        ///          Elastic Transcoder automatically appends the count to the end of the segment files.</p>
        ///          <p>For example, suppose you're transcoding into srt format. When you enter "Sydney-{language}-sunrise",
        ///           and the language of the captions is English (en), the name of the first caption file is be
        ///           Sydney-en-sunrise00000.srt.</p>
        public let pattern: Swift.String?

        public init (
            encryption: ElasticTranscoderClientTypes.Encryption? = nil,
            format: Swift.String? = nil,
            pattern: Swift.String? = nil
        )
        {
            self.encryption = encryption
            self.format = format
            self.pattern = pattern
        }
    }

}

extension ElasticTranscoderClientTypes.CaptionSource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryption = "Encryption"
        case key = "Key"
        case label = "Label"
        case language = "Language"
        case timeOffset = "TimeOffset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let timeOffset = timeOffset {
            try encodeContainer.encode(timeOffset, forKey: .timeOffset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
        let timeOffsetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeOffset)
        timeOffset = timeOffsetDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
    }
}

extension ElasticTranscoderClientTypes.CaptionSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CaptionSource(encryption: \(Swift.String(describing: encryption)), key: \(Swift.String(describing: key)), label: \(Swift.String(describing: label)), language: \(Swift.String(describing: language)), timeOffset: \(Swift.String(describing: timeOffset)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>A source file for the input sidecar captions used during the transcoding process.</p>
    public struct CaptionSource: Swift.Equatable {
        /// <p>The encryption settings, if any, that Elastic Transcoder needs to decyrpt your caption sources, or that you
        ///             want Elastic Transcoder to apply to your caption sources.</p>
        public let encryption: ElasticTranscoderClientTypes.Encryption?
        /// <p>The name of the sidecar caption file that you want Elastic Transcoder to include in the output file.</p>
        public let key: Swift.String?
        /// <p>The label of the caption shown in the player when choosing a language. We recommend that you
        ///             put the caption language name here, in the language of the captions.</p>
        public let label: Swift.String?
        /// <p>A string that specifies the language of the caption. If you specified multiple inputs with captions,
        ///             the caption language must match in order to be included in the output. Specify this as one of:</p>
        ///         <ul>
        ///             <li>
        ///                 <p>2-character ISO 639-1 code</p>
        ///             </li>
        ///             <li>
        ///                 <p>3-character ISO 639-2 code</p>
        ///             </li>
        ///          </ul>
        ///         <p>For more information on ISO language codes and language names, see the List of ISO 639-1 codes.</p>
        public let language: Swift.String?
        /// <p>For clip generation or captions that do not start at the same time
        ///             as the associated video file, the <code>TimeOffset</code> tells Elastic Transcoder how much of the video to encode
        ///             before including captions.</p>
        ///         <p>Specify the TimeOffset in the form [+-]SS.sss or [+-]HH:mm:SS.ss.</p>
        public let timeOffset: Swift.String?

        public init (
            encryption: ElasticTranscoderClientTypes.Encryption? = nil,
            key: Swift.String? = nil,
            label: Swift.String? = nil,
            language: Swift.String? = nil,
            timeOffset: Swift.String? = nil
        )
        {
            self.encryption = encryption
            self.key = key
            self.label = label
            self.language = language
            self.timeOffset = timeOffset
        }
    }

}

extension ElasticTranscoderClientTypes.Captions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case captionFormats = "CaptionFormats"
        case captionSources = "CaptionSources"
        case mergePolicy = "MergePolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let captionFormats = captionFormats {
            var captionFormatsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .captionFormats)
            for captionformats0 in captionFormats {
                try captionFormatsContainer.encode(captionformats0)
            }
        }
        if let captionSources = captionSources {
            var captionSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .captionSources)
            for captionsources0 in captionSources {
                try captionSourcesContainer.encode(captionsources0)
            }
        }
        if let mergePolicy = mergePolicy {
            try encodeContainer.encode(mergePolicy, forKey: .mergePolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mergePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergePolicy)
        mergePolicy = mergePolicyDecoded
        let captionSourcesContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.CaptionSource?].self, forKey: .captionSources)
        var captionSourcesDecoded0:[ElasticTranscoderClientTypes.CaptionSource]? = nil
        if let captionSourcesContainer = captionSourcesContainer {
            captionSourcesDecoded0 = [ElasticTranscoderClientTypes.CaptionSource]()
            for structure0 in captionSourcesContainer {
                if let structure0 = structure0 {
                    captionSourcesDecoded0?.append(structure0)
                }
            }
        }
        captionSources = captionSourcesDecoded0
        let captionFormatsContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.CaptionFormat?].self, forKey: .captionFormats)
        var captionFormatsDecoded0:[ElasticTranscoderClientTypes.CaptionFormat]? = nil
        if let captionFormatsContainer = captionFormatsContainer {
            captionFormatsDecoded0 = [ElasticTranscoderClientTypes.CaptionFormat]()
            for structure0 in captionFormatsContainer {
                if let structure0 = structure0 {
                    captionFormatsDecoded0?.append(structure0)
                }
            }
        }
        captionFormats = captionFormatsDecoded0
    }
}

extension ElasticTranscoderClientTypes.Captions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Captions(captionFormats: \(Swift.String(describing: captionFormats)), captionSources: \(Swift.String(describing: captionSources)), mergePolicy: \(Swift.String(describing: mergePolicy)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>The captions to be created, if any.</p>
    public struct Captions: Swift.Equatable {
        /// <p>The array of file formats for the output captions. If you leave this value blank, Elastic Transcoder returns an error.</p>
        public let captionFormats: [ElasticTranscoderClientTypes.CaptionFormat]?
        /// <p>Source files for the input sidecar captions used during the transcoding
        ///          process. To omit all sidecar captions, leave <code>CaptionSources</code> blank.</p>
        @available(*, deprecated)
        public let captionSources: [ElasticTranscoderClientTypes.CaptionSource]?
        /// <p>A policy that determines how Elastic Transcoder handles the existence of multiple captions.</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <b>MergeOverride:</b> Elastic Transcoder transcodes both embedded
        ///             and sidecar captions into outputs. If captions for a language are embedded in the input
        ///             file and also appear in a sidecar file, Elastic Transcoder uses the sidecar captions and ignores the
        ///             embedded captions for that language.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>MergeRetain:</b>  Elastic Transcoder transcodes both embedded
        ///             and sidecar captions into outputs. If captions for a language are embedded in the input
        ///             file and also appear in a sidecar file, Elastic Transcoder uses the embedded captions and ignores the
        ///             sidecar captions for that language. If <code>CaptionSources</code> is empty,
        ///             Elastic Transcoder omits all sidecar captions from the output files.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Override:</b> Elastic Transcoder transcodes only the
        ///             sidecar captions that you specify in <code>CaptionSources</code>.</p>
        ///             </li>
        ///          </ul>
        ///          <p>
        ///             <code>MergePolicy</code> cannot be null.</p>
        @available(*, deprecated)
        public let mergePolicy: Swift.String?

        public init (
            captionFormats: [ElasticTranscoderClientTypes.CaptionFormat]? = nil,
            captionSources: [ElasticTranscoderClientTypes.CaptionSource]? = nil,
            mergePolicy: Swift.String? = nil
        )
        {
            self.captionFormats = captionFormats
            self.captionSources = captionSources
            self.mergePolicy = mergePolicy
        }
    }

}

extension ElasticTranscoderClientTypes.Clip: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timeSpan = "TimeSpan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timeSpan = timeSpan {
            try encodeContainer.encode(timeSpan, forKey: .timeSpan)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeSpanDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.TimeSpan.self, forKey: .timeSpan)
        timeSpan = timeSpanDecoded
    }
}

extension ElasticTranscoderClientTypes.Clip: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Clip(timeSpan: \(Swift.String(describing: timeSpan)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>Settings for one clip in a composition. All jobs in a playlist must have the same clip settings.</p>
    @available(*, deprecated)
    public struct Clip: Swift.Equatable {
        /// <p>Settings that determine when a clip begins and how long it lasts.</p>
        public let timeSpan: ElasticTranscoderClientTypes.TimeSpan?

        public init (
            timeSpan: ElasticTranscoderClientTypes.TimeSpan? = nil
        )
        {
            self.timeSpan = timeSpan
        }
    }

}

public struct CreateJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateJobOutputError>
}

extension CreateJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateJobInput(input: \(Swift.String(describing: input)), inputs: \(Swift.String(describing: inputs)), output: \(Swift.String(describing: output)), outputKeyPrefix: \(Swift.String(describing: outputKeyPrefix)), outputs: \(Swift.String(describing: outputs)), pipelineId: \(Swift.String(describing: pipelineId)), playlists: \(Swift.String(describing: playlists)), userMetadata: \(Swift.String(describing: userMetadata)))"}
}

extension CreateJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case input = "Input"
        case inputs = "Inputs"
        case output = "Output"
        case outputKeyPrefix = "OutputKeyPrefix"
        case outputs = "Outputs"
        case pipelineId = "PipelineId"
        case playlists = "Playlists"
        case userMetadata = "UserMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let inputs = inputs {
            var inputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputs)
            for jobinputs0 in inputs {
                try inputsContainer.encode(jobinputs0)
            }
        }
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputKeyPrefix = outputKeyPrefix {
            try encodeContainer.encode(outputKeyPrefix, forKey: .outputKeyPrefix)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for createjoboutputs0 in outputs {
                try outputsContainer.encode(createjoboutputs0)
            }
        }
        if let pipelineId = pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let playlists = playlists {
            var playlistsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .playlists)
            for createjobplaylists0 in playlists {
                try playlistsContainer.encode(createjobplaylists0)
            }
        }
        if let userMetadata = userMetadata {
            var userMetadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .userMetadata)
            for (dictKey0, usermetadata0) in userMetadata {
                try userMetadataContainer.encode(usermetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateJobOutputError>
}

public struct CreateJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateJobOutputError>
}

/// <p>The <code>CreateJobRequest</code> structure.</p>
public struct CreateJobInput: Swift.Equatable {
    /// <p>A section of the request body that provides information about the file that is being
    ///              transcoded.</p>
    public let input: ElasticTranscoderClientTypes.JobInput?
    /// <p>A section of the request body that provides information about the files that are being
    ///             transcoded.</p>
    public let inputs: [ElasticTranscoderClientTypes.JobInput]?
    /// <p> A section of the request body that provides information about the transcoded (target)
    ///             file. We strongly recommend that you use the <code>Outputs</code> syntax instead of the
    ///             <code>Output</code> syntax. </p>
    public let output: ElasticTranscoderClientTypes.CreateJobOutput?
    /// <p>The value, if any, that you want Elastic Transcoder to prepend to the names of all files that this
    ///             job creates, including output files, thumbnails, and playlists.</p>
    public let outputKeyPrefix: Swift.String?
    /// <p> A section of the request body that provides information about the transcoded (target)
    ///             files. We recommend that you use the <code>Outputs</code> syntax instead of the
    ///                 <code>Output</code> syntax. </p>
    public let outputs: [ElasticTranscoderClientTypes.CreateJobOutput]?
    /// <p>The <code>Id</code> of the pipeline that you want Elastic Transcoder to use for
    ///             transcoding. The pipeline determines several settings, including the Amazon S3 bucket
    ///             from which Elastic Transcoder gets the files to transcode and the bucket into which
    ///             Elastic Transcoder puts the transcoded files.</p>
    public let pipelineId: Swift.String?
    /// <p>If you specify a preset in <code>PresetId</code> for which the value of
    ///                 <code>Container</code> is fmp4 (Fragmented MP4) or ts (MPEG-TS), Playlists contains
    ///                 information about the master playlists that you want Elastic Transcoder to create.</p>
    ///         <p>The maximum number of master playlists in a job is 30.</p>
    public let playlists: [ElasticTranscoderClientTypes.CreateJobPlaylist]?
    /// <p>User-defined metadata that you want to associate with an Elastic Transcoder job. You specify metadata in
    ///             <code>key/value</code> pairs, and you can add up to 10 <code>key/value</code> pairs per job.
    ///             Elastic Transcoder does not guarantee that <code>key/value</code> pairs are returned in the same
    ///             order in which you specify them.</p>
    public let userMetadata: [Swift.String:Swift.String]?

    public init (
        input: ElasticTranscoderClientTypes.JobInput? = nil,
        inputs: [ElasticTranscoderClientTypes.JobInput]? = nil,
        output: ElasticTranscoderClientTypes.CreateJobOutput? = nil,
        outputKeyPrefix: Swift.String? = nil,
        outputs: [ElasticTranscoderClientTypes.CreateJobOutput]? = nil,
        pipelineId: Swift.String? = nil,
        playlists: [ElasticTranscoderClientTypes.CreateJobPlaylist]? = nil,
        userMetadata: [Swift.String:Swift.String]? = nil
    )
    {
        self.input = input
        self.inputs = inputs
        self.output = output
        self.outputKeyPrefix = outputKeyPrefix
        self.outputs = outputs
        self.pipelineId = pipelineId
        self.playlists = playlists
        self.userMetadata = userMetadata
    }
}

struct CreateJobInputBody: Swift.Equatable {
    public let pipelineId: Swift.String?
    public let input: ElasticTranscoderClientTypes.JobInput?
    public let inputs: [ElasticTranscoderClientTypes.JobInput]?
    public let output: ElasticTranscoderClientTypes.CreateJobOutput?
    public let outputs: [ElasticTranscoderClientTypes.CreateJobOutput]?
    public let outputKeyPrefix: Swift.String?
    public let playlists: [ElasticTranscoderClientTypes.CreateJobPlaylist]?
    public let userMetadata: [Swift.String:Swift.String]?
}

extension CreateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case input = "Input"
        case inputs = "Inputs"
        case output = "Output"
        case outputKeyPrefix = "OutputKeyPrefix"
        case outputs = "Outputs"
        case pipelineId = "PipelineId"
        case playlists = "Playlists"
        case userMetadata = "UserMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let inputDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.JobInput.self, forKey: .input)
        input = inputDecoded
        let inputsContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.JobInput?].self, forKey: .inputs)
        var inputsDecoded0:[ElasticTranscoderClientTypes.JobInput]? = nil
        if let inputsContainer = inputsContainer {
            inputsDecoded0 = [ElasticTranscoderClientTypes.JobInput]()
            for structure0 in inputsContainer {
                if let structure0 = structure0 {
                    inputsDecoded0?.append(structure0)
                }
            }
        }
        inputs = inputsDecoded0
        let outputDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.CreateJobOutput.self, forKey: .output)
        output = outputDecoded
        let outputsContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.CreateJobOutput?].self, forKey: .outputs)
        var outputsDecoded0:[ElasticTranscoderClientTypes.CreateJobOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ElasticTranscoderClientTypes.CreateJobOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let outputKeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputKeyPrefix)
        outputKeyPrefix = outputKeyPrefixDecoded
        let playlistsContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.CreateJobPlaylist?].self, forKey: .playlists)
        var playlistsDecoded0:[ElasticTranscoderClientTypes.CreateJobPlaylist]? = nil
        if let playlistsContainer = playlistsContainer {
            playlistsDecoded0 = [ElasticTranscoderClientTypes.CreateJobPlaylist]()
            for structure0 in playlistsContainer {
                if let structure0 = structure0 {
                    playlistsDecoded0?.append(structure0)
                }
            }
        }
        playlists = playlistsDecoded0
        let userMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .userMetadata)
        var userMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let userMetadataContainer = userMetadataContainer {
            userMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in userMetadataContainer {
                if let string0 = string0 {
                    userMetadataDecoded0?[key0] = string0
                }
            }
        }
        userMetadata = userMetadataDecoded0
    }
}

extension ElasticTranscoderClientTypes.CreateJobOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case albumArt = "AlbumArt"
        case captions = "Captions"
        case composition = "Composition"
        case encryption = "Encryption"
        case key = "Key"
        case presetId = "PresetId"
        case rotate = "Rotate"
        case segmentDuration = "SegmentDuration"
        case thumbnailEncryption = "ThumbnailEncryption"
        case thumbnailPattern = "ThumbnailPattern"
        case watermarks = "Watermarks"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let albumArt = albumArt {
            try encodeContainer.encode(albumArt, forKey: .albumArt)
        }
        if let captions = captions {
            try encodeContainer.encode(captions, forKey: .captions)
        }
        if let composition = composition {
            var compositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .composition)
            for composition0 in composition {
                try compositionContainer.encode(composition0)
            }
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let presetId = presetId {
            try encodeContainer.encode(presetId, forKey: .presetId)
        }
        if let rotate = rotate {
            try encodeContainer.encode(rotate, forKey: .rotate)
        }
        if let segmentDuration = segmentDuration {
            try encodeContainer.encode(segmentDuration, forKey: .segmentDuration)
        }
        if let thumbnailEncryption = thumbnailEncryption {
            try encodeContainer.encode(thumbnailEncryption, forKey: .thumbnailEncryption)
        }
        if let thumbnailPattern = thumbnailPattern {
            try encodeContainer.encode(thumbnailPattern, forKey: .thumbnailPattern)
        }
        if let watermarks = watermarks {
            var watermarksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .watermarks)
            for jobwatermarks0 in watermarks {
                try watermarksContainer.encode(jobwatermarks0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let thumbnailPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thumbnailPattern)
        thumbnailPattern = thumbnailPatternDecoded
        let thumbnailEncryptionDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Encryption.self, forKey: .thumbnailEncryption)
        thumbnailEncryption = thumbnailEncryptionDecoded
        let rotateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotate)
        rotate = rotateDecoded
        let presetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .presetId)
        presetId = presetIdDecoded
        let segmentDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentDuration)
        segmentDuration = segmentDurationDecoded
        let watermarksContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.JobWatermark?].self, forKey: .watermarks)
        var watermarksDecoded0:[ElasticTranscoderClientTypes.JobWatermark]? = nil
        if let watermarksContainer = watermarksContainer {
            watermarksDecoded0 = [ElasticTranscoderClientTypes.JobWatermark]()
            for structure0 in watermarksContainer {
                if let structure0 = structure0 {
                    watermarksDecoded0?.append(structure0)
                }
            }
        }
        watermarks = watermarksDecoded0
        let albumArtDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.JobAlbumArt.self, forKey: .albumArt)
        albumArt = albumArtDecoded
        let compositionContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.Clip?].self, forKey: .composition)
        var compositionDecoded0:[ElasticTranscoderClientTypes.Clip]? = nil
        if let compositionContainer = compositionContainer {
            compositionDecoded0 = [ElasticTranscoderClientTypes.Clip]()
            for structure0 in compositionContainer {
                if let structure0 = structure0 {
                    compositionDecoded0?.append(structure0)
                }
            }
        }
        composition = compositionDecoded0
        let captionsDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Captions.self, forKey: .captions)
        captions = captionsDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
    }
}

extension ElasticTranscoderClientTypes.CreateJobOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateJobOutput(albumArt: \(Swift.String(describing: albumArt)), captions: \(Swift.String(describing: captions)), composition: \(Swift.String(describing: composition)), encryption: \(Swift.String(describing: encryption)), key: \(Swift.String(describing: key)), presetId: \(Swift.String(describing: presetId)), rotate: \(Swift.String(describing: rotate)), segmentDuration: \(Swift.String(describing: segmentDuration)), thumbnailEncryption: \(Swift.String(describing: thumbnailEncryption)), thumbnailPattern: \(Swift.String(describing: thumbnailPattern)), watermarks: \(Swift.String(describing: watermarks)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>The <code>CreateJobOutput</code> structure.</p>
    public struct CreateJobOutput: Swift.Equatable {
        /// <p>Information about the album art that you want Elastic Transcoder to add to the file during transcoding.
        ///             You can specify up to twenty album artworks for each output. Settings for each artwork must be
        ///             defined in the job for the current output.</p>
        public let albumArt: ElasticTranscoderClientTypes.JobAlbumArt?
        /// <p>You can configure Elastic Transcoder to transcode captions, or subtitles, from one format to another. All
        ///           captions must be in UTF-8. Elastic Transcoder supports two types of captions:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <b>Embedded:</b> Embedded captions
        ///             are included in the same file as the audio and video. Elastic Transcoder supports
        ///             only one embedded caption per language, to a maximum of 300 embedded captions per file.</p>
        ///                <p>Valid input values include: <code>CEA-608 (EIA-608</code>, first non-empty channel only),
        ///             	<code>CEA-708 (EIA-708</code>, first non-empty channel only), and <code>mov-text</code>
        ///                </p>
        ///                <p>Valid outputs include: <code>mov-text</code>
        ///                </p>
        ///                <p>Elastic Transcoder supports a maximum of one embedded format per output.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Sidecar:</b> Sidecar captions are kept in a
        ///             separate metadata file from the audio and video data.  Sidecar captions require a player
        ///             that is capable of understanding the relationship between the video file and the sidecar
        ///             file. Elastic Transcoder supports only one sidecar caption per language, to a maximum of 20 sidecar
        ///             captions per file.</p>
        ///                <p>Valid input values include: <code>dfxp</code> (first div element only),
        ///                <code>ebu-tt</code>, <code>scc</code>, <code>smpt</code>, <code>srt</code>,
        ///                <code>ttml</code> (first div element only), and <code>webvtt</code>
        ///                </p>
        ///                <p>Valid outputs include: <code>dfxp</code> (first div element only), <code>scc</code>,
        ///                <code>srt</code>, and <code>webvtt</code>.</p>
        ///             </li>
        ///          </ul>
        ///          <p>If you want ttml or smpte-tt compatible captions, specify dfxp as your output format.</p>
        ///          <p>Elastic Transcoder does not support OCR (Optical Character Recognition), does not accept pictures
        ///              as a valid input for captions, and is not available for audio-only transcoding. Elastic Transcoder does
        ///              not preserve text formatting (for example, italics) during the transcoding process.</p>
        ///          <p>To remove captions or leave the captions empty, set <code>Captions</code> to null. To pass through
        ///              existing captions unchanged, set the <code>MergePolicy</code> to <code>MergeRetain</code>,
        ///              and pass in a null <code>CaptionSources</code> array.</p>
        ///          <p>For more information on embedded files, see the Subtitles Wikipedia page.</p>
        ///          <p>For more information on sidecar files, see the Extensible Metadata Platform and Sidecar file Wikipedia pages.</p>
        public let captions: ElasticTranscoderClientTypes.Captions?
        /// <p>You can create an output file that contains an excerpt from the input file. This excerpt, called a
        ///             clip, can come from the beginning, middle, or end of the file. The Composition object contains settings
        ///             for the clips that make up an output file. For the current release, you can only specify settings for a
        ///             single clip per output file. The Composition object cannot be null.</p>
        @available(*, deprecated)
        public let composition: [ElasticTranscoderClientTypes.Clip]?
        /// <p>You can specify encryption settings for any output files that you want to use for a
        ///     transcoding job. This includes the output file and any watermarks, thumbnails, album art,
        ///     or captions that you want to use. You must specify encryption settings for each file
        ///     individually.</p>
        public let encryption: ElasticTranscoderClientTypes.Encryption?
        /// <p> The name to assign to the transcoded file. Elastic Transcoder saves the file in the Amazon S3 bucket
        ///     specified by the <code>OutputBucket</code> object in the pipeline that is specified by
        ///     the pipeline ID. If a file with the specified name already exists in the output bucket,
        ///     the job fails. </p>
        public let key: Swift.String?
        /// <p> The <code>Id</code> of the preset to use for this job. The preset determines the audio,
        ///     video, and thumbnail settings that Elastic Transcoder uses for transcoding. </p>
        public let presetId: Swift.String?
        /// <p> The number of degrees clockwise by which you want Elastic Transcoder to rotate the output relative to
        ///     the input. Enter one of the following values: <code>auto</code>, <code>0</code>,
        ///         <code>90</code>, <code>180</code>, <code>270</code>. The value <code>auto</code>
        ///     generally works only if the file that you're transcoding contains rotation metadata.
        /// </p>
        public let rotate: Swift.String?
        /// <important>
        ///             <p>(Outputs in Fragmented MP4 or MPEG-TS format only.</p>
        ///          </important>
        ///          <p>If you specify a preset in
        ///         <code>PresetId</code> for which the value of <code>Container</code> is <code>fmp4</code> (Fragmented MP4) or
        ///         <code>ts</code> (MPEG-TS), <code>SegmentDuration</code> is the target maximum duration of
        ///     each segment in seconds. For <code>HLSv3</code> format playlists,
        ///     each media segment is stored in a separate <code>.ts</code> file. For <code>HLSv4</code> and <code>Smooth</code>
        ///     playlists, all media segments for an output are stored in a single file. Each segment is approximately the length of
        ///     the <code>SegmentDuration</code>, though individual segments might be shorter or longer.</p>
        ///
        ///          <p>The range of valid values is 1 to 60 seconds. If the duration
        ///     of the video is not evenly divisible by <code>SegmentDuration</code>, the duration of
        ///     the last segment is the remainder of total length/SegmentDuration.</p>
        ///          <p>Elastic Transcoder
        ///     creates an output-specific playlist for each output <code>HLS</code> output that you specify in OutputKeys. To
        ///     add an output to the master playlist for this job, include it in the <code>OutputKeys</code> of
        ///     the associated playlist.</p>
        public let segmentDuration: Swift.String?
        /// <p>The encryption settings, if any, that you want Elastic Transcoder to apply to your thumbnail.</p>
        public let thumbnailEncryption: ElasticTranscoderClientTypes.Encryption?
        /// <p>Whether you want Elastic Transcoder to create thumbnails for your videos and, if so, how you want Elastic Transcoder to name the files.</p>
        ///          <p>If you don't want Elastic Transcoder to create thumbnails, specify "".</p>
        ///          <p>If you do want Elastic Transcoder to create thumbnails, specify the information that you want to include
        ///     in the file name for each thumbnail. You can specify the following values in any sequence:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <b>
        ///                      <code>{count}</code> (Required)</b>: If you want to create thumbnails, you
        ///             must include <code>{count}</code> in the <code>ThumbnailPattern</code> object.
        ///             Wherever you specify <code>{count}</code>, Elastic Transcoder adds a five-digit sequence
        ///             number (beginning with <b>00001</b>) to thumbnail file names. The number
        ///             indicates where a given thumbnail appears in the sequence of thumbnails for a
        ///             transcoded file. </p>
        ///                <important>
        ///                   <p>If you specify a literal value and/or <code>{resolution}</code> but you
        ///             omit <code>{count}</code>, Elastic Transcoder returns a validation error and does not create
        ///             the job.</p>
        ///                </important>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Literal values (Optional)</b>: You can specify literal values anywhere in the
        ///                 <code>ThumbnailPattern</code> object. For example, you can include them as a
        ///             file name prefix or as a delimiter between <code>{resolution}</code> and
        ///                 <code>{count}</code>. </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>
        ///                      <code>{resolution}</code> (Optional)</b>: If you want Elastic Transcoder to include the
        ///             resolution in the file name, include <code>{resolution}</code> in the
        ///                 <code>ThumbnailPattern</code> object. </p>
        ///             </li>
        ///          </ul>
        ///          <p>When creating thumbnails, Elastic Transcoder automatically saves the files in the format (.jpg or .png)
        ///     that appears in the preset that you specified in the <code>PresetID</code> value of
        ///         <code>CreateJobOutput</code>. Elastic Transcoder also appends the applicable file name
        ///     extension.</p>
        public let thumbnailPattern: Swift.String?
        /// <p>Information about the watermarks that you want Elastic Transcoder to add to the video during transcoding.
        ///     You can specify up to four watermarks for each output. Settings for each watermark must be defined
        ///     in the preset for the current output.</p>
        public let watermarks: [ElasticTranscoderClientTypes.JobWatermark]?

        public init (
            albumArt: ElasticTranscoderClientTypes.JobAlbumArt? = nil,
            captions: ElasticTranscoderClientTypes.Captions? = nil,
            composition: [ElasticTranscoderClientTypes.Clip]? = nil,
            encryption: ElasticTranscoderClientTypes.Encryption? = nil,
            key: Swift.String? = nil,
            presetId: Swift.String? = nil,
            rotate: Swift.String? = nil,
            segmentDuration: Swift.String? = nil,
            thumbnailEncryption: ElasticTranscoderClientTypes.Encryption? = nil,
            thumbnailPattern: Swift.String? = nil,
            watermarks: [ElasticTranscoderClientTypes.JobWatermark]? = nil
        )
        {
            self.albumArt = albumArt
            self.captions = captions
            self.composition = composition
            self.encryption = encryption
            self.key = key
            self.presetId = presetId
            self.rotate = rotate
            self.segmentDuration = segmentDuration
            self.thumbnailEncryption = thumbnailEncryption
            self.thumbnailPattern = thumbnailPattern
            self.watermarks = watermarks
        }
    }

}

extension CreateJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateJobOutputResponse(job: \(Swift.String(describing: job)))"}
}

extension CreateJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

/// <p>The CreateJobResponse structure.</p>
public struct CreateJobOutputResponse: Swift.Equatable {
    /// <p>A section of the response body that provides information about the job that is created.</p>
    public let job: ElasticTranscoderClientTypes.Job?

    public init (
        job: ElasticTranscoderClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct CreateJobOutputResponseBody: Swift.Equatable {
    public let job: ElasticTranscoderClientTypes.Job?
}

extension CreateJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

extension ElasticTranscoderClientTypes.CreateJobPlaylist: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "Format"
        case hlsContentProtection = "HlsContentProtection"
        case name = "Name"
        case outputKeys = "OutputKeys"
        case playReadyDrm = "PlayReadyDrm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let hlsContentProtection = hlsContentProtection {
            try encodeContainer.encode(hlsContentProtection, forKey: .hlsContentProtection)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputKeys = outputKeys {
            var outputKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputKeys)
            for outputkeys0 in outputKeys {
                try outputKeysContainer.encode(outputkeys0)
            }
        }
        if let playReadyDrm = playReadyDrm {
            try encodeContainer.encode(playReadyDrm, forKey: .playReadyDrm)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let outputKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .outputKeys)
        var outputKeysDecoded0:[Swift.String]? = nil
        if let outputKeysContainer = outputKeysContainer {
            outputKeysDecoded0 = [Swift.String]()
            for string0 in outputKeysContainer {
                if let string0 = string0 {
                    outputKeysDecoded0?.append(string0)
                }
            }
        }
        outputKeys = outputKeysDecoded0
        let hlsContentProtectionDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.HlsContentProtection.self, forKey: .hlsContentProtection)
        hlsContentProtection = hlsContentProtectionDecoded
        let playReadyDrmDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.PlayReadyDrm.self, forKey: .playReadyDrm)
        playReadyDrm = playReadyDrmDecoded
    }
}

extension ElasticTranscoderClientTypes.CreateJobPlaylist: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateJobPlaylist(format: \(Swift.String(describing: format)), hlsContentProtection: \(Swift.String(describing: hlsContentProtection)), name: \(Swift.String(describing: name)), outputKeys: \(Swift.String(describing: outputKeys)), playReadyDrm: \(Swift.String(describing: playReadyDrm)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>Information about the master playlist.</p>
    public struct CreateJobPlaylist: Swift.Equatable {
        /// <p>The format of the output playlist. Valid formats include <code>HLSv3</code>,
        ///             <code>HLSv4</code>, and <code>Smooth</code>.</p>
        public let format: Swift.String?
        /// <p>The HLS content protection settings, if any, that you want Elastic Transcoder to apply to the output
        ///             files associated with this playlist.</p>
        public let hlsContentProtection: ElasticTranscoderClientTypes.HlsContentProtection?
        /// <p>The name that you want Elastic Transcoder to assign to the master playlist, for example,
        ///     nyc-vacation.m3u8. If the name includes a <code>/</code> character,
        ///     the section of the name before the last <code>/</code> must be identical
        ///     for all <code>Name</code> objects. If you create more than one
        ///     master playlist, the values of all <code>Name</code> objects must be
        ///     unique.</p>
        ///          <note>
        ///             <p>
        ///     Elastic Transcoder automatically appends the relevant file extension to the file name (<code>.m3u8</code>
        ///             for <code>HLSv3</code> and <code>HLSv4</code> playlists, and <code>.ism</code> and <code>.ismc</code> for
        ///             <code>Smooth</code> playlists).
        ///             If you include a file extension in <code>Name</code>, the file name will have
        ///             two extensions.</p>
        ///          </note>
        public let name: Swift.String?
        /// <p>For each output in this job that you want to include in a master playlist, the value of
        ///             the <code>Outputs:Key</code> object. </p>
        ///         <ul>
        ///             <li>
        ///                 <p>If your output is not <code>HLS</code> or does not have a segment duration set,
        ///                     the name of the output file is a concatenation of <code>OutputKeyPrefix</code>
        ///                     and <code>Outputs:Key</code>:</p>
        ///                 <p>OutputKeyPrefix<code>Outputs:Key</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                 <p>If your output is <code>HLSv3</code> and has a segment duration set, or is not included in a
        ///                     playlist, Elastic Transcoder creates an output playlist file with a file extension of <code>.m3u8</code>, and a
        ///                     series of <code>.ts</code> files that include a five-digit
        ///                     sequential counter beginning with 00000:</p>
        ///                 <p>OutputKeyPrefix<code>Outputs:Key</code>.m3u8</p>
        ///                 <p>OutputKeyPrefix<code>Outputs:Key</code>00000.ts</p>
        ///             </li>
        ///             <li>
        ///                 <p>If your output is <code>HLSv4</code>, has a segment duration set, and is included in an
        ///                     <code>HLSv4</code> playlist, Elastic Transcoder creates an output playlist file with a file extension
        ///                     of <code>_v4.m3u8</code>. If the output is video, Elastic Transcoder also creates an output file with
        ///                     an extension of <code>_iframe.m3u8</code>:</p>
        ///                 <p>OutputKeyPrefix<code>Outputs:Key</code>_v4.m3u8</p>
        ///                 <p>OutputKeyPrefix<code>Outputs:Key</code>_iframe.m3u8</p>
        ///                 <p>OutputKeyPrefix<code>Outputs:Key</code>.ts</p>
        ///             </li>
        ///          </ul>
        ///
        ///         <p>Elastic Transcoder automatically appends the relevant file extension to the file name. If you include a
        ///             file extension in Output Key, the file name will have two extensions.</p>
        ///
        ///         <p>If you include more than one output in a playlist,
        ///             any segment duration settings, clip settings, or caption settings must be the
        ///             same for all outputs in the playlist. For <code>Smooth</code> playlists, the <code>Audio:Profile</code>,
        ///             <code>Video:Profile</code>, and <code>Video:FrameRate</code> to
        ///             <code>Video:KeyframesMaxDist</code> ratio must be the same for all outputs.</p>
        public let outputKeys: [Swift.String]?
        /// <p>The DRM settings, if any, that you want Elastic Transcoder to apply to the output files associated with this playlist.</p>
        public let playReadyDrm: ElasticTranscoderClientTypes.PlayReadyDrm?

        public init (
            format: Swift.String? = nil,
            hlsContentProtection: ElasticTranscoderClientTypes.HlsContentProtection? = nil,
            name: Swift.String? = nil,
            outputKeys: [Swift.String]? = nil,
            playReadyDrm: ElasticTranscoderClientTypes.PlayReadyDrm? = nil
        )
        {
            self.format = format
            self.hlsContentProtection = hlsContentProtection
            self.name = name
            self.outputKeys = outputKeys
            self.playReadyDrm = playReadyDrm
        }
    }

}

public struct CreatePipelineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePipelineOutputError>
}

extension CreatePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePipelineInput(awsKmsKeyArn: \(Swift.String(describing: awsKmsKeyArn)), contentConfig: \(Swift.String(describing: contentConfig)), inputBucket: \(Swift.String(describing: inputBucket)), name: \(Swift.String(describing: name)), notifications: \(Swift.String(describing: notifications)), outputBucket: \(Swift.String(describing: outputBucket)), role: \(Swift.String(describing: role)), thumbnailConfig: \(Swift.String(describing: thumbnailConfig)))"}
}

extension CreatePipelineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsKmsKeyArn = "AwsKmsKeyArn"
        case contentConfig = "ContentConfig"
        case inputBucket = "InputBucket"
        case name = "Name"
        case notifications = "Notifications"
        case outputBucket = "OutputBucket"
        case role = "Role"
        case thumbnailConfig = "ThumbnailConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsKmsKeyArn = awsKmsKeyArn {
            try encodeContainer.encode(awsKmsKeyArn, forKey: .awsKmsKeyArn)
        }
        if let contentConfig = contentConfig {
            try encodeContainer.encode(contentConfig, forKey: .contentConfig)
        }
        if let inputBucket = inputBucket {
            try encodeContainer.encode(inputBucket, forKey: .inputBucket)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notifications = notifications {
            try encodeContainer.encode(notifications, forKey: .notifications)
        }
        if let outputBucket = outputBucket {
            try encodeContainer.encode(outputBucket, forKey: .outputBucket)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let thumbnailConfig = thumbnailConfig {
            try encodeContainer.encode(thumbnailConfig, forKey: .thumbnailConfig)
        }
    }
}

public struct CreatePipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePipelineOutputError>
}

public struct CreatePipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePipelineOutputError>
}

/// <p>The <code>CreatePipelineRequest</code> structure.</p>
public struct CreatePipelineInput: Swift.Equatable {
    /// <p>The AWS Key Management Service (AWS KMS) key that you want to use with this pipeline.</p>
    ///         <p>If you use either <code>s3</code> or <code>s3-aws-kms</code> as your
    ///             <code>Encryption:Mode</code>, you don't need to provide a key with
    ///             your job because a default key, known as an AWS-KMS key, is created for you automatically.
    ///             You need to provide an AWS-KMS key only if you want to use a non-default AWS-KMS key, or if you are
    ///             using an <code>Encryption:Mode</code> of <code>aes-cbc-pkcs7</code>, <code>aes-ctr</code>,
    ///             or <code>aes-gcm</code>.</p>
    public let awsKmsKeyArn: Swift.String?
    /// <p>The optional <code>ContentConfig</code> object specifies information about the Amazon S3
    ///             bucket in which you want Elastic Transcoder to save transcoded files and playlists:
    ///             which bucket to use, which users you want to have access to the files, the type of
    ///             access you want users to have, and the storage class that you want to assign to the
    ///             files.</p>
    ///         <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
    ///                 <code>ThumbnailConfig</code>.</p>
    ///         <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
    ///             omit the <code>OutputBucket</code> object.</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
    ///                 transcoded files and playlists.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Permissions</b> (Optional): The Permissions object specifies which users you want
    ///                 to have access to transcoded files and the type of access you want them to have. You
    ///                 can grant permissions to a maximum of 30 users and/or predefined Amazon S3
    ///                 groups.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Grantee Type</b>: Specify the type of value that appears in the
    ///                     <code>Grantee</code> object: </p>
    /// 					          <ul>
    ///                   <li>
    ///                      <p>
    ///                         <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
    ///                         canonical user ID for an AWS account or an origin access identity for an
    ///                         Amazon CloudFront distribution. For more information about canonical user
    ///                         IDs, see Access Control List (ACL) Overview in the Amazon Simple Storage
    ///                         Service Developer Guide. For more information about using CloudFront origin
    ///                         access identities to require that users use CloudFront URLs instead of
    ///                         Amazon S3 URLs, see Using an Origin Access Identity to Restrict Access to
    ///                         Your Amazon S3 Content.</p>
    /// 						               <important>
    ///                         <p>A canonical user ID is not the same as an
    ///                             AWS account number.</p>
    ///                      </important>
    ///                     </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>Email</b>: The value in the <code>Grantee</code> object is the registered
    ///                         email address of an AWS account.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>Group</b>: The value in the <code>Grantee</code> object is one of the
    ///                         following predefined Amazon S3 groups: <code>AllUsers</code>,
    ///                             <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Grantee</b>: The AWS user or group that you want to have access to transcoded
    ///                 files and playlists. To identify the user or group, you can specify the canonical
    ///                 user ID for an AWS account, an origin access identity for a CloudFront distribution,
    ///                 the registered email address of an AWS account, or a predefined Amazon S3 group </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Access</b>: The permission that you want to give to the AWS user that you
    ///                 specified in <code>Grantee</code>. Permissions are granted on the files that Elastic
    ///                 Transcoder adds to the bucket, including playlists and video files. Valid values
    ///                 include: </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>READ</code>: The grantee can read the objects and metadata for objects
    ///                         that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>READ_ACP</code>: The grantee can read the object ACL for objects that
    ///                         Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>WRITE_ACP</code>: The grantee can write the ACL for the objects that
    ///                         Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
    ///                             <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
    ///                         objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
    ///                     <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
    ///                 the video files and playlists that it stores in your Amazon S3 bucket.</p>
    ///             </li>
    ///          </ul>
    public let contentConfig: ElasticTranscoderClientTypes.PipelineOutputConfig?
    /// <p>The Amazon S3 bucket in which you saved the media files that you want to transcode.</p>
    public let inputBucket: Swift.String?
    /// <p>The name of the pipeline. We recommend that the name be unique within the AWS account,
    ///             but uniqueness is not enforced.</p>
    ///         <p>Constraints: Maximum 40 characters.</p>
    public let name: Swift.String?
    /// <p>The Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status.</p>
    ///         <important>
    ///             <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
    ///          </important>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Progressing</b>: The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to
    ///                 notify when Elastic Transcoder has started to process a job in this pipeline. This is the ARN that
    ///                 Amazon SNS returned when you created the topic. For more information, see Create a
    ///                 Topic in the Amazon Simple Notification Service Developer Guide.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Complete</b>: The topic ARN for the Amazon SNS topic that you want to notify when
    ///                 Elastic Transcoder has finished processing a job in this pipeline. This is the ARN that Amazon SNS
    ///                 returned when you created the topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Warning</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
    ///                 encounters a warning condition while processing a job in this pipeline. This is the
    ///                 ARN that Amazon SNS returned when you created the topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Error</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
    ///                 encounters an error condition while processing a job in this pipeline. This is the
    ///                 ARN that Amazon SNS returned when you created the topic.</p>
    ///             </li>
    ///          </ul>
    public let notifications: ElasticTranscoderClientTypes.Notifications?
    /// <p>The Amazon S3 bucket in which you want Elastic Transcoder to save the transcoded files. (Use
    /// 		  this, or use ContentConfig:Bucket plus ThumbnailConfig:Bucket.)</p>
    ///         <p>Specify this value when all of the following are true:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>You want to save transcoded files, thumbnails (if any), and playlists (if any)
    ///                     together in one bucket.</p>
    ///             </li>
    ///             <li>
    ///                <p>You do not want to specify the users or groups who have access to the transcoded
    ///                     files, thumbnails, and playlists.</p>
    ///             </li>
    ///             <li>
    ///                <p>You do not want to specify the permissions that Elastic Transcoder grants to the
    /// 				
    ///                     files. </p>
    /// 				           <important>
    ///                   <p>When Elastic Transcoder saves files in
    ///                             <code>OutputBucket</code>, it grants full control over the files only to
    ///                         the AWS account that owns the role that is specified by
    ///                         <code>Role</code>.</p>
    ///                </important>
    ///             </li>
    ///             <li>
    ///                <p>You want to associate the transcoded files and thumbnails with the Amazon S3
    ///                     Standard storage class.</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>If you want to save transcoded files and playlists in one bucket and thumbnails in
    ///             another bucket, specify which users can access the transcoded files or the permissions
    ///             the users have, or change the Amazon S3 storage class, omit <code>OutputBucket</code>
    ///             and specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>
    ///             instead.</p>
    public let outputBucket: Swift.String?
    /// <p>The IAM Amazon Resource Name (ARN) for the role that you want Elastic Transcoder to use to create the pipeline.</p>
    public let role: Swift.String?
    /// <p>The <code>ThumbnailConfig</code> object specifies several values, including the Amazon S3
    ///             bucket in which you want Elastic Transcoder to save thumbnail files, which users you want to have
    ///             access to the files, the type of access you want users to have, and the storage class
    ///             that you want to assign to the files.</p>
    ///         <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
    ///                 <code>ThumbnailConfig</code> even if you don't want to create thumbnails.</p>
    ///         <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
    ///             omit the <code>OutputBucket</code> object.</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
    ///                 thumbnail files.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Permissions</b> (Optional): The <code>Permissions</code> object specifies which
    ///                 users and/or predefined Amazon S3 groups you want to have access to thumbnail files,
    ///                 and the type of access you want them to have. You can grant permissions to a maximum
    ///                 of 30 users and/or predefined Amazon S3 groups.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>GranteeType</b>: Specify the type of value that appears in the Grantee object: </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
    ///                         canonical user ID for an AWS account or an origin access identity for an
    ///                         Amazon CloudFront distribution.</p>
    ///                      <important>
    ///                         <p>A canonical user ID is not the
    ///                             same as an AWS account number.</p>
    ///                      </important>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>Email</b>: The value in the <code>Grantee</code> object is the registered
    ///                         email address of an AWS account. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>Group</b>: The value in the <code>Grantee</code> object is one of the
    ///                         following predefined Amazon S3 groups: <code>AllUsers</code>,
    ///                             <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Grantee</b>: The AWS user or group that you want to have access to thumbnail
    ///                 files. To identify the user or group, you can specify the canonical user ID for an
    ///                 AWS account, an origin access identity for a CloudFront distribution, the registered
    ///                 email address of an AWS account, or a predefined Amazon S3 group. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Access</b>: The permission that you want to give to the AWS user that you
    ///                 specified in <code>Grantee</code>. Permissions are granted on the thumbnail files
    ///                 that Elastic Transcoder adds to the bucket. Valid values include: </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>READ</code>: The grantee can read the thumbnails and metadata for
    ///                         objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>READ_ACP</code>: The grantee can read the object ACL for thumbnails
    ///                         that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>WRITE_ACP</code>: The grantee can write the ACL for the thumbnails
    ///                         that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
    ///                             <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
    ///                         thumbnails that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
    ///                     <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
    ///                 the thumbnails that it stores in your Amazon S3 bucket.</p>
    ///             </li>
    ///          </ul>
    public let thumbnailConfig: ElasticTranscoderClientTypes.PipelineOutputConfig?

    public init (
        awsKmsKeyArn: Swift.String? = nil,
        contentConfig: ElasticTranscoderClientTypes.PipelineOutputConfig? = nil,
        inputBucket: Swift.String? = nil,
        name: Swift.String? = nil,
        notifications: ElasticTranscoderClientTypes.Notifications? = nil,
        outputBucket: Swift.String? = nil,
        role: Swift.String? = nil,
        thumbnailConfig: ElasticTranscoderClientTypes.PipelineOutputConfig? = nil
    )
    {
        self.awsKmsKeyArn = awsKmsKeyArn
        self.contentConfig = contentConfig
        self.inputBucket = inputBucket
        self.name = name
        self.notifications = notifications
        self.outputBucket = outputBucket
        self.role = role
        self.thumbnailConfig = thumbnailConfig
    }
}

struct CreatePipelineInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let inputBucket: Swift.String?
    public let outputBucket: Swift.String?
    public let role: Swift.String?
    public let awsKmsKeyArn: Swift.String?
    public let notifications: ElasticTranscoderClientTypes.Notifications?
    public let contentConfig: ElasticTranscoderClientTypes.PipelineOutputConfig?
    public let thumbnailConfig: ElasticTranscoderClientTypes.PipelineOutputConfig?
}

extension CreatePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsKmsKeyArn = "AwsKmsKeyArn"
        case contentConfig = "ContentConfig"
        case inputBucket = "InputBucket"
        case name = "Name"
        case notifications = "Notifications"
        case outputBucket = "OutputBucket"
        case role = "Role"
        case thumbnailConfig = "ThumbnailConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let inputBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputBucket)
        inputBucket = inputBucketDecoded
        let outputBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputBucket)
        outputBucket = outputBucketDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let awsKmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsKmsKeyArn)
        awsKmsKeyArn = awsKmsKeyArnDecoded
        let notificationsDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Notifications.self, forKey: .notifications)
        notifications = notificationsDecoded
        let contentConfigDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.PipelineOutputConfig.self, forKey: .contentConfig)
        contentConfig = contentConfigDecoded
        let thumbnailConfigDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.PipelineOutputConfig.self, forKey: .thumbnailConfig)
        thumbnailConfig = thumbnailConfigDecoded
    }
}

extension CreatePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePipelineOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePipelineOutputResponse(pipeline: \(Swift.String(describing: pipeline)), warnings: \(Swift.String(describing: warnings)))"}
}

extension CreatePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
            self.warnings = output.warnings
        } else {
            self.pipeline = nil
            self.warnings = nil
        }
    }
}

/// <p>When you create a pipeline, Elastic Transcoder returns the values that you specified in the request.</p>
public struct CreatePipelineOutputResponse: Swift.Equatable {
    /// <p>A section of the response body that provides information about the pipeline that is created.</p>
    public let pipeline: ElasticTranscoderClientTypes.Pipeline?
    /// <p>Elastic Transcoder returns a warning if the resources used by your pipeline are not in the same region as
    ///             the pipeline.</p>
    ///         <p>Using resources in the same region, such as your Amazon S3 buckets, Amazon SNS notification topics, and
    ///             AWS KMS key, reduces processing time and prevents cross-regional charges.</p>
    public let warnings: [ElasticTranscoderClientTypes.Warning]?

    public init (
        pipeline: ElasticTranscoderClientTypes.Pipeline? = nil,
        warnings: [ElasticTranscoderClientTypes.Warning]? = nil
    )
    {
        self.pipeline = pipeline
        self.warnings = warnings
    }
}

struct CreatePipelineOutputResponseBody: Swift.Equatable {
    public let pipeline: ElasticTranscoderClientTypes.Pipeline?
    public let warnings: [ElasticTranscoderClientTypes.Warning]?
}

extension CreatePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline = "Pipeline"
        case warnings = "Warnings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Pipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
        let warningsContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.Warning?].self, forKey: .warnings)
        var warningsDecoded0:[ElasticTranscoderClientTypes.Warning]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [ElasticTranscoderClientTypes.Warning]()
            for structure0 in warningsContainer {
                if let structure0 = structure0 {
                    warningsDecoded0?.append(structure0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

public struct CreatePresetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePresetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePresetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePresetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePresetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePresetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePresetOutputError>
}

extension CreatePresetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePresetInput(audio: \(Swift.String(describing: audio)), container: \(Swift.String(describing: container)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), thumbnails: \(Swift.String(describing: thumbnails)), video: \(Swift.String(describing: video)))"}
}

extension CreatePresetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audio = "Audio"
        case container = "Container"
        case description = "Description"
        case name = "Name"
        case thumbnails = "Thumbnails"
        case video = "Video"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audio = audio {
            try encodeContainer.encode(audio, forKey: .audio)
        }
        if let container = container {
            try encodeContainer.encode(container, forKey: .container)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let thumbnails = thumbnails {
            try encodeContainer.encode(thumbnails, forKey: .thumbnails)
        }
        if let video = video {
            try encodeContainer.encode(video, forKey: .video)
        }
    }
}

public struct CreatePresetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePresetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePresetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePresetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePresetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePresetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePresetOutputError>
}

public struct CreatePresetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePresetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePresetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePresetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePresetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePresetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePresetOutputError>
}

/// <p>The <code>CreatePresetRequest</code> structure.</p>
public struct CreatePresetInput: Swift.Equatable {
    /// <p>A section of the request body that specifies the audio parameters.</p>
    public let audio: ElasticTranscoderClientTypes.AudioParameters?
    /// <p>The container type for the output file. Valid values include <code>flac</code>,
    ///             <code>flv</code>, <code>fmp4</code>,
    ///             <code>gif</code>, <code>mp3</code>,
    ///             <code>mp4</code>, <code>mpg</code>, <code>mxf</code>, <code>oga</code>,
    ///             <code>ogg</code>, <code>ts</code>, and <code>webm</code>.</p>
    public let container: Swift.String?
    /// <p>A description of the preset.</p>
    public let description: Swift.String?
    /// <p>The name of the preset. We recommend that the name be unique within the AWS account, but uniqueness is not enforced.</p>
    public let name: Swift.String?
    /// <p>A section of the request body that specifies the thumbnail parameters, if any.</p>
    public let thumbnails: ElasticTranscoderClientTypes.Thumbnails?
    /// <p>A section of the request body that specifies the video parameters.</p>
    public let video: ElasticTranscoderClientTypes.VideoParameters?

    public init (
        audio: ElasticTranscoderClientTypes.AudioParameters? = nil,
        container: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        thumbnails: ElasticTranscoderClientTypes.Thumbnails? = nil,
        video: ElasticTranscoderClientTypes.VideoParameters? = nil
    )
    {
        self.audio = audio
        self.container = container
        self.description = description
        self.name = name
        self.thumbnails = thumbnails
        self.video = video
    }
}

struct CreatePresetInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let container: Swift.String?
    public let video: ElasticTranscoderClientTypes.VideoParameters?
    public let audio: ElasticTranscoderClientTypes.AudioParameters?
    public let thumbnails: ElasticTranscoderClientTypes.Thumbnails?
}

extension CreatePresetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audio = "Audio"
        case container = "Container"
        case description = "Description"
        case name = "Name"
        case thumbnails = "Thumbnails"
        case video = "Video"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let containerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .container)
        container = containerDecoded
        let videoDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.VideoParameters.self, forKey: .video)
        video = videoDecoded
        let audioDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.AudioParameters.self, forKey: .audio)
        audio = audioDecoded
        let thumbnailsDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Thumbnails.self, forKey: .thumbnails)
        thumbnails = thumbnailsDecoded
    }
}

extension CreatePresetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePresetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePresetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case limitExceededException(LimitExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePresetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePresetOutputResponse(preset: \(Swift.String(describing: preset)), warning: \(Swift.String(describing: warning)))"}
}

extension CreatePresetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePresetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.preset = output.preset
            self.warning = output.warning
        } else {
            self.preset = nil
            self.warning = nil
        }
    }
}

/// <p>The <code>CreatePresetResponse</code> structure.</p>
public struct CreatePresetOutputResponse: Swift.Equatable {
    /// <p>A section of the response body that provides information about the preset that is created.</p>
    public let preset: ElasticTranscoderClientTypes.Preset?
    /// <p>If the preset settings don't comply with the standards for the video codec but Elastic Transcoder
    ///             created the preset, this message explains the reason the preset settings don't meet the
    ///             standard. Elastic Transcoder created the preset because the settings might produce
    ///             acceptable output.</p>
    public let warning: Swift.String?

    public init (
        preset: ElasticTranscoderClientTypes.Preset? = nil,
        warning: Swift.String? = nil
    )
    {
        self.preset = preset
        self.warning = warning
    }
}

struct CreatePresetOutputResponseBody: Swift.Equatable {
    public let preset: ElasticTranscoderClientTypes.Preset?
    public let warning: Swift.String?
}

extension CreatePresetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preset = "Preset"
        case warning = "Warning"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let presetDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Preset.self, forKey: .preset)
        preset = presetDecoded
        let warningDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warning)
        warning = warningDecoded
    }
}

extension DeletePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePipelineInput(id: \(Swift.String(describing: id)))"}
}

extension DeletePipelineInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeletePipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePipelineOutputError>
}

public struct DeletePipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePipelineOutputError>
}

/// <p>The <code>DeletePipelineRequest</code> structure.</p>
public struct DeletePipelineInput: Swift.Equatable {
    /// <p>The identifier of the pipeline that you want to delete.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeletePipelineInputBody: Swift.Equatable {
}

extension DeletePipelineInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePipelineOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePipelineOutputResponse()"}
}

extension DeletePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p>The <code>DeletePipelineResponse</code> structure.</p>
public struct DeletePipelineOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePipelineOutputResponseBody: Swift.Equatable {
}

extension DeletePipelineOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePresetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePresetInput(id: \(Swift.String(describing: id)))"}
}

extension DeletePresetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeletePresetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePresetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePresetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePresetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePresetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePresetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePresetOutputError>
}

public struct DeletePresetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePresetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePresetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePresetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePresetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePresetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePresetOutputError>
}

/// <p>The <code>DeletePresetRequest</code> structure.</p>
public struct DeletePresetInput: Swift.Equatable {
    /// <p>The identifier of the preset for which you want to get detailed information.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeletePresetInputBody: Swift.Equatable {
}

extension DeletePresetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePresetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePresetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePresetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePresetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePresetOutputResponse()"}
}

extension DeletePresetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// <p>The <code>DeletePresetResponse</code> structure.</p>
public struct DeletePresetOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePresetOutputResponseBody: Swift.Equatable {
}

extension DeletePresetOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ElasticTranscoderClientTypes.DetectedProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationMillis = "DurationMillis"
        case fileSize = "FileSize"
        case frameRate = "FrameRate"
        case height = "Height"
        case width = "Width"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationMillis = durationMillis {
            try encodeContainer.encode(durationMillis, forKey: .durationMillis)
        }
        if let fileSize = fileSize {
            try encodeContainer.encode(fileSize, forKey: .fileSize)
        }
        if let frameRate = frameRate {
            try encodeContainer.encode(frameRate, forKey: .frameRate)
        }
        if let height = height {
            try encodeContainer.encode(height, forKey: .height)
        }
        if let width = width {
            try encodeContainer.encode(width, forKey: .width)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let widthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .width)
        width = widthDecoded
        let heightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .height)
        height = heightDecoded
        let frameRateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameRate)
        frameRate = frameRateDecoded
        let fileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fileSize)
        fileSize = fileSizeDecoded
        let durationMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationMillis)
        durationMillis = durationMillisDecoded
    }
}

extension ElasticTranscoderClientTypes.DetectedProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetectedProperties(durationMillis: \(Swift.String(describing: durationMillis)), fileSize: \(Swift.String(describing: fileSize)), frameRate: \(Swift.String(describing: frameRate)), height: \(Swift.String(describing: height)), width: \(Swift.String(describing: width)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>The detected properties of the input file. Elastic Transcoder identifies these values from the input file.</p>
    public struct DetectedProperties: Swift.Equatable {
        /// <p>The detected duration of the input file, in milliseconds.</p>
        public let durationMillis: Swift.Int?
        /// <p>The detected file size of the input file, in bytes.</p>
        public let fileSize: Swift.Int?
        /// <p>The detected frame rate of the input file, in frames per second.</p>
        public let frameRate: Swift.String?
        /// <p>The detected height of the input file, in pixels.</p>
        public let height: Swift.Int?
        /// <p>The detected width of the input file, in pixels.</p>
        public let width: Swift.Int?

        public init (
            durationMillis: Swift.Int? = nil,
            fileSize: Swift.Int? = nil,
            frameRate: Swift.String? = nil,
            height: Swift.Int? = nil,
            width: Swift.Int? = nil
        )
        {
            self.durationMillis = durationMillis
            self.fileSize = fileSize
            self.frameRate = frameRate
            self.height = height
            self.width = width
        }
    }

}

extension ElasticTranscoderClientTypes.Encryption: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initializationVector = "InitializationVector"
        case key = "Key"
        case keyMd5 = "KeyMd5"
        case mode = "Mode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initializationVector = initializationVector {
            try encodeContainer.encode(initializationVector, forKey: .initializationVector)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let keyMd5 = keyMd5 {
            try encodeContainer.encode(keyMd5, forKey: .keyMd5)
        }
        if let mode = mode {
            try encodeContainer.encode(mode, forKey: .mode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mode)
        mode = modeDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let keyMd5Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyMd5)
        keyMd5 = keyMd5Decoded
        let initializationVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initializationVector)
        initializationVector = initializationVectorDecoded
    }
}

extension ElasticTranscoderClientTypes.Encryption: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Encryption(initializationVector: \(Swift.String(describing: initializationVector)), key: \(Swift.String(describing: key)), keyMd5: \(Swift.String(describing: keyMd5)), mode: \(Swift.String(describing: mode)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>The encryption settings, if any, that are used for decrypting your input files or
    ///             encrypting your output files. If your input file is encrypted, you must specify the mode
    ///             that Elastic Transcoder uses to decrypt your file, otherwise you must specify the mode you want
    ///             Elastic Transcoder to use to encrypt your output files.</p>
    public struct Encryption: Swift.Equatable {
        /// <p>The series of random bits created by a random bit generator, unique for every encryption
        ///             operation, that you used to encrypt your input files or that you want Elastic Transcoder to use to encrypt
        ///             your output files. The initialization vector must be base64-encoded, and it must be exactly
        ///             16 bytes long before being base64-encoded.</p>
        public let initializationVector: Swift.String?
        /// <p>The data encryption key that you want Elastic Transcoder to use to encrypt your output file, or that
        ///             was used to encrypt your input file. The key must be base64-encoded and it must be one of the
        ///             following bit lengths before being base64-encoded:</p>
        ///         <p>
        ///             <code>128</code>, <code>192</code>, or <code>256</code>. </p>
        ///         <p>The key must also be encrypted by using the Amazon Key Management Service.</p>
        public let key: Swift.String?
        /// <p>The MD5 digest of the key that you used to encrypt your input file, or that you want
        ///             Elastic Transcoder to use to encrypt your output file. Elastic Transcoder uses the key digest as a
        ///             checksum to make sure your key was not corrupted in transit. The key MD5 must be base64-encoded,
        ///             and it must be exactly 16 bytes long before being base64-encoded.</p>
        public let keyMd5: Swift.String?
        /// <p>The specific server-side encryption mode that you want Elastic Transcoder to use when decrypting
        ///             your input files or encrypting your output files. Elastic Transcoder supports the following options:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <b>s3:</b> Amazon S3 creates and manages the
        ///                 keys used for encrypting your files.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>s3-aws-kms:</b> Amazon S3 calls the Amazon Key Management
        ///                 Service, which
        ///                 creates and manages the keys that are used for encrypting your files. If you specify
        ///                 <code>s3-aws-kms</code> and you don't want to use the default key,
        ///                 you must add the AWS-KMS key that you want to use to your pipeline.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>aes-cbc-pkcs7:</b> A padded cipher-block
        ///                 mode of operation originally used for HLS files.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>aes-ctr:</b> AES Counter Mode.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>aes-gcm:</b> AES Galois Counter Mode,
        ///                 a mode of operation that is an authenticated encryption format, meaning that a file, key,
        ///                 or initialization vector that has been tampered with fails the decryption
        ///                 process.</p>
        ///             </li>
        ///          </ul>
        ///         <p>For all three AES options, you must provide the following settings, which must be base64-encoded:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <b>Key</b>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Key MD5</b>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Initialization Vector</b>
        ///                </p>
        ///             </li>
        ///          </ul>
        ///         <important>
        ///             <p>For the AES modes, your private encryption keys and your unencrypted data are never
        ///              stored by AWS; therefore, it is important that you safely manage your encryption keys.
        ///              If you lose them, you won't be able to unencrypt your data.</p>
        ///          </important>
        public let mode: Swift.String?

        public init (
            initializationVector: Swift.String? = nil,
            key: Swift.String? = nil,
            keyMd5: Swift.String? = nil,
            mode: Swift.String? = nil
        )
        {
            self.initializationVector = initializationVector
            self.key = key
            self.keyMd5 = keyMd5
            self.mode = mode
        }
    }

}

extension ElasticTranscoderClientTypes.HlsContentProtection: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initializationVector = "InitializationVector"
        case key = "Key"
        case keyMd5 = "KeyMd5"
        case keyStoragePolicy = "KeyStoragePolicy"
        case licenseAcquisitionUrl = "LicenseAcquisitionUrl"
        case method = "Method"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initializationVector = initializationVector {
            try encodeContainer.encode(initializationVector, forKey: .initializationVector)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let keyMd5 = keyMd5 {
            try encodeContainer.encode(keyMd5, forKey: .keyMd5)
        }
        if let keyStoragePolicy = keyStoragePolicy {
            try encodeContainer.encode(keyStoragePolicy, forKey: .keyStoragePolicy)
        }
        if let licenseAcquisitionUrl = licenseAcquisitionUrl {
            try encodeContainer.encode(licenseAcquisitionUrl, forKey: .licenseAcquisitionUrl)
        }
        if let method = method {
            try encodeContainer.encode(method, forKey: .method)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let methodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .method)
        method = methodDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let keyMd5Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyMd5)
        keyMd5 = keyMd5Decoded
        let initializationVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initializationVector)
        initializationVector = initializationVectorDecoded
        let licenseAcquisitionUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseAcquisitionUrl)
        licenseAcquisitionUrl = licenseAcquisitionUrlDecoded
        let keyStoragePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyStoragePolicy)
        keyStoragePolicy = keyStoragePolicyDecoded
    }
}

extension ElasticTranscoderClientTypes.HlsContentProtection: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HlsContentProtection(initializationVector: \(Swift.String(describing: initializationVector)), key: \(Swift.String(describing: key)), keyMd5: \(Swift.String(describing: keyMd5)), keyStoragePolicy: \(Swift.String(describing: keyStoragePolicy)), licenseAcquisitionUrl: \(Swift.String(describing: licenseAcquisitionUrl)), method: \(Swift.String(describing: method)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>The HLS content protection settings, if any, that you want Elastic Transcoder to apply to your output files.</p>
    public struct HlsContentProtection: Swift.Equatable {
        /// <p>If Elastic Transcoder is generating your key for you, you must leave this field blank.</p>
        ///          <p>The series of random bits created by a random bit generator, unique for every encryption operation,
        ///     that you want Elastic Transcoder to use to encrypt your output files. The initialization vector must be base64-encoded,
        ///     and it must be exactly 16 bytes before being base64-encoded.</p>
        public let initializationVector: Swift.String?
        /// <p>If you want Elastic Transcoder to generate a key for you, leave this field blank.</p>
        ///          <p>If you choose to supply your own key, you must encrypt the key by using AWS KMS. The key must be
        ///     base64-encoded, and it must be one of the following bit lengths before being base64-encoded:</p>
        ///          <p>
        ///             <code>128</code>, <code>192</code>, or <code>256</code>. </p>
        public let key: Swift.String?
        /// <p>If Elastic Transcoder is generating your key for you, you must leave this field blank.</p>
        ///          <p>The MD5 digest of the key that you want Elastic Transcoder to use to encrypt your output file, and that you want
        ///     Elastic Transcoder to use as a checksum to make sure your key was not corrupted in transit. The key MD5 must be
        ///     base64-encoded, and it must be exactly 16 bytes before being base64- encoded.</p>
        public let keyMd5: Swift.String?
        /// <p>Specify whether you want Elastic Transcoder to write your HLS license key to an Amazon S3 bucket. If
        /// you choose <code>WithVariantPlaylists</code>, <code>LicenseAcquisitionUrl</code> must be left blank and Elastic Transcoder
        /// writes your data key into the same bucket as the associated playlist.</p>
        public let keyStoragePolicy: Swift.String?
        /// <p>The location of the license key required to decrypt your HLS playlist. The URL must be an absolute
        ///     path, and is referenced in the URI attribute of the EXT-X-KEY metadata tag in the playlist file.</p>
        public let licenseAcquisitionUrl: Swift.String?
        /// <p>The content protection method for your output. The only valid value is:
        /// <code>aes-128</code>.</p>
        ///          <p>This value is written into the method attribute of the <code>EXT-X-KEY</code> metadata tag in the output
        /// playlist.</p>
        public let method: Swift.String?

        public init (
            initializationVector: Swift.String? = nil,
            key: Swift.String? = nil,
            keyMd5: Swift.String? = nil,
            keyStoragePolicy: Swift.String? = nil,
            licenseAcquisitionUrl: Swift.String? = nil,
            method: Swift.String? = nil
        )
        {
            self.initializationVector = initializationVector
            self.key = key
            self.keyMd5 = keyMd5
            self.keyStoragePolicy = keyStoragePolicy
            self.licenseAcquisitionUrl = licenseAcquisitionUrl
            self.method = method
        }
    }

}

extension IncompatibleVersionException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncompatibleVersionException(message: \(Swift.String(describing: message)))"}
}

extension IncompatibleVersionException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IncompatibleVersionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct IncompatibleVersionException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IncompatibleVersionExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IncompatibleVersionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticTranscoderClientTypes.InputCaptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case captionSources = "CaptionSources"
        case mergePolicy = "MergePolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let captionSources = captionSources {
            var captionSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .captionSources)
            for captionsources0 in captionSources {
                try captionSourcesContainer.encode(captionsources0)
            }
        }
        if let mergePolicy = mergePolicy {
            try encodeContainer.encode(mergePolicy, forKey: .mergePolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mergePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergePolicy)
        mergePolicy = mergePolicyDecoded
        let captionSourcesContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.CaptionSource?].self, forKey: .captionSources)
        var captionSourcesDecoded0:[ElasticTranscoderClientTypes.CaptionSource]? = nil
        if let captionSourcesContainer = captionSourcesContainer {
            captionSourcesDecoded0 = [ElasticTranscoderClientTypes.CaptionSource]()
            for structure0 in captionSourcesContainer {
                if let structure0 = structure0 {
                    captionSourcesDecoded0?.append(structure0)
                }
            }
        }
        captionSources = captionSourcesDecoded0
    }
}

extension ElasticTranscoderClientTypes.InputCaptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InputCaptions(captionSources: \(Swift.String(describing: captionSources)), mergePolicy: \(Swift.String(describing: mergePolicy)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>The captions to be created, if any.</p>
    public struct InputCaptions: Swift.Equatable {
        /// <p>Source files for the input sidecar captions used during the transcoding
        ///             process. To omit all sidecar captions, leave <code>CaptionSources</code> blank.</p>
        public let captionSources: [ElasticTranscoderClientTypes.CaptionSource]?
        /// <p>A policy that determines how Elastic Transcoder handles the existence of multiple captions.</p>
        ///         <ul>
        ///             <li>
        ///                 <p>
        ///                     <b>MergeOverride:</b> Elastic Transcoder transcodes both embedded
        ///                     and sidecar captions into outputs. If captions for a language are embedded in the input
        ///                     file and also appear in a sidecar file, Elastic Transcoder uses the sidecar captions and ignores the
        ///                     embedded captions for that language.</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <b>MergeRetain:</b>  Elastic Transcoder transcodes both embedded
        ///                     and sidecar captions into outputs. If captions for a language are embedded in the input
        ///                     file and also appear in a sidecar file, Elastic Transcoder uses the embedded captions and ignores the
        ///                     sidecar captions for that language. If <code>CaptionSources</code> is empty,
        ///                     Elastic Transcoder omits all sidecar captions from the output files.</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <b>Override:</b> Elastic Transcoder transcodes only the
        ///                     sidecar captions that you specify in <code>CaptionSources</code>.</p>
        ///             </li>
        ///          </ul>
        ///         <p>
        ///             <code>MergePolicy</code> cannot be null.</p>
        public let mergePolicy: Swift.String?

        public init (
            captionSources: [ElasticTranscoderClientTypes.CaptionSource]? = nil,
            mergePolicy: Swift.String? = nil
        )
        {
            self.captionSources = captionSources
            self.mergePolicy = mergePolicy
        }
    }

}

extension InternalServiceException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServiceException(message: \(Swift.String(describing: message)))"}
}

extension InternalServiceException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Elastic Transcoder encountered an unexpected exception while trying to fulfill the request.</p>
public struct InternalServiceException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticTranscoderClientTypes.Job: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case id = "Id"
        case input = "Input"
        case inputs = "Inputs"
        case output = "Output"
        case outputKeyPrefix = "OutputKeyPrefix"
        case outputs = "Outputs"
        case pipelineId = "PipelineId"
        case playlists = "Playlists"
        case status = "Status"
        case timing = "Timing"
        case userMetadata = "UserMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let inputs = inputs {
            var inputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputs)
            for jobinputs0 in inputs {
                try inputsContainer.encode(jobinputs0)
            }
        }
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputKeyPrefix = outputKeyPrefix {
            try encodeContainer.encode(outputKeyPrefix, forKey: .outputKeyPrefix)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for joboutputs0 in outputs {
                try outputsContainer.encode(joboutputs0)
            }
        }
        if let pipelineId = pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let playlists = playlists {
            var playlistsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .playlists)
            for playlists0 in playlists {
                try playlistsContainer.encode(playlists0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let timing = timing {
            try encodeContainer.encode(timing, forKey: .timing)
        }
        if let userMetadata = userMetadata {
            var userMetadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .userMetadata)
            for (dictKey0, usermetadata0) in userMetadata {
                try userMetadataContainer.encode(usermetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let pipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let inputDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.JobInput.self, forKey: .input)
        input = inputDecoded
        let inputsContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.JobInput?].self, forKey: .inputs)
        var inputsDecoded0:[ElasticTranscoderClientTypes.JobInput]? = nil
        if let inputsContainer = inputsContainer {
            inputsDecoded0 = [ElasticTranscoderClientTypes.JobInput]()
            for structure0 in inputsContainer {
                if let structure0 = structure0 {
                    inputsDecoded0?.append(structure0)
                }
            }
        }
        inputs = inputsDecoded0
        let outputDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.JobOutput.self, forKey: .output)
        output = outputDecoded
        let outputsContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.JobOutput?].self, forKey: .outputs)
        var outputsDecoded0:[ElasticTranscoderClientTypes.JobOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ElasticTranscoderClientTypes.JobOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let outputKeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputKeyPrefix)
        outputKeyPrefix = outputKeyPrefixDecoded
        let playlistsContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.Playlist?].self, forKey: .playlists)
        var playlistsDecoded0:[ElasticTranscoderClientTypes.Playlist]? = nil
        if let playlistsContainer = playlistsContainer {
            playlistsDecoded0 = [ElasticTranscoderClientTypes.Playlist]()
            for structure0 in playlistsContainer {
                if let structure0 = structure0 {
                    playlistsDecoded0?.append(structure0)
                }
            }
        }
        playlists = playlistsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let userMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .userMetadata)
        var userMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let userMetadataContainer = userMetadataContainer {
            userMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in userMetadataContainer {
                if let string0 = string0 {
                    userMetadataDecoded0?[key0] = string0
                }
            }
        }
        userMetadata = userMetadataDecoded0
        let timingDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Timing.self, forKey: .timing)
        timing = timingDecoded
    }
}

extension ElasticTranscoderClientTypes.Job: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Job(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), input: \(Swift.String(describing: input)), inputs: \(Swift.String(describing: inputs)), output: \(Swift.String(describing: output)), outputKeyPrefix: \(Swift.String(describing: outputKeyPrefix)), outputs: \(Swift.String(describing: outputs)), pipelineId: \(Swift.String(describing: pipelineId)), playlists: \(Swift.String(describing: playlists)), status: \(Swift.String(describing: status)), timing: \(Swift.String(describing: timing)), userMetadata: \(Swift.String(describing: userMetadata)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>A section of the response body that provides information about the job that is created.</p>
    public struct Job: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) for the job.</p>
        public let arn: Swift.String?
        /// <p>The identifier that Elastic Transcoder assigned to the job. You use this value to get settings for the job or to delete the job.</p>
        public let id: Swift.String?
        /// <p>A section of the request or response body that provides information about the file that is being transcoded.</p>
        public let input: ElasticTranscoderClientTypes.JobInput?
        /// <p>Information about the files that you're transcoding. If you specified multiple files for this
        ///             job, Elastic Transcoder stitches the files together to make one output.</p>
        public let inputs: [ElasticTranscoderClientTypes.JobInput]?
        /// <p>If you specified one output for a job, information about that output. If you
        /// 		specified multiple outputs for a job, the Output object lists information about the first
        /// 		output. This duplicates the information that is listed for the first output in the Outputs object.</p>
        ///          <important>
        ///             <p>Outputs recommended instead.</p>
        ///          </important>
        /// 		       <p>A section of the request or response
        ///             body that provides information about the transcoded (target) file. </p>
        public let output: ElasticTranscoderClientTypes.JobOutput?
        /// <p>The value, if any, that you want Elastic Transcoder to prepend to the names of all files that this job
        ///             creates, including output files, thumbnails, and playlists. We recommend that you add a
        ///             / or some other delimiter to the end of the <code>OutputKeyPrefix</code>.</p>
        public let outputKeyPrefix: Swift.String?
        /// <p>Information about the output files. We recommend that you use the <code>Outputs</code>
        ///             syntax for all jobs, even when you want Elastic Transcoder to transcode a file into only
        ///             one format. Do not use both the <code>Outputs</code> and <code>Output</code> syntaxes in
        ///             the same request. You can create a maximum of 30 outputs per job. </p>
        ///         <p>If you specify more than one output for a job, Elastic Transcoder creates the files for each output
        ///             in the order in which you specify them in the job.</p>
        public let outputs: [ElasticTranscoderClientTypes.JobOutput]?
        /// <p> The <code>Id</code> of the pipeline that you want Elastic Transcoder to use for transcoding. The
        ///             pipeline determines several settings, including the Amazon S3 bucket from which Elastic Transcoder gets the
        ///             files to transcode and the bucket into which Elastic Transcoder puts the transcoded files. </p>
        public let pipelineId: Swift.String?
        /// <important>
        ///             <p>Outputs in Fragmented MP4 or MPEG-TS format only.</p>
        ///          </important>
        /// 		       <p>If you specify a preset in
        ///                 <code>PresetId</code> for which the value of <code>Container</code> is fmp4 (Fragmented MP4) or ts (MPEG-TS),
        ///                 <code>Playlists</code> contains information about the master playlists that you want
        ///             Elastic Transcoder to create.</p>
        ///         <p>The maximum number of master playlists in a job is 30.</p>
        public let playlists: [ElasticTranscoderClientTypes.Playlist]?
        /// <p> The status of the job: <code>Submitted</code>, <code>Progressing</code>, <code>Complete</code>,
        ///                 <code>Canceled</code>, or <code>Error</code>. </p>
        public let status: Swift.String?
        /// <p>Details about the timing of a job.</p>
        public let timing: ElasticTranscoderClientTypes.Timing?
        /// <p>User-defined metadata that you want to associate with an Elastic Transcoder job. You specify metadata in
        ///             <code>key/value</code> pairs, and you can add up to 10 <code>key/value</code> pairs per job.
        ///             Elastic Transcoder does not guarantee that <code>key/value</code> pairs are returned in the same
        ///             order in which you specify them.</p>
        ///             <p>Metadata <code>keys</code> and <code>values</code> must use characters from the following list:</p>
        ///             <ul>
        ///             <li>
        ///                <p>
        ///                   <code>0-9</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>A-Z</code> and <code>a-z</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Space</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>The following symbols: <code>_.:/=+-%@</code>
        ///                </p>
        ///             </li>
        ///          </ul>
        public let userMetadata: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            input: ElasticTranscoderClientTypes.JobInput? = nil,
            inputs: [ElasticTranscoderClientTypes.JobInput]? = nil,
            output: ElasticTranscoderClientTypes.JobOutput? = nil,
            outputKeyPrefix: Swift.String? = nil,
            outputs: [ElasticTranscoderClientTypes.JobOutput]? = nil,
            pipelineId: Swift.String? = nil,
            playlists: [ElasticTranscoderClientTypes.Playlist]? = nil,
            status: Swift.String? = nil,
            timing: ElasticTranscoderClientTypes.Timing? = nil,
            userMetadata: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.input = input
            self.inputs = inputs
            self.output = output
            self.outputKeyPrefix = outputKeyPrefix
            self.outputs = outputs
            self.pipelineId = pipelineId
            self.playlists = playlists
            self.status = status
            self.timing = timing
            self.userMetadata = userMetadata
        }
    }

}

extension ElasticTranscoderClientTypes.JobAlbumArt: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artwork = "Artwork"
        case mergePolicy = "MergePolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artwork = artwork {
            var artworkContainer = encodeContainer.nestedUnkeyedContainer(forKey: .artwork)
            for artworks0 in artwork {
                try artworkContainer.encode(artworks0)
            }
        }
        if let mergePolicy = mergePolicy {
            try encodeContainer.encode(mergePolicy, forKey: .mergePolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mergePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mergePolicy)
        mergePolicy = mergePolicyDecoded
        let artworkContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.Artwork?].self, forKey: .artwork)
        var artworkDecoded0:[ElasticTranscoderClientTypes.Artwork]? = nil
        if let artworkContainer = artworkContainer {
            artworkDecoded0 = [ElasticTranscoderClientTypes.Artwork]()
            for structure0 in artworkContainer {
                if let structure0 = structure0 {
                    artworkDecoded0?.append(structure0)
                }
            }
        }
        artwork = artworkDecoded0
    }
}

extension ElasticTranscoderClientTypes.JobAlbumArt: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobAlbumArt(artwork: \(Swift.String(describing: artwork)), mergePolicy: \(Swift.String(describing: mergePolicy)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>The .jpg or .png file associated with an audio file.</p>
    public struct JobAlbumArt: Swift.Equatable {
        /// <p>The file to be used as album art. There can be multiple artworks associated with an audio file,
        ///             to a maximum of 20. Valid formats are <code>.jpg</code> and <code>.png</code>
        ///          </p>
        public let artwork: [ElasticTranscoderClientTypes.Artwork]?
        /// <p>A policy that determines how Elastic Transcoder handles the existence of multiple album artwork files.</p>
        ///
        ///             <ul>
        ///             <li>
        ///                <p>
        ///                   <code>Replace:</code> The specified album art replaces any existing album art.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Prepend:</code> The specified album art is placed in front of any existing
        ///                     album art.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Append:</code> The specified album art is placed after any existing album art.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Fallback:</code> If the original input file contains artwork, Elastic Transcoder uses that
        ///                     artwork for the output. If the original input does not contain artwork, Elastic Transcoder uses the
        ///                     specified album art file.</p>
        ///             </li>
        ///          </ul>
        public let mergePolicy: Swift.String?

        public init (
            artwork: [ElasticTranscoderClientTypes.Artwork]? = nil,
            mergePolicy: Swift.String? = nil
        )
        {
            self.artwork = artwork
            self.mergePolicy = mergePolicy
        }
    }

}

extension ElasticTranscoderClientTypes.JobInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aspectRatio = "AspectRatio"
        case container = "Container"
        case detectedProperties = "DetectedProperties"
        case encryption = "Encryption"
        case frameRate = "FrameRate"
        case inputCaptions = "InputCaptions"
        case interlaced = "Interlaced"
        case key = "Key"
        case resolution = "Resolution"
        case timeSpan = "TimeSpan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aspectRatio = aspectRatio {
            try encodeContainer.encode(aspectRatio, forKey: .aspectRatio)
        }
        if let container = container {
            try encodeContainer.encode(container, forKey: .container)
        }
        if let detectedProperties = detectedProperties {
            try encodeContainer.encode(detectedProperties, forKey: .detectedProperties)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let frameRate = frameRate {
            try encodeContainer.encode(frameRate, forKey: .frameRate)
        }
        if let inputCaptions = inputCaptions {
            try encodeContainer.encode(inputCaptions, forKey: .inputCaptions)
        }
        if let interlaced = interlaced {
            try encodeContainer.encode(interlaced, forKey: .interlaced)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let resolution = resolution {
            try encodeContainer.encode(resolution, forKey: .resolution)
        }
        if let timeSpan = timeSpan {
            try encodeContainer.encode(timeSpan, forKey: .timeSpan)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let frameRateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameRate)
        frameRate = frameRateDecoded
        let resolutionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolution)
        resolution = resolutionDecoded
        let aspectRatioDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aspectRatio)
        aspectRatio = aspectRatioDecoded
        let interlacedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interlaced)
        interlaced = interlacedDecoded
        let containerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .container)
        container = containerDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let timeSpanDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.TimeSpan.self, forKey: .timeSpan)
        timeSpan = timeSpanDecoded
        let inputCaptionsDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.InputCaptions.self, forKey: .inputCaptions)
        inputCaptions = inputCaptionsDecoded
        let detectedPropertiesDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.DetectedProperties.self, forKey: .detectedProperties)
        detectedProperties = detectedPropertiesDecoded
    }
}

extension ElasticTranscoderClientTypes.JobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobInput(aspectRatio: \(Swift.String(describing: aspectRatio)), container: \(Swift.String(describing: container)), detectedProperties: \(Swift.String(describing: detectedProperties)), encryption: \(Swift.String(describing: encryption)), frameRate: \(Swift.String(describing: frameRate)), inputCaptions: \(Swift.String(describing: inputCaptions)), interlaced: \(Swift.String(describing: interlaced)), key: \(Swift.String(describing: key)), resolution: \(Swift.String(describing: resolution)), timeSpan: \(Swift.String(describing: timeSpan)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>Information about the file that you're transcoding.</p>
    public struct JobInput: Swift.Equatable {
        /// <p> The aspect ratio of the input file. If you want Elastic Transcoder to automatically detect the aspect
        ///             ratio of the input file, specify <code>auto</code>. If you want to specify the aspect
        ///             ratio for the output file, enter one of the following values: </p>
        ///         <p>
        ///             <code>1:1</code>, <code>4:3</code>, <code>3:2</code>, <code>16:9</code>
        ///         </p>
        ///         <p> If you specify a value other than <code>auto</code>, Elastic Transcoder disables automatic detection
        ///             of the aspect ratio. </p>
        public let aspectRatio: Swift.String?
        /// <p>The container type for the input file. If you want Elastic Transcoder to automatically detect the
        ///             container type of the input file, specify <code>auto</code>. If you want to specify the
        ///             container type for the input file, enter one of the following values: </p>
        ///         <p>
        ///             <code>3gp</code>, <code>aac</code>, <code>asf</code>, <code>avi</code>,
        ///                 <code>divx</code>, <code>flv</code>, <code>m4a</code>, <code>mkv</code>,
        ///                 <code>mov</code>, <code>mp3</code>, <code>mp4</code>, <code>mpeg</code>,
        ///                 <code>mpeg-ps</code>, <code>mpeg-ts</code>, <code>mxf</code>, <code>ogg</code>,
        ///                 <code>vob</code>, <code>wav</code>, <code>webm</code>
        ///         </p>
        public let container: Swift.String?
        /// <p>The detected properties of the input file.</p>
        public let detectedProperties: ElasticTranscoderClientTypes.DetectedProperties?
        /// <p>The encryption settings, if any, that are used for decrypting your input files. If
        ///             your input file is encrypted, you must specify the mode that Elastic Transcoder uses to decrypt your file.</p>
        public let encryption: ElasticTranscoderClientTypes.Encryption?
        /// <p>The frame rate of the input file. If you want Elastic Transcoder to automatically detect the frame rate
        ///             of the input file, specify <code>auto</code>. If you want to specify the frame rate for
        ///             the input file, enter one of the following values: </p>
        ///         <p>
        ///             <code>10</code>, <code>15</code>, <code>23.97</code>, <code>24</code>, <code>25</code>,
        ///                 <code>29.97</code>, <code>30</code>, <code>60</code>
        ///         </p>
        ///         <p>If you specify a value other than <code>auto</code>, Elastic Transcoder disables automatic detection of
        ///             the frame rate.</p>
        public let frameRate: Swift.String?
        /// <p>You can configure Elastic Transcoder to transcode captions, or subtitles, from one format to another.
        ///             All captions must be in UTF-8. Elastic Transcoder supports two types of captions:</p>
        ///         <ul>
        ///             <li>
        ///                 <p>
        ///                     <b>Embedded:</b> Embedded captions
        ///                     are included in the same file as the audio and video. Elastic Transcoder supports
        ///                     only one embedded caption per language, to a maximum of 300 embedded captions per file.</p>
        ///                 <p>Valid input values include: <code>CEA-608 (EIA-608</code>, first non-empty channel only),
        ///                     <code>CEA-708 (EIA-708</code>, first non-empty channel only), and <code>mov-text</code>
        ///                 </p>
        ///                 <p>Valid outputs include: <code>mov-text</code>
        ///                 </p>
        ///                 <p>Elastic Transcoder supports a maximum of one embedded format per output.</p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <b>Sidecar:</b> Sidecar captions are kept in a
        ///                     separate metadata file from the audio and video data.  Sidecar captions require a player
        ///                     that is capable of understanding the relationship between the video file and the sidecar
        ///                     file. Elastic Transcoder supports only one sidecar caption per language, to a maximum of 20 sidecar
        ///                     captions per file.</p>
        ///                 <p>Valid input values include: <code>dfxp</code> (first div element only),
        ///                     <code>ebu-tt</code>, <code>scc</code>, <code>smpt</code>, <code>srt</code>,
        ///                     <code>ttml</code> (first div element only), and <code>webvtt</code>
        ///                 </p>
        ///                 <p>Valid outputs include: <code>dfxp</code> (first div element only), <code>scc</code>,
        ///                     <code>srt</code>, and <code>webvtt</code>.</p>
        ///             </li>
        ///          </ul>
        ///         <p>If you want ttml or smpte-tt compatible captions, specify dfxp as your output format.</p>
        ///         <p>Elastic Transcoder does not support OCR (Optical Character Recognition), does not accept pictures
        ///             as a valid input for captions, and is not available for audio-only transcoding. Elastic Transcoder does
        ///             not preserve text formatting (for example, italics) during the transcoding process.</p>
        ///         <p>To remove captions or leave the captions empty, set <code>Captions</code> to null. To pass through
        ///             existing captions unchanged, set the <code>MergePolicy</code> to <code>MergeRetain</code>,
        ///             and pass in a null <code>CaptionSources</code> array.</p>
        ///         <p>For more information on embedded files, see the Subtitles Wikipedia page.</p>
        ///         <p>For more information on sidecar files, see the Extensible Metadata Platform and Sidecar file Wikipedia pages.</p>
        public let inputCaptions: ElasticTranscoderClientTypes.InputCaptions?
        /// <p>Whether the input file is interlaced. If you want Elastic Transcoder to automatically detect whether
        ///             the input file is interlaced, specify <code>auto</code>. If you want to specify whether
        ///             the input file is interlaced, enter one of the following values:</p>
        ///         <p>
        ///             <code>true</code>, <code>false</code>
        ///          </p>
        ///         <p>If you specify a value other than <code>auto</code>, Elastic Transcoder disables automatic detection of
        ///             interlacing.</p>
        public let interlaced: Swift.String?
        /// <p> The name of the file to transcode. Elsewhere in the body of the JSON block is the the ID
        ///             of the pipeline to use for processing the job. The <code>InputBucket</code> object in
        ///             that pipeline tells Elastic Transcoder which Amazon S3 bucket to get the file from. </p>
        ///         <p>If the file name includes a prefix, such as <code>cooking/lasagna.mpg</code>, include the
        ///             prefix in the key. If the file isn't in the specified bucket, Elastic Transcoder returns an error.</p>
        public let key: Swift.String?
        /// <p>This value must be <code>auto</code>, which causes Elastic Transcoder to automatically
        ///             detect the resolution of the input file.</p>
        public let resolution: Swift.String?
        /// <p>Settings for clipping an input. Each input can have different clip settings.</p>
        public let timeSpan: ElasticTranscoderClientTypes.TimeSpan?

        public init (
            aspectRatio: Swift.String? = nil,
            container: Swift.String? = nil,
            detectedProperties: ElasticTranscoderClientTypes.DetectedProperties? = nil,
            encryption: ElasticTranscoderClientTypes.Encryption? = nil,
            frameRate: Swift.String? = nil,
            inputCaptions: ElasticTranscoderClientTypes.InputCaptions? = nil,
            interlaced: Swift.String? = nil,
            key: Swift.String? = nil,
            resolution: Swift.String? = nil,
            timeSpan: ElasticTranscoderClientTypes.TimeSpan? = nil
        )
        {
            self.aspectRatio = aspectRatio
            self.container = container
            self.detectedProperties = detectedProperties
            self.encryption = encryption
            self.frameRate = frameRate
            self.inputCaptions = inputCaptions
            self.interlaced = interlaced
            self.key = key
            self.resolution = resolution
            self.timeSpan = timeSpan
        }
    }

}

extension ElasticTranscoderClientTypes.JobOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case albumArt = "AlbumArt"
        case appliedColorSpaceConversion = "AppliedColorSpaceConversion"
        case captions = "Captions"
        case composition = "Composition"
        case duration = "Duration"
        case durationMillis = "DurationMillis"
        case encryption = "Encryption"
        case fileSize = "FileSize"
        case frameRate = "FrameRate"
        case height = "Height"
        case id = "Id"
        case key = "Key"
        case presetId = "PresetId"
        case rotate = "Rotate"
        case segmentDuration = "SegmentDuration"
        case status = "Status"
        case statusDetail = "StatusDetail"
        case thumbnailEncryption = "ThumbnailEncryption"
        case thumbnailPattern = "ThumbnailPattern"
        case watermarks = "Watermarks"
        case width = "Width"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let albumArt = albumArt {
            try encodeContainer.encode(albumArt, forKey: .albumArt)
        }
        if let appliedColorSpaceConversion = appliedColorSpaceConversion {
            try encodeContainer.encode(appliedColorSpaceConversion, forKey: .appliedColorSpaceConversion)
        }
        if let captions = captions {
            try encodeContainer.encode(captions, forKey: .captions)
        }
        if let composition = composition {
            var compositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .composition)
            for composition0 in composition {
                try compositionContainer.encode(composition0)
            }
        }
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let durationMillis = durationMillis {
            try encodeContainer.encode(durationMillis, forKey: .durationMillis)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let fileSize = fileSize {
            try encodeContainer.encode(fileSize, forKey: .fileSize)
        }
        if let frameRate = frameRate {
            try encodeContainer.encode(frameRate, forKey: .frameRate)
        }
        if let height = height {
            try encodeContainer.encode(height, forKey: .height)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let presetId = presetId {
            try encodeContainer.encode(presetId, forKey: .presetId)
        }
        if let rotate = rotate {
            try encodeContainer.encode(rotate, forKey: .rotate)
        }
        if let segmentDuration = segmentDuration {
            try encodeContainer.encode(segmentDuration, forKey: .segmentDuration)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusDetail = statusDetail {
            try encodeContainer.encode(statusDetail, forKey: .statusDetail)
        }
        if let thumbnailEncryption = thumbnailEncryption {
            try encodeContainer.encode(thumbnailEncryption, forKey: .thumbnailEncryption)
        }
        if let thumbnailPattern = thumbnailPattern {
            try encodeContainer.encode(thumbnailPattern, forKey: .thumbnailPattern)
        }
        if let watermarks = watermarks {
            var watermarksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .watermarks)
            for jobwatermarks0 in watermarks {
                try watermarksContainer.encode(jobwatermarks0)
            }
        }
        if let width = width {
            try encodeContainer.encode(width, forKey: .width)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let thumbnailPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thumbnailPattern)
        thumbnailPattern = thumbnailPatternDecoded
        let thumbnailEncryptionDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Encryption.self, forKey: .thumbnailEncryption)
        thumbnailEncryption = thumbnailEncryptionDecoded
        let rotateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotate)
        rotate = rotateDecoded
        let presetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .presetId)
        presetId = presetIdDecoded
        let segmentDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .segmentDuration)
        segmentDuration = segmentDurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let statusDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetail)
        statusDetail = statusDetailDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let widthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .width)
        width = widthDecoded
        let heightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .height)
        height = heightDecoded
        let frameRateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameRate)
        frameRate = frameRateDecoded
        let fileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fileSize)
        fileSize = fileSizeDecoded
        let durationMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationMillis)
        durationMillis = durationMillisDecoded
        let watermarksContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.JobWatermark?].self, forKey: .watermarks)
        var watermarksDecoded0:[ElasticTranscoderClientTypes.JobWatermark]? = nil
        if let watermarksContainer = watermarksContainer {
            watermarksDecoded0 = [ElasticTranscoderClientTypes.JobWatermark]()
            for structure0 in watermarksContainer {
                if let structure0 = structure0 {
                    watermarksDecoded0?.append(structure0)
                }
            }
        }
        watermarks = watermarksDecoded0
        let albumArtDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.JobAlbumArt.self, forKey: .albumArt)
        albumArt = albumArtDecoded
        let compositionContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.Clip?].self, forKey: .composition)
        var compositionDecoded0:[ElasticTranscoderClientTypes.Clip]? = nil
        if let compositionContainer = compositionContainer {
            compositionDecoded0 = [ElasticTranscoderClientTypes.Clip]()
            for structure0 in compositionContainer {
                if let structure0 = structure0 {
                    compositionDecoded0?.append(structure0)
                }
            }
        }
        composition = compositionDecoded0
        let captionsDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Captions.self, forKey: .captions)
        captions = captionsDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let appliedColorSpaceConversionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appliedColorSpaceConversion)
        appliedColorSpaceConversion = appliedColorSpaceConversionDecoded
    }
}

extension ElasticTranscoderClientTypes.JobOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobOutput(albumArt: \(Swift.String(describing: albumArt)), appliedColorSpaceConversion: \(Swift.String(describing: appliedColorSpaceConversion)), captions: \(Swift.String(describing: captions)), composition: \(Swift.String(describing: composition)), duration: \(Swift.String(describing: duration)), durationMillis: \(Swift.String(describing: durationMillis)), encryption: \(Swift.String(describing: encryption)), fileSize: \(Swift.String(describing: fileSize)), frameRate: \(Swift.String(describing: frameRate)), height: \(Swift.String(describing: height)), id: \(Swift.String(describing: id)), key: \(Swift.String(describing: key)), presetId: \(Swift.String(describing: presetId)), rotate: \(Swift.String(describing: rotate)), segmentDuration: \(Swift.String(describing: segmentDuration)), status: \(Swift.String(describing: status)), statusDetail: \(Swift.String(describing: statusDetail)), thumbnailEncryption: \(Swift.String(describing: thumbnailEncryption)), thumbnailPattern: \(Swift.String(describing: thumbnailPattern)), watermarks: \(Swift.String(describing: watermarks)), width: \(Swift.String(describing: width)))"}
}

extension ElasticTranscoderClientTypes {
    /// <important>
    ///             <p>Outputs recommended instead.</p>
    ///          </important>
    /// 		       <p>If you specified one output for a job,
    ///             information about that output. If you specified multiple outputs for a job, the
    ///                 <code>Output</code> object lists information about the first output. This duplicates
    ///             the information that is listed for the first output in the <code>Outputs</code>
    ///             object.</p>
    public struct JobOutput: Swift.Equatable {
        /// <p>The album art to be associated with the output file, if any.</p>
        public let albumArt: ElasticTranscoderClientTypes.JobAlbumArt?
        /// <p>If Elastic Transcoder used a preset with a <code>ColorSpaceConversionMode</code> to transcode the output
        ///       file, the <code>AppliedColorSpaceConversion</code> parameter shows the conversion used. If no
        ///       <code>ColorSpaceConversionMode</code> was defined in the preset, this parameter is not be
        ///       included in the job response.</p>
        public let appliedColorSpaceConversion: Swift.String?
        /// <p>You can configure Elastic Transcoder to transcode captions, or subtitles, from one format to another.
        ///           All captions must be in UTF-8. Elastic Transcoder supports two types of captions:</p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <b>Embedded:</b> Embedded captions
        ///             are included in the same file as the audio and video. Elastic Transcoder supports
        ///             only one embedded caption per language, to a maximum of 300 embedded captions per file.</p>
        ///                <p>Valid input values include: <code>CEA-608 (EIA-608</code>, first non-empty channel only),
        ///                <code>CEA-708 (EIA-708</code>, first non-empty channel only), and <code>mov-text</code>
        ///                </p>
        ///                <p>Valid outputs include: <code>mov-text</code>
        ///                </p>
        ///                <p>Elastic Transcoder supports a maximum of one embedded format per output.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Sidecar:</b> Sidecar captions are kept in a
        ///             separate metadata file from the audio and video data.  Sidecar captions require a player
        ///             that is capable of understanding the relationship between the video file and the sidecar
        ///             file. Elastic Transcoder supports only one sidecar caption per language, to a maximum of 20 sidecar
        ///             captions per file.</p>
        ///                <p>Valid input values include: <code>dfxp</code> (first div element only),
        ///                <code>ebu-tt</code>, <code>scc</code>, <code>smpt</code>, <code>srt</code>,
        ///                <code>ttml</code> (first div element only), and <code>webvtt</code>
        ///                </p>
        ///                <p>Valid outputs include: <code>dfxp</code> (first div element only), <code>scc</code>,
        ///                <code>srt</code>, and <code>webvtt</code>.</p>
        ///             </li>
        ///          </ul>
        ///          <p>If you want ttml or smpte-tt compatible captions, specify dfxp as your output format.</p>
        ///          <p>Elastic Transcoder does not support OCR (Optical Character Recognition), does not accept pictures
        ///              as a valid input for captions, and is not available for audio-only transcoding. Elastic Transcoder does
        ///              not preserve text formatting (for example, italics) during the transcoding process.</p>
        ///              <p>To remove captions or leave the captions empty, set <code>Captions</code> to null. To pass through
        ///              existing captions unchanged, set the <code>MergePolicy</code> to <code>MergeRetain</code>,
        ///              and pass in a null <code>CaptionSources</code> array.</p>
        ///          <p>For more information on embedded files, see the Subtitles Wikipedia page.</p>
        ///          <p>For more information on sidecar files, see the Extensible Metadata Platform and Sidecar file Wikipedia pages.</p>
        public let captions: ElasticTranscoderClientTypes.Captions?
        /// <p>You can create an output file that contains an excerpt from the input file. This excerpt, called
        ///             a clip, can come from the beginning, middle, or end of the file. The Composition object contains settings
        ///             for the clips that make up an output file. For the current release, you can only specify settings for a
        ///             single clip per output file. The Composition object cannot be null.</p>
        @available(*, deprecated)
        public let composition: [ElasticTranscoderClientTypes.Clip]?
        /// <p>Duration of the output file, in seconds.</p>
        public let duration: Swift.Int?
        /// <p>Duration of the output file, in milliseconds.</p>
        public let durationMillis: Swift.Int?
        /// <p>The encryption settings, if any, that you want Elastic Transcoder to apply to your output files.
        ///             If you choose to use encryption, you must specify a mode to use. If you choose not to
        ///             use encryption, Elastic Transcoder writes an unencrypted file to your Amazon S3 bucket.</p>
        public let encryption: ElasticTranscoderClientTypes.Encryption?
        /// <p>File size of the output file, in bytes.</p>
        public let fileSize: Swift.Int?
        /// <p>Frame rate of the output file, in frames per second.</p>
        public let frameRate: Swift.String?
        /// <p>Height of the output file, in pixels.</p>
        public let height: Swift.Int?
        /// <p>A sequential counter, starting with 1, that identifies an output among the outputs from
        ///             the current job. In the Output syntax, this value is always 1.</p>
        public let id: Swift.String?
        /// <p> The name to assign to the transcoded file. Elastic Transcoder saves the file in the Amazon S3 bucket
        ///             specified by the <code>OutputBucket</code> object in the pipeline that is specified by
        ///             the pipeline ID.</p>
        public let key: Swift.String?
        /// <p>The value of the <code>Id</code> object for the preset that you want to use for this job.
        ///             The preset determines the audio, video, and thumbnail settings that Elastic Transcoder
        ///             uses for transcoding. To use a preset that you created, specify the preset ID that
        ///             Elastic Transcoder returned in the response when you created the preset. You can also
        ///             use the Elastic Transcoder system presets, which you can get with <code>ListPresets</code>.</p>
        public let presetId: Swift.String?
        /// <p>The number of degrees clockwise by which you want Elastic Transcoder to rotate the output relative
        ///             to the input. Enter one of the following values:</p>
        ///         <p>
        ///             <code>auto</code>, <code>0</code>, <code>90</code>, <code>180</code>,
        ///             <code>270</code>
        ///          </p>
        ///         <p> The value <code>auto</code> generally works only if the file that you're transcoding
        ///             contains rotation metadata.</p>
        public let rotate: Swift.String?
        /// <important>
        ///             <p>(Outputs in Fragmented MP4 or MPEG-TS format only.</p>
        ///          </important>
        /// 		       <p>If you specify a preset in
        ///                 <code>PresetId</code> for which the value of <code>Container</code> is <code>fmp4</code> (Fragmented MP4) or
        ///                 <code>ts</code> (MPEG-TS), <code>SegmentDuration</code> is the target maximum duration of
        ///             each segment in seconds. For <code>HLSv3</code> format playlists,
        ///             each media segment is stored in a separate <code>.ts</code> file. For <code>HLSv4</code>, <code>MPEG-DASH</code>, and <code>Smooth</code>
        ///             playlists, all media segments for an output are stored in a single file. Each segment is approximately the length of
        ///             the <code>SegmentDuration</code>, though individual segments might be shorter or longer.</p>
        ///
        ///             <p>The range of valid values is 1 to 60 seconds. If the duration
        ///             of the video is not evenly divisible by <code>SegmentDuration</code>, the duration of
        ///             the last segment is the remainder of total length/SegmentDuration.</p>
        ///             <p>Elastic Transcoder
        ///             creates an output-specific playlist for each output <code>HLS</code> output that you specify in OutputKeys. To
        ///             add an output to the master playlist for this job, include it in the <code>OutputKeys</code> of
        ///             the associated playlist.</p>
        public let segmentDuration: Swift.String?
        /// <p> The status of one output in a job. If you specified only one output for the job,
        ///                 <code>Outputs:Status</code> is always the same as <code>Job:Status</code>. If you
        ///             specified more than one output: </p>
        /// 			      <ul>
        ///             <li>
        ///                <p>
        ///                   <code>Job:Status</code> and <code>Outputs:Status</code> for all of the outputs
        ///                     is Submitted until Elastic Transcoder starts to process the first output.</p>
        ///             </li>
        ///             <li>
        ///                <p>When Elastic Transcoder starts to process the first output,
        ///                         <code>Outputs:Status</code> for that output and <code>Job:Status</code> both
        ///                     change to Progressing. For each output, the value of <code>Outputs:Status</code>
        ///                     remains Submitted until Elastic Transcoder starts to process the output.</p>
        ///             </li>
        ///             <li>
        ///                <p>Job:Status remains Progressing until all of the outputs reach a terminal status,
        ///                     either Complete or Error.</p>
        ///             </li>
        ///             <li>
        ///                <p>When all of the outputs reach a terminal status, <code>Job:Status</code> changes
        ///                     to Complete only if <code>Outputs:Status</code> for all of the outputs is
        ///                         <code>Complete</code>. If <code>Outputs:Status</code> for one or more
        ///                     outputs is <code>Error</code>, the terminal status for <code>Job:Status</code>
        ///                     is also <code>Error</code>.</p>
        ///             </li>
        ///          </ul>
        /// 			      <p>The value of <code>Status</code> is one of the following: <code>Submitted</code>,
        ///                 <code>Progressing</code>, <code>Complete</code>, <code>Canceled</code>, or
        ///                 <code>Error</code>. </p>
        public let status: Swift.String?
        /// <p>Information that further explains <code>Status</code>.</p>
        public let statusDetail: Swift.String?
        /// <p>The encryption settings, if any, that you want Elastic Transcoder to apply to your thumbnail.</p>
        public let thumbnailEncryption: ElasticTranscoderClientTypes.Encryption?
        /// <p>Whether you want Elastic Transcoder to create thumbnails for your videos and, if so, how you want
        ///             Elastic Transcoder to name the files.</p>
        ///         <p>If you don't want Elastic Transcoder to create thumbnails, specify "".</p>
        ///         <p>If you do want Elastic Transcoder to create thumbnails, specify the information that you want to
        ///             include in the file name for each thumbnail. You can specify the following values in any sequence:</p>
        ///         <ul>
        ///             <li>
        ///                 <p>
        ///                     <b>
        ///                      <code>{count}</code> (Required)</b>: If you want to create thumbnails, you
        ///                     must include <code>{count}</code> in the <code>ThumbnailPattern</code> object.
        ///                     Wherever you specify <code>{count}</code>, Elastic Transcoder adds a five-digit sequence
        ///                     number (beginning with <b>00001</b>) to thumbnail file names. The number
        ///                     indicates where a given thumbnail appears in the sequence of thumbnails for a
        ///                     transcoded file. </p>
        ///                 <important>
        ///                   <p>If you specify a literal value and/or <code>{resolution}</code> but you
        ///                     omit <code>{count}</code>, Elastic Transcoder returns a validation error and does not create
        ///                     the job.</p>
        ///                </important>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <b>Literal values (Optional)</b>: You can specify literal values anywhere in the
        ///                         <code>ThumbnailPattern</code> object. For example, you can include them as a
        ///                     file name prefix or as a delimiter between <code>{resolution}</code> and
        ///                         <code>{count}</code>. </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                     <b>
        ///                      <code>{resolution}</code> (Optional)</b>: If you want Elastic Transcoder to include the
        ///                     resolution in the file name, include <code>{resolution}</code> in the
        ///                         <code>ThumbnailPattern</code> object. </p>
        ///             </li>
        ///          </ul>
        ///         <p>When creating thumbnails, Elastic Transcoder automatically saves the files in the format (.jpg or .png)
        ///             that appears in the preset that you specified in the <code>PresetID</code> value of
        ///                 <code>CreateJobOutput</code>. Elastic Transcoder also appends the applicable file name
        ///             extension.</p>
        public let thumbnailPattern: Swift.String?
        /// <p>Information about the watermarks that you want Elastic Transcoder to add to the video during
        ///             transcoding. You can specify up to four watermarks for each output. Settings for each
        ///             watermark must be defined in the preset that you specify in <code>Preset</code> for the
        ///             current output.</p>
        ///         <p>Watermarks are added to the output video in the sequence in which you list them
        ///             in the job outputthe first watermark in the list is added to the output video first,
        ///             the second watermark in the list is added next, and so on. As a result, if the settings
        ///             in a preset cause Elastic Transcoder to place all watermarks in the same location, the second watermark
        ///             that you add covers the first one, the third one covers the second, and the
        ///             fourth one covers the third.</p>
        public let watermarks: [ElasticTranscoderClientTypes.JobWatermark]?
        /// <p>Specifies the width of the output file in pixels.</p>
        public let width: Swift.Int?

        public init (
            albumArt: ElasticTranscoderClientTypes.JobAlbumArt? = nil,
            appliedColorSpaceConversion: Swift.String? = nil,
            captions: ElasticTranscoderClientTypes.Captions? = nil,
            composition: [ElasticTranscoderClientTypes.Clip]? = nil,
            duration: Swift.Int? = nil,
            durationMillis: Swift.Int? = nil,
            encryption: ElasticTranscoderClientTypes.Encryption? = nil,
            fileSize: Swift.Int? = nil,
            frameRate: Swift.String? = nil,
            height: Swift.Int? = nil,
            id: Swift.String? = nil,
            key: Swift.String? = nil,
            presetId: Swift.String? = nil,
            rotate: Swift.String? = nil,
            segmentDuration: Swift.String? = nil,
            status: Swift.String? = nil,
            statusDetail: Swift.String? = nil,
            thumbnailEncryption: ElasticTranscoderClientTypes.Encryption? = nil,
            thumbnailPattern: Swift.String? = nil,
            watermarks: [ElasticTranscoderClientTypes.JobWatermark]? = nil,
            width: Swift.Int? = nil
        )
        {
            self.albumArt = albumArt
            self.appliedColorSpaceConversion = appliedColorSpaceConversion
            self.captions = captions
            self.composition = composition
            self.duration = duration
            self.durationMillis = durationMillis
            self.encryption = encryption
            self.fileSize = fileSize
            self.frameRate = frameRate
            self.height = height
            self.id = id
            self.key = key
            self.presetId = presetId
            self.rotate = rotate
            self.segmentDuration = segmentDuration
            self.status = status
            self.statusDetail = statusDetail
            self.thumbnailEncryption = thumbnailEncryption
            self.thumbnailPattern = thumbnailPattern
            self.watermarks = watermarks
            self.width = width
        }
    }

}

extension ElasticTranscoderClientTypes.JobWatermark: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryption = "Encryption"
        case inputKey = "InputKey"
        case presetWatermarkId = "PresetWatermarkId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let inputKey = inputKey {
            try encodeContainer.encode(inputKey, forKey: .inputKey)
        }
        if let presetWatermarkId = presetWatermarkId {
            try encodeContainer.encode(presetWatermarkId, forKey: .presetWatermarkId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let presetWatermarkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .presetWatermarkId)
        presetWatermarkId = presetWatermarkIdDecoded
        let inputKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputKey)
        inputKey = inputKeyDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
    }
}

extension ElasticTranscoderClientTypes.JobWatermark: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobWatermark(encryption: \(Swift.String(describing: encryption)), inputKey: \(Swift.String(describing: inputKey)), presetWatermarkId: \(Swift.String(describing: presetWatermarkId)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>Watermarks can be in .png or .jpg format. If you want to display a watermark that is not
    ///     rectangular, use the .png format, which supports transparency.</p>
    public struct JobWatermark: Swift.Equatable {
        /// <p>The encryption settings, if any, that you want Elastic Transcoder to apply to your watermarks.</p>
        public let encryption: ElasticTranscoderClientTypes.Encryption?
        /// <p> The name of the .png or .jpg file that you want to use for the watermark. To determine
        ///     which Amazon S3 bucket contains the specified file, Elastic Transcoder checks the pipeline specified by
        ///         <code>Pipeline</code>; the <code>Input Bucket</code> object in that pipeline
        ///     identifies the bucket.</p>
        ///          <p> If the file name includes a prefix, for example, <b>logos/128x64.png</b>,
        ///     include the prefix in the key. If the file isn't in the specified bucket, Elastic Transcoder returns
        ///     an error. </p>
        public let inputKey: Swift.String?
        /// <p>The ID of the watermark settings that Elastic Transcoder uses to add watermarks to the video during transcoding.
        ///     The settings are in the preset specified by Preset for the current output. In that preset, the value
        ///     of Watermarks Id tells Elastic Transcoder which settings to use.</p>
        public let presetWatermarkId: Swift.String?

        public init (
            encryption: ElasticTranscoderClientTypes.Encryption? = nil,
            inputKey: Swift.String? = nil,
            presetWatermarkId: Swift.String? = nil
        )
        {
            self.encryption = encryption
            self.inputKey = inputKey
            self.presetWatermarkId = presetWatermarkId
        }
    }

}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Too many operations for a given AWS account. For example, the number of pipelines
///             exceeds the maximum allowed.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListJobsByPipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListJobsByPipelineInput(ascending: \(Swift.String(describing: ascending)), pageToken: \(Swift.String(describing: pageToken)), pipelineId: \(Swift.String(describing: pipelineId)))"}
}

extension ListJobsByPipelineInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListJobsByPipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobsByPipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListJobsByPipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsByPipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListJobsByPipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobsByPipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobsByPipelineOutputError>
}

public struct ListJobsByPipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobsByPipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListJobsByPipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsByPipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageToken = input.operationInput.pageToken {
            let pageTokenQueryItem = ClientRuntime.URLQueryItem(name: "PageToken".urlPercentEncoding(), value: Swift.String(pageToken).urlPercentEncoding())
            input.builder.withQueryItem(pageTokenQueryItem)
        }
        if let ascending = input.operationInput.ascending {
            let ascendingQueryItem = ClientRuntime.URLQueryItem(name: "Ascending".urlPercentEncoding(), value: Swift.String(ascending).urlPercentEncoding())
            input.builder.withQueryItem(ascendingQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListJobsByPipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobsByPipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobsByPipelineOutputError>
}

/// <p>The <code>ListJobsByPipelineRequest</code> structure.</p>
public struct ListJobsByPipelineInput: Swift.Equatable {
    /// <p> To list jobs in chronological order by the date and time that they were submitted, enter
    ///                 <code>true</code>. To list jobs in reverse chronological order, enter
    ///                 <code>false</code>. </p>
    public let ascending: Swift.String?
    /// <p> When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
    ///             subsequent <code>GET</code> requests to get each successive page of results. </p>
    public let pageToken: Swift.String?
    /// <p>The ID of the pipeline for which you want to get job information.</p>
    public let pipelineId: Swift.String?

    public init (
        ascending: Swift.String? = nil,
        pageToken: Swift.String? = nil,
        pipelineId: Swift.String? = nil
    )
    {
        self.ascending = ascending
        self.pageToken = pageToken
        self.pipelineId = pipelineId
    }
}

struct ListJobsByPipelineInputBody: Swift.Equatable {
}

extension ListJobsByPipelineInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListJobsByPipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsByPipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobsByPipelineOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsByPipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListJobsByPipelineOutputResponse(jobs: \(Swift.String(describing: jobs)), nextPageToken: \(Swift.String(describing: nextPageToken)))"}
}

extension ListJobsByPipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListJobsByPipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextPageToken = output.nextPageToken
        } else {
            self.jobs = nil
            self.nextPageToken = nil
        }
    }
}

/// <p>The <code>ListJobsByPipelineResponse</code> structure.</p>
public struct ListJobsByPipelineOutputResponse: Swift.Equatable {
    /// <p>An array of <code>Job</code> objects that are in the specified pipeline.</p>
    public let jobs: [ElasticTranscoderClientTypes.Job]?
    /// <p> A value that you use to access the second and subsequent pages of results, if any. When
    ///             the jobs in the specified pipeline fit on one page or when you've reached the last page
    ///             of results, the value of <code>NextPageToken</code> is <code>null</code>. </p>
    public let nextPageToken: Swift.String?

    public init (
        jobs: [ElasticTranscoderClientTypes.Job]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextPageToken = nextPageToken
    }
}

struct ListJobsByPipelineOutputResponseBody: Swift.Equatable {
    public let jobs: [ElasticTranscoderClientTypes.Job]?
    public let nextPageToken: Swift.String?
}

extension ListJobsByPipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs = "Jobs"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.Job?].self, forKey: .jobs)
        var jobsDecoded0:[ElasticTranscoderClientTypes.Job]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [ElasticTranscoderClientTypes.Job]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension ListJobsByStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListJobsByStatusInput(ascending: \(Swift.String(describing: ascending)), pageToken: \(Swift.String(describing: pageToken)), status: \(Swift.String(describing: status)))"}
}

extension ListJobsByStatusInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListJobsByStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobsByStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListJobsByStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsByStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListJobsByStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobsByStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobsByStatusOutputError>
}

public struct ListJobsByStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListJobsByStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListJobsByStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListJobsByStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageToken = input.operationInput.pageToken {
            let pageTokenQueryItem = ClientRuntime.URLQueryItem(name: "PageToken".urlPercentEncoding(), value: Swift.String(pageToken).urlPercentEncoding())
            input.builder.withQueryItem(pageTokenQueryItem)
        }
        if let ascending = input.operationInput.ascending {
            let ascendingQueryItem = ClientRuntime.URLQueryItem(name: "Ascending".urlPercentEncoding(), value: Swift.String(ascending).urlPercentEncoding())
            input.builder.withQueryItem(ascendingQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListJobsByStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListJobsByStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListJobsByStatusOutputError>
}

/// <p>The <code>ListJobsByStatusRequest</code> structure.</p>
public struct ListJobsByStatusInput: Swift.Equatable {
    /// <p> To list jobs in chronological order by the date and time that they were submitted, enter
    ///                 <code>true</code>. To list jobs in reverse chronological order, enter
    ///                 <code>false</code>. </p>
    public let ascending: Swift.String?
    /// <p> When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
    ///             subsequent <code>GET</code> requests to get each successive page of results. </p>
    public let pageToken: Swift.String?
    /// <p>To get information about all of the jobs associated with the current AWS account that
    ///             have a given status, specify the following status: <code>Submitted</code>,
    ///                 <code>Progressing</code>, <code>Complete</code>, <code>Canceled</code>, or
    ///                 <code>Error</code>.</p>
    public let status: Swift.String?

    public init (
        ascending: Swift.String? = nil,
        pageToken: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.ascending = ascending
        self.pageToken = pageToken
        self.status = status
    }
}

struct ListJobsByStatusInputBody: Swift.Equatable {
}

extension ListJobsByStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListJobsByStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsByStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobsByStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsByStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListJobsByStatusOutputResponse(jobs: \(Swift.String(describing: jobs)), nextPageToken: \(Swift.String(describing: nextPageToken)))"}
}

extension ListJobsByStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListJobsByStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextPageToken = output.nextPageToken
        } else {
            self.jobs = nil
            self.nextPageToken = nil
        }
    }
}

/// <p>
///             The <code>ListJobsByStatusResponse</code> structure.
///         </p>
public struct ListJobsByStatusOutputResponse: Swift.Equatable {
    /// <p>An array of <code>Job</code> objects that have the specified status.</p>
    public let jobs: [ElasticTranscoderClientTypes.Job]?
    /// <p> A value that you use to access the second and subsequent pages of results, if any. When
    ///             the jobs in the specified pipeline fit on one page or when you've reached the last page
    ///             of results, the value of <code>NextPageToken</code> is <code>null</code>. </p>
    public let nextPageToken: Swift.String?

    public init (
        jobs: [ElasticTranscoderClientTypes.Job]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextPageToken = nextPageToken
    }
}

struct ListJobsByStatusOutputResponseBody: Swift.Equatable {
    public let jobs: [ElasticTranscoderClientTypes.Job]?
    public let nextPageToken: Swift.String?
}

extension ListJobsByStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs = "Jobs"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.Job?].self, forKey: .jobs)
        var jobsDecoded0:[ElasticTranscoderClientTypes.Job]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [ElasticTranscoderClientTypes.Job]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension ListPipelinesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPipelinesInput(ascending: \(Swift.String(describing: ascending)), pageToken: \(Swift.String(describing: pageToken)))"}
}

extension ListPipelinesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListPipelinesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPipelinesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPipelinesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPipelinesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPipelinesOutputError>
}

public struct ListPipelinesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPipelinesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPipelinesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageToken = input.operationInput.pageToken {
            let pageTokenQueryItem = ClientRuntime.URLQueryItem(name: "PageToken".urlPercentEncoding(), value: Swift.String(pageToken).urlPercentEncoding())
            input.builder.withQueryItem(pageTokenQueryItem)
        }
        if let ascending = input.operationInput.ascending {
            let ascendingQueryItem = ClientRuntime.URLQueryItem(name: "Ascending".urlPercentEncoding(), value: Swift.String(ascending).urlPercentEncoding())
            input.builder.withQueryItem(ascendingQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPipelinesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPipelinesOutputError>
}

/// <p>The <code>ListPipelineRequest</code> structure.</p>
public struct ListPipelinesInput: Swift.Equatable {
    /// <p>To list pipelines in chronological order by the date and time that they were created, enter
    ///             <code>true</code>. To list pipelines in reverse chronological order, enter
    ///             <code>false</code>.</p>
    public let ascending: Swift.String?
    /// <p>When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
    ///             subsequent <code>GET</code> requests to get each successive page of results. </p>
    public let pageToken: Swift.String?

    public init (
        ascending: Swift.String? = nil,
        pageToken: Swift.String? = nil
    )
    {
        self.ascending = ascending
        self.pageToken = pageToken
    }
}

struct ListPipelinesInputBody: Swift.Equatable {
}

extension ListPipelinesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPipelinesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPipelinesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPipelinesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPipelinesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPipelinesOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), pipelines: \(Swift.String(describing: pipelines)))"}
}

extension ListPipelinesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPipelinesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.pipelines = output.pipelines
        } else {
            self.nextPageToken = nil
            self.pipelines = nil
        }
    }
}

/// <p>A list of the pipelines associated with the current AWS account.</p>
public struct ListPipelinesOutputResponse: Swift.Equatable {
    /// <p>A value that you use to access the second and subsequent pages of results, if any. When
    ///             the pipelines fit on one page or when you've reached the last page
    ///             of results, the value of <code>NextPageToken</code> is <code>null</code>.</p>
    public let nextPageToken: Swift.String?
    /// <p>An array of <code>Pipeline</code> objects.</p>
    public let pipelines: [ElasticTranscoderClientTypes.Pipeline]?

    public init (
        nextPageToken: Swift.String? = nil,
        pipelines: [ElasticTranscoderClientTypes.Pipeline]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.pipelines = pipelines
    }
}

struct ListPipelinesOutputResponseBody: Swift.Equatable {
    public let pipelines: [ElasticTranscoderClientTypes.Pipeline]?
    public let nextPageToken: Swift.String?
}

extension ListPipelinesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case pipelines = "Pipelines"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelinesContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.Pipeline?].self, forKey: .pipelines)
        var pipelinesDecoded0:[ElasticTranscoderClientTypes.Pipeline]? = nil
        if let pipelinesContainer = pipelinesContainer {
            pipelinesDecoded0 = [ElasticTranscoderClientTypes.Pipeline]()
            for structure0 in pipelinesContainer {
                if let structure0 = structure0 {
                    pipelinesDecoded0?.append(structure0)
                }
            }
        }
        pipelines = pipelinesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension ListPresetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPresetsInput(ascending: \(Swift.String(describing: ascending)), pageToken: \(Swift.String(describing: pageToken)))"}
}

extension ListPresetsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListPresetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPresetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPresetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPresetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPresetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPresetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPresetsOutputError>
}

public struct ListPresetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPresetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPresetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPresetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageToken = input.operationInput.pageToken {
            let pageTokenQueryItem = ClientRuntime.URLQueryItem(name: "PageToken".urlPercentEncoding(), value: Swift.String(pageToken).urlPercentEncoding())
            input.builder.withQueryItem(pageTokenQueryItem)
        }
        if let ascending = input.operationInput.ascending {
            let ascendingQueryItem = ClientRuntime.URLQueryItem(name: "Ascending".urlPercentEncoding(), value: Swift.String(ascending).urlPercentEncoding())
            input.builder.withQueryItem(ascendingQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPresetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPresetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPresetsOutputError>
}

/// <p>The <code>ListPresetsRequest</code> structure.</p>
public struct ListPresetsInput: Swift.Equatable {
    /// <p>To list presets in chronological order by the date and time that they were created, enter
    ///             <code>true</code>. To list presets in reverse chronological order, enter
    ///             <code>false</code>.</p>
    public let ascending: Swift.String?
    /// <p>When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
    ///             subsequent <code>GET</code> requests to get each successive page of results. </p>
    public let pageToken: Swift.String?

    public init (
        ascending: Swift.String? = nil,
        pageToken: Swift.String? = nil
    )
    {
        self.ascending = ascending
        self.pageToken = pageToken
    }
}

struct ListPresetsInputBody: Swift.Equatable {
}

extension ListPresetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPresetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPresetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPresetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPresetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPresetsOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), presets: \(Swift.String(describing: presets)))"}
}

extension ListPresetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPresetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.presets = output.presets
        } else {
            self.nextPageToken = nil
            self.presets = nil
        }
    }
}

/// <p>The <code>ListPresetsResponse</code> structure.</p>
public struct ListPresetsOutputResponse: Swift.Equatable {
    /// <p>A value that you use to access the second and subsequent pages of results, if any. When
    ///             the presets fit on one page or when you've reached the last page
    ///             of results, the value of <code>NextPageToken</code> is <code>null</code>.</p>
    public let nextPageToken: Swift.String?
    /// <p>An array of <code>Preset</code> objects.</p>
    public let presets: [ElasticTranscoderClientTypes.Preset]?

    public init (
        nextPageToken: Swift.String? = nil,
        presets: [ElasticTranscoderClientTypes.Preset]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.presets = presets
    }
}

struct ListPresetsOutputResponseBody: Swift.Equatable {
    public let presets: [ElasticTranscoderClientTypes.Preset]?
    public let nextPageToken: Swift.String?
}

extension ListPresetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case presets = "Presets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let presetsContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.Preset?].self, forKey: .presets)
        var presetsDecoded0:[ElasticTranscoderClientTypes.Preset]? = nil
        if let presetsContainer = presetsContainer {
            presetsDecoded0 = [ElasticTranscoderClientTypes.Preset]()
            for structure0 in presetsContainer {
                if let structure0 = structure0 {
                    presetsDecoded0?.append(structure0)
                }
            }
        }
        presets = presetsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension ElasticTranscoderClientTypes.Notifications: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completed = "Completed"
        case error = "Error"
        case progressing = "Progressing"
        case warning = "Warning"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completed = completed {
            try encodeContainer.encode(completed, forKey: .completed)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let progressing = progressing {
            try encodeContainer.encode(progressing, forKey: .progressing)
        }
        if let warning = warning {
            try encodeContainer.encode(warning, forKey: .warning)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressing)
        progressing = progressingDecoded
        let completedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .completed)
        completed = completedDecoded
        let warningDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warning)
        warning = warningDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
    }
}

extension ElasticTranscoderClientTypes.Notifications: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Notifications(completed: \(Swift.String(describing: completed)), error: \(Swift.String(describing: error)), progressing: \(Swift.String(describing: progressing)), warning: \(Swift.String(describing: warning)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>The Amazon Simple Notification Service (Amazon SNS) topic or topics to notify in order to report job status.</p>
    ///         <important>
    ///             <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
    ///          </important>
    public struct Notifications: Swift.Equatable {
        /// <p>The Amazon SNS topic that you want to notify when Elastic Transcoder has finished processing the job.</p>
        public let completed: Swift.String?
        /// <p>The Amazon SNS topic that you want to notify when Elastic Transcoder encounters an error condition.</p>
        public let error: Swift.String?
        /// <p>The Amazon Simple Notification Service (Amazon SNS) topic that you want to notify when Elastic Transcoder has started to process the job.</p>
        public let progressing: Swift.String?
        /// <p>The Amazon SNS topic that you want to notify when Elastic Transcoder encounters a warning condition.</p>
        public let warning: Swift.String?

        public init (
            completed: Swift.String? = nil,
            error: Swift.String? = nil,
            progressing: Swift.String? = nil,
            warning: Swift.String? = nil
        )
        {
            self.completed = completed
            self.error = error
            self.progressing = progressing
            self.warning = warning
        }
    }

}

extension ElasticTranscoderClientTypes.Permission: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case access = "Access"
        case grantee = "Grantee"
        case granteeType = "GranteeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let access = access {
            var accessContainer = encodeContainer.nestedUnkeyedContainer(forKey: .access)
            for accesscontrols0 in access {
                try accessContainer.encode(accesscontrols0)
            }
        }
        if let grantee = grantee {
            try encodeContainer.encode(grantee, forKey: .grantee)
        }
        if let granteeType = granteeType {
            try encodeContainer.encode(granteeType, forKey: .granteeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let granteeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .granteeType)
        granteeType = granteeTypeDecoded
        let granteeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .grantee)
        grantee = granteeDecoded
        let accessContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .access)
        var accessDecoded0:[Swift.String]? = nil
        if let accessContainer = accessContainer {
            accessDecoded0 = [Swift.String]()
            for string0 in accessContainer {
                if let string0 = string0 {
                    accessDecoded0?.append(string0)
                }
            }
        }
        access = accessDecoded0
    }
}

extension ElasticTranscoderClientTypes.Permission: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Permission(access: \(Swift.String(describing: access)), grantee: \(Swift.String(describing: grantee)), granteeType: \(Swift.String(describing: granteeType)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>The <code>Permission</code> structure.</p>
    public struct Permission: Swift.Equatable {
        /// <p> The permission that you want to give to the AWS user that is listed in Grantee. Valid
        ///             values include: </p>
        /// 			      <ul>
        ///             <li>
        ///                <p>
        ///                   <code>READ</code>: The grantee can read the thumbnails and metadata for
        ///                     thumbnails that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>READ_ACP</code>: The grantee can read the object ACL for thumbnails that
        ///                     Elastic Transcoder adds to the Amazon S3 bucket.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>WRITE_ACP</code>: The grantee can write the ACL for the thumbnails that
        ///                     Elastic Transcoder adds to the Amazon S3 bucket.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>FULL_CONTROL</code>: The grantee has READ, READ_ACP, and WRITE_ACP
        ///                     permissions for the thumbnails that Elastic Transcoder adds to the Amazon S3
        ///                     bucket.</p>
        ///             </li>
        ///          </ul>
        public let access: [Swift.String]?
        /// <p>The AWS user or group that you want to have access to transcoded files and playlists. To
        ///             identify the user or group, you can specify the canonical user ID for an AWS account, an origin
        ///             access identity for a CloudFront distribution, the registered email address of an AWS account,
        ///             or a predefined Amazon S3 group.</p>
        public let grantee: Swift.String?
        /// <p>The type of value that appears in the Grantee object:</p>
        /// 		       <ul>
        ///             <li>
        ///                <p>
        ///                   <code>Canonical</code>: Either the canonical user ID for an AWS account or an
        ///                     origin access identity for an Amazon CloudFront distribution.</p>
        /// 					          <important>
        ///                   <p>A
        ///                         canonical user ID is not the same as an AWS account number.</p>
        ///                </important>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Email</code>: The registered email address of an AWS account.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Group</code>: One of the following predefined Amazon S3 groups:
        ///                         <code>AllUsers</code>, <code>AuthenticatedUsers</code>, or
        ///                         <code>LogDelivery</code>.</p>
        ///             </li>
        ///          </ul>
        public let granteeType: Swift.String?

        public init (
            access: [Swift.String]? = nil,
            grantee: Swift.String? = nil,
            granteeType: Swift.String? = nil
        )
        {
            self.access = access
            self.grantee = grantee
            self.granteeType = granteeType
        }
    }

}

extension ElasticTranscoderClientTypes.Pipeline: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case awsKmsKeyArn = "AwsKmsKeyArn"
        case contentConfig = "ContentConfig"
        case id = "Id"
        case inputBucket = "InputBucket"
        case name = "Name"
        case notifications = "Notifications"
        case outputBucket = "OutputBucket"
        case role = "Role"
        case status = "Status"
        case thumbnailConfig = "ThumbnailConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let awsKmsKeyArn = awsKmsKeyArn {
            try encodeContainer.encode(awsKmsKeyArn, forKey: .awsKmsKeyArn)
        }
        if let contentConfig = contentConfig {
            try encodeContainer.encode(contentConfig, forKey: .contentConfig)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let inputBucket = inputBucket {
            try encodeContainer.encode(inputBucket, forKey: .inputBucket)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notifications = notifications {
            try encodeContainer.encode(notifications, forKey: .notifications)
        }
        if let outputBucket = outputBucket {
            try encodeContainer.encode(outputBucket, forKey: .outputBucket)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let thumbnailConfig = thumbnailConfig {
            try encodeContainer.encode(thumbnailConfig, forKey: .thumbnailConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let inputBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputBucket)
        inputBucket = inputBucketDecoded
        let outputBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputBucket)
        outputBucket = outputBucketDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let awsKmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsKmsKeyArn)
        awsKmsKeyArn = awsKmsKeyArnDecoded
        let notificationsDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Notifications.self, forKey: .notifications)
        notifications = notificationsDecoded
        let contentConfigDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.PipelineOutputConfig.self, forKey: .contentConfig)
        contentConfig = contentConfigDecoded
        let thumbnailConfigDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.PipelineOutputConfig.self, forKey: .thumbnailConfig)
        thumbnailConfig = thumbnailConfigDecoded
    }
}

extension ElasticTranscoderClientTypes.Pipeline: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Pipeline(arn: \(Swift.String(describing: arn)), awsKmsKeyArn: \(Swift.String(describing: awsKmsKeyArn)), contentConfig: \(Swift.String(describing: contentConfig)), id: \(Swift.String(describing: id)), inputBucket: \(Swift.String(describing: inputBucket)), name: \(Swift.String(describing: name)), notifications: \(Swift.String(describing: notifications)), outputBucket: \(Swift.String(describing: outputBucket)), role: \(Swift.String(describing: role)), status: \(Swift.String(describing: status)), thumbnailConfig: \(Swift.String(describing: thumbnailConfig)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>The pipeline (queue) that is used to manage jobs.</p>
    public struct Pipeline: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) for the pipeline.</p>
        public let arn: Swift.String?
        /// <p>The AWS Key Management Service (AWS KMS) key that you want to use with this pipeline.</p>
        ///         <p>If you use either <code>s3</code> or <code>s3-aws-kms</code> as your
        ///             <code>Encryption:Mode</code>, you don't need to provide a key with
        ///             your job because a default key, known as an AWS-KMS key, is created for you automatically.
        ///             You need to provide an AWS-KMS key only if you want to use a non-default AWS-KMS key, or if you are
        ///             using an <code>Encryption:Mode</code> of <code>aes-cbc-pkcs7</code>, <code>aes-ctr</code>,
        ///             or <code>aes-gcm</code>.</p>
        public let awsKmsKeyArn: Swift.String?
        /// <p>Information about the Amazon S3 bucket in which you want Elastic Transcoder to save
        ///             transcoded files and playlists. Either you specify both <code>ContentConfig</code> and
        ///                 <code>ThumbnailConfig</code>, or you specify <code>OutputBucket</code>.</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
        ///                 transcoded files and playlists.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Permissions</b>: A list of the users and/or predefined Amazon S3 groups you want
        ///                 to have access to transcoded files and playlists, and the type of access that you
        ///                 want them to have. </p>
        /// 				           <ul>
        ///                   <li>
        ///                      <p>GranteeType: The type of value that appears in the <code>Grantee</code>
        ///                         object: </p>
        ///                      <ul>
        ///                         <li>
        ///                            <p>
        ///                               <code>Canonical</code>: Either the canonical user ID for an AWS
        ///                                 account or an origin access identity for an Amazon CloudFront
        ///                                 distribution.</p>
        ///                         </li>
        ///                         <li>
        ///                            <p>
        ///                               <code>Email</code>: The registered email address of an AWS
        ///                                 account.</p>
        ///                         </li>
        ///                         <li>
        ///                            <p>
        ///                               <code>Group</code>: One of the following predefined Amazon S3
        ///                                 groups: <code>AllUsers</code>, <code>AuthenticatedUsers</code>, or
        ///                                     <code>LogDelivery</code>.</p>
        ///                         </li>
        ///                      </ul>
        ///                     </li>
        ///                   <li>
        ///                      <p>
        ///                         <code>Grantee</code>: The AWS user or group that you want to have access to
        ///                         transcoded files and playlists.</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>
        ///                         <code>Access</code>: The permission that you want to give to the AWS user
        ///                         that is listed in <code>Grantee</code>. Valid values include:</p>
        /// 						               <ul>
        ///                         <li>
        ///                            <p>
        ///                               <code>READ</code>: The grantee can read the objects and metadata for
        ///                                 objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        ///                         </li>
        ///                         <li>
        ///                            <p>
        ///                               <code>READ_ACP</code>: The grantee can read the object ACL for
        ///                                 objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        ///                         </li>
        ///                         <li>
        ///                            <p>
        ///                               <code>WRITE_ACP</code>: The grantee can write the ACL for the
        ///                                 objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
        ///                         </li>
        ///                         <li>
        ///                            <p>
        ///                               <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
        ///                                     <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions
        ///                                 for the objects that Elastic Transcoder adds to the Amazon S3
        ///                                 bucket.</p>
        ///                         </li>
        ///                      </ul>
        ///                     </li>
        ///                </ul>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>StorageClass</b>: The Amazon S3 storage class, Standard or ReducedRedundancy,
        ///                 that you want Elastic Transcoder to assign to the video files and playlists that it
        ///                 stores in your Amazon S3 bucket. </p>
        ///             </li>
        ///          </ul>
        public let contentConfig: ElasticTranscoderClientTypes.PipelineOutputConfig?
        /// <p>The identifier for the pipeline. You use this value to identify the pipeline in
        ///             which you want to perform a variety of operations, such as creating a job or a preset.</p>
        public let id: Swift.String?
        /// <p>The Amazon S3 bucket from which Elastic Transcoder gets media files for transcoding and the graphics
        ///             files, if any, that you want to use for watermarks.</p>
        public let inputBucket: Swift.String?
        /// <p>The name of the pipeline. We recommend that the name be unique within the AWS account,
        ///             but uniqueness is not enforced.</p>
        ///         <p>Constraints: Maximum 40 characters</p>
        public let name: Swift.String?
        /// <p>The Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status.</p>
        ///         <important>
        ///             <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
        ///          </important>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <b>Progressing</b> (optional): The Amazon Simple Notification Service (Amazon SNS) topic that you want to notify
        ///                 when Elastic Transcoder has started to process the job.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Complete</b> (optional): The Amazon SNS topic that you want to notify when Elastic Transcoder has
        ///                 finished processing the job.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Warning</b> (optional): The Amazon SNS topic that you want to notify when Elastic Transcoder
        ///                 encounters a warning condition.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Error</b> (optional): The Amazon SNS topic that you want to notify when Elastic Transcoder
        ///                 encounters an error condition.</p>
        ///             </li>
        ///          </ul>
        public let notifications: ElasticTranscoderClientTypes.Notifications?
        /// <p>The Amazon S3 bucket in which you want Elastic Transcoder to save transcoded files,
        ///             thumbnails, and playlists. Either you specify this value, or you specify both
        ///                 <code>ContentConfig</code> and <code>ThumbnailConfig</code>.</p>
        public let outputBucket: Swift.String?
        /// <p>The IAM Amazon Resource Name (ARN) for the role that Elastic Transcoder uses to transcode jobs for this pipeline.</p>
        public let role: Swift.String?
        /// <p>The current status of the pipeline:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>Active</code>: The pipeline is processing jobs.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Paused</code>: The pipeline is not currently processing jobs.</p>
        ///             </li>
        ///          </ul>
        public let status: Swift.String?
        /// <p>Information about the Amazon S3 bucket in which you want Elastic Transcoder to save
        ///             thumbnail files. Either you specify both <code>ContentConfig</code> and
        ///                 <code>ThumbnailConfig</code>, or you specify <code>OutputBucket</code>.</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>Bucket</code>: The Amazon S3 bucket in which you want Elastic Transcoder to
        ///                 save thumbnail files. </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Permissions</code>: A list of the users and/or predefined Amazon S3 groups you
        ///                 want to have access to thumbnail files, and the type of access that you want them to
        ///                 have. </p>
        /// 				           <ul>
        ///                   <li>
        ///                      <p>GranteeType: The type of value that appears in the Grantee object:</p>
        /// 					                <ul>
        ///                         <li>
        ///                            <p>
        ///                               <code>Canonical</code>: Either the canonical user ID for an AWS
        ///                                 account or an origin access identity for an Amazon CloudFront
        ///                                 distribution.</p>
        ///                            <important>
        ///                               <p>A canonical user ID is not the same as an
        ///                                     AWS account number.</p>
        ///                            </important>
        ///                         </li>
        ///                         <li>
        ///                            <p>
        ///                               <code>Email</code>: The registered email address of an AWS
        ///                                 account.</p>
        ///                         </li>
        ///                         <li>
        ///                            <p>
        ///                               <code>Group</code>: One of the following predefined Amazon S3
        ///                                 groups: <code>AllUsers</code>, <code>AuthenticatedUsers</code>, or
        ///                                     <code>LogDelivery</code>.</p>
        ///                         </li>
        ///                      </ul>
        ///                     </li>
        ///                   <li>
        ///                      <p>
        ///                         <code>Grantee</code>: The AWS user or group that you want to have access to
        ///                         thumbnail files.</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>Access: The permission that you want to give to the AWS user that is listed
        ///                         in Grantee. Valid values include: </p>
        /// 						               <ul>
        ///                         <li>
        ///                            <p>
        ///                               <code>READ</code>: The grantee can read the thumbnails and metadata
        ///                                 for thumbnails that Elastic Transcoder adds to the Amazon S3
        ///                                 bucket.</p>
        ///                         </li>
        ///                         <li>
        ///                            <p>
        ///                               <code>READ_ACP</code>: The grantee can read the object ACL for
        ///                                 thumbnails that Elastic Transcoder adds to the Amazon S3
        ///                                 bucket.</p>
        ///                         </li>
        ///                         <li>
        ///                            <p>
        ///                               <code>WRITE_ACP</code>: The grantee can write the ACL for the
        ///                                 thumbnails that Elastic Transcoder adds to the Amazon S3
        ///                                 bucket.</p>
        ///                         </li>
        ///                         <li>
        ///                            <p>
        ///                               <code>FULL_CONTROL</code>: The grantee has READ, READ_ACP, and
        ///                                 WRITE_ACP permissions for the thumbnails that Elastic Transcoder
        ///                                 adds to the Amazon S3 bucket.</p>
        ///                         </li>
        ///                      </ul>
        ///                     </li>
        ///                </ul>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>StorageClass</code>: The Amazon S3 storage class, <code>Standard</code> or
        ///                     <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
        ///                 the thumbnails that it stores in your Amazon S3 bucket.</p>
        ///             </li>
        ///          </ul>
        public let thumbnailConfig: ElasticTranscoderClientTypes.PipelineOutputConfig?

        public init (
            arn: Swift.String? = nil,
            awsKmsKeyArn: Swift.String? = nil,
            contentConfig: ElasticTranscoderClientTypes.PipelineOutputConfig? = nil,
            id: Swift.String? = nil,
            inputBucket: Swift.String? = nil,
            name: Swift.String? = nil,
            notifications: ElasticTranscoderClientTypes.Notifications? = nil,
            outputBucket: Swift.String? = nil,
            role: Swift.String? = nil,
            status: Swift.String? = nil,
            thumbnailConfig: ElasticTranscoderClientTypes.PipelineOutputConfig? = nil
        )
        {
            self.arn = arn
            self.awsKmsKeyArn = awsKmsKeyArn
            self.contentConfig = contentConfig
            self.id = id
            self.inputBucket = inputBucket
            self.name = name
            self.notifications = notifications
            self.outputBucket = outputBucket
            self.role = role
            self.status = status
            self.thumbnailConfig = thumbnailConfig
        }
    }

}

extension ElasticTranscoderClientTypes.PipelineOutputConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case permissions = "Permissions"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permissions0 in permissions {
                try permissionsContainer.encode(permissions0)
            }
        }
        if let storageClass = storageClass {
            try encodeContainer.encode(storageClass, forKey: .storageClass)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[ElasticTranscoderClientTypes.Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [ElasticTranscoderClientTypes.Permission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
    }
}

extension ElasticTranscoderClientTypes.PipelineOutputConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PipelineOutputConfig(bucket: \(Swift.String(describing: bucket)), permissions: \(Swift.String(describing: permissions)), storageClass: \(Swift.String(describing: storageClass)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>The <code>PipelineOutputConfig</code> structure.</p>
    public struct PipelineOutputConfig: Swift.Equatable {
        /// <p> The Amazon S3 bucket in which you want Elastic Transcoder to save the transcoded files. Specify this
        ///             value when all of the following are true:</p>
        /// 			      <ul>
        ///             <li>
        ///                <p>You want to save transcoded files, thumbnails (if any), and playlists (if any)
        ///                     together in one bucket.</p>
        ///             </li>
        ///             <li>
        ///                <p>You do not want to specify the users or groups who have access to the transcoded
        ///                     files, thumbnails, and playlists.</p>
        ///             </li>
        ///             <li>
        ///                <p>You do not want to specify the permissions that Elastic Transcoder grants to the files.</p>
        ///             </li>
        ///             <li>
        ///                <p>You want to associate the transcoded files and thumbnails with the Amazon S3
        ///                     Standard storage class.</p>
        ///             </li>
        ///          </ul>
        /// 			      <p>If you want to save transcoded files and playlists in one bucket and thumbnails in
        ///             another bucket, specify which users can access the transcoded files or the permissions
        ///             the users have, or change the Amazon S3 storage class, omit OutputBucket and specify
        ///             values for <code>ContentConfig</code> and <code>ThumbnailConfig</code> instead. </p>
        public let bucket: Swift.String?
        /// <p>Optional. The <code>Permissions</code> object specifies which users and/or predefined
        ///             Amazon S3 groups you want to have access to transcoded files and playlists, and the type
        ///             of access you want them to have. You can grant permissions to a maximum of 30 users
        ///             and/or predefined Amazon S3 groups.</p>
        ///         <p>If you include <code>Permissions</code>, Elastic Transcoder grants only the permissions that you
        ///             specify. It does not grant full permissions to the owner of the role specified by
        ///                 <code>Role</code>. If you want that user to have full control, you must explicitly
        ///             grant full control to the user.</p>
        ///         <p> If you omit <code>Permissions</code>, Elastic Transcoder grants full control over the transcoded files
        ///             and playlists to the owner of the role specified by <code>Role</code>, and grants no
        ///             other permissions to any other user or group.</p>
        public let permissions: [ElasticTranscoderClientTypes.Permission]?
        /// <p> The Amazon S3 storage class, <code>Standard</code> or <code>ReducedRedundancy</code>,
        ///             that you want Elastic Transcoder to assign to the video files and playlists that it stores in your
        ///             Amazon S3 bucket. </p>
        public let storageClass: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            permissions: [ElasticTranscoderClientTypes.Permission]? = nil,
            storageClass: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.permissions = permissions
            self.storageClass = storageClass
        }
    }

}

extension ElasticTranscoderClientTypes.PlayReadyDrm: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "Format"
        case initializationVector = "InitializationVector"
        case key = "Key"
        case keyId = "KeyId"
        case keyMd5 = "KeyMd5"
        case licenseAcquisitionUrl = "LicenseAcquisitionUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let initializationVector = initializationVector {
            try encodeContainer.encode(initializationVector, forKey: .initializationVector)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let keyMd5 = keyMd5 {
            try encodeContainer.encode(keyMd5, forKey: .keyMd5)
        }
        if let licenseAcquisitionUrl = licenseAcquisitionUrl {
            try encodeContainer.encode(licenseAcquisitionUrl, forKey: .licenseAcquisitionUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let keyMd5Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyMd5)
        keyMd5 = keyMd5Decoded
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let initializationVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initializationVector)
        initializationVector = initializationVectorDecoded
        let licenseAcquisitionUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseAcquisitionUrl)
        licenseAcquisitionUrl = licenseAcquisitionUrlDecoded
    }
}

extension ElasticTranscoderClientTypes.PlayReadyDrm: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PlayReadyDrm(format: \(Swift.String(describing: format)), initializationVector: \(Swift.String(describing: initializationVector)), key: \(Swift.String(describing: key)), keyId: \(Swift.String(describing: keyId)), keyMd5: \(Swift.String(describing: keyMd5)), licenseAcquisitionUrl: \(Swift.String(describing: licenseAcquisitionUrl)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>The PlayReady DRM settings, if any, that you want Elastic Transcoder to apply to the output files associated with this playlist.</p>
    ///          <p>PlayReady DRM encrypts your media files
    /// using <code>aes-ctr</code> encryption.</p>
    ///          <p>If you use DRM for an <code>HLSv3</code> playlist, your outputs must have a master playlist.</p>
    public struct PlayReadyDrm: Swift.Equatable {
        /// <p>The type of DRM, if any, that you want Elastic Transcoder to apply to the output files associated with this playlist.</p>
        public let format: Swift.String?
        /// <p>The series of random bits created by a random bit generator, unique for every encryption operation,
        ///     that you want Elastic Transcoder to use to encrypt your files. The initialization vector must be base64-encoded, and it
        ///     must be exactly 8 bytes long before being base64-encoded. If no initialization vector is provided, Elastic Transcoder
        ///     generates one for you.</p>
        public let initializationVector: Swift.String?
        /// <p>The DRM key for your file, provided by your DRM license provider. The key must be base64-encoded,
        ///     and it must be one of the following bit lengths before being base64-encoded:</p>
        ///          <p>
        ///             <code>128</code>, <code>192</code>, or <code>256</code>. </p>
        ///          <p>The key must also be encrypted by using AWS KMS.</p>
        public let key: Swift.String?
        /// <p>The ID for your DRM key, so that your DRM license provider knows which key to provide.</p>
        ///          <p>The key ID must be provided in big endian, and Elastic Transcoder converts it to little endian before inserting
        ///     it into the PlayReady DRM headers. If you are unsure whether your license server provides your key ID in
        ///     big or little endian, check with your DRM provider.</p>
        public let keyId: Swift.String?
        /// <p>The MD5 digest of the key used for DRM on your file, and that you want Elastic Transcoder to use as a checksum
        ///     to make sure your key was not corrupted in transit. The key MD5 must be base64-encoded, and it must be
        ///     exactly 16 bytes before being base64-encoded.</p>
        public let keyMd5: Swift.String?
        /// <p>The location of the license key required to play DRM content. The URL must be an absolute path,
        /// and is referenced by the PlayReady header. The PlayReady header is referenced in the protection
        /// header of the client manifest for Smooth Streaming outputs, and in the EXT-X-DXDRM and EXT-XDXDRMINFO
        /// metadata tags for HLS playlist outputs. An example URL looks like this:
        /// <code>https://www.example.com/exampleKey/</code>
        ///          </p>
        public let licenseAcquisitionUrl: Swift.String?

        public init (
            format: Swift.String? = nil,
            initializationVector: Swift.String? = nil,
            key: Swift.String? = nil,
            keyId: Swift.String? = nil,
            keyMd5: Swift.String? = nil,
            licenseAcquisitionUrl: Swift.String? = nil
        )
        {
            self.format = format
            self.initializationVector = initializationVector
            self.key = key
            self.keyId = keyId
            self.keyMd5 = keyMd5
            self.licenseAcquisitionUrl = licenseAcquisitionUrl
        }
    }

}

extension ElasticTranscoderClientTypes.Playlist: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "Format"
        case hlsContentProtection = "HlsContentProtection"
        case name = "Name"
        case outputKeys = "OutputKeys"
        case playReadyDrm = "PlayReadyDrm"
        case status = "Status"
        case statusDetail = "StatusDetail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let hlsContentProtection = hlsContentProtection {
            try encodeContainer.encode(hlsContentProtection, forKey: .hlsContentProtection)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputKeys = outputKeys {
            var outputKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputKeys)
            for outputkeys0 in outputKeys {
                try outputKeysContainer.encode(outputkeys0)
            }
        }
        if let playReadyDrm = playReadyDrm {
            try encodeContainer.encode(playReadyDrm, forKey: .playReadyDrm)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusDetail = statusDetail {
            try encodeContainer.encode(statusDetail, forKey: .statusDetail)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let outputKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .outputKeys)
        var outputKeysDecoded0:[Swift.String]? = nil
        if let outputKeysContainer = outputKeysContainer {
            outputKeysDecoded0 = [Swift.String]()
            for string0 in outputKeysContainer {
                if let string0 = string0 {
                    outputKeysDecoded0?.append(string0)
                }
            }
        }
        outputKeys = outputKeysDecoded0
        let hlsContentProtectionDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.HlsContentProtection.self, forKey: .hlsContentProtection)
        hlsContentProtection = hlsContentProtectionDecoded
        let playReadyDrmDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.PlayReadyDrm.self, forKey: .playReadyDrm)
        playReadyDrm = playReadyDrmDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let statusDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetail)
        statusDetail = statusDetailDecoded
    }
}

extension ElasticTranscoderClientTypes.Playlist: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Playlist(format: \(Swift.String(describing: format)), hlsContentProtection: \(Swift.String(describing: hlsContentProtection)), name: \(Swift.String(describing: name)), outputKeys: \(Swift.String(describing: outputKeys)), playReadyDrm: \(Swift.String(describing: playReadyDrm)), status: \(Swift.String(describing: status)), statusDetail: \(Swift.String(describing: statusDetail)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p> Use Only for Fragmented MP4 or MPEG-TS Outputs. If you specify a preset for which the value of Container
    ///             is <code>fmp4</code> (Fragmented MP4) or <code>ts</code> (MPEG-TS), Playlists
    ///             contains information about the master playlists
    ///             that you want Elastic Transcoder to create. We recommend that you create only one master
    ///             playlist per output format. The maximum number of master playlists in a job is 30. </p>
    public struct Playlist: Swift.Equatable {
        /// <p>The format of the output playlist. Valid formats include <code>HLSv3</code>, <code>HLSv4</code>,
        /// and <code>Smooth</code>.</p>
        public let format: Swift.String?
        /// <p>The HLS content protection settings, if any, that you want Elastic Transcoder to apply to the output files associated with this playlist.</p>
        public let hlsContentProtection: ElasticTranscoderClientTypes.HlsContentProtection?
        /// <p>The name that you want Elastic Transcoder to assign to the master playlist, for example,
        ///             nyc-vacation.m3u8. If the name includes a <code>/</code> character, the
        ///             section of the name before the last <code>/</code> must be identical for all
        ///             <code>Name</code> objects. If you create more than one
        ///             master playlist, the values of all <code>Name</code> objects must be
        ///             unique.</p>
        ///         <note>
        ///             <p>Elastic Transcoder automatically appends the relevant file extension to the file name (<code>.m3u8</code>
        ///     for <code>HLSv3</code> and <code>HLSv4</code> playlists, and
        ///     <code>.ism</code> and <code>.ismc</code> for <code>Smooth</code> playlists).
        ///     If you include a file extension in <code>Name</code>, the file name will have
        ///     two extensions.</p>
        ///          </note>
        public let name: Swift.String?
        /// <p>For each output in this job that you want to include in a master playlist, the value of the Outputs:Key object.</p>
        ///          <ul>
        ///             <li>
        ///                <p>If your output is not <code>HLS</code> or does not have a segment duration set,
        ///             the name of the output file is a concatenation of <code>OutputKeyPrefix</code>
        ///             and <code>Outputs:Key</code>:</p>
        ///                <p>OutputKeyPrefix<code>Outputs:Key</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>If your output is <code>HLSv3</code> and has a segment duration set, or is not included in a
        ///             playlist, Elastic Transcoder creates an output playlist file with a file extension of <code>.m3u8</code>, and a
        ///             series of <code>.ts</code> files that include a five-digit
        ///             sequential counter beginning with 00000:</p>
        ///                <p>OutputKeyPrefix<code>Outputs:Key</code>.m3u8</p>
        ///                <p>OutputKeyPrefix<code>Outputs:Key</code>00000.ts</p>
        ///             </li>
        ///             <li>
        ///                <p>If your output is <code>HLSv4</code>, has a segment duration set, and is included in an
        ///             <code>HLSv4</code> playlist, Elastic Transcoder creates an output playlist file with a file extension
        ///             of <code>_v4.m3u8</code>. If the output is video, Elastic Transcoder also creates an output file with
        ///             an extension of <code>_iframe.m3u8</code>:</p>
        ///                <p>OutputKeyPrefix<code>Outputs:Key</code>_v4.m3u8</p>
        ///                <p>OutputKeyPrefix<code>Outputs:Key</code>_iframe.m3u8</p>
        ///                <p>OutputKeyPrefix<code>Outputs:Key</code>.ts</p>
        ///             </li>
        ///          </ul>
        ///
        ///          <p>Elastic Transcoder automatically appends the relevant file extension to the file name. If you include a file
        ///     extension in Output Key, the file name will have two extensions.</p>
        ///          <p>If you include more than one output in a playlist,
        ///     any segment duration settings, clip settings, or caption settings must be the
        ///     same for all outputs in the playlist. For <code>Smooth</code> playlists, the <code>Audio:Profile</code>,
        ///     <code>Video:Profile</code>, and <code>Video:FrameRate</code> to
        ///     <code>Video:KeyframesMaxDist</code> ratio must be the same for all outputs.</p>
        public let outputKeys: [Swift.String]?
        /// <p>The DRM settings, if any, that you want Elastic Transcoder to apply to the output files associated with this playlist.</p>
        public let playReadyDrm: ElasticTranscoderClientTypes.PlayReadyDrm?
        /// <p>The status of the job with which the playlist is associated.</p>
        public let status: Swift.String?
        /// <p>Information that further explains the status.</p>
        public let statusDetail: Swift.String?

        public init (
            format: Swift.String? = nil,
            hlsContentProtection: ElasticTranscoderClientTypes.HlsContentProtection? = nil,
            name: Swift.String? = nil,
            outputKeys: [Swift.String]? = nil,
            playReadyDrm: ElasticTranscoderClientTypes.PlayReadyDrm? = nil,
            status: Swift.String? = nil,
            statusDetail: Swift.String? = nil
        )
        {
            self.format = format
            self.hlsContentProtection = hlsContentProtection
            self.name = name
            self.outputKeys = outputKeys
            self.playReadyDrm = playReadyDrm
            self.status = status
            self.statusDetail = statusDetail
        }
    }

}

extension ElasticTranscoderClientTypes.Preset: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case audio = "Audio"
        case container = "Container"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case thumbnails = "Thumbnails"
        case type = "Type"
        case video = "Video"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let audio = audio {
            try encodeContainer.encode(audio, forKey: .audio)
        }
        if let container = container {
            try encodeContainer.encode(container, forKey: .container)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let thumbnails = thumbnails {
            try encodeContainer.encode(thumbnails, forKey: .thumbnails)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let video = video {
            try encodeContainer.encode(video, forKey: .video)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let containerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .container)
        container = containerDecoded
        let audioDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.AudioParameters.self, forKey: .audio)
        audio = audioDecoded
        let videoDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.VideoParameters.self, forKey: .video)
        video = videoDecoded
        let thumbnailsDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Thumbnails.self, forKey: .thumbnails)
        thumbnails = thumbnailsDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension ElasticTranscoderClientTypes.Preset: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Preset(arn: \(Swift.String(describing: arn)), audio: \(Swift.String(describing: audio)), container: \(Swift.String(describing: container)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), thumbnails: \(Swift.String(describing: thumbnails)), type: \(Swift.String(describing: type)), video: \(Swift.String(describing: video)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>Presets are templates that contain most of the settings for transcoding media files
    ///             from one format to another. Elastic Transcoder includes some default presets for common formats, for
    ///             example, several iPod and iPhone versions. You can also create your own presets for formats
    ///             that aren't included among the default presets. You specify which preset you want to use
    ///             when you create a job.</p>
    public struct Preset: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) for the preset.</p>
        public let arn: Swift.String?
        /// <p>A section of the response body that provides information about the audio preset values.</p>
        public let audio: ElasticTranscoderClientTypes.AudioParameters?
        /// <p>The container type for the output file. Valid values include <code>flac</code>,
        ///             <code>flv</code>, <code>fmp4</code>, <code>gif</code>, <code>mp3</code>,
        ///             <code>mp4</code>, <code>mpg</code>, <code>mxf</code>, <code>oga</code>,
        ///             <code>ogg</code>, <code>ts</code>, and <code>webm</code>.</p>
        public let container: Swift.String?
        /// <p>A description of the preset.</p>
        public let description: Swift.String?
        /// <p>Identifier for the new preset. You use this value to get settings for the preset or to delete it.</p>
        public let id: Swift.String?
        /// <p>The name of the preset.</p>
        public let name: Swift.String?
        /// <p>A section of the response body that provides information about the thumbnail preset values, if any.</p>
        public let thumbnails: ElasticTranscoderClientTypes.Thumbnails?
        /// <p>Whether the preset is a default preset provided by Elastic Transcoder
        ///                 (<code>System</code>) or a preset that you have defined (<code>Custom</code>).</p>
        public let type: Swift.String?
        /// <p>A section of the response body that provides information about the video preset values.</p>
        public let video: ElasticTranscoderClientTypes.VideoParameters?

        public init (
            arn: Swift.String? = nil,
            audio: ElasticTranscoderClientTypes.AudioParameters? = nil,
            container: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            thumbnails: ElasticTranscoderClientTypes.Thumbnails? = nil,
            type: Swift.String? = nil,
            video: ElasticTranscoderClientTypes.VideoParameters? = nil
        )
        {
            self.arn = arn
            self.audio = audio
            self.container = container
            self.description = description
            self.id = id
            self.name = name
            self.thumbnails = thumbnails
            self.type = type
            self.video = video
        }
    }

}

extension ElasticTranscoderClientTypes.PresetWatermark: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case horizontalAlign = "HorizontalAlign"
        case horizontalOffset = "HorizontalOffset"
        case id = "Id"
        case maxHeight = "MaxHeight"
        case maxWidth = "MaxWidth"
        case opacity = "Opacity"
        case sizingPolicy = "SizingPolicy"
        case target = "Target"
        case verticalAlign = "VerticalAlign"
        case verticalOffset = "VerticalOffset"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let horizontalAlign = horizontalAlign {
            try encodeContainer.encode(horizontalAlign, forKey: .horizontalAlign)
        }
        if let horizontalOffset = horizontalOffset {
            try encodeContainer.encode(horizontalOffset, forKey: .horizontalOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let maxHeight = maxHeight {
            try encodeContainer.encode(maxHeight, forKey: .maxHeight)
        }
        if let maxWidth = maxWidth {
            try encodeContainer.encode(maxWidth, forKey: .maxWidth)
        }
        if let opacity = opacity {
            try encodeContainer.encode(opacity, forKey: .opacity)
        }
        if let sizingPolicy = sizingPolicy {
            try encodeContainer.encode(sizingPolicy, forKey: .sizingPolicy)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let verticalAlign = verticalAlign {
            try encodeContainer.encode(verticalAlign, forKey: .verticalAlign)
        }
        if let verticalOffset = verticalOffset {
            try encodeContainer.encode(verticalOffset, forKey: .verticalOffset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let maxWidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxWidth)
        maxWidth = maxWidthDecoded
        let maxHeightDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxHeight)
        maxHeight = maxHeightDecoded
        let sizingPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sizingPolicy)
        sizingPolicy = sizingPolicyDecoded
        let horizontalAlignDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .horizontalAlign)
        horizontalAlign = horizontalAlignDecoded
        let horizontalOffsetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .horizontalOffset)
        horizontalOffset = horizontalOffsetDecoded
        let verticalAlignDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verticalAlign)
        verticalAlign = verticalAlignDecoded
        let verticalOffsetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verticalOffset)
        verticalOffset = verticalOffsetDecoded
        let opacityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .opacity)
        opacity = opacityDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension ElasticTranscoderClientTypes.PresetWatermark: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PresetWatermark(horizontalAlign: \(Swift.String(describing: horizontalAlign)), horizontalOffset: \(Swift.String(describing: horizontalOffset)), id: \(Swift.String(describing: id)), maxHeight: \(Swift.String(describing: maxHeight)), maxWidth: \(Swift.String(describing: maxWidth)), opacity: \(Swift.String(describing: opacity)), sizingPolicy: \(Swift.String(describing: sizingPolicy)), target: \(Swift.String(describing: target)), verticalAlign: \(Swift.String(describing: verticalAlign)), verticalOffset: \(Swift.String(describing: verticalOffset)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>Settings for the size, location, and opacity of graphics that you want Elastic Transcoder to
    ///             overlay over videos that are transcoded using this preset. You can specify settings
    ///             for up to four watermarks. Watermarks appear in the specified size and location, and
    ///             with the specified opacity for the duration of the transcoded video.</p>
    ///         <p>Watermarks can be in .png or .jpg format. If you want to display a watermark that
    ///             is not rectangular, use the .png format, which supports transparency.</p>
    ///         <p>When you create a job that uses this preset, you specify the .png or .jpg graphics
    ///             that you want Elastic Transcoder to include in the transcoded videos. You can specify fewer graphics
    ///             in the job than you specify watermark settings in the preset, which allows you to use
    ///             the same preset for up to four watermarks that have different dimensions.</p>
    public struct PresetWatermark: Swift.Equatable {
        /// <p>The horizontal position of the watermark unless you specify a non-zero value for
        ///                 <code>HorizontalOffset</code>: </p>
        /// 			      <ul>
        ///             <li>
        ///                <p>
        ///                   <b>Left</b>: The left edge of the watermark is aligned with the left border of
        ///                     the video.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Right</b>: The right edge of the watermark is aligned with the right border
        ///                     of the video.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Center</b>: The watermark is centered between the left and right
        ///                     borders.</p>
        ///             </li>
        ///          </ul>
        public let horizontalAlign: Swift.String?
        /// <p>The amount by which you want the horizontal position of the watermark to be offset from
        ///             the position specified by HorizontalAlign: </p>
        /// 			      <ul>
        ///             <li>
        ///                <p>number of pixels (px): The minimum value is 0 pixels, and the maximum value is
        ///                     the value of MaxWidth.</p>
        ///             </li>
        ///             <li>
        ///                <p>integer percentage (%): The range of valid values is 0 to 100.</p>
        ///             </li>
        ///          </ul>
        /// 			      <p>For example, if you specify Left for <code>HorizontalAlign</code> and 5px for
        ///                 <code>HorizontalOffset</code>, the left side of the watermark appears 5 pixels from
        ///             the left border of the output video.</p>
        ///         <p>
        ///             <code>HorizontalOffset</code> is only valid when the value of
        ///                 <code>HorizontalAlign</code> is <code>Left</code> or <code>Right</code>. If you
        ///             specify an offset that causes the watermark to extend beyond the left or right border
        ///             and Elastic Transcoder has not added black bars, the watermark is cropped. If Elastic
        ///             Transcoder has added black bars, the watermark extends into the black bars. If the
        ///             watermark extends beyond the black bars, it is cropped.</p>
        ///         <p>Use the value of <code>Target</code> to specify whether you want to include the black
        ///             bars that are added by Elastic Transcoder, if any, in the offset calculation.</p>
        public let horizontalOffset: Swift.String?
        /// <p> A unique identifier for the settings for one
        ///         watermark. The value of <code>Id</code> can be up to 40 characters long. </p>
        public let id: Swift.String?
        /// <p>The maximum height of the watermark in one of the following formats: </p>
        /// 		       <ul>
        ///             <li>
        ///                <p>number of pixels (px): The minimum value is 16 pixels, and the maximum value is
        ///                     the value of <code>MaxHeight</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>integer percentage (%): The range of valid values is 0 to 100. Use the value of
        ///                         <code>Target</code> to specify whether you want Elastic Transcoder to include the black
        ///                     bars that are added by Elastic Transcoder, if any, in the calculation.</p>
        ///             </li>
        ///          </ul>
        ///          <p>If you specify the value in pixels, it must be less than or equal to the value of
        ///                 <code>MaxHeight</code>.</p>
        public let maxHeight: Swift.String?
        /// <p>The maximum width of the watermark in one of the following formats: </p>
        /// 		       <ul>
        ///             <li>
        ///                <p>number of pixels (px): The minimum value is 16 pixels, and the maximum value is
        ///                     the value of <code>MaxWidth</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>integer percentage (%): The range of valid values is 0 to 100. Use the value of
        ///                         <code>Target</code> to specify whether you want Elastic Transcoder to include the black
        ///                     bars that are added by Elastic Transcoder, if any, in the calculation.</p>
        /// 					          <p>If
        ///                 you specify the value in pixels, it must be less than or equal to the value of
        ///                     <code>MaxWidth</code>.</p>
        ///             </li>
        ///          </ul>
        public let maxWidth: Swift.String?
        /// <p>A percentage that indicates how much you want a watermark to obscure the video in the
        ///             location where it appears. Valid values are 0 (the watermark is invisible) to 100 (the
        ///             watermark completely obscures the video in the specified location). The datatype of
        ///                 <code>Opacity</code> is float.</p>
        ///         <p>Elastic Transcoder supports transparent .png graphics. If you use a transparent .png, the transparent
        ///             portion of the video appears as if you had specified a value of 0 for
        ///                 <code>Opacity</code>. The .jpg file format doesn't support transparency.</p>
        public let opacity: Swift.String?
        /// <p>A value that controls scaling of the watermark: </p>
        /// 		       <ul>
        ///             <li>
        ///                <p>
        ///                   <b>Fit</b>: Elastic Transcoder scales the watermark so it matches the value that
        ///                     you specified in either <code>MaxWidth</code> or <code>MaxHeight</code> without
        ///                     exceeding the other value.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Stretch</b>: Elastic Transcoder stretches the watermark to match the values
        ///                     that you specified for <code>MaxWidth</code> and <code>MaxHeight</code>. If the
        ///                     relative proportions of the watermark and the values of <code>MaxWidth</code>
        ///                     and <code>MaxHeight</code> are different, the watermark will be distorted.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>ShrinkToFit</b>: Elastic Transcoder scales the watermark down so that its
        ///                     dimensions match the values that you specified for at least one of
        ///                         <code>MaxWidth</code> and <code>MaxHeight</code> without exceeding either
        ///                     value. If you specify this option, Elastic Transcoder does not scale the
        ///                     watermark up.</p>
        ///             </li>
        ///          </ul>
        public let sizingPolicy: Swift.String?
        /// <p>A value that determines how Elastic Transcoder interprets values that you specified for
        ///                 <code>HorizontalOffset</code>, <code>VerticalOffset</code>, <code>MaxWidth</code>,
        ///             and <code>MaxHeight</code>:</p>
        /// 		       <ul>
        ///             <li>
        ///                <p>
        ///                   <b>Content</b>: <code>HorizontalOffset</code> and
        ///                         <code>VerticalOffset</code> values are calculated based on the borders of
        ///                     the video excluding black bars added by Elastic Transcoder, if any. In addition,
        ///                         <code>MaxWidth</code> and <code>MaxHeight</code>, if specified as a
        ///                     percentage, are calculated based on the borders of the video excluding black
        ///                     bars added by Elastic Transcoder, if any.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Frame</b>: <code>HorizontalOffset</code> and <code>VerticalOffset</code>
        ///                     values are calculated based on the borders of the video including black bars
        ///                     added by Elastic Transcoder, if any. In addition, <code>MaxWidth</code> and
        ///                     <code>MaxHeight</code>, if specified as a percentage, are calculated based on
        ///                 the borders of the video including black bars added by Elastic Transcoder, if any.</p>
        ///             </li>
        ///          </ul>
        public let target: Swift.String?
        /// <p>The vertical position of the watermark unless you specify a non-zero value for
        ///                 <code>VerticalOffset</code>: </p>
        /// 			      <ul>
        ///             <li>
        ///                <p>
        ///                   <b>Top</b>: The top edge of the watermark is aligned with the top border of the
        ///                     video.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Bottom</b>: The bottom edge of the watermark is aligned with the bottom
        ///                     border of the video.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <b>Center</b>: The watermark is centered between the top and bottom
        ///                     borders.</p>
        ///             </li>
        ///          </ul>
        public let verticalAlign: Swift.String?
        /// <p>
        ///             <code>VerticalOffset</code>
        ///          </p>
        ///         <p>The amount by which you want the vertical position of the watermark to be offset from the
        ///             position specified by VerticalAlign:</p>
        /// 			      <ul>
        ///             <li>
        ///                <p>number of pixels (px): The minimum value is 0 pixels, and the maximum value is
        ///                     the value of <code>MaxHeight</code>.</p>
        ///             </li>
        ///             <li>
        ///                <p>integer percentage (%): The range of valid values is 0 to 100.</p>
        ///             </li>
        ///          </ul>
        /// 			      <p>For example, if you specify <code>Top</code> for <code>VerticalAlign</code> and
        ///                 <code>5px</code> for <code>VerticalOffset</code>, the top of the watermark appears 5
        ///             pixels from the top border of the output video.</p>
        ///         <p>
        ///             <code>VerticalOffset</code> is only valid when the value of VerticalAlign is Top or
        ///             Bottom.</p>
        ///         <p>If you specify an offset that causes the watermark to extend beyond the top or
        ///             bottom border and Elastic Transcoder has not added black bars, the watermark is cropped. If Elastic Transcoder has
        ///             added black bars, the watermark extends into the black bars. If the watermark extends
        ///             beyond the black bars, it is cropped.</p>
        ///
        ///         <p>Use the value of <code>Target</code> to specify whether you want Elastic Transcoder to
        ///             include the black bars that are added by Elastic Transcoder, if any, in the offset
        ///             calculation.</p>
        public let verticalOffset: Swift.String?

        public init (
            horizontalAlign: Swift.String? = nil,
            horizontalOffset: Swift.String? = nil,
            id: Swift.String? = nil,
            maxHeight: Swift.String? = nil,
            maxWidth: Swift.String? = nil,
            opacity: Swift.String? = nil,
            sizingPolicy: Swift.String? = nil,
            target: Swift.String? = nil,
            verticalAlign: Swift.String? = nil,
            verticalOffset: Swift.String? = nil
        )
        {
            self.horizontalAlign = horizontalAlign
            self.horizontalOffset = horizontalOffset
            self.id = id
            self.maxHeight = maxHeight
            self.maxWidth = maxWidth
            self.opacity = opacity
            self.sizingPolicy = sizingPolicy
            self.target = target
            self.verticalAlign = verticalAlign
            self.verticalOffset = verticalOffset
        }
    }

}

extension ReadJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReadJobInput(id: \(Swift.String(describing: id)))"}
}

extension ReadJobInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ReadJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReadJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReadJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ReadJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReadJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReadJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ReadJobOutputError>
}

public struct ReadJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReadJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReadJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ReadJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReadJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReadJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ReadJobOutputError>
}

/// <p>The <code>ReadJobRequest</code> structure.</p>
public struct ReadJobInput: Swift.Equatable {
    /// <p>The identifier of the job for which you want to get detailed information.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct ReadJobInputBody: Swift.Equatable {
}

extension ReadJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ReadJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReadJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReadJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReadJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReadJobOutputResponse(job: \(Swift.String(describing: job)))"}
}

extension ReadJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ReadJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

/// <p>The <code>ReadJobResponse</code> structure.</p>
public struct ReadJobOutputResponse: Swift.Equatable {
    /// <p>A section of the response body that provides information about the job.</p>
    public let job: ElasticTranscoderClientTypes.Job?

    public init (
        job: ElasticTranscoderClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct ReadJobOutputResponseBody: Swift.Equatable {
    public let job: ElasticTranscoderClientTypes.Job?
}

extension ReadJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

extension ReadPipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReadPipelineInput(id: \(Swift.String(describing: id)))"}
}

extension ReadPipelineInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ReadPipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReadPipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReadPipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ReadPipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReadPipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReadPipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ReadPipelineOutputError>
}

public struct ReadPipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReadPipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReadPipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ReadPipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReadPipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReadPipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ReadPipelineOutputError>
}

/// <p>The <code>ReadPipelineRequest</code> structure.</p>
public struct ReadPipelineInput: Swift.Equatable {
    /// <p>The identifier of the pipeline to read.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct ReadPipelineInputBody: Swift.Equatable {
}

extension ReadPipelineInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ReadPipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReadPipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReadPipelineOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReadPipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReadPipelineOutputResponse(pipeline: \(Swift.String(describing: pipeline)), warnings: \(Swift.String(describing: warnings)))"}
}

extension ReadPipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ReadPipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
            self.warnings = output.warnings
        } else {
            self.pipeline = nil
            self.warnings = nil
        }
    }
}

/// <p>The <code>ReadPipelineResponse</code> structure.</p>
public struct ReadPipelineOutputResponse: Swift.Equatable {
    /// <p>A section of the response body that provides information about the pipeline.</p>
    public let pipeline: ElasticTranscoderClientTypes.Pipeline?
    /// <p>Elastic Transcoder returns a warning if the resources used by your pipeline are not in the same region
    ///             as the pipeline.</p>
    ///         <p>Using resources in the same region, such as your Amazon S3 buckets, Amazon SNS notification topics,
    ///             and AWS KMS key, reduces processing time and prevents cross-regional charges.</p>
    public let warnings: [ElasticTranscoderClientTypes.Warning]?

    public init (
        pipeline: ElasticTranscoderClientTypes.Pipeline? = nil,
        warnings: [ElasticTranscoderClientTypes.Warning]? = nil
    )
    {
        self.pipeline = pipeline
        self.warnings = warnings
    }
}

struct ReadPipelineOutputResponseBody: Swift.Equatable {
    public let pipeline: ElasticTranscoderClientTypes.Pipeline?
    public let warnings: [ElasticTranscoderClientTypes.Warning]?
}

extension ReadPipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline = "Pipeline"
        case warnings = "Warnings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Pipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
        let warningsContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.Warning?].self, forKey: .warnings)
        var warningsDecoded0:[ElasticTranscoderClientTypes.Warning]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [ElasticTranscoderClientTypes.Warning]()
            for structure0 in warningsContainer {
                if let structure0 = structure0 {
                    warningsDecoded0?.append(structure0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

extension ReadPresetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReadPresetInput(id: \(Swift.String(describing: id)))"}
}

extension ReadPresetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ReadPresetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReadPresetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReadPresetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ReadPresetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReadPresetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReadPresetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ReadPresetOutputError>
}

public struct ReadPresetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ReadPresetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ReadPresetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ReadPresetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ReadPresetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ReadPresetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ReadPresetOutputError>
}

/// <p>The <code>ReadPresetRequest</code> structure.</p>
public struct ReadPresetInput: Swift.Equatable {
    /// <p>The identifier of the preset for which you want to get detailed information.</p>
    public let id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct ReadPresetInputBody: Swift.Equatable {
}

extension ReadPresetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ReadPresetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReadPresetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReadPresetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReadPresetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReadPresetOutputResponse(preset: \(Swift.String(describing: preset)))"}
}

extension ReadPresetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ReadPresetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.preset = output.preset
        } else {
            self.preset = nil
        }
    }
}

/// <p>The <code>ReadPresetResponse</code> structure.</p>
public struct ReadPresetOutputResponse: Swift.Equatable {
    /// <p>A section of the response body that provides information about the preset.</p>
    public let preset: ElasticTranscoderClientTypes.Preset?

    public init (
        preset: ElasticTranscoderClientTypes.Preset? = nil
    )
    {
        self.preset = preset
    }
}

struct ReadPresetOutputResponseBody: Swift.Equatable {
    public let preset: ElasticTranscoderClientTypes.Preset?
}

extension ReadPresetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preset = "Preset"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let presetDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Preset.self, forKey: .preset)
        preset = presetDecoded
    }
}

extension ResourceInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceInUseException(message: \(Swift.String(describing: message)))"}
}

extension ResourceInUseException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource you are attempting to change is in use. For example, you are attempting
///             to delete a pipeline that is currently in use.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource does not exist or is not available. For example, the pipeline
///             to which you're trying to add a job doesn't exist or is still being created.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TestRoleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestRoleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestRoleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestRoleOutputError>
}

extension TestRoleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestRoleInput(inputBucket: \(Swift.String(describing: inputBucket)), outputBucket: \(Swift.String(describing: outputBucket)), role: \(Swift.String(describing: role)), topics: \(Swift.String(describing: topics)))"}
}

extension TestRoleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputBucket = "InputBucket"
        case outputBucket = "OutputBucket"
        case role = "Role"
        case topics = "Topics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputBucket = inputBucket {
            try encodeContainer.encode(inputBucket, forKey: .inputBucket)
        }
        if let outputBucket = outputBucket {
            try encodeContainer.encode(outputBucket, forKey: .outputBucket)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let topics = topics {
            var topicsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topics)
            for snstopics0 in topics {
                try topicsContainer.encode(snstopics0)
            }
        }
    }
}

public struct TestRoleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestRoleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestRoleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestRoleOutputError>
}

public struct TestRoleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TestRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TestRoleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TestRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TestRoleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TestRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TestRoleOutputError>
}

/// <p> The <code>TestRoleRequest</code> structure. </p>
@available(*, deprecated)
public struct TestRoleInput: Swift.Equatable {
    /// <p>The Amazon S3 bucket that contains media files to be transcoded. The action attempts to read from this bucket.</p>
    public let inputBucket: Swift.String?
    /// <p>The Amazon S3 bucket that Elastic Transcoder writes transcoded media files to. The action attempts to read from this bucket.</p>
    public let outputBucket: Swift.String?
    /// <p>The IAM Amazon Resource Name (ARN) for the role that you want Elastic Transcoder to test.</p>
    public let role: Swift.String?
    /// <p>The ARNs of one or more Amazon Simple Notification Service (Amazon SNS) topics that you want the action to send a test notification to.</p>
    public let topics: [Swift.String]?

    public init (
        inputBucket: Swift.String? = nil,
        outputBucket: Swift.String? = nil,
        role: Swift.String? = nil,
        topics: [Swift.String]? = nil
    )
    {
        self.inputBucket = inputBucket
        self.outputBucket = outputBucket
        self.role = role
        self.topics = topics
    }
}

struct TestRoleInputBody: Swift.Equatable {
    public let role: Swift.String?
    public let inputBucket: Swift.String?
    public let outputBucket: Swift.String?
    public let topics: [Swift.String]?
}

extension TestRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputBucket = "InputBucket"
        case outputBucket = "OutputBucket"
        case role = "Role"
        case topics = "Topics"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let inputBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputBucket)
        inputBucket = inputBucketDecoded
        let outputBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputBucket)
        outputBucket = outputBucketDecoded
        let topicsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .topics)
        var topicsDecoded0:[Swift.String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [Swift.String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
    }
}

extension TestRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestRoleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestRoleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestRoleOutputResponse(messages: \(Swift.String(describing: messages)), success: \(Swift.String(describing: success)))"}
}

extension TestRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TestRoleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.messages = output.messages
            self.success = output.success
        } else {
            self.messages = nil
            self.success = nil
        }
    }
}

/// <p>The <code>TestRoleResponse</code> structure.</p>
@available(*, deprecated)
public struct TestRoleOutputResponse: Swift.Equatable {
    /// <p>If the <code>Success</code> element contains <code>false</code>, this value is an array
    ///             of one or more error messages that were generated during the test process.</p>
    public let messages: [Swift.String]?
    /// <p>If the operation is successful, this value is <code>true</code>; otherwise, the value is
    ///                 <code>false</code>.</p>
    public let success: Swift.String?

    public init (
        messages: [Swift.String]? = nil,
        success: Swift.String? = nil
    )
    {
        self.messages = messages
        self.success = success
    }
}

struct TestRoleOutputResponseBody: Swift.Equatable {
    public let success: Swift.String?
    public let messages: [Swift.String]?
}

extension TestRoleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messages = "Messages"
        case success = "Success"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .success)
        success = successDecoded
        let messagesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .messages)
        var messagesDecoded0:[Swift.String]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [Swift.String]()
            for string0 in messagesContainer {
                if let string0 = string0 {
                    messagesDecoded0?.append(string0)
                }
            }
        }
        messages = messagesDecoded0
    }
}

extension ElasticTranscoderClientTypes.Thumbnails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aspectRatio = "AspectRatio"
        case format = "Format"
        case interval = "Interval"
        case maxHeight = "MaxHeight"
        case maxWidth = "MaxWidth"
        case paddingPolicy = "PaddingPolicy"
        case resolution = "Resolution"
        case sizingPolicy = "SizingPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aspectRatio = aspectRatio {
            try encodeContainer.encode(aspectRatio, forKey: .aspectRatio)
        }
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let interval = interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let maxHeight = maxHeight {
            try encodeContainer.encode(maxHeight, forKey: .maxHeight)
        }
        if let maxWidth = maxWidth {
            try encodeContainer.encode(maxWidth, forKey: .maxWidth)
        }
        if let paddingPolicy = paddingPolicy {
            try encodeContainer.encode(paddingPolicy, forKey: .paddingPolicy)
        }
        if let resolution = resolution {
            try encodeContainer.encode(resolution, forKey: .resolution)
        }
        if let sizingPolicy = sizingPolicy {
            try encodeContainer.encode(sizingPolicy, forKey: .sizingPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interval)
        interval = intervalDecoded
        let resolutionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolution)
        resolution = resolutionDecoded
        let aspectRatioDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aspectRatio)
        aspectRatio = aspectRatioDecoded
        let maxWidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxWidth)
        maxWidth = maxWidthDecoded
        let maxHeightDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxHeight)
        maxHeight = maxHeightDecoded
        let sizingPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sizingPolicy)
        sizingPolicy = sizingPolicyDecoded
        let paddingPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paddingPolicy)
        paddingPolicy = paddingPolicyDecoded
    }
}

extension ElasticTranscoderClientTypes.Thumbnails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Thumbnails(aspectRatio: \(Swift.String(describing: aspectRatio)), format: \(Swift.String(describing: format)), interval: \(Swift.String(describing: interval)), maxHeight: \(Swift.String(describing: maxHeight)), maxWidth: \(Swift.String(describing: maxWidth)), paddingPolicy: \(Swift.String(describing: paddingPolicy)), resolution: \(Swift.String(describing: resolution)), sizingPolicy: \(Swift.String(describing: sizingPolicy)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>Thumbnails for videos.</p>
    public struct Thumbnails: Swift.Equatable {
        /// <important>
        ///             <p>To better control resolution and aspect ratio of thumbnails, we recommend that you
        ///                 use the values <code>MaxWidth</code>, <code>MaxHeight</code>,
        ///                     <code>SizingPolicy</code>, and <code>PaddingPolicy</code> instead of
        ///                     <code>Resolution</code> and <code>AspectRatio</code>. The two groups of settings
        ///                 are mutually exclusive. Do not use them together.</p>
        ///         </important>
        ///         <p>The aspect ratio of thumbnails. Valid values include:</p>
        ///         <p>
        ///             <code>auto</code>, <code>1:1</code>, <code>4:3</code>, <code>3:2</code>,
        ///                 <code>16:9</code>
        ///          </p>
        ///         <p>If you specify <code>auto</code>, Elastic Transcoder tries to preserve the aspect ratio of the video in
        ///             the output file.</p>
        public let aspectRatio: Swift.String?
        /// <p>The format of thumbnails, if any. Valid values are <code>jpg</code> and <code>png</code>. </p>
        ///         <p>You specify whether you want Elastic Transcoder to create thumbnails when you create a job.</p>
        public let format: Swift.String?
        /// <p>The approximate number of seconds between thumbnails. Specify an integer value.</p>
        public let interval: Swift.String?
        /// <p>The maximum height of thumbnails in pixels. If you specify auto, Elastic Transcoder uses 1080
        ///             (Full HD) as the default value. If you specify a numeric value, enter an even integer
        ///             between 32 and 3072.</p>
        public let maxHeight: Swift.String?
        /// <p>The maximum width of thumbnails in pixels. If you specify auto, Elastic Transcoder uses 1920 (Full HD)
        ///             as the default value. If you specify a numeric value, enter an even integer between 32 and 4096.</p>
        public let maxWidth: Swift.String?
        /// <p>When you set <code>PaddingPolicy</code> to <code>Pad</code>, Elastic Transcoder may add
        ///             black bars to the top and bottom and/or left and right sides of thumbnails to make the
        ///             total size of the thumbnails match the values that you specified for thumbnail
        ///                 <code>MaxWidth</code> and <code>MaxHeight</code> settings.</p>
        public let paddingPolicy: Swift.String?
        /// <important>
        ///             <p>To better control resolution and aspect ratio of thumbnails, we recommend that you
        ///                 use the values <code>MaxWidth</code>, <code>MaxHeight</code>,
        ///                     <code>SizingPolicy</code>, and <code>PaddingPolicy</code> instead of
        ///                     <code>Resolution</code> and <code>AspectRatio</code>. The two groups of settings
        ///                 are mutually exclusive. Do not use them together.</p>
        ///         </important>
        ///         <p>The width and height of thumbnail files in pixels. Specify a value in the format
        ///                     <code>
        ///                <i>width</i>
        ///             </code> x <code>
        ///                <i>height</i>
        ///             </code> where both values are
        ///             even integers. The values cannot exceed the width and height that you specified in the
        ///                 <code>Video:Resolution</code> object.</p>
        public let resolution: Swift.String?
        /// <p>Specify one of the following values to control scaling of thumbnails:</p>
        ///
        ///             <ul>
        ///             <li>
        ///                <p>
        ///                   <code>Fit</code>: Elastic Transcoder scales thumbnails so they match the value
        ///                     that you specified in thumbnail MaxWidth or MaxHeight settings without exceeding
        ///                     the other value. </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Fill</code>: Elastic Transcoder scales thumbnails so they match the value
        ///                     that you specified in thumbnail <code>MaxWidth</code> or <code>MaxHeight</code>
        ///                     settings and matches or exceeds the other value. Elastic Transcoder centers the
        ///                     image in thumbnails and then crops in the dimension (if any) that exceeds the
        ///                     maximum value.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Stretch</code>: Elastic Transcoder stretches thumbnails to match the
        ///                     values that you specified for thumbnail <code>MaxWidth</code> and
        ///                         <code>MaxHeight</code> settings. If the relative proportions of the input
        ///                     video and thumbnails are different, the thumbnails will be distorted.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Keep</code>: Elastic Transcoder does not scale thumbnails. If either
        ///                     dimension of the input video exceeds the values that you specified for thumbnail
        ///                         <code>MaxWidth</code> and <code>MaxHeight</code> settings, Elastic
        ///                     Transcoder crops the thumbnails.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>ShrinkToFit</code>: Elastic Transcoder scales thumbnails down so that
        ///                     their dimensions match the values that you specified for at least one of
        ///                     thumbnail <code>MaxWidth</code> and <code>MaxHeight</code> without exceeding
        ///                     either value. If you specify this option, Elastic Transcoder does not scale
        ///                     thumbnails up.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>ShrinkToFill</code>: Elastic Transcoder scales thumbnails down so that
        ///                     their dimensions match the values that you specified for at least one of
        ///                         <code>MaxWidth</code> and <code>MaxHeight</code> without dropping below
        ///                     either value. If you specify this option, Elastic Transcoder does not scale
        ///                     thumbnails up.</p>
        ///             </li>
        ///          </ul>
        public let sizingPolicy: Swift.String?

        public init (
            aspectRatio: Swift.String? = nil,
            format: Swift.String? = nil,
            interval: Swift.String? = nil,
            maxHeight: Swift.String? = nil,
            maxWidth: Swift.String? = nil,
            paddingPolicy: Swift.String? = nil,
            resolution: Swift.String? = nil,
            sizingPolicy: Swift.String? = nil
        )
        {
            self.aspectRatio = aspectRatio
            self.format = format
            self.interval = interval
            self.maxHeight = maxHeight
            self.maxWidth = maxWidth
            self.paddingPolicy = paddingPolicy
            self.resolution = resolution
            self.sizingPolicy = sizingPolicy
        }
    }

}

extension ElasticTranscoderClientTypes.TimeSpan: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duration = "Duration"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .duration)
        duration = durationDecoded
    }
}

extension ElasticTranscoderClientTypes.TimeSpan: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TimeSpan(duration: \(Swift.String(describing: duration)), startTime: \(Swift.String(describing: startTime)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>Settings that determine when a clip begins and how long it lasts.</p>
    public struct TimeSpan: Swift.Equatable {
        /// <p>The duration of the clip. The format can be either HH:mm:ss.SSS (maximum value: 23:59:59.999;
        ///            SSS is thousandths of a second) or sssss.SSS (maximum value: 86399.999). If you don't specify a
        ///            value, Elastic Transcoder creates an output file from StartTime to the end of the file.</p>
        ///          <p>If you specify a value longer than the duration of the input file, Elastic Transcoder transcodes the
        ///            file and returns a warning message.</p>
        public let duration: Swift.String?
        /// <p>The place in the input file where you want a clip to start. The format can be either
        ///            HH:mm:ss.SSS (maximum value: 23:59:59.999; SSS is thousandths of a second) or sssss.SSS
        ///            (maximum value: 86399.999). If you don't specify a value, Elastic Transcoder starts at the beginning of
        ///            the input file.</p>
        public let startTime: Swift.String?

        public init (
            duration: Swift.String? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.duration = duration
            self.startTime = startTime
        }
    }

}

extension ElasticTranscoderClientTypes.Timing: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finishTimeMillis = "FinishTimeMillis"
        case startTimeMillis = "StartTimeMillis"
        case submitTimeMillis = "SubmitTimeMillis"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finishTimeMillis = finishTimeMillis {
            try encodeContainer.encode(finishTimeMillis, forKey: .finishTimeMillis)
        }
        if let startTimeMillis = startTimeMillis {
            try encodeContainer.encode(startTimeMillis, forKey: .startTimeMillis)
        }
        if let submitTimeMillis = submitTimeMillis {
            try encodeContainer.encode(submitTimeMillis, forKey: .submitTimeMillis)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let submitTimeMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .submitTimeMillis)
        submitTimeMillis = submitTimeMillisDecoded
        let startTimeMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startTimeMillis)
        startTimeMillis = startTimeMillisDecoded
        let finishTimeMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .finishTimeMillis)
        finishTimeMillis = finishTimeMillisDecoded
    }
}

extension ElasticTranscoderClientTypes.Timing: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Timing(finishTimeMillis: \(Swift.String(describing: finishTimeMillis)), startTimeMillis: \(Swift.String(describing: startTimeMillis)), submitTimeMillis: \(Swift.String(describing: submitTimeMillis)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>Details about the timing of a job.</p>
    public struct Timing: Swift.Equatable {
        /// <p>The time the job finished transcoding, in epoch milliseconds.</p>
        public let finishTimeMillis: Swift.Int?
        /// <p>The time the job began transcoding, in epoch milliseconds.</p>
        public let startTimeMillis: Swift.Int?
        /// <p>The time the job was submitted to Elastic Transcoder, in epoch milliseconds.</p>
        public let submitTimeMillis: Swift.Int?

        public init (
            finishTimeMillis: Swift.Int? = nil,
            startTimeMillis: Swift.Int? = nil,
            submitTimeMillis: Swift.Int? = nil
        )
        {
            self.finishTimeMillis = finishTimeMillis
            self.startTimeMillis = startTimeMillis
            self.submitTimeMillis = submitTimeMillis
        }
    }

}

public struct UpdatePipelineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePipelineOutputError>
}

extension UpdatePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePipelineInput(awsKmsKeyArn: \(Swift.String(describing: awsKmsKeyArn)), contentConfig: \(Swift.String(describing: contentConfig)), id: \(Swift.String(describing: id)), inputBucket: \(Swift.String(describing: inputBucket)), name: \(Swift.String(describing: name)), notifications: \(Swift.String(describing: notifications)), role: \(Swift.String(describing: role)), thumbnailConfig: \(Swift.String(describing: thumbnailConfig)))"}
}

extension UpdatePipelineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsKmsKeyArn = "AwsKmsKeyArn"
        case contentConfig = "ContentConfig"
        case inputBucket = "InputBucket"
        case name = "Name"
        case notifications = "Notifications"
        case role = "Role"
        case thumbnailConfig = "ThumbnailConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsKmsKeyArn = awsKmsKeyArn {
            try encodeContainer.encode(awsKmsKeyArn, forKey: .awsKmsKeyArn)
        }
        if let contentConfig = contentConfig {
            try encodeContainer.encode(contentConfig, forKey: .contentConfig)
        }
        if let inputBucket = inputBucket {
            try encodeContainer.encode(inputBucket, forKey: .inputBucket)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notifications = notifications {
            try encodeContainer.encode(notifications, forKey: .notifications)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let thumbnailConfig = thumbnailConfig {
            try encodeContainer.encode(thumbnailConfig, forKey: .thumbnailConfig)
        }
    }
}

public struct UpdatePipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePipelineOutputError>
}

public struct UpdatePipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePipelineOutputError>
}

/// <p>The <code>UpdatePipelineRequest</code> structure.</p>
public struct UpdatePipelineInput: Swift.Equatable {
    /// <p>The AWS Key Management Service (AWS KMS) key that you want to use with this pipeline.</p>
    ///         <p>If you use either <code>s3</code> or <code>s3-aws-kms</code> as your <code>Encryption:Mode</code>,
    ///         you don't need to provide a key with your job because a default key, known as an AWS-KMS key, is
    ///         created for you automatically. You need to provide an AWS-KMS key only if you want to use a non-default
    ///         AWS-KMS key, or if you are using an <code>Encryption:Mode</code> of <code>aes-cbc-pkcs7</code>, <code>aes-ctr</code>,
    ///             or <code>aes-gcm</code>.</p>
    public let awsKmsKeyArn: Swift.String?
    /// <p>The optional <code>ContentConfig</code> object specifies information about the Amazon S3
    ///             bucket in which you want Elastic Transcoder to save transcoded files and playlists:
    ///             which bucket to use, which users you want to have access to the files, the type of
    ///             access you want users to have, and the storage class that you want to assign to the
    ///             files.</p>
    ///         <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
    ///                 <code>ThumbnailConfig</code>.</p>
    ///         <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
    ///             omit the <code>OutputBucket</code> object.</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
    ///                 transcoded files and playlists.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Permissions</b> (Optional): The Permissions object specifies which users you want
    ///                 to have access to transcoded files and the type of access you want them to have. You
    ///                 can grant permissions to a maximum of 30 users and/or predefined Amazon S3
    ///                 groups.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Grantee Type</b>: Specify the type of value that appears in the
    ///                     <code>Grantee</code> object:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
    ///                         canonical user ID for an AWS account or an origin access identity for an
    ///                         Amazon CloudFront distribution. For more information about canonical user
    ///                         IDs, see Access Control List (ACL) Overview in the Amazon Simple Storage
    ///                         Service Developer Guide. For more information about using CloudFront origin
    ///                         access identities to require that users use CloudFront URLs instead of
    ///                         Amazon S3 URLs, see Using an Origin Access Identity to Restrict Access to
    ///                         Your Amazon S3 Content.</p>
    ///                      <important>
    ///                         <p>A canonical user ID is not the same as an
    ///                             AWS account number.</p>
    ///                      </important>
    ///                     </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>Email</b>: The value in the <code>Grantee</code> object is the registered
    ///                         email address of an AWS account.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>Group</b>: The value in the <code>Grantee</code> object is one of the
    ///                         following predefined Amazon S3 groups: <code>AllUsers</code>,
    ///                             <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Grantee</b>: The AWS user or group that you want to have access to transcoded
    ///                 files and playlists. To identify the user or group, you can specify the canonical
    ///                 user ID for an AWS account, an origin access identity for a CloudFront distribution,
    ///                 the registered email address of an AWS account, or a predefined Amazon S3 group </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Access</b>: The permission that you want to give to the AWS user that you
    ///                 specified in <code>Grantee</code>. Permissions are granted on the files that Elastic
    ///                 Transcoder adds to the bucket, including playlists and video files. Valid values
    ///                 include: </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>READ</code>: The grantee can read the objects and metadata for objects
    ///                         that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>READ_ACP</code>: The grantee can read the object ACL for objects that
    ///                         Elastic Transcoder adds to the Amazon S3 bucket. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>WRITE_ACP</code>: The grantee can write the ACL for the objects that
    ///                         Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
    ///                             <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
    ///                         objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
    ///                     <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
    ///                 the video files and playlists that it stores in your Amazon S3 bucket.</p>
    ///             </li>
    ///          </ul>
    public let contentConfig: ElasticTranscoderClientTypes.PipelineOutputConfig?
    /// <p>The ID of the pipeline that you want to update.</p>
    public let id: Swift.String?
    /// <p>The Amazon S3 bucket in which you saved the media files that you want to transcode and the graphics
    ///             that you want to use as watermarks.</p>
    public let inputBucket: Swift.String?
    /// <p>The name of the pipeline. We recommend that the name be unique within the AWS account, but
    ///             uniqueness is not enforced.</p>
    ///         <p>Constraints: Maximum 40 characters</p>
    public let name: Swift.String?
    /// <p>The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status.</p>
    ///         <important>
    ///             <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
    ///         </important>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Progressing</b>: The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to
    ///                 notify when Elastic Transcoder has started to process jobs that are added to this pipeline. This
    ///                 is the ARN that Amazon SNS returned when you created the topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Complete</b>: The topic ARN for the Amazon SNS topic that you want to notify when
    ///                 Elastic Transcoder has finished processing a job. This is the ARN that Amazon SNS returned when
    ///                 you created the topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Warning</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
    ///                 encounters a warning condition. This is the ARN that Amazon SNS returned when you
    ///                 created the topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Error</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
    ///                 encounters an error condition. This is the ARN that Amazon SNS returned when you
    ///                 created the topic.</p>
    ///             </li>
    ///          </ul>
    public let notifications: ElasticTranscoderClientTypes.Notifications?
    /// <p>The IAM Amazon Resource Name (ARN) for the role that you want Elastic Transcoder to use to transcode jobs for
    ///             this pipeline.</p>
    public let role: Swift.String?
    /// <p>The <code>ThumbnailConfig</code> object specifies several values, including the Amazon S3
    ///             bucket in which you want Elastic Transcoder to save thumbnail files, which users you want to have
    ///             access to the files, the type of access you want users to have, and the storage class
    ///             that you want to assign to the files.</p>
    ///         <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
    ///                 <code>ThumbnailConfig</code> even if you don't want to create thumbnails.</p>
    ///         <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
    ///             omit the <code>OutputBucket</code> object.</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
    ///                 thumbnail files.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Permissions</b> (Optional): The <code>Permissions</code> object specifies which
    ///                 users and/or predefined Amazon S3 groups you want to have access to thumbnail files,
    ///                 and the type of access you want them to have. You can grant permissions to a maximum
    ///                 of 30 users and/or predefined Amazon S3 groups.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>GranteeType</b>: Specify the type of value that appears in the Grantee object:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
    ///                         canonical user ID for an AWS account or an origin access identity for an
    ///                         Amazon CloudFront distribution.</p>
    ///                      <important>
    ///                         <p>A canonical user ID is not the
    ///                             same as an AWS account number.</p>
    ///                      </important>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>Email</b>: The value in the <code>Grantee</code> object is the registered
    ///                         email address of an AWS account.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>Group</b>: The value in the <code>Grantee</code> object is one of the
    ///                         following predefined Amazon S3 groups: <code>AllUsers</code>,
    ///                             <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Grantee</b>: The AWS user or group that you want to have access to thumbnail
    ///                 files. To identify the user or group, you can specify the canonical user ID for an
    ///                 AWS account, an origin access identity for a CloudFront distribution, the registered
    ///                 email address of an AWS account, or a predefined Amazon S3 group. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Access</b>: The permission that you want to give to the AWS user that you
    ///                 specified in <code>Grantee</code>. Permissions are granted on the thumbnail files
    ///                 that Elastic Transcoder adds to the bucket. Valid values include: </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>READ</code>: The grantee can read the thumbnails and metadata for
    ///                         objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>READ_ACP</code>: The grantee can read the object ACL for thumbnails
    ///                         that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>WRITE_ACP</code>: The grantee can write the ACL for the thumbnails
    ///                         that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
    ///                             <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
    ///                         thumbnails that Elastic Transcoder adds to the Amazon S3 bucket. </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
    ///                     <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
    ///                 the thumbnails that it stores in your Amazon S3 bucket.</p>
    ///             </li>
    ///          </ul>
    public let thumbnailConfig: ElasticTranscoderClientTypes.PipelineOutputConfig?

    public init (
        awsKmsKeyArn: Swift.String? = nil,
        contentConfig: ElasticTranscoderClientTypes.PipelineOutputConfig? = nil,
        id: Swift.String? = nil,
        inputBucket: Swift.String? = nil,
        name: Swift.String? = nil,
        notifications: ElasticTranscoderClientTypes.Notifications? = nil,
        role: Swift.String? = nil,
        thumbnailConfig: ElasticTranscoderClientTypes.PipelineOutputConfig? = nil
    )
    {
        self.awsKmsKeyArn = awsKmsKeyArn
        self.contentConfig = contentConfig
        self.id = id
        self.inputBucket = inputBucket
        self.name = name
        self.notifications = notifications
        self.role = role
        self.thumbnailConfig = thumbnailConfig
    }
}

struct UpdatePipelineInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let inputBucket: Swift.String?
    public let role: Swift.String?
    public let awsKmsKeyArn: Swift.String?
    public let notifications: ElasticTranscoderClientTypes.Notifications?
    public let contentConfig: ElasticTranscoderClientTypes.PipelineOutputConfig?
    public let thumbnailConfig: ElasticTranscoderClientTypes.PipelineOutputConfig?
}

extension UpdatePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsKmsKeyArn = "AwsKmsKeyArn"
        case contentConfig = "ContentConfig"
        case inputBucket = "InputBucket"
        case name = "Name"
        case notifications = "Notifications"
        case role = "Role"
        case thumbnailConfig = "ThumbnailConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let inputBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputBucket)
        inputBucket = inputBucketDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let awsKmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsKmsKeyArn)
        awsKmsKeyArn = awsKmsKeyArnDecoded
        let notificationsDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Notifications.self, forKey: .notifications)
        notifications = notificationsDecoded
        let contentConfigDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.PipelineOutputConfig.self, forKey: .contentConfig)
        contentConfig = contentConfigDecoded
        let thumbnailConfigDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.PipelineOutputConfig.self, forKey: .thumbnailConfig)
        thumbnailConfig = thumbnailConfigDecoded
    }
}

public struct UpdatePipelineNotificationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePipelineNotificationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePipelineNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePipelineNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePipelineNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePipelineNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePipelineNotificationsOutputError>
}

extension UpdatePipelineNotificationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePipelineNotificationsInput(id: \(Swift.String(describing: id)), notifications: \(Swift.String(describing: notifications)))"}
}

extension UpdatePipelineNotificationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notifications = "Notifications"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notifications = notifications {
            try encodeContainer.encode(notifications, forKey: .notifications)
        }
    }
}

public struct UpdatePipelineNotificationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePipelineNotificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePipelineNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePipelineNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePipelineNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePipelineNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePipelineNotificationsOutputError>
}

public struct UpdatePipelineNotificationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePipelineNotificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePipelineNotificationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePipelineNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePipelineNotificationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePipelineNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePipelineNotificationsOutputError>
}

/// <p>The <code>UpdatePipelineNotificationsRequest</code> structure.</p>
public struct UpdatePipelineNotificationsInput: Swift.Equatable {
    /// <p>The identifier of the pipeline for which you want to change notification settings.</p>
    public let id: Swift.String?
    /// <p>The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status.</p>
    ///         <important>
    ///             <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
    ///          </important>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Progressing</b>: The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to
    ///                 notify when Elastic Transcoder has started to process jobs that are added to this pipeline. This
    ///                 is the ARN that Amazon SNS returned when you created the topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Complete</b>: The topic ARN for the Amazon SNS topic that you want to notify when
    ///                 Elastic Transcoder has finished processing a job. This is the ARN that Amazon SNS returned when
    ///                 you created the topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Warning</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
    ///                 encounters a warning condition. This is the ARN that Amazon SNS returned when you
    ///                 created the topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Error</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
    ///                 encounters an error condition. This is the ARN that Amazon SNS returned when you
    ///                 created the topic.</p>
    ///             </li>
    ///          </ul>
    public let notifications: ElasticTranscoderClientTypes.Notifications?

    public init (
        id: Swift.String? = nil,
        notifications: ElasticTranscoderClientTypes.Notifications? = nil
    )
    {
        self.id = id
        self.notifications = notifications
    }
}

struct UpdatePipelineNotificationsInputBody: Swift.Equatable {
    public let notifications: ElasticTranscoderClientTypes.Notifications?
}

extension UpdatePipelineNotificationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notifications = "Notifications"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationsDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Notifications.self, forKey: .notifications)
        notifications = notificationsDecoded
    }
}

extension UpdatePipelineNotificationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePipelineNotificationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePipelineNotificationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePipelineNotificationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePipelineNotificationsOutputResponse(pipeline: \(Swift.String(describing: pipeline)))"}
}

extension UpdatePipelineNotificationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePipelineNotificationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
        } else {
            self.pipeline = nil
        }
    }
}

/// <p>The <code>UpdatePipelineNotificationsResponse</code> structure.</p>
public struct UpdatePipelineNotificationsOutputResponse: Swift.Equatable {
    /// <p>A section of the response body that provides information about the pipeline associated
    ///             with this notification.</p>
    public let pipeline: ElasticTranscoderClientTypes.Pipeline?

    public init (
        pipeline: ElasticTranscoderClientTypes.Pipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct UpdatePipelineNotificationsOutputResponseBody: Swift.Equatable {
    public let pipeline: ElasticTranscoderClientTypes.Pipeline?
}

extension UpdatePipelineNotificationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline = "Pipeline"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Pipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

extension UpdatePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePipelineOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePipelineOutputResponse(pipeline: \(Swift.String(describing: pipeline)), warnings: \(Swift.String(describing: warnings)))"}
}

extension UpdatePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
            self.warnings = output.warnings
        } else {
            self.pipeline = nil
            self.warnings = nil
        }
    }
}

/// <p>When you update a pipeline, Elastic Transcoder returns the values that you specified in the request.</p>
public struct UpdatePipelineOutputResponse: Swift.Equatable {
    /// <p>The pipeline updated by this <code>UpdatePipelineResponse</code> call.</p>
    public let pipeline: ElasticTranscoderClientTypes.Pipeline?
    /// <p>Elastic Transcoder returns a warning if the resources used by your pipeline are not in the same region as the
    ///             pipeline.</p>
    ///         <p>Using resources in the same region, such as your Amazon S3 buckets, Amazon SNS notification topics, and
    ///             AWS KMS key, reduces processing time and prevents cross-regional charges.</p>
    public let warnings: [ElasticTranscoderClientTypes.Warning]?

    public init (
        pipeline: ElasticTranscoderClientTypes.Pipeline? = nil,
        warnings: [ElasticTranscoderClientTypes.Warning]? = nil
    )
    {
        self.pipeline = pipeline
        self.warnings = warnings
    }
}

struct UpdatePipelineOutputResponseBody: Swift.Equatable {
    public let pipeline: ElasticTranscoderClientTypes.Pipeline?
    public let warnings: [ElasticTranscoderClientTypes.Warning]?
}

extension UpdatePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline = "Pipeline"
        case warnings = "Warnings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Pipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
        let warningsContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.Warning?].self, forKey: .warnings)
        var warningsDecoded0:[ElasticTranscoderClientTypes.Warning]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [ElasticTranscoderClientTypes.Warning]()
            for structure0 in warningsContainer {
                if let structure0 = structure0 {
                    warningsDecoded0?.append(structure0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

public struct UpdatePipelineStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePipelineStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePipelineStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePipelineStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePipelineStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePipelineStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePipelineStatusOutputError>
}

extension UpdatePipelineStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePipelineStatusInput(id: \(Swift.String(describing: id)), status: \(Swift.String(describing: status)))"}
}

extension UpdatePipelineStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }
}

public struct UpdatePipelineStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePipelineStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePipelineStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePipelineStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePipelineStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePipelineStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePipelineStatusOutputError>
}

public struct UpdatePipelineStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePipelineStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePipelineStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePipelineStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePipelineStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePipelineStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePipelineStatusOutputError>
}

/// <p>The <code>UpdatePipelineStatusRequest</code> structure.</p>
public struct UpdatePipelineStatusInput: Swift.Equatable {
    /// <p>The identifier of the pipeline to update.</p>
    public let id: Swift.String?
    /// <p>The desired status of the pipeline:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Active</code>: The pipeline is processing jobs.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Paused</code>: The pipeline is not currently processing jobs.</p>
    ///             </li>
    ///          </ul>
    public let status: Swift.String?

    public init (
        id: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.id = id
        self.status = status
    }
}

struct UpdatePipelineStatusInputBody: Swift.Equatable {
    public let status: Swift.String?
}

extension UpdatePipelineStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdatePipelineStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePipelineStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePipelineStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePipelineStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePipelineStatusOutputResponse(pipeline: \(Swift.String(describing: pipeline)))"}
}

extension UpdatePipelineStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePipelineStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
        } else {
            self.pipeline = nil
        }
    }
}

/// <p>When you update status for a pipeline,
///             Elastic Transcoder returns the values that you specified in the request.</p>
public struct UpdatePipelineStatusOutputResponse: Swift.Equatable {
    /// <p>A section of the response body that provides information about the pipeline.</p>
    public let pipeline: ElasticTranscoderClientTypes.Pipeline?

    public init (
        pipeline: ElasticTranscoderClientTypes.Pipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct UpdatePipelineStatusOutputResponseBody: Swift.Equatable {
    public let pipeline: ElasticTranscoderClientTypes.Pipeline?
}

extension UpdatePipelineStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline = "Pipeline"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(ElasticTranscoderClientTypes.Pipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more required parameter values were not provided in the request.</p>
public struct ValidationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticTranscoderClientTypes.VideoParameters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aspectRatio = "AspectRatio"
        case bitRate = "BitRate"
        case codec = "Codec"
        case codecOptions = "CodecOptions"
        case displayAspectRatio = "DisplayAspectRatio"
        case fixedGOP = "FixedGOP"
        case frameRate = "FrameRate"
        case keyframesMaxDist = "KeyframesMaxDist"
        case maxFrameRate = "MaxFrameRate"
        case maxHeight = "MaxHeight"
        case maxWidth = "MaxWidth"
        case paddingPolicy = "PaddingPolicy"
        case resolution = "Resolution"
        case sizingPolicy = "SizingPolicy"
        case watermarks = "Watermarks"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aspectRatio = aspectRatio {
            try encodeContainer.encode(aspectRatio, forKey: .aspectRatio)
        }
        if let bitRate = bitRate {
            try encodeContainer.encode(bitRate, forKey: .bitRate)
        }
        if let codec = codec {
            try encodeContainer.encode(codec, forKey: .codec)
        }
        if let codecOptions = codecOptions {
            var codecOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .codecOptions)
            for (dictKey0, codecoptions0) in codecOptions {
                try codecOptionsContainer.encode(codecoptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let displayAspectRatio = displayAspectRatio {
            try encodeContainer.encode(displayAspectRatio, forKey: .displayAspectRatio)
        }
        if let fixedGOP = fixedGOP {
            try encodeContainer.encode(fixedGOP, forKey: .fixedGOP)
        }
        if let frameRate = frameRate {
            try encodeContainer.encode(frameRate, forKey: .frameRate)
        }
        if let keyframesMaxDist = keyframesMaxDist {
            try encodeContainer.encode(keyframesMaxDist, forKey: .keyframesMaxDist)
        }
        if let maxFrameRate = maxFrameRate {
            try encodeContainer.encode(maxFrameRate, forKey: .maxFrameRate)
        }
        if let maxHeight = maxHeight {
            try encodeContainer.encode(maxHeight, forKey: .maxHeight)
        }
        if let maxWidth = maxWidth {
            try encodeContainer.encode(maxWidth, forKey: .maxWidth)
        }
        if let paddingPolicy = paddingPolicy {
            try encodeContainer.encode(paddingPolicy, forKey: .paddingPolicy)
        }
        if let resolution = resolution {
            try encodeContainer.encode(resolution, forKey: .resolution)
        }
        if let sizingPolicy = sizingPolicy {
            try encodeContainer.encode(sizingPolicy, forKey: .sizingPolicy)
        }
        if let watermarks = watermarks {
            var watermarksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .watermarks)
            for presetwatermarks0 in watermarks {
                try watermarksContainer.encode(presetwatermarks0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codec)
        codec = codecDecoded
        let codecOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .codecOptions)
        var codecOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let codecOptionsContainer = codecOptionsContainer {
            codecOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, codecoption0) in codecOptionsContainer {
                if let codecoption0 = codecoption0 {
                    codecOptionsDecoded0?[key0] = codecoption0
                }
            }
        }
        codecOptions = codecOptionsDecoded0
        let keyframesMaxDistDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyframesMaxDist)
        keyframesMaxDist = keyframesMaxDistDecoded
        let fixedGOPDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fixedGOP)
        fixedGOP = fixedGOPDecoded
        let bitRateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bitRate)
        bitRate = bitRateDecoded
        let frameRateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameRate)
        frameRate = frameRateDecoded
        let maxFrameRateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxFrameRate)
        maxFrameRate = maxFrameRateDecoded
        let resolutionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolution)
        resolution = resolutionDecoded
        let aspectRatioDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aspectRatio)
        aspectRatio = aspectRatioDecoded
        let maxWidthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxWidth)
        maxWidth = maxWidthDecoded
        let maxHeightDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxHeight)
        maxHeight = maxHeightDecoded
        let displayAspectRatioDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayAspectRatio)
        displayAspectRatio = displayAspectRatioDecoded
        let sizingPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sizingPolicy)
        sizingPolicy = sizingPolicyDecoded
        let paddingPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paddingPolicy)
        paddingPolicy = paddingPolicyDecoded
        let watermarksContainer = try containerValues.decodeIfPresent([ElasticTranscoderClientTypes.PresetWatermark?].self, forKey: .watermarks)
        var watermarksDecoded0:[ElasticTranscoderClientTypes.PresetWatermark]? = nil
        if let watermarksContainer = watermarksContainer {
            watermarksDecoded0 = [ElasticTranscoderClientTypes.PresetWatermark]()
            for structure0 in watermarksContainer {
                if let structure0 = structure0 {
                    watermarksDecoded0?.append(structure0)
                }
            }
        }
        watermarks = watermarksDecoded0
    }
}

extension ElasticTranscoderClientTypes.VideoParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VideoParameters(aspectRatio: \(Swift.String(describing: aspectRatio)), bitRate: \(Swift.String(describing: bitRate)), codec: \(Swift.String(describing: codec)), codecOptions: \(Swift.String(describing: codecOptions)), displayAspectRatio: \(Swift.String(describing: displayAspectRatio)), fixedGOP: \(Swift.String(describing: fixedGOP)), frameRate: \(Swift.String(describing: frameRate)), keyframesMaxDist: \(Swift.String(describing: keyframesMaxDist)), maxFrameRate: \(Swift.String(describing: maxFrameRate)), maxHeight: \(Swift.String(describing: maxHeight)), maxWidth: \(Swift.String(describing: maxWidth)), paddingPolicy: \(Swift.String(describing: paddingPolicy)), resolution: \(Swift.String(describing: resolution)), sizingPolicy: \(Swift.String(describing: sizingPolicy)), watermarks: \(Swift.String(describing: watermarks)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>The <code>VideoParameters</code> structure.</p>
    public struct VideoParameters: Swift.Equatable {
        /// <important>
        ///             <p>To better control resolution and aspect ratio of output videos, we recommend that you
        ///                 use the values <code>MaxWidth</code>, <code>MaxHeight</code>,
        ///                     <code>SizingPolicy</code>, <code>PaddingPolicy</code>, and
        ///                     <code>DisplayAspectRatio</code> instead of <code>Resolution</code> and
        ///                     <code>AspectRatio</code>. The two groups of settings are mutually exclusive. Do
        ///                 not use them together.</p>
        ///         </important>
        ///         <p>The display aspect ratio of the video in the output file. Valid values include:</p>
        ///         <p>
        ///             <code>auto</code>, <code>1:1</code>, <code>4:3</code>, <code>3:2</code>,
        ///                 <code>16:9</code>
        ///          </p>
        ///         <p>If you specify <code>auto</code>, Elastic Transcoder tries to preserve the aspect ratio of the input
        ///             file.</p>
        ///         <p>If you specify an aspect ratio for the output file that differs from aspect ratio
        ///             of the input file, Elastic Transcoder adds pillarboxing (black bars on the sides) or letterboxing
        ///             (black bars on the top and bottom) to maintain the aspect ratio of the active region
        ///             of the video.</p>
        public let aspectRatio: Swift.String?
        /// <p>The bit rate of the video stream in the output file, in kilobits/second. Valid values
        ///             depend on the values of <code>Level</code> and <code>Profile</code>. If you specify
        ///                 <code>auto</code>, Elastic Transcoder uses the detected bit rate of the input source. If you
        ///             specify a value other than <code>auto</code>, we recommend that you specify a value less
        ///             than or equal to the maximum H.264-compliant value listed for your level and
        ///             profile:</p>
        ///         <p>
        ///             <i>Level - Maximum video bit rate in kilobits/second (baseline and main Profile) :
        ///                 maximum video bit rate in kilobits/second (high Profile)</i>
        ///         </p>
        ///         <ul>
        ///             <li>
        ///                <p>1 - 64 : 80</p>
        ///             </li>
        ///             <li>
        ///                <p>1b - 128 : 160</p>
        ///             </li>
        ///             <li>
        ///                <p>1.1 - 192 : 240</p>
        ///             </li>
        ///             <li>
        ///                <p>1.2 - 384 : 480</p>
        ///             </li>
        ///             <li>
        ///                <p>1.3 - 768 : 960</p>
        ///             </li>
        ///             <li>
        ///                <p>2 - 2000 : 2500</p>
        ///             </li>
        ///             <li>
        ///                <p>3 - 10000 : 12500</p>
        ///             </li>
        ///             <li>
        ///                <p>3.1 - 14000 : 17500</p>
        ///             </li>
        ///             <li>
        ///                <p>3.2 - 20000 : 25000</p>
        ///             </li>
        ///             <li>
        ///                <p>4 - 20000 : 25000</p>
        ///             </li>
        ///             <li>
        ///                <p>4.1 - 50000 : 62500</p>
        ///             </li>
        ///          </ul>
        public let bitRate: Swift.String?
        /// <p>The video codec for the output file. Valid values include <code>gif</code>,
        ///                 <code>H.264</code>, <code>mpeg2</code>, <code>vp8</code>, and <code>vp9</code>.
        ///                 You can only specify <code>vp8</code> and <code>vp9</code> when the container type is
        ///                 <code>webm</code>, <code>gif</code> when the container type is <code>gif</code>,
        ///                 and <code>mpeg2</code> when the container type is <code>mpg</code>.</p>
        public let codec: Swift.String?
        /// <p>
        ///             <b>Profile (H.264/VP8/VP9 Only)</b>
        ///         </p>
        ///         <p>The H.264 profile that you want to use for the output file. Elastic Transcoder supports the following profiles:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>baseline</code>: The profile most commonly used for videoconferencing and for
        ///                 mobile applications.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>main</code>: The profile used for standard-definition digital TV
        ///                 broadcasts.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>high</code>: The profile used for high-definition digital TV broadcasts and
        ///                 for Blu-ray discs.</p>
        ///             </li>
        ///          </ul>
        ///         <p>
        ///             <b>Level (H.264 Only)</b>
        ///         </p>
        ///         <p>The H.264 level that you want to use for the output file. Elastic Transcoder supports the following levels:</p>
        ///         <p>
        ///             <code>1</code>, <code>1b</code>, <code>1.1</code>, <code>1.2</code>, <code>1.3</code>,
        ///                 <code>2</code>, <code>2.1</code>, <code>2.2</code>, <code>3</code>,
        ///             <code>3.1</code>, <code>3.2</code>, <code>4</code>, <code>4.1</code>
        ///          </p>
        ///         <p>
        ///             <b>MaxReferenceFrames (H.264 Only)</b>
        ///         </p>
        ///         <p>Applicable only when the value of Video:Codec is H.264. The maximum number of
        ///             previously decoded frames to use as a reference for decoding future frames. Valid
        ///             values are integers 0 through 16, but we recommend that you not use a value greater
        ///             than the following:</p>
        ///         <p>
        ///             <code>Min(Floor(Maximum decoded picture buffer in macroblocks * 256 / (Width in pixels *
        ///                 Height in pixels)), 16)</code>
        ///         </p>
        ///         <p>where <i>Width in pixels</i> and <i>Height in pixels</i> represent either MaxWidth and
        ///             MaxHeight, or Resolution. <i>Maximum decoded picture buffer in macroblocks</i> depends
        ///             on the value of the <code>Level</code> object. See the list below. (A macroblock is a
        ///             block of pixels measuring 16x16.) </p>
        ///         <ul>
        ///             <li>
        ///                <p>1 - 396</p>
        ///             </li>
        ///             <li>
        ///                <p>1b - 396</p>
        ///             </li>
        ///             <li>
        ///                <p>1.1 - 900</p>
        ///             </li>
        ///             <li>
        ///                <p>1.2 - 2376</p>
        ///             </li>
        ///             <li>
        ///                <p>1.3 - 2376</p>
        ///             </li>
        ///             <li>
        ///                <p>2 - 2376</p>
        ///             </li>
        ///             <li>
        ///                <p>2.1 - 4752</p>
        ///             </li>
        ///             <li>
        ///                <p>2.2 - 8100</p>
        ///             </li>
        ///             <li>
        ///                <p>3 - 8100</p>
        ///             </li>
        ///             <li>
        ///                <p>3.1 - 18000</p>
        ///             </li>
        ///             <li>
        ///                <p>3.2 - 20480</p>
        ///             </li>
        ///             <li>
        ///                <p>4 - 32768</p>
        ///             </li>
        ///             <li>
        ///                <p>4.1 - 32768</p>
        ///             </li>
        ///          </ul>
        ///         <p>
        ///             <b>MaxBitRate (Optional, H.264/MPEG2/VP8/VP9 only)</b>
        ///         </p>
        ///         <p>The maximum number of bits per second in a video buffer; the size of the buffer is
        ///             specified by <code>BufferSize</code>. Specify a value between 16 and 62,500. You can
        ///             reduce the bandwidth required to stream a video by reducing the maximum bit rate, but
        ///             this also reduces the quality of the video.</p>
        ///         <p>
        ///             <b>BufferSize (Optional, H.264/MPEG2/VP8/VP9 only)</b>
        ///         </p>
        ///         <p>The maximum number of bits in any x seconds of the output video. This window is commonly
        ///             10 seconds, the standard segment duration when you're using FMP4 or MPEG-TS for the container
        ///             type of the output video. Specify an integer greater than 0. If you specify
        ///                 <code>MaxBitRate</code> and omit <code>BufferSize</code>, Elastic Transcoder sets
        ///                 <code>BufferSize</code> to 10 times the value of <code>MaxBitRate</code>.</p>
        ///         <p>
        ///             <b>InterlacedMode (Optional, H.264/MPEG2 Only)</b>
        ///         </p>
        ///         <p>The interlace mode for the output video.</p>
        ///         <p>Interlaced video is used to double the perceived frame rate for a video by interlacing
        ///             two fields (one field on every other line, the other field on the other lines) so that the
        ///             human eye registers multiple pictures per frame. Interlacing reduces the bandwidth required
        ///             for transmitting a video, but can result in blurred images and flickering.</p>
        ///         <p>Valid values include <code>Progressive</code> (no interlacing, top to bottom),
        ///             <code>TopFirst</code> (top field first), <code>BottomFirst</code> (bottom field
        ///             first), and <code>Auto</code>.</p>
        ///         <p>If <code>InterlaceMode</code> is not specified, Elastic Transcoder uses <code>Progressive</code> for the output. If
        ///             <code>Auto</code> is specified, Elastic Transcoder interlaces the output.</p>
        ///         <p>
        ///             <b>ColorSpaceConversionMode (Optional, H.264/MPEG2 Only)</b>
        ///         </p>
        ///         <p>The color space conversion Elastic Transcoder applies to the output video. Color spaces are the algorithms
        ///             used by the computer to store information about how to render color. <code>Bt.601</code> is the
        ///             standard for standard definition video, while <code>Bt.709</code> is the standard for high definition
        ///             video.</p>
        ///         <p>Valid values include <code>None</code>,
        ///             <code>Bt709toBt601</code>, <code>Bt601toBt709</code>, and <code>Auto</code>.</p>
        ///         <p>If you chose <code>Auto</code> for <code>ColorSpaceConversionMode</code> and your output
        ///             is interlaced, your frame rate is one of <code>23.97</code>, <code>24</code>,
        ///             <code>25</code>, <code>29.97</code>, <code>50</code>, or <code>60</code>, your
        ///             <code>SegmentDuration</code> is null, and you are using one of the resolution
        ///             changes from the list below, Elastic Transcoder applies the following color space
        ///             conversions:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <i>Standard to HD, 720x480 to 1920x1080</i> - Elastic Transcoder applies <code>Bt601ToBt709</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <i>Standard to HD, 720x576 to 1920x1080</i> - Elastic Transcoder applies <code>Bt601ToBt709</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <i>HD to Standard, 1920x1080 to 720x480</i> - Elastic Transcoder applies <code>Bt709ToBt601</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <i>HD to Standard, 1920x1080 to 720x576</i> - Elastic Transcoder applies <code>Bt709ToBt601</code>
        ///                </p>
        ///             </li>
        ///          </ul>
        ///         <note>
        ///             <p>Elastic Transcoder may change the behavior of the <code>ColorspaceConversionMode</code>
        ///                <code>Auto</code> mode in the future. All outputs in a playlist must use the same
        ///             <code>ColorSpaceConversionMode</code>.</p>
        ///          </note>
        ///         <p>If you do not specify a <code>ColorSpaceConversionMode</code>, Elastic Transcoder does not change the
        ///             color space of a file. If you are unsure what <code>ColorSpaceConversionMode</code> was applied to
        ///             your output file, you can check the <code>AppliedColorSpaceConversion</code> parameter included in
        ///             your job response. If your job does not have an <code>AppliedColorSpaceConversion</code> in its
        ///             response, no <code>ColorSpaceConversionMode</code> was applied.</p>
        ///          <p>
        ///              <b>ChromaSubsampling</b>
        ///          </p>
        ///          <p>The sampling pattern for the chroma (color) channels of the output video.
        ///              Valid values include <code>yuv420p</code> and <code>yuv422p</code>.</p>
        ///          <p>
        ///             <code>yuv420p</code> samples the chroma information of every other horizontal and every other vertical
        ///              line, <code>yuv422p</code> samples the color information of every horizontal line and every other
        ///              vertical line.</p>
        ///
        ///          <p>
        ///              <b>LoopCount (Gif Only)</b>
        ///          </p>
        ///          <p>The number of times you want the output gif to loop. Valid values include <code>Infinite</code> and
        ///              integers between <code>0</code> and <code>100</code>, inclusive.</p>
        public let codecOptions: [Swift.String:Swift.String]?
        /// <p>The value that Elastic Transcoder adds to the metadata in the output file.</p>
        public let displayAspectRatio: Swift.String?
        /// <p>Applicable only when the value of Video:Codec is one of <code>H.264</code>, <code>MPEG2</code>,
        ///             or <code>VP8</code>.</p>
        ///         <p>Whether to use a fixed value for <code>FixedGOP</code>. Valid values are
        ///                 <code>true</code> and <code>false</code>:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>true</code>: Elastic Transcoder uses the value of <code>KeyframesMaxDist</code> for the
        ///                 distance between key frames (the number of frames in a group of pictures, or
        ///                 GOP).</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>false</code>: The distance between key frames can vary.</p>
        ///             </li>
        ///          </ul>
        ///         <important>
        ///             <p>
        ///                <code>FixedGOP</code> must be set to <code>true</code> for <code>fmp4</code> containers.</p>
        ///          </important>
        public let fixedGOP: Swift.String?
        /// <p>The frames per second for the video stream in the output file. Valid values include:</p>
        ///         <p>
        ///             <code>auto</code>, <code>10</code>, <code>15</code>, <code>23.97</code>, <code>24</code>,
        ///                 <code>25</code>, <code>29.97</code>, <code>30</code>, <code>60</code>
        ///          </p>
        ///         <p>If you specify <code>auto</code>, Elastic Transcoder uses the detected frame rate of the input source.
        ///             If you specify a frame rate, we recommend that you perform the following
        ///             calculation:</p>
        ///         <p>
        ///             <code>Frame rate = maximum recommended decoding speed in luma samples/second / (width in
        ///                 pixels * height in pixels)</code>
        ///         </p>
        ///         <p>where:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <i>width in pixels</i> and <i>height in pixels</i> represent the Resolution of the
        ///                 output video.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <i>maximum recommended decoding speed in Luma samples/second</i> is less than or
        ///                 equal to the maximum value listed in the following table, based on the value that
        ///                 you specified for Level.</p>
        ///             </li>
        ///          </ul>
        ///         <p>The maximum recommended decoding speed in Luma samples/second for each level is described
        ///             in the following list (<i>Level - Decoding speed</i>):</p>
        ///         <ul>
        ///             <li>
        ///                <p>1 - 380160</p>
        ///             </li>
        ///             <li>
        ///                <p>1b - 380160</p>
        ///             </li>
        ///             <li>
        ///                <p>1.1 - 76800</p>
        ///             </li>
        ///             <li>
        ///                <p>1.2 - 1536000</p>
        ///             </li>
        ///             <li>
        ///                <p>1.3 - 3041280</p>
        ///             </li>
        ///             <li>
        ///                <p>2 - 3041280</p>
        ///             </li>
        ///             <li>
        ///                <p>2.1 - 5068800</p>
        ///             </li>
        ///             <li>
        ///                <p>2.2 - 5184000</p>
        ///             </li>
        ///             <li>
        ///                <p>3 - 10368000</p>
        ///             </li>
        ///             <li>
        ///                <p>3.1 - 27648000</p>
        ///             </li>
        ///             <li>
        ///                <p>3.2 - 55296000</p>
        ///             </li>
        ///             <li>
        ///                <p>4 - 62914560</p>
        ///             </li>
        ///             <li>
        ///                <p>4.1 - 62914560</p>
        ///             </li>
        ///          </ul>
        public let frameRate: Swift.String?
        /// <p>Applicable only when the value of Video:Codec is one of <code>H.264</code>, <code>MPEG2</code>,
        ///             or <code>VP8</code>.</p>
        ///         <p>The maximum number of frames between key frames. Key frames are fully encoded frames;
        ///             the frames between key frames are encoded based, in part, on the content of the key frames.
        ///             The value is an integer formatted as a string; valid values are between 1 (every frame is a
        ///             key frame) and 100000, inclusive. A higher value results in higher compression but may also
        ///             discernibly decrease video quality.</p>
        ///         <p>For <code>Smooth</code> outputs, the <code>FrameRate</code> must have a constant ratio to the
        ///             <code>KeyframesMaxDist</code>. This allows <code>Smooth</code> playlists to switch between different quality levels
        ///             while the file is being played.</p>
        ///         <p>For example, an input file can have a <code>FrameRate</code> of
        ///             30 with a <code>KeyframesMaxDist</code> of 90. The output file then needs to have a ratio of 1:3.
        ///             Valid outputs would have <code>FrameRate</code> of 30, 25, and 10, and <code>KeyframesMaxDist</code>
        ///             of 90, 75, and 30, respectively.</p>
        ///         <p>Alternately, this can be achieved by setting <code>FrameRate</code>
        ///             to auto and having the same values for <code>MaxFrameRate</code> and <code>KeyframesMaxDist</code>.</p>
        public let keyframesMaxDist: Swift.String?
        /// <p>If you specify <code>auto</code> for <code>FrameRate</code>, Elastic Transcoder uses the frame rate of
        ///             the input video for the frame rate of the output video. Specify the maximum frame rate
        ///             that you want Elastic Transcoder to use when the frame rate of the input video is greater than the
        ///             desired maximum frame rate of the output video. Valid values include: <code>10</code>,
        ///                 <code>15</code>, <code>23.97</code>, <code>24</code>, <code>25</code>,
        ///                 <code>29.97</code>, <code>30</code>, <code>60</code>.</p>
        public let maxFrameRate: Swift.String?
        /// <p>The maximum height of the output video in pixels. If you specify <code>auto</code>, Elastic Transcoder
        ///             uses 1080 (Full HD) as the default value. If you specify a numeric value, enter an even
        ///             integer between 96 and 3072.</p>
        public let maxHeight: Swift.String?
        /// <p> The maximum width of the output video in pixels. If you specify <code>auto</code>, Elastic Transcoder
        ///             uses 1920 (Full HD) as the default value. If you specify a numeric value, enter an even
        ///             integer between 128 and 4096. </p>
        public let maxWidth: Swift.String?
        /// <p>When you set <code>PaddingPolicy</code> to <code>Pad</code>, Elastic Transcoder may add black bars to
        ///             the top and bottom and/or left and right sides of the output video to make the total
        ///             size of the output video match the values that you specified for <code>MaxWidth</code>
        ///             and <code>MaxHeight</code>.</p>
        public let paddingPolicy: Swift.String?
        /// <important>
        ///             <p>To better control resolution and aspect ratio of output videos, we recommend that you
        ///                 use the values <code>MaxWidth</code>, <code>MaxHeight</code>,
        ///                     <code>SizingPolicy</code>, <code>PaddingPolicy</code>, and
        ///                     <code>DisplayAspectRatio</code> instead of <code>Resolution</code> and
        ///                     <code>AspectRatio</code>. The two groups of settings are mutually exclusive. Do
        ///                 not use them together.</p>
        ///         </important>
        ///         <p>The width and height of the video in the output file, in pixels. Valid values are
        ///                 <code>auto</code> and <i>width</i> x <i>height</i>:</p>
        ///         <ul>
        ///             <li>
        ///                <p>
        ///                   <code>auto</code>: Elastic Transcoder attempts to preserve the width and height of the input file,
        ///                 subject to the following rules.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>
        ///                      <i>width</i> x <i>height</i>
        ///                   </code>: The width and height of the output video
        ///                 in pixels.</p>
        ///             </li>
        ///          </ul>
        ///         <p>Note the following about specifying the width and height:</p>
        ///         <ul>
        ///             <li>
        ///                <p>The width must be an even integer between 128 and 4096, inclusive.</p>
        ///             </li>
        ///             <li>
        ///                <p>The height must be an even integer between 96 and 3072, inclusive.</p>
        ///             </li>
        ///             <li>
        ///                <p>If you specify a resolution that is less than the resolution of the input file, Elastic Transcoder
        ///                 rescales the output file to the lower resolution.</p>
        ///             </li>
        ///             <li>
        ///                <p>If you specify a resolution that is greater than the resolution of the input file,
        ///                 Elastic Transcoder rescales the output to the higher resolution.</p>
        ///             </li>
        ///             <li>
        ///                <p>We recommend that you specify a resolution for which the product of width and height
        ///                 is less than or equal to the applicable value in the following list (<i>List - Max
        ///                     width x height value</i>):</p>
        ///                <ul>
        ///                   <li>
        ///                      <p>1 - 25344</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>1b - 25344</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>1.1 - 101376</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>1.2 - 101376</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>1.3 - 101376</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>2 - 101376</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>2.1 - 202752</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>2.2 - 404720</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>3 - 404720</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>3.1 - 921600</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>3.2 - 1310720</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>4 - 2097152</p>
        ///                   </li>
        ///                   <li>
        ///                      <p>4.1 - 2097152</p>
        ///                   </li>
        ///                </ul>
        /// 			         </li>
        ///          </ul>
        public let resolution: Swift.String?
        /// <p>Specify one of the following values to control scaling of the output video:</p>
        ///
        ///             <ul>
        ///             <li>
        ///                <p>
        ///                   <code>Fit</code>: Elastic Transcoder scales the output video so it matches the value that you
        ///                     specified in either <code>MaxWidth</code> or <code>MaxHeight</code> without
        ///                     exceeding the other value.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Fill</code>: Elastic Transcoder scales the output video so it matches the value that you
        ///                     specified in either <code>MaxWidth</code> or <code>MaxHeight</code> and matches
        ///                     or exceeds the other value. Elastic Transcoder centers the output video and then crops it in
        ///                     the dimension (if any) that exceeds the maximum value.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Stretch</code>: Elastic Transcoder stretches the output video to match the values that
        ///                     you specified for <code>MaxWidth</code> and <code>MaxHeight</code>. If the
        ///                     relative proportions of the input video and the output video are different, the
        ///                     output video will be distorted.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>Keep</code>: Elastic Transcoder does not scale the output video. If either
        ///                     dimension of the input video exceeds the values that you specified for
        ///                         <code>MaxWidth</code> and <code>MaxHeight</code>, Elastic Transcoder crops the output
        ///                     video.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>ShrinkToFit</code>: Elastic Transcoder scales the output video down so that its
        ///                     dimensions match the values that you specified for at least one of
        ///                         <code>MaxWidth</code> and <code>MaxHeight</code> without exceeding either
        ///                     value. If you specify this option, Elastic Transcoder does not scale the video up.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>ShrinkToFill</code>: Elastic Transcoder scales the output video down so that its
        ///                     dimensions match the values that you specified for at least one of
        ///                         <code>MaxWidth</code> and <code>MaxHeight</code> without dropping below
        ///                     either value. If you specify this option, Elastic Transcoder does not scale the video up.</p>
        ///             </li>
        ///          </ul>
        public let sizingPolicy: Swift.String?
        /// <p>Settings for the size, location, and opacity of graphics that you want Elastic Transcoder to overlay
        ///             over videos that are transcoded using this preset. You can specify settings for up to four
        ///             watermarks. Watermarks appear in the specified size and location, and with the specified
        ///             opacity for the duration of the transcoded video.</p>
        ///         <p>Watermarks can be in .png or .jpg format. If you want to display a watermark that is not
        ///             rectangular, use the .png format, which supports transparency.</p>
        ///         <p>When you create a job that uses this preset, you specify the .png or .jpg graphics that
        ///             you want Elastic Transcoder to include in the transcoded videos. You can specify fewer graphics in the job
        ///             than you specify watermark settings in the preset, which allows you to use the same preset
        ///             for up to four watermarks that have different dimensions.</p>
        public let watermarks: [ElasticTranscoderClientTypes.PresetWatermark]?

        public init (
            aspectRatio: Swift.String? = nil,
            bitRate: Swift.String? = nil,
            codec: Swift.String? = nil,
            codecOptions: [Swift.String:Swift.String]? = nil,
            displayAspectRatio: Swift.String? = nil,
            fixedGOP: Swift.String? = nil,
            frameRate: Swift.String? = nil,
            keyframesMaxDist: Swift.String? = nil,
            maxFrameRate: Swift.String? = nil,
            maxHeight: Swift.String? = nil,
            maxWidth: Swift.String? = nil,
            paddingPolicy: Swift.String? = nil,
            resolution: Swift.String? = nil,
            sizingPolicy: Swift.String? = nil,
            watermarks: [ElasticTranscoderClientTypes.PresetWatermark]? = nil
        )
        {
            self.aspectRatio = aspectRatio
            self.bitRate = bitRate
            self.codec = codec
            self.codecOptions = codecOptions
            self.displayAspectRatio = displayAspectRatio
            self.fixedGOP = fixedGOP
            self.frameRate = frameRate
            self.keyframesMaxDist = keyframesMaxDist
            self.maxFrameRate = maxFrameRate
            self.maxHeight = maxHeight
            self.maxWidth = maxWidth
            self.paddingPolicy = paddingPolicy
            self.resolution = resolution
            self.sizingPolicy = sizingPolicy
            self.watermarks = watermarks
        }
    }

}

extension ElasticTranscoderClientTypes.Warning: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ElasticTranscoderClientTypes.Warning: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Warning(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension ElasticTranscoderClientTypes {
    /// <p>Elastic Transcoder returns a warning if the resources used by your pipeline are not in the same region
    ///             as the pipeline.</p>
    ///         <p>Using resources in the same region, such as your Amazon S3 buckets, Amazon SNS notification topics,
    ///             and AWS KMS key, reduces processing time and prevents cross-regional charges.</p>
    public struct Warning: Swift.Equatable {
        /// <p>The code of the cross-regional warning.</p>
        public let code: Swift.String?
        /// <p>The message explaining what resources are in a different region from the pipeline.</p>
        ///         <note>
        ///             <p>AWS KMS keys must be in the same region as the pipeline.</p>
        ///          </note>
        public let message: Swift.String?

        public init (
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}
