// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>General authentication failure. The request was not signed correctly.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Artwork: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case albumArtFormat = "AlbumArtFormat"
        case encryption = "Encryption"
        case inputKey = "InputKey"
        case maxHeight = "MaxHeight"
        case maxWidth = "MaxWidth"
        case paddingPolicy = "PaddingPolicy"
        case sizingPolicy = "SizingPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let albumArtFormat = albumArtFormat {
            try encodeContainer.encode(albumArtFormat, forKey: .albumArtFormat)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let inputKey = inputKey {
            try encodeContainer.encode(inputKey, forKey: .inputKey)
        }
        if let maxHeight = maxHeight {
            try encodeContainer.encode(maxHeight, forKey: .maxHeight)
        }
        if let maxWidth = maxWidth {
            try encodeContainer.encode(maxWidth, forKey: .maxWidth)
        }
        if let paddingPolicy = paddingPolicy {
            try encodeContainer.encode(paddingPolicy, forKey: .paddingPolicy)
        }
        if let sizingPolicy = sizingPolicy {
            try encodeContainer.encode(sizingPolicy, forKey: .sizingPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputKey)
        inputKey = inputKeyDecoded
        let maxWidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxWidth)
        maxWidth = maxWidthDecoded
        let maxHeightDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxHeight)
        maxHeight = maxHeightDecoded
        let sizingPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sizingPolicy)
        sizingPolicy = sizingPolicyDecoded
        let paddingPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paddingPolicy)
        paddingPolicy = paddingPolicyDecoded
        let albumArtFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .albumArtFormat)
        albumArtFormat = albumArtFormatDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
    }
}

extension Artwork: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Artwork(albumArtFormat: \(String(describing: albumArtFormat)), encryption: \(String(describing: encryption)), inputKey: \(String(describing: inputKey)), maxHeight: \(String(describing: maxHeight)), maxWidth: \(String(describing: maxWidth)), paddingPolicy: \(String(describing: paddingPolicy)), sizingPolicy: \(String(describing: sizingPolicy)))"}
}

/// <p>The file to be used as album art. There can be multiple artworks associated with an
///             audio file, to a maximum of 20.</p>
///         <p>To remove artwork or leave the artwork empty, you can either set <code>Artwork</code>
///             to null, or set the <code>Merge Policy</code> to "Replace" and use an empty
///             <code>Artwork</code> array.</p>
///         <p>To pass through existing artwork unchanged, set the <code>Merge Policy</code> to
///             "Prepend", "Append", or "Fallback", and use an empty <code>Artwork</code> array.</p>
public struct Artwork: Equatable {
    /// <p>The format of album art, if any. Valid formats are <code>.jpg</code> and <code>.png</code>.</p>
    public let albumArtFormat: String?
    /// <p>The encryption settings, if any, that you want Elastic Transcoder to apply to your artwork.</p>
    public let encryption: Encryption?
    /// <p>The name of the file to be used as album art. To determine which Amazon S3 bucket contains the
    ///             specified file, Elastic Transcoder checks the pipeline specified by <code>PipelineId</code>; the
    ///             <code>InputBucket</code> object in that pipeline identifies the bucket.</p>
    ///         <p>If the file name includes a prefix, for example, <code>cooking/pie.jpg</code>,
    ///             include the prefix in the key. If the file isn't in the specified bucket,
    ///             Elastic Transcoder returns an error.</p>
    public let inputKey: String?
    /// <p>The maximum height of the output album art in pixels. If you specify <code>auto</code>, Elastic Transcoder
    ///         uses 600 as the default value. If you specify a numeric value, enter an even integer between 32
    ///         and 3072, inclusive.</p>
    public let maxHeight: String?
    /// <p>The maximum width of the output album art in pixels. If you specify <code>auto</code>, Elastic Transcoder
    ///         uses 600 as the default value. If you specify a numeric value, enter an even integer between 32
    ///         and 4096, inclusive.</p>
    public let maxWidth: String?
    /// <p>When you set <code>PaddingPolicy</code> to <code>Pad</code>, Elastic Transcoder may add white bars to the
    ///         top and bottom and/or left and right sides of the output album art to make the total size of
    ///         the output art match the values that you specified for <code>MaxWidth</code> and
    ///         <code>MaxHeight</code>.</p>
    public let paddingPolicy: String?
    /// <p>Specify one of the following values to control scaling of the output album art:</p>
    ///
    ///             <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Fit:</code> Elastic Transcoder scales the output art so it matches the value that you
    ///                     specified in either <code>MaxWidth</code> or <code>MaxHeight</code> without
    ///                     exceeding the other value.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Fill:</code> Elastic Transcoder scales the output art so it matches the value that you
    ///                     specified in either <code>MaxWidth</code> or <code>MaxHeight</code> and matches or
    ///                     exceeds the other value. Elastic Transcoder centers the output art and then crops it in the
    ///                     dimension (if any) that exceeds the maximum value. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Stretch:</code> Elastic Transcoder stretches the output art to match the values that you
    ///                     specified for <code>MaxWidth</code> and <code>MaxHeight</code>. If the relative
    ///                     proportions of the input art and the output art are different, the output art will
    ///                     be distorted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Keep:</code> Elastic Transcoder does not scale the output art. If either dimension of the
    ///                     input art exceeds the values that you specified for <code>MaxWidth</code> and
    ///                     <code>MaxHeight</code>, Elastic Transcoder crops the output art.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ShrinkToFit:</code> Elastic Transcoder scales the output art down so that its dimensions
    ///                     match the values that you specified for at least one of <code>MaxWidth</code> and
    ///                     <code>MaxHeight</code> without exceeding either value. If you specify this option,
    ///                     Elastic Transcoder does not scale the art up.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ShrinkToFill</code> Elastic Transcoder scales the output art down so that its dimensions
    ///                     match the values that you specified for at least one of <code>MaxWidth</code> and
    ///                     <code>MaxHeight</code> without dropping below either value. If you specify this
    ///                     option, Elastic Transcoder does not scale the art up.</p>
    ///             </li>
    ///          </ul>
    public let sizingPolicy: String?

    public init (
        albumArtFormat: String? = nil,
        encryption: Encryption? = nil,
        inputKey: String? = nil,
        maxHeight: String? = nil,
        maxWidth: String? = nil,
        paddingPolicy: String? = nil,
        sizingPolicy: String? = nil
    )
    {
        self.albumArtFormat = albumArtFormat
        self.encryption = encryption
        self.inputKey = inputKey
        self.maxHeight = maxHeight
        self.maxWidth = maxWidth
        self.paddingPolicy = paddingPolicy
        self.sizingPolicy = sizingPolicy
    }
}

extension AudioCodecOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bitDepth = "BitDepth"
        case bitOrder = "BitOrder"
        case profile = "Profile"
        case signed = "Signed"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bitDepth = bitDepth {
            try encodeContainer.encode(bitDepth, forKey: .bitDepth)
        }
        if let bitOrder = bitOrder {
            try encodeContainer.encode(bitOrder, forKey: .bitOrder)
        }
        if let profile = profile {
            try encodeContainer.encode(profile, forKey: .profile)
        }
        if let signed = signed {
            try encodeContainer.encode(signed, forKey: .signed)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profile)
        profile = profileDecoded
        let bitDepthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bitDepth)
        bitDepth = bitDepthDecoded
        let bitOrderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bitOrder)
        bitOrder = bitOrderDecoded
        let signedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signed)
        signed = signedDecoded
    }
}

extension AudioCodecOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AudioCodecOptions(bitDepth: \(String(describing: bitDepth)), bitOrder: \(String(describing: bitOrder)), profile: \(String(describing: profile)), signed: \(String(describing: signed)))"}
}

/// <p>Options associated with your audio codec.</p>
public struct AudioCodecOptions: Equatable {
    /// <p>You can only choose an audio bit depth when you specify <code>flac</code> or
    ///            <code>pcm</code> for the value of Audio:Codec.</p>
    ///         <p>The bit depth of a sample is how many bits of information are included in the
    ///             audio samples. The higher the bit depth, the better the audio, but the larger the file.</p>
    ///             <p>Valid values are <code>16</code> and <code>24</code>.</p>
    ///             <p>The most common bit depth is <code>24</code>.</p>
    public let bitDepth: String?
    /// <p>You can only choose an audio bit order when you specify
    ///            <code>pcm</code> for the value of Audio:Codec.</p>
    ///          <p>The order the bits of a PCM sample are stored in.</p>
    ///          <p>The supported value is <code>LittleEndian</code>.</p>
    public let bitOrder: String?
    /// <p>You can only choose an audio profile when you specify AAC for the value of Audio:Codec.</p>
    ///         <p>Specify the AAC profile for the output file. Elastic Transcoder supports the following profiles:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>auto</code>: If you specify <code>auto</code>, Elastic Transcoder selects
    ///                 the profile based on the bit rate selected for the output file.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AAC-LC</code>: The most common AAC profile. Use for bit rates larger than
    ///                 64 kbps.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HE-AAC</code>: Not supported on some older players and devices.
    ///                 Use for bit rates between 40 and 80 kbps.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HE-AACv2</code>: Not supported on some players and devices.
    ///                 Use for bit rates less than 48 kbps.</p>
    ///             </li>
    ///          </ul>
    ///         <p>All outputs in a <code>Smooth</code> playlist must have the same value for <code>Profile</code>.</p>
    ///         <note>
    ///             <p>If you created any presets before AAC profiles were added, Elastic Transcoder automatically updated your
    ///              presets to use AAC-LC. You can change the value as required.</p>
    ///          </note>
    public let profile: String?
    /// <p>You can only choose whether an audio sample is signed when you specify
    ///            <code>pcm</code> for the value of Audio:Codec.</p>
    ///         <p>Whether audio samples are represented with negative and positive numbers (signed) or
    ///             only positive numbers (unsigned).</p>
    ///         <p>The supported value is <code>Signed</code>.</p>
    public let signed: String?

    public init (
        bitDepth: String? = nil,
        bitOrder: String? = nil,
        profile: String? = nil,
        signed: String? = nil
    )
    {
        self.bitDepth = bitDepth
        self.bitOrder = bitOrder
        self.profile = profile
        self.signed = signed
    }
}

extension AudioParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case audioPackingMode = "AudioPackingMode"
        case bitRate = "BitRate"
        case channels = "Channels"
        case codec = "Codec"
        case codecOptions = "CodecOptions"
        case sampleRate = "SampleRate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioPackingMode = audioPackingMode {
            try encodeContainer.encode(audioPackingMode, forKey: .audioPackingMode)
        }
        if let bitRate = bitRate {
            try encodeContainer.encode(bitRate, forKey: .bitRate)
        }
        if let channels = channels {
            try encodeContainer.encode(channels, forKey: .channels)
        }
        if let codec = codec {
            try encodeContainer.encode(codec, forKey: .codec)
        }
        if let codecOptions = codecOptions {
            try encodeContainer.encode(codecOptions, forKey: .codecOptions)
        }
        if let sampleRate = sampleRate {
            try encodeContainer.encode(sampleRate, forKey: .sampleRate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codecDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codec)
        codec = codecDecoded
        let sampleRateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sampleRate)
        sampleRate = sampleRateDecoded
        let bitRateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bitRate)
        bitRate = bitRateDecoded
        let channelsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channels)
        channels = channelsDecoded
        let audioPackingModeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .audioPackingMode)
        audioPackingMode = audioPackingModeDecoded
        let codecOptionsDecoded = try containerValues.decodeIfPresent(AudioCodecOptions.self, forKey: .codecOptions)
        codecOptions = codecOptionsDecoded
    }
}

extension AudioParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AudioParameters(audioPackingMode: \(String(describing: audioPackingMode)), bitRate: \(String(describing: bitRate)), channels: \(String(describing: channels)), codec: \(String(describing: codec)), codecOptions: \(String(describing: codecOptions)), sampleRate: \(String(describing: sampleRate)))"}
}

/// <p>Parameters required for transcoding audio.</p>
public struct AudioParameters: Equatable {
    /// <p>The method of organizing audio channels and tracks. Use <code>Audio:Channels</code> to
    ///             specify the number of channels in your output, and <code>Audio:AudioPackingMode</code>
    ///             to specify the number of tracks and their relation to the channels. If you do not specify
    ///             an <code>Audio:AudioPackingMode</code>, Elastic Transcoder uses <code>SingleTrack</code>.</p>
    ///         <p>The following values are valid:</p>
    ///         <p>
    ///             <code>SingleTrack</code>, <code>OneChannelPerTrack</code>, and <code>OneChannelPerTrackWithMosTo8Tracks</code>
    ///          </p>
    ///
    ///         <p>When you specify <code>SingleTrack</code>, Elastic Transcoder creates a single track for your output.
    ///             The track can have up to eight channels. Use <code>SingleTrack</code> for all non-<code>mxf</code>
    ///             containers.</p>
    ///
    ///         <p>The outputs of <code>SingleTrack</code> for a specific channel value and inputs
    ///             are as follows:</p>
    ///
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>0</code>
    ///                   <b> channels with any input:</b> Audio omitted from the output</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>1, 2, or auto </code>
    ///                   <b>channels with no audio input:</b> Audio omitted from the output</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>1 </code>
    ///                   <b>channel with any input with audio:</b> One track with one channel, downmixed if necessary</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>2 </code>
    ///                   <b>channels with one track with one channel:</b> One track with two identical channels</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>2 or auto </code>
    ///                   <b>channels with two tracks with one channel each:</b> One track with two channels</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>2 or auto </code>
    ///                   <b>channels with one track with two channels:</b> One track with two channels</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>2 </code>
    ///                   <b>channels with one track with multiple channels:</b> One track with two channels</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>auto </code>
    ///                   <b>channels with one track with one channel:</b> One track with one channel</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>auto </code>
    ///                   <b>channels with one track with multiple channels:</b> One track with multiple channels</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>When you specify <code>OneChannelPerTrack</code>, Elastic Transcoder creates a new track for every channel in your output. Your output
    ///             can have up to eight single-channel tracks.</p>
    ///         <p>The outputs of <code>OneChannelPerTrack</code> for a specific channel value and inputs
    ///             are as follows:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>0 </code>
    ///                   <b>channels with any input:</b> Audio omitted from the output</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>1, 2, or auto </code>
    ///                   <b>channels with no audio input:</b> Audio omitted from the output</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>1 </code>
    ///                   <b>channel with any input with audio:</b> One track with one channel, downmixed if necessary</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>2 </code>
    ///                   <b>channels with one track with one channel:</b> Two tracks with one identical channel each</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>2 or auto </code>
    ///                   <b>channels with two tracks with one channel each:</b> Two tracks with one channel each</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>2 or auto </code>
    ///                   <b>channels with one track with two channels:</b> Two tracks with one channel each</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>2 </code>
    ///                   <b>channels with one track with multiple channels:</b> Two tracks with one channel each</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>auto </code>
    ///                   <b>channels with one track with one channel:</b> One track with one channel</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>auto </code>
    ///                   <b>channels with one track with multiple channels:</b> Up to eight tracks with one channel each</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>When you specify <code>OneChannelPerTrackWithMosTo8Tracks</code>, Elastic Transcoder creates eight single-channel
    ///             tracks for your output. All tracks that do not contain audio data from an input channel are
    ///             MOS, or Mit Out Sound, tracks.</p>
    ///         <p>The outputs of <code>OneChannelPerTrackWithMosTo8Tracks</code> for a specific channel value and inputs
    ///             are as follows:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>0 </code>
    ///                   <b>channels with any input:</b> Audio omitted from the output</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>1, 2, or auto </code>
    ///                   <b>channels with no audio input:</b> Audio omitted from the output</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>1 </code>
    ///                   <b>channel with any input with audio:</b> One track with one channel,
    ///                    downmixed if necessary, plus six MOS tracks</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>2 </code>
    ///                   <b>channels with one track with one channel:</b> Two tracks with one
    ///                    identical channel each, plus six MOS tracks</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>2 or auto </code>
    ///                   <b>channels with two tracks with one channel each:</b> Two tracks with
    ///                    one channel each, plus six MOS tracks</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>2 or auto </code>
    ///                   <b>channels with one track with two channels:</b> Two tracks with one
    ///                    channel each, plus six MOS tracks</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>2 </code>
    ///                   <b>channels with one track with multiple channels:</b> Two tracks with
    ///                    one channel each, plus six MOS tracks</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>auto </code>
    ///                   <b>channels with one track with one channel:</b> One track with one
    ///                    channel, plus seven MOS tracks</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>auto </code>
    ///                   <b>channels with one track with multiple channels:</b> Up to eight
    ///                    tracks with one channel each, plus MOS tracks
    ///                 until there are eight tracks in all</p>
    ///             </li>
    ///          </ul>
    public let audioPackingMode: String?
    /// <p>The bit rate of the audio stream in the output file, in kilobits/second. Enter an integer
    ///             between 64 and 320, inclusive.</p>
    public let bitRate: String?
    /// <p>The number of audio channels in the output file. The following values are valid:</p>
    ///         <p>
    ///             <code>auto</code>, <code>0</code>, <code>1</code>, <code>2</code>
    ///          </p>
    ///         <p>One channel carries the information played by a single speaker. For example, a stereo
    ///             track with two channels sends one channel to the left speaker, and the other
    ///             channel to the right speaker. The output channels are organized into tracks.
    ///             If you want Elastic Transcoder to automatically detect the number
    ///             of audio channels in the input file and use that value for the output file, select
    ///             <code>auto</code>.</p>
    ///
    ///         <p>The output of a specific channel value and inputs are as follows:</p>
    ///
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>auto</code>
    ///                   <b> channel specified, with any input:</b> Pass through up to eight input channels.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>0</code>
    ///                   <b> channels specified, with any input:</b> Audio omitted from the output.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>1</code>
    ///                   <b> channel specified, with at least one input channel:</b> Mono sound.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>2</code>
    ///                   <b> channels specified, with any input:</b> Two identical mono channels or stereo. For more
    ///                 information about tracks, see <code>Audio:AudioPackingMode.</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p> For more information about how Elastic Transcoder organizes channels and tracks, see
    ///             <code>Audio:AudioPackingMode</code>.</p>
    public let channels: String?
    /// <p>The audio codec for the output file. Valid values include <code>aac</code>,
    ///             <code>flac</code>, <code>mp2</code>, <code>mp3</code>, <code>pcm</code>,
    ///             and <code>vorbis</code>.</p>
    public let codec: String?
    /// <p>If you specified <code>AAC</code> for <code>Audio:Codec</code>, this is the <code>AAC</code>
    ///             compression profile to use. Valid values include:</p>
    ///         <p>
    ///             <code>auto</code>, <code>AAC-LC</code>, <code>HE-AAC</code>, <code>HE-AACv2</code>
    ///          </p>
    ///         <p>If you specify <code>auto</code>, Elastic Transcoder chooses a profile based on the bit rate of the output file.</p>
    public let codecOptions: AudioCodecOptions?
    /// <p>The sample rate of the audio stream in the output file, in Hertz. Valid values include:</p>
    ///         <p>
    ///             <code>auto</code>, <code>22050</code>, <code>32000</code>, <code>44100</code>,
    ///                 <code>48000</code>, <code>96000</code>
    ///          </p>
    ///         <p>If you specify <code>auto</code>, Elastic Transcoder automatically detects the sample rate.</p>
    public let sampleRate: String?

    public init (
        audioPackingMode: String? = nil,
        bitRate: String? = nil,
        channels: String? = nil,
        codec: String? = nil,
        codecOptions: AudioCodecOptions? = nil,
        sampleRate: String? = nil
    )
    {
        self.audioPackingMode = audioPackingMode
        self.bitRate = bitRate
        self.channels = channels
        self.codec = codec
        self.codecOptions = codecOptions
        self.sampleRate = sampleRate
    }
}

extension CancelJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelJobInput(id: \(String(describing: id)))"}
}

extension CancelJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CancelJobInputHeadersMiddleware: Middleware {
    public let id: String = "CancelJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelJobInput>
    public typealias MOutput = OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelJobOutputError>
}

public struct CancelJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelJobInput>
    public typealias MOutput = OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelJobOutputError>
}

/// <p>The <code>CancelJobRequest</code> structure.</p>
public struct CancelJobInput: Equatable {
    /// <p>The identifier of the job that you want to cancel.</p>
    ///         <p>To get a list of the jobs (including their <code>jobId</code>) that have a status of
    ///                 <code>Submitted</code>, use the <a>ListJobsByStatus</a> API action.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct CancelJobInputBody: Equatable {
}

extension CancelJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CancelJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelJobOutputResponse()"}
}

extension CancelJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The response body contains a JSON object. If the job is successfully canceled, the value
///             of <code>Success</code> is <code>true</code>.</p>
public struct CancelJobOutputResponse: Equatable {

    public init() {}
}

struct CancelJobOutputResponseBody: Equatable {
}

extension CancelJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CaptionFormat: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryption = "Encryption"
        case format = "Format"
        case pattern = "Pattern"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let pattern = pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .format)
        format = formatDecoded
        let patternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pattern)
        pattern = patternDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
    }
}

extension CaptionFormat: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CaptionFormat(encryption: \(String(describing: encryption)), format: \(String(describing: format)), pattern: \(String(describing: pattern)))"}
}

/// <p>The file format of the output captions. If you leave this value blank, Elastic Transcoder returns an error.</p>
public struct CaptionFormat: Equatable {
    /// <p>The encryption settings, if any, that you want Elastic Transcoder to apply to your caption formats.</p>
    public let encryption: Encryption?
    /// <p>The format you specify determines whether Elastic Transcoder generates an embedded or sidecar caption for this output.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Valid Embedded Caption Formats:</b>
    ///                </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <b>for FLAC</b>: None</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>For MP3</b>: None</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>For MP4</b>: mov-text</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>For MPEG-TS</b>: None</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>For ogg</b>: None</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>For webm</b>: None</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Valid Sidecar Caption Formats:</b> Elastic Transcoder
    ///             supports dfxp (first div element only), scc, srt, and webvtt.
    ///             If you want ttml or smpte-tt
    ///             compatible captions, specify dfxp as your output format.</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <b>For FMP4</b>: dfxp</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>Non-FMP4 outputs</b>: All sidecar types</p>
    ///                   </li>
    ///                </ul>
    ///                <p>
    ///                   <code>fmp4</code> captions have an extension of <code>.ismt</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let format: String?
    /// <p>The prefix for caption filenames, in the form <i>description</i>-<code>{language}</code>, where:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <i>description</i> is a description of the video.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>{language}</code> is a literal value that Elastic Transcoder replaces with the two- or three-letter
    ///             code for the language of the caption in the output file names.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you don't include <code>{language}</code> in the file name pattern, Elastic Transcoder automatically
    ///          appends "<code>{language}</code>" to the value that you specify for the description.  In addition,
    ///          Elastic Transcoder automatically appends the count to the end of the segment files.</p>
    ///          <p>For example, suppose you're transcoding into srt format. When you enter "Sydney-{language}-sunrise",
    ///           and the language of the captions is English (en), the name of the first caption file is be
    ///           Sydney-en-sunrise00000.srt.</p>
    public let pattern: String?

    public init (
        encryption: Encryption? = nil,
        format: String? = nil,
        pattern: String? = nil
    )
    {
        self.encryption = encryption
        self.format = format
        self.pattern = pattern
    }
}

extension CaptionSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryption = "Encryption"
        case key = "Key"
        case label = "Label"
        case language = "Language"
        case timeOffset = "TimeOffset"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let language = language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let timeOffset = timeOffset {
            try encodeContainer.encode(timeOffset, forKey: .timeOffset)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let languageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .language)
        language = languageDecoded
        let timeOffsetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeOffset)
        timeOffset = timeOffsetDecoded
        let labelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .label)
        label = labelDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
    }
}

extension CaptionSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CaptionSource(encryption: \(String(describing: encryption)), key: \(String(describing: key)), label: \(String(describing: label)), language: \(String(describing: language)), timeOffset: \(String(describing: timeOffset)))"}
}

/// <p>A source file for the input sidecar captions used during the transcoding process.</p>
public struct CaptionSource: Equatable {
    /// <p>The encryption settings, if any, that Elastic Transcoder needs to decyrpt your caption sources, or that you
    ///             want Elastic Transcoder to apply to your caption sources.</p>
    public let encryption: Encryption?
    /// <p>The name of the sidecar caption file that you want Elastic Transcoder to include in the output file.</p>
    public let key: String?
    /// <p>The label of the caption shown in the player when choosing a language. We recommend that you
    ///             put the caption language name here, in the language of the captions.</p>
    public let label: String?
    /// <p>A string that specifies the language of the caption. If you specified multiple inputs with captions,
    ///             the caption language must match in order to be included in the output. Specify this as one of:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>2-character ISO 639-1 code</p>
    ///             </li>
    ///             <li>
    ///                 <p>3-character ISO 639-2 code</p>
    ///             </li>
    ///          </ul>
    ///         <p>For more information on ISO language codes and language names, see the List of ISO 639-1 codes.</p>
    public let language: String?
    /// <p>For clip generation or captions that do not start at the same time
    ///             as the associated video file, the <code>TimeOffset</code> tells Elastic Transcoder how much of the video to encode
    ///             before including captions.</p>
    ///         <p>Specify the TimeOffset in the form [+-]SS.sss or [+-]HH:mm:SS.ss.</p>
    public let timeOffset: String?

    public init (
        encryption: Encryption? = nil,
        key: String? = nil,
        label: String? = nil,
        language: String? = nil,
        timeOffset: String? = nil
    )
    {
        self.encryption = encryption
        self.key = key
        self.label = label
        self.language = language
        self.timeOffset = timeOffset
    }
}

extension Captions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case captionFormats = "CaptionFormats"
        case captionSources = "CaptionSources"
        case mergePolicy = "MergePolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let captionFormats = captionFormats {
            var captionFormatsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .captionFormats)
            for captionformats0 in captionFormats {
                try captionFormatsContainer.encode(captionformats0)
            }
        }
        if let captionSources = captionSources {
            var captionSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .captionSources)
            for captionsources0 in captionSources {
                try captionSourcesContainer.encode(captionsources0)
            }
        }
        if let mergePolicy = mergePolicy {
            try encodeContainer.encode(mergePolicy, forKey: .mergePolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mergePolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mergePolicy)
        mergePolicy = mergePolicyDecoded
        let captionSourcesContainer = try containerValues.decodeIfPresent([CaptionSource?].self, forKey: .captionSources)
        var captionSourcesDecoded0:[CaptionSource]? = nil
        if let captionSourcesContainer = captionSourcesContainer {
            captionSourcesDecoded0 = [CaptionSource]()
            for structure0 in captionSourcesContainer {
                if let structure0 = structure0 {
                    captionSourcesDecoded0?.append(structure0)
                }
            }
        }
        captionSources = captionSourcesDecoded0
        let captionFormatsContainer = try containerValues.decodeIfPresent([CaptionFormat?].self, forKey: .captionFormats)
        var captionFormatsDecoded0:[CaptionFormat]? = nil
        if let captionFormatsContainer = captionFormatsContainer {
            captionFormatsDecoded0 = [CaptionFormat]()
            for structure0 in captionFormatsContainer {
                if let structure0 = structure0 {
                    captionFormatsDecoded0?.append(structure0)
                }
            }
        }
        captionFormats = captionFormatsDecoded0
    }
}

extension Captions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Captions(captionFormats: \(String(describing: captionFormats)), captionSources: \(String(describing: captionSources)), mergePolicy: \(String(describing: mergePolicy)))"}
}

/// <p>The captions to be created, if any.</p>
public struct Captions: Equatable {
    /// <p>The array of file formats for the output captions. If you leave this value blank, Elastic Transcoder returns an error.</p>
    public let captionFormats: [CaptionFormat]?
    /// <p>Source files for the input sidecar captions used during the transcoding
    ///          process. To omit all sidecar captions, leave <code>CaptionSources</code> blank.</p>
    @available(*, deprecated)
    public let captionSources: [CaptionSource]?
    /// <p>A policy that determines how Elastic Transcoder handles the existence of multiple captions.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>MergeOverride:</b> Elastic Transcoder transcodes both embedded
    ///             and sidecar captions into outputs. If captions for a language are embedded in the input
    ///             file and also appear in a sidecar file, Elastic Transcoder uses the sidecar captions and ignores the
    ///             embedded captions for that language.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>MergeRetain:</b>  Elastic Transcoder transcodes both embedded
    ///             and sidecar captions into outputs. If captions for a language are embedded in the input
    ///             file and also appear in a sidecar file, Elastic Transcoder uses the embedded captions and ignores the
    ///             sidecar captions for that language. If <code>CaptionSources</code> is empty,
    ///             Elastic Transcoder omits all sidecar captions from the output files.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Override:</b> Elastic Transcoder transcodes only the
    ///             sidecar captions that you specify in <code>CaptionSources</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <code>MergePolicy</code> cannot be null.</p>
    @available(*, deprecated)
    public let mergePolicy: String?

    public init (
        captionFormats: [CaptionFormat]? = nil,
        captionSources: [CaptionSource]? = nil,
        mergePolicy: String? = nil
    )
    {
        self.captionFormats = captionFormats
        self.captionSources = captionSources
        self.mergePolicy = mergePolicy
    }
}

extension Clip: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timeSpan = "TimeSpan"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timeSpan = timeSpan {
            try encodeContainer.encode(timeSpan, forKey: .timeSpan)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeSpanDecoded = try containerValues.decodeIfPresent(TimeSpan.self, forKey: .timeSpan)
        timeSpan = timeSpanDecoded
    }
}

extension Clip: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Clip(timeSpan: \(String(describing: timeSpan)))"}
}

/// <p>Settings for one clip in a composition. All jobs in a playlist must have the same clip settings.</p>
@available(*, deprecated)
public struct Clip: Equatable {
    /// <p>Settings that determine when a clip begins and how long it lasts.</p>
    public let timeSpan: TimeSpan?

    public init (
        timeSpan: TimeSpan? = nil
    )
    {
        self.timeSpan = timeSpan
    }
}

public struct CreateJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobInput>
    public typealias MOutput = OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobOutputError>
}

extension CreateJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJobInput(input: \(String(describing: input)), inputs: \(String(describing: inputs)), output: \(String(describing: output)), outputKeyPrefix: \(String(describing: outputKeyPrefix)), outputs: \(String(describing: outputs)), pipelineId: \(String(describing: pipelineId)), playlists: \(String(describing: playlists)), userMetadata: \(String(describing: userMetadata)))"}
}

extension CreateJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case input = "Input"
        case inputs = "Inputs"
        case output = "Output"
        case outputKeyPrefix = "OutputKeyPrefix"
        case outputs = "Outputs"
        case pipelineId = "PipelineId"
        case playlists = "Playlists"
        case userMetadata = "UserMetadata"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let inputs = inputs {
            var inputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputs)
            for jobinputs0 in inputs {
                try inputsContainer.encode(jobinputs0)
            }
        }
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputKeyPrefix = outputKeyPrefix {
            try encodeContainer.encode(outputKeyPrefix, forKey: .outputKeyPrefix)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for createjoboutputs0 in outputs {
                try outputsContainer.encode(createjoboutputs0)
            }
        }
        if let pipelineId = pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let playlists = playlists {
            var playlistsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .playlists)
            for createjobplaylists0 in playlists {
                try playlistsContainer.encode(createjobplaylists0)
            }
        }
        if let userMetadata = userMetadata {
            var userMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .userMetadata)
            for (dictKey0, usermetadata0) in userMetadata {
                try userMetadataContainer.encode(usermetadata0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobInput>
    public typealias MOutput = OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobOutputError>
}

public struct CreateJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobInput>
    public typealias MOutput = OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobOutputError>
}

/// <p>The <code>CreateJobRequest</code> structure.</p>
public struct CreateJobInput: Equatable {
    /// <p>A section of the request body that provides information about the file that is being
    ///              transcoded.</p>
    public let input: JobInput?
    /// <p>A section of the request body that provides information about the files that are being
    ///             transcoded.</p>
    public let inputs: [JobInput]?
    /// <p> A section of the request body that provides information about the transcoded (target)
    ///             file. We strongly recommend that you use the <code>Outputs</code> syntax instead of the
    ///             <code>Output</code> syntax. </p>
    public let output: CreateJobOutput?
    /// <p>The value, if any, that you want Elastic Transcoder to prepend to the names of all files that this
    ///             job creates, including output files, thumbnails, and playlists.</p>
    public let outputKeyPrefix: String?
    /// <p> A section of the request body that provides information about the transcoded (target)
    ///             files. We recommend that you use the <code>Outputs</code> syntax instead of the
    ///                 <code>Output</code> syntax. </p>
    public let outputs: [CreateJobOutput]?
    /// <p>The <code>Id</code> of the pipeline that you want Elastic Transcoder to use for
    ///             transcoding. The pipeline determines several settings, including the Amazon S3 bucket
    ///             from which Elastic Transcoder gets the files to transcode and the bucket into which
    ///             Elastic Transcoder puts the transcoded files.</p>
    public let pipelineId: String?
    /// <p>If you specify a preset in <code>PresetId</code> for which the value of
    ///                 <code>Container</code> is fmp4 (Fragmented MP4) or ts (MPEG-TS), Playlists contains
    ///                 information about the master playlists that you want Elastic Transcoder to create.</p>
    ///         <p>The maximum number of master playlists in a job is 30.</p>
    public let playlists: [CreateJobPlaylist]?
    /// <p>User-defined metadata that you want to associate with an Elastic Transcoder job. You specify metadata in
    ///             <code>key/value</code> pairs, and you can add up to 10 <code>key/value</code> pairs per job.
    ///             Elastic Transcoder does not guarantee that <code>key/value</code> pairs are returned in the same
    ///             order in which you specify them.</p>
    public let userMetadata: [String:String]?

    public init (
        input: JobInput? = nil,
        inputs: [JobInput]? = nil,
        output: CreateJobOutput? = nil,
        outputKeyPrefix: String? = nil,
        outputs: [CreateJobOutput]? = nil,
        pipelineId: String? = nil,
        playlists: [CreateJobPlaylist]? = nil,
        userMetadata: [String:String]? = nil
    )
    {
        self.input = input
        self.inputs = inputs
        self.output = output
        self.outputKeyPrefix = outputKeyPrefix
        self.outputs = outputs
        self.pipelineId = pipelineId
        self.playlists = playlists
        self.userMetadata = userMetadata
    }
}

struct CreateJobInputBody: Equatable {
    public let pipelineId: String?
    public let input: JobInput?
    public let inputs: [JobInput]?
    public let output: CreateJobOutput?
    public let outputs: [CreateJobOutput]?
    public let outputKeyPrefix: String?
    public let playlists: [CreateJobPlaylist]?
    public let userMetadata: [String:String]?
}

extension CreateJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case input = "Input"
        case inputs = "Inputs"
        case output = "Output"
        case outputKeyPrefix = "OutputKeyPrefix"
        case outputs = "Outputs"
        case pipelineId = "PipelineId"
        case playlists = "Playlists"
        case userMetadata = "UserMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let inputDecoded = try containerValues.decodeIfPresent(JobInput.self, forKey: .input)
        input = inputDecoded
        let inputsContainer = try containerValues.decodeIfPresent([JobInput?].self, forKey: .inputs)
        var inputsDecoded0:[JobInput]? = nil
        if let inputsContainer = inputsContainer {
            inputsDecoded0 = [JobInput]()
            for structure0 in inputsContainer {
                if let structure0 = structure0 {
                    inputsDecoded0?.append(structure0)
                }
            }
        }
        inputs = inputsDecoded0
        let outputDecoded = try containerValues.decodeIfPresent(CreateJobOutput.self, forKey: .output)
        output = outputDecoded
        let outputsContainer = try containerValues.decodeIfPresent([CreateJobOutput?].self, forKey: .outputs)
        var outputsDecoded0:[CreateJobOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [CreateJobOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let outputKeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputKeyPrefix)
        outputKeyPrefix = outputKeyPrefixDecoded
        let playlistsContainer = try containerValues.decodeIfPresent([CreateJobPlaylist?].self, forKey: .playlists)
        var playlistsDecoded0:[CreateJobPlaylist]? = nil
        if let playlistsContainer = playlistsContainer {
            playlistsDecoded0 = [CreateJobPlaylist]()
            for structure0 in playlistsContainer {
                if let structure0 = structure0 {
                    playlistsDecoded0?.append(structure0)
                }
            }
        }
        playlists = playlistsDecoded0
        let userMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .userMetadata)
        var userMetadataDecoded0: [String:String]? = nil
        if let userMetadataContainer = userMetadataContainer {
            userMetadataDecoded0 = [String:String]()
            for (key0, string0) in userMetadataContainer {
                if let string0 = string0 {
                    userMetadataDecoded0?[key0] = string0
                }
            }
        }
        userMetadata = userMetadataDecoded0
    }
}

extension CreateJobOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case albumArt = "AlbumArt"
        case captions = "Captions"
        case composition = "Composition"
        case encryption = "Encryption"
        case key = "Key"
        case presetId = "PresetId"
        case rotate = "Rotate"
        case segmentDuration = "SegmentDuration"
        case thumbnailEncryption = "ThumbnailEncryption"
        case thumbnailPattern = "ThumbnailPattern"
        case watermarks = "Watermarks"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let albumArt = albumArt {
            try encodeContainer.encode(albumArt, forKey: .albumArt)
        }
        if let captions = captions {
            try encodeContainer.encode(captions, forKey: .captions)
        }
        if let composition = composition {
            var compositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .composition)
            for composition0 in composition {
                try compositionContainer.encode(composition0)
            }
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let presetId = presetId {
            try encodeContainer.encode(presetId, forKey: .presetId)
        }
        if let rotate = rotate {
            try encodeContainer.encode(rotate, forKey: .rotate)
        }
        if let segmentDuration = segmentDuration {
            try encodeContainer.encode(segmentDuration, forKey: .segmentDuration)
        }
        if let thumbnailEncryption = thumbnailEncryption {
            try encodeContainer.encode(thumbnailEncryption, forKey: .thumbnailEncryption)
        }
        if let thumbnailPattern = thumbnailPattern {
            try encodeContainer.encode(thumbnailPattern, forKey: .thumbnailPattern)
        }
        if let watermarks = watermarks {
            var watermarksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .watermarks)
            for jobwatermarks0 in watermarks {
                try watermarksContainer.encode(jobwatermarks0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let thumbnailPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thumbnailPattern)
        thumbnailPattern = thumbnailPatternDecoded
        let thumbnailEncryptionDecoded = try containerValues.decodeIfPresent(Encryption.self, forKey: .thumbnailEncryption)
        thumbnailEncryption = thumbnailEncryptionDecoded
        let rotateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rotate)
        rotate = rotateDecoded
        let presetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .presetId)
        presetId = presetIdDecoded
        let segmentDurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .segmentDuration)
        segmentDuration = segmentDurationDecoded
        let watermarksContainer = try containerValues.decodeIfPresent([JobWatermark?].self, forKey: .watermarks)
        var watermarksDecoded0:[JobWatermark]? = nil
        if let watermarksContainer = watermarksContainer {
            watermarksDecoded0 = [JobWatermark]()
            for structure0 in watermarksContainer {
                if let structure0 = structure0 {
                    watermarksDecoded0?.append(structure0)
                }
            }
        }
        watermarks = watermarksDecoded0
        let albumArtDecoded = try containerValues.decodeIfPresent(JobAlbumArt.self, forKey: .albumArt)
        albumArt = albumArtDecoded
        let compositionContainer = try containerValues.decodeIfPresent([Clip?].self, forKey: .composition)
        var compositionDecoded0:[Clip]? = nil
        if let compositionContainer = compositionContainer {
            compositionDecoded0 = [Clip]()
            for structure0 in compositionContainer {
                if let structure0 = structure0 {
                    compositionDecoded0?.append(structure0)
                }
            }
        }
        composition = compositionDecoded0
        let captionsDecoded = try containerValues.decodeIfPresent(Captions.self, forKey: .captions)
        captions = captionsDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
    }
}

extension CreateJobOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJobOutput(albumArt: \(String(describing: albumArt)), captions: \(String(describing: captions)), composition: \(String(describing: composition)), encryption: \(String(describing: encryption)), key: \(String(describing: key)), presetId: \(String(describing: presetId)), rotate: \(String(describing: rotate)), segmentDuration: \(String(describing: segmentDuration)), thumbnailEncryption: \(String(describing: thumbnailEncryption)), thumbnailPattern: \(String(describing: thumbnailPattern)), watermarks: \(String(describing: watermarks)))"}
}

/// <p>The <code>CreateJobOutput</code> structure.</p>
public struct CreateJobOutput: Equatable {
    /// <p>Information about the album art that you want Elastic Transcoder to add to the file during transcoding.
    ///             You can specify up to twenty album artworks for each output. Settings for each artwork must be
    ///             defined in the job for the current output.</p>
    public let albumArt: JobAlbumArt?
    /// <p>You can configure Elastic Transcoder to transcode captions, or subtitles, from one format to another. All
    ///           captions must be in UTF-8. Elastic Transcoder supports two types of captions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Embedded:</b> Embedded captions
    ///             are included in the same file as the audio and video. Elastic Transcoder supports
    ///             only one embedded caption per language, to a maximum of 300 embedded captions per file.</p>
    ///                <p>Valid input values include: <code>CEA-608 (EIA-608</code>, first non-empty channel only),
    ///             	<code>CEA-708 (EIA-708</code>, first non-empty channel only), and <code>mov-text</code>
    ///                </p>
    ///                <p>Valid outputs include: <code>mov-text</code>
    ///                </p>
    ///                <p>Elastic Transcoder supports a maximum of one embedded format per output.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Sidecar:</b> Sidecar captions are kept in a
    ///             separate metadata file from the audio and video data.  Sidecar captions require a player
    ///             that is capable of understanding the relationship between the video file and the sidecar
    ///             file. Elastic Transcoder supports only one sidecar caption per language, to a maximum of 20 sidecar
    ///             captions per file.</p>
    ///                <p>Valid input values include: <code>dfxp</code> (first div element only),
    ///                <code>ebu-tt</code>, <code>scc</code>, <code>smpt</code>, <code>srt</code>,
    ///                <code>ttml</code> (first div element only), and <code>webvtt</code>
    ///                </p>
    ///                <p>Valid outputs include: <code>dfxp</code> (first div element only), <code>scc</code>,
    ///                <code>srt</code>, and <code>webvtt</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you want ttml or smpte-tt compatible captions, specify dfxp as your output format.</p>
    ///          <p>Elastic Transcoder does not support OCR (Optical Character Recognition), does not accept pictures
    ///              as a valid input for captions, and is not available for audio-only transcoding. Elastic Transcoder does
    ///              not preserve text formatting (for example, italics) during the transcoding process.</p>
    ///          <p>To remove captions or leave the captions empty, set <code>Captions</code> to null. To pass through
    ///              existing captions unchanged, set the <code>MergePolicy</code> to <code>MergeRetain</code>,
    ///              and pass in a null <code>CaptionSources</code> array.</p>
    ///          <p>For more information on embedded files, see the Subtitles Wikipedia page.</p>
    ///          <p>For more information on sidecar files, see the Extensible Metadata Platform and Sidecar file Wikipedia pages.</p>
    public let captions: Captions?
    /// <p>You can create an output file that contains an excerpt from the input file. This excerpt, called a
    ///             clip, can come from the beginning, middle, or end of the file. The Composition object contains settings
    ///             for the clips that make up an output file. For the current release, you can only specify settings for a
    ///             single clip per output file. The Composition object cannot be null.</p>
    @available(*, deprecated)
    public let composition: [Clip]?
    /// <p>You can specify encryption settings for any output files that you want to use for a
    ///     transcoding job. This includes the output file and any watermarks, thumbnails, album art,
    ///     or captions that you want to use. You must specify encryption settings for each file
    ///     individually.</p>
    public let encryption: Encryption?
    /// <p> The name to assign to the transcoded file. Elastic Transcoder saves the file in the Amazon S3 bucket
    ///     specified by the <code>OutputBucket</code> object in the pipeline that is specified by
    ///     the pipeline ID. If a file with the specified name already exists in the output bucket,
    ///     the job fails. </p>
    public let key: String?
    /// <p> The <code>Id</code> of the preset to use for this job. The preset determines the audio,
    ///     video, and thumbnail settings that Elastic Transcoder uses for transcoding. </p>
    public let presetId: String?
    /// <p> The number of degrees clockwise by which you want Elastic Transcoder to rotate the output relative to
    ///     the input. Enter one of the following values: <code>auto</code>, <code>0</code>,
    ///         <code>90</code>, <code>180</code>, <code>270</code>. The value <code>auto</code>
    ///     generally works only if the file that you're transcoding contains rotation metadata.
    /// </p>
    public let rotate: String?
    /// <important>
    ///             <p>(Outputs in Fragmented MP4 or MPEG-TS format only.</p>
    ///          </important>
    ///          <p>If you specify a preset in
    ///         <code>PresetId</code> for which the value of <code>Container</code> is <code>fmp4</code> (Fragmented MP4) or
    ///         <code>ts</code> (MPEG-TS), <code>SegmentDuration</code> is the target maximum duration of
    ///     each segment in seconds. For <code>HLSv3</code> format playlists,
    ///     each media segment is stored in a separate <code>.ts</code> file. For <code>HLSv4</code> and <code>Smooth</code>
    ///     playlists, all media segments for an output are stored in a single file. Each segment is approximately the length of
    ///     the <code>SegmentDuration</code>, though individual segments might be shorter or longer.</p>
    ///
    ///          <p>The range of valid values is 1 to 60 seconds. If the duration
    ///     of the video is not evenly divisible by <code>SegmentDuration</code>, the duration of
    ///     the last segment is the remainder of total length/SegmentDuration.</p>
    ///          <p>Elastic Transcoder
    ///     creates an output-specific playlist for each output <code>HLS</code> output that you specify in OutputKeys. To
    ///     add an output to the master playlist for this job, include it in the <code>OutputKeys</code> of
    ///     the associated playlist.</p>
    public let segmentDuration: String?
    /// <p>The encryption settings, if any, that you want Elastic Transcoder to apply to your thumbnail.</p>
    public let thumbnailEncryption: Encryption?
    /// <p>Whether you want Elastic Transcoder to create thumbnails for your videos and, if so, how you want Elastic Transcoder to name the files.</p>
    ///          <p>If you don't want Elastic Transcoder to create thumbnails, specify "".</p>
    ///          <p>If you do want Elastic Transcoder to create thumbnails, specify the information that you want to include
    ///     in the file name for each thumbnail. You can specify the following values in any sequence:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <code>{count}</code> (Required)</b>: If you want to create thumbnails, you
    ///             must include <code>{count}</code> in the <code>ThumbnailPattern</code> object.
    ///             Wherever you specify <code>{count}</code>, Elastic Transcoder adds a five-digit sequence
    ///             number (beginning with <b>00001</b>) to thumbnail file names. The number
    ///             indicates where a given thumbnail appears in the sequence of thumbnails for a
    ///             transcoded file. </p>
    ///                <important>
    ///                   <p>If you specify a literal value and/or <code>{resolution}</code> but you
    ///             omit <code>{count}</code>, Elastic Transcoder returns a validation error and does not create
    ///             the job.</p>
    ///                </important>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Literal values (Optional)</b>: You can specify literal values anywhere in the
    ///                 <code>ThumbnailPattern</code> object. For example, you can include them as a
    ///             file name prefix or as a delimiter between <code>{resolution}</code> and
    ///                 <code>{count}</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <code>{resolution}</code> (Optional)</b>: If you want Elastic Transcoder to include the
    ///             resolution in the file name, include <code>{resolution}</code> in the
    ///                 <code>ThumbnailPattern</code> object. </p>
    ///             </li>
    ///          </ul>
    ///          <p>When creating thumbnails, Elastic Transcoder automatically saves the files in the format (.jpg or .png)
    ///     that appears in the preset that you specified in the <code>PresetID</code> value of
    ///         <code>CreateJobOutput</code>. Elastic Transcoder also appends the applicable file name
    ///     extension.</p>
    public let thumbnailPattern: String?
    /// <p>Information about the watermarks that you want Elastic Transcoder to add to the video during transcoding.
    ///     You can specify up to four watermarks for each output. Settings for each watermark must be defined
    ///     in the preset for the current output.</p>
    public let watermarks: [JobWatermark]?

    public init (
        albumArt: JobAlbumArt? = nil,
        captions: Captions? = nil,
        composition: [Clip]? = nil,
        encryption: Encryption? = nil,
        key: String? = nil,
        presetId: String? = nil,
        rotate: String? = nil,
        segmentDuration: String? = nil,
        thumbnailEncryption: Encryption? = nil,
        thumbnailPattern: String? = nil,
        watermarks: [JobWatermark]? = nil
    )
    {
        self.albumArt = albumArt
        self.captions = captions
        self.composition = composition
        self.encryption = encryption
        self.key = key
        self.presetId = presetId
        self.rotate = rotate
        self.segmentDuration = segmentDuration
        self.thumbnailEncryption = thumbnailEncryption
        self.thumbnailPattern = thumbnailPattern
        self.watermarks = watermarks
    }
}

extension CreateJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJobOutputResponse(job: \(String(describing: job)))"}
}

extension CreateJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

/// <p>The CreateJobResponse structure.</p>
public struct CreateJobOutputResponse: Equatable {
    /// <p>A section of the response body that provides information about the job that is created.</p>
    public let job: Job?

    public init (
        job: Job? = nil
    )
    {
        self.job = job
    }
}

struct CreateJobOutputResponseBody: Equatable {
    public let job: Job?
}

extension CreateJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job = "Job"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Job.self, forKey: .job)
        job = jobDecoded
    }
}

extension CreateJobPlaylist: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case format = "Format"
        case hlsContentProtection = "HlsContentProtection"
        case name = "Name"
        case outputKeys = "OutputKeys"
        case playReadyDrm = "PlayReadyDrm"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let hlsContentProtection = hlsContentProtection {
            try encodeContainer.encode(hlsContentProtection, forKey: .hlsContentProtection)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputKeys = outputKeys {
            var outputKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputKeys)
            for outputkeys0 in outputKeys {
                try outputKeysContainer.encode(outputkeys0)
            }
        }
        if let playReadyDrm = playReadyDrm {
            try encodeContainer.encode(playReadyDrm, forKey: .playReadyDrm)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .format)
        format = formatDecoded
        let outputKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .outputKeys)
        var outputKeysDecoded0:[String]? = nil
        if let outputKeysContainer = outputKeysContainer {
            outputKeysDecoded0 = [String]()
            for string0 in outputKeysContainer {
                if let string0 = string0 {
                    outputKeysDecoded0?.append(string0)
                }
            }
        }
        outputKeys = outputKeysDecoded0
        let hlsContentProtectionDecoded = try containerValues.decodeIfPresent(HlsContentProtection.self, forKey: .hlsContentProtection)
        hlsContentProtection = hlsContentProtectionDecoded
        let playReadyDrmDecoded = try containerValues.decodeIfPresent(PlayReadyDrm.self, forKey: .playReadyDrm)
        playReadyDrm = playReadyDrmDecoded
    }
}

extension CreateJobPlaylist: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJobPlaylist(format: \(String(describing: format)), hlsContentProtection: \(String(describing: hlsContentProtection)), name: \(String(describing: name)), outputKeys: \(String(describing: outputKeys)), playReadyDrm: \(String(describing: playReadyDrm)))"}
}

/// <p>Information about the master playlist.</p>
public struct CreateJobPlaylist: Equatable {
    /// <p>The format of the output playlist. Valid formats include <code>HLSv3</code>,
    ///             <code>HLSv4</code>, and <code>Smooth</code>.</p>
    public let format: String?
    /// <p>The HLS content protection settings, if any, that you want Elastic Transcoder to apply to the output
    ///             files associated with this playlist.</p>
    public let hlsContentProtection: HlsContentProtection?
    /// <p>The name that you want Elastic Transcoder to assign to the master playlist, for example,
    ///     nyc-vacation.m3u8. If the name includes a <code>/</code> character,
    ///     the section of the name before the last <code>/</code> must be identical
    ///     for all <code>Name</code> objects. If you create more than one
    ///     master playlist, the values of all <code>Name</code> objects must be
    ///     unique.</p>
    ///          <note>
    ///             <p>
    ///     Elastic Transcoder automatically appends the relevant file extension to the file name (<code>.m3u8</code>
    ///             for <code>HLSv3</code> and <code>HLSv4</code> playlists, and <code>.ism</code> and <code>.ismc</code> for
    ///             <code>Smooth</code> playlists).
    ///             If you include a file extension in <code>Name</code>, the file name will have
    ///             two extensions.</p>
    ///          </note>
    public let name: String?
    /// <p>For each output in this job that you want to include in a master playlist, the value of
    ///             the <code>Outputs:Key</code> object. </p>
    ///         <ul>
    ///             <li>
    ///                 <p>If your output is not <code>HLS</code> or does not have a segment duration set,
    ///                     the name of the output file is a concatenation of <code>OutputKeyPrefix</code>
    ///                     and <code>Outputs:Key</code>:</p>
    ///                 <p>OutputKeyPrefix<code>Outputs:Key</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>If your output is <code>HLSv3</code> and has a segment duration set, or is not included in a
    ///                     playlist, Elastic Transcoder creates an output playlist file with a file extension of <code>.m3u8</code>, and a
    ///                     series of <code>.ts</code> files that include a five-digit
    ///                     sequential counter beginning with 00000:</p>
    ///                 <p>OutputKeyPrefix<code>Outputs:Key</code>.m3u8</p>
    ///                 <p>OutputKeyPrefix<code>Outputs:Key</code>00000.ts</p>
    ///             </li>
    ///             <li>
    ///                 <p>If your output is <code>HLSv4</code>, has a segment duration set, and is included in an
    ///                     <code>HLSv4</code> playlist, Elastic Transcoder creates an output playlist file with a file extension
    ///                     of <code>_v4.m3u8</code>. If the output is video, Elastic Transcoder also creates an output file with
    ///                     an extension of <code>_iframe.m3u8</code>:</p>
    ///                 <p>OutputKeyPrefix<code>Outputs:Key</code>_v4.m3u8</p>
    ///                 <p>OutputKeyPrefix<code>Outputs:Key</code>_iframe.m3u8</p>
    ///                 <p>OutputKeyPrefix<code>Outputs:Key</code>.ts</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>Elastic Transcoder automatically appends the relevant file extension to the file name. If you include a
    ///             file extension in Output Key, the file name will have two extensions.</p>
    ///
    ///         <p>If you include more than one output in a playlist,
    ///             any segment duration settings, clip settings, or caption settings must be the
    ///             same for all outputs in the playlist. For <code>Smooth</code> playlists, the <code>Audio:Profile</code>,
    ///             <code>Video:Profile</code>, and <code>Video:FrameRate</code> to
    ///             <code>Video:KeyframesMaxDist</code> ratio must be the same for all outputs.</p>
    public let outputKeys: [String]?
    /// <p>The DRM settings, if any, that you want Elastic Transcoder to apply to the output files associated with this playlist.</p>
    public let playReadyDrm: PlayReadyDrm?

    public init (
        format: String? = nil,
        hlsContentProtection: HlsContentProtection? = nil,
        name: String? = nil,
        outputKeys: [String]? = nil,
        playReadyDrm: PlayReadyDrm? = nil
    )
    {
        self.format = format
        self.hlsContentProtection = hlsContentProtection
        self.name = name
        self.outputKeys = outputKeys
        self.playReadyDrm = playReadyDrm
    }
}

public struct CreatePipelineInputBodyMiddleware: Middleware {
    public let id: String = "CreatePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePipelineOutputError>
}

extension CreatePipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePipelineInput(awsKmsKeyArn: \(String(describing: awsKmsKeyArn)), contentConfig: \(String(describing: contentConfig)), inputBucket: \(String(describing: inputBucket)), name: \(String(describing: name)), notifications: \(String(describing: notifications)), outputBucket: \(String(describing: outputBucket)), role: \(String(describing: role)), thumbnailConfig: \(String(describing: thumbnailConfig)))"}
}

extension CreatePipelineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsKmsKeyArn = "AwsKmsKeyArn"
        case contentConfig = "ContentConfig"
        case inputBucket = "InputBucket"
        case name = "Name"
        case notifications = "Notifications"
        case outputBucket = "OutputBucket"
        case role = "Role"
        case thumbnailConfig = "ThumbnailConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsKmsKeyArn = awsKmsKeyArn {
            try encodeContainer.encode(awsKmsKeyArn, forKey: .awsKmsKeyArn)
        }
        if let contentConfig = contentConfig {
            try encodeContainer.encode(contentConfig, forKey: .contentConfig)
        }
        if let inputBucket = inputBucket {
            try encodeContainer.encode(inputBucket, forKey: .inputBucket)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notifications = notifications {
            try encodeContainer.encode(notifications, forKey: .notifications)
        }
        if let outputBucket = outputBucket {
            try encodeContainer.encode(outputBucket, forKey: .outputBucket)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let thumbnailConfig = thumbnailConfig {
            try encodeContainer.encode(thumbnailConfig, forKey: .thumbnailConfig)
        }
    }
}

public struct CreatePipelineInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePipelineOutputError>
}

public struct CreatePipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePipelineOutputError>
}

/// <p>The <code>CreatePipelineRequest</code> structure.</p>
public struct CreatePipelineInput: Equatable {
    /// <p>The AWS Key Management Service (AWS KMS) key that you want to use with this pipeline.</p>
    ///         <p>If you use either <code>s3</code> or <code>s3-aws-kms</code> as your
    ///             <code>Encryption:Mode</code>, you don't need to provide a key with
    ///             your job because a default key, known as an AWS-KMS key, is created for you automatically.
    ///             You need to provide an AWS-KMS key only if you want to use a non-default AWS-KMS key, or if you are
    ///             using an <code>Encryption:Mode</code> of <code>aes-cbc-pkcs7</code>, <code>aes-ctr</code>,
    ///             or <code>aes-gcm</code>.</p>
    public let awsKmsKeyArn: String?
    /// <p>The optional <code>ContentConfig</code> object specifies information about the Amazon S3
    ///             bucket in which you want Elastic Transcoder to save transcoded files and playlists:
    ///             which bucket to use, which users you want to have access to the files, the type of
    ///             access you want users to have, and the storage class that you want to assign to the
    ///             files.</p>
    ///         <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
    ///                 <code>ThumbnailConfig</code>.</p>
    ///         <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
    ///             omit the <code>OutputBucket</code> object.</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
    ///                 transcoded files and playlists.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Permissions</b> (Optional): The Permissions object specifies which users you want
    ///                 to have access to transcoded files and the type of access you want them to have. You
    ///                 can grant permissions to a maximum of 30 users and/or predefined Amazon S3
    ///                 groups.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Grantee Type</b>: Specify the type of value that appears in the
    ///                     <code>Grantee</code> object: </p>
    /// 					          <ul>
    ///                   <li>
    ///                      <p>
    ///                         <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
    ///                         canonical user ID for an AWS account or an origin access identity for an
    ///                         Amazon CloudFront distribution. For more information about canonical user
    ///                         IDs, see Access Control List (ACL) Overview in the Amazon Simple Storage
    ///                         Service Developer Guide. For more information about using CloudFront origin
    ///                         access identities to require that users use CloudFront URLs instead of
    ///                         Amazon S3 URLs, see Using an Origin Access Identity to Restrict Access to
    ///                         Your Amazon S3 Content.</p>
    /// 						               <important>
    ///                         <p>A canonical user ID is not the same as an
    ///                             AWS account number.</p>
    ///                      </important>
    ///                     </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>Email</b>: The value in the <code>Grantee</code> object is the registered
    ///                         email address of an AWS account.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>Group</b>: The value in the <code>Grantee</code> object is one of the
    ///                         following predefined Amazon S3 groups: <code>AllUsers</code>,
    ///                             <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Grantee</b>: The AWS user or group that you want to have access to transcoded
    ///                 files and playlists. To identify the user or group, you can specify the canonical
    ///                 user ID for an AWS account, an origin access identity for a CloudFront distribution,
    ///                 the registered email address of an AWS account, or a predefined Amazon S3 group </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Access</b>: The permission that you want to give to the AWS user that you
    ///                 specified in <code>Grantee</code>. Permissions are granted on the files that Elastic
    ///                 Transcoder adds to the bucket, including playlists and video files. Valid values
    ///                 include: </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>READ</code>: The grantee can read the objects and metadata for objects
    ///                         that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>READ_ACP</code>: The grantee can read the object ACL for objects that
    ///                         Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>WRITE_ACP</code>: The grantee can write the ACL for the objects that
    ///                         Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
    ///                             <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
    ///                         objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
    ///                     <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
    ///                 the video files and playlists that it stores in your Amazon S3 bucket.</p>
    ///             </li>
    ///          </ul>
    public let contentConfig: PipelineOutputConfig?
    /// <p>The Amazon S3 bucket in which you saved the media files that you want to transcode.</p>
    public let inputBucket: String?
    /// <p>The name of the pipeline. We recommend that the name be unique within the AWS account,
    ///             but uniqueness is not enforced.</p>
    ///         <p>Constraints: Maximum 40 characters.</p>
    public let name: String?
    /// <p>The Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status.</p>
    ///         <important>
    ///             <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
    ///          </important>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Progressing</b>: The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to
    ///                 notify when Elastic Transcoder has started to process a job in this pipeline. This is the ARN that
    ///                 Amazon SNS returned when you created the topic. For more information, see Create a
    ///                 Topic in the Amazon Simple Notification Service Developer Guide.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Complete</b>: The topic ARN for the Amazon SNS topic that you want to notify when
    ///                 Elastic Transcoder has finished processing a job in this pipeline. This is the ARN that Amazon SNS
    ///                 returned when you created the topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Warning</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
    ///                 encounters a warning condition while processing a job in this pipeline. This is the
    ///                 ARN that Amazon SNS returned when you created the topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Error</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
    ///                 encounters an error condition while processing a job in this pipeline. This is the
    ///                 ARN that Amazon SNS returned when you created the topic.</p>
    ///             </li>
    ///          </ul>
    public let notifications: Notifications?
    /// <p>The Amazon S3 bucket in which you want Elastic Transcoder to save the transcoded files. (Use
    /// 		  this, or use ContentConfig:Bucket plus ThumbnailConfig:Bucket.)</p>
    ///         <p>Specify this value when all of the following are true:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>You want to save transcoded files, thumbnails (if any), and playlists (if any)
    ///                     together in one bucket.</p>
    ///             </li>
    ///             <li>
    ///                <p>You do not want to specify the users or groups who have access to the transcoded
    ///                     files, thumbnails, and playlists.</p>
    ///             </li>
    ///             <li>
    ///                <p>You do not want to specify the permissions that Elastic Transcoder grants to the
    /// 				
    ///                     files. </p>
    /// 				           <important>
    ///                   <p>When Elastic Transcoder saves files in
    ///                             <code>OutputBucket</code>, it grants full control over the files only to
    ///                         the AWS account that owns the role that is specified by
    ///                         <code>Role</code>.</p>
    ///                </important>
    ///             </li>
    ///             <li>
    ///                <p>You want to associate the transcoded files and thumbnails with the Amazon S3
    ///                     Standard storage class.</p>
    ///             </li>
    ///          </ul>
    ///
    ///         <p>If you want to save transcoded files and playlists in one bucket and thumbnails in
    ///             another bucket, specify which users can access the transcoded files or the permissions
    ///             the users have, or change the Amazon S3 storage class, omit <code>OutputBucket</code>
    ///             and specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>
    ///             instead.</p>
    public let outputBucket: String?
    /// <p>The IAM Amazon Resource Name (ARN) for the role that you want Elastic Transcoder to use to create the pipeline.</p>
    public let role: String?
    /// <p>The <code>ThumbnailConfig</code> object specifies several values, including the Amazon S3
    ///             bucket in which you want Elastic Transcoder to save thumbnail files, which users you want to have
    ///             access to the files, the type of access you want users to have, and the storage class
    ///             that you want to assign to the files.</p>
    ///         <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
    ///                 <code>ThumbnailConfig</code> even if you don't want to create thumbnails.</p>
    ///         <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
    ///             omit the <code>OutputBucket</code> object.</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
    ///                 thumbnail files.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Permissions</b> (Optional): The <code>Permissions</code> object specifies which
    ///                 users and/or predefined Amazon S3 groups you want to have access to thumbnail files,
    ///                 and the type of access you want them to have. You can grant permissions to a maximum
    ///                 of 30 users and/or predefined Amazon S3 groups.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>GranteeType</b>: Specify the type of value that appears in the Grantee object: </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
    ///                         canonical user ID for an AWS account or an origin access identity for an
    ///                         Amazon CloudFront distribution.</p>
    ///                      <important>
    ///                         <p>A canonical user ID is not the
    ///                             same as an AWS account number.</p>
    ///                      </important>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>Email</b>: The value in the <code>Grantee</code> object is the registered
    ///                         email address of an AWS account. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>Group</b>: The value in the <code>Grantee</code> object is one of the
    ///                         following predefined Amazon S3 groups: <code>AllUsers</code>,
    ///                             <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Grantee</b>: The AWS user or group that you want to have access to thumbnail
    ///                 files. To identify the user or group, you can specify the canonical user ID for an
    ///                 AWS account, an origin access identity for a CloudFront distribution, the registered
    ///                 email address of an AWS account, or a predefined Amazon S3 group. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Access</b>: The permission that you want to give to the AWS user that you
    ///                 specified in <code>Grantee</code>. Permissions are granted on the thumbnail files
    ///                 that Elastic Transcoder adds to the bucket. Valid values include: </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>READ</code>: The grantee can read the thumbnails and metadata for
    ///                         objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>READ_ACP</code>: The grantee can read the object ACL for thumbnails
    ///                         that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>WRITE_ACP</code>: The grantee can write the ACL for the thumbnails
    ///                         that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
    ///                             <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
    ///                         thumbnails that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
    ///                     <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
    ///                 the thumbnails that it stores in your Amazon S3 bucket.</p>
    ///             </li>
    ///          </ul>
    public let thumbnailConfig: PipelineOutputConfig?

    public init (
        awsKmsKeyArn: String? = nil,
        contentConfig: PipelineOutputConfig? = nil,
        inputBucket: String? = nil,
        name: String? = nil,
        notifications: Notifications? = nil,
        outputBucket: String? = nil,
        role: String? = nil,
        thumbnailConfig: PipelineOutputConfig? = nil
    )
    {
        self.awsKmsKeyArn = awsKmsKeyArn
        self.contentConfig = contentConfig
        self.inputBucket = inputBucket
        self.name = name
        self.notifications = notifications
        self.outputBucket = outputBucket
        self.role = role
        self.thumbnailConfig = thumbnailConfig
    }
}

struct CreatePipelineInputBody: Equatable {
    public let name: String?
    public let inputBucket: String?
    public let outputBucket: String?
    public let role: String?
    public let awsKmsKeyArn: String?
    public let notifications: Notifications?
    public let contentConfig: PipelineOutputConfig?
    public let thumbnailConfig: PipelineOutputConfig?
}

extension CreatePipelineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case awsKmsKeyArn = "AwsKmsKeyArn"
        case contentConfig = "ContentConfig"
        case inputBucket = "InputBucket"
        case name = "Name"
        case notifications = "Notifications"
        case outputBucket = "OutputBucket"
        case role = "Role"
        case thumbnailConfig = "ThumbnailConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let inputBucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputBucket)
        inputBucket = inputBucketDecoded
        let outputBucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputBucket)
        outputBucket = outputBucketDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let awsKmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsKmsKeyArn)
        awsKmsKeyArn = awsKmsKeyArnDecoded
        let notificationsDecoded = try containerValues.decodeIfPresent(Notifications.self, forKey: .notifications)
        notifications = notificationsDecoded
        let contentConfigDecoded = try containerValues.decodeIfPresent(PipelineOutputConfig.self, forKey: .contentConfig)
        contentConfig = contentConfigDecoded
        let thumbnailConfigDecoded = try containerValues.decodeIfPresent(PipelineOutputConfig.self, forKey: .thumbnailConfig)
        thumbnailConfig = thumbnailConfigDecoded
    }
}

extension CreatePipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePipelineOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePipelineOutputResponse(pipeline: \(String(describing: pipeline)), warnings: \(String(describing: warnings)))"}
}

extension CreatePipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePipelineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pipeline = output.pipeline
            self.warnings = output.warnings
        } else {
            self.pipeline = nil
            self.warnings = nil
        }
    }
}

/// <p>When you create a pipeline, Elastic Transcoder returns the values that you specified in the request.</p>
public struct CreatePipelineOutputResponse: Equatable {
    /// <p>A section of the response body that provides information about the pipeline that is created.</p>
    public let pipeline: Pipeline?
    /// <p>Elastic Transcoder returns a warning if the resources used by your pipeline are not in the same region as
    ///             the pipeline.</p>
    ///         <p>Using resources in the same region, such as your Amazon S3 buckets, Amazon SNS notification topics, and
    ///             AWS KMS key, reduces processing time and prevents cross-regional charges.</p>
    public let warnings: [Warning]?

    public init (
        pipeline: Pipeline? = nil,
        warnings: [Warning]? = nil
    )
    {
        self.pipeline = pipeline
        self.warnings = warnings
    }
}

struct CreatePipelineOutputResponseBody: Equatable {
    public let pipeline: Pipeline?
    public let warnings: [Warning]?
}

extension CreatePipelineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipeline = "Pipeline"
        case warnings = "Warnings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(Pipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Warning?].self, forKey: .warnings)
        var warningsDecoded0:[Warning]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Warning]()
            for structure0 in warningsContainer {
                if let structure0 = structure0 {
                    warningsDecoded0?.append(structure0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

public struct CreatePresetInputBodyMiddleware: Middleware {
    public let id: String = "CreatePresetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePresetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePresetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePresetInput>
    public typealias MOutput = OperationOutput<CreatePresetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePresetOutputError>
}

extension CreatePresetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePresetInput(audio: \(String(describing: audio)), container: \(String(describing: container)), description: \(String(describing: description)), name: \(String(describing: name)), thumbnails: \(String(describing: thumbnails)), video: \(String(describing: video)))"}
}

extension CreatePresetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case audio = "Audio"
        case container = "Container"
        case description = "Description"
        case name = "Name"
        case thumbnails = "Thumbnails"
        case video = "Video"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audio = audio {
            try encodeContainer.encode(audio, forKey: .audio)
        }
        if let container = container {
            try encodeContainer.encode(container, forKey: .container)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let thumbnails = thumbnails {
            try encodeContainer.encode(thumbnails, forKey: .thumbnails)
        }
        if let video = video {
            try encodeContainer.encode(video, forKey: .video)
        }
    }
}

public struct CreatePresetInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePresetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePresetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePresetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePresetInput>
    public typealias MOutput = OperationOutput<CreatePresetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePresetOutputError>
}

public struct CreatePresetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePresetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePresetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePresetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePresetInput>
    public typealias MOutput = OperationOutput<CreatePresetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePresetOutputError>
}

/// <p>The <code>CreatePresetRequest</code> structure.</p>
public struct CreatePresetInput: Equatable {
    /// <p>A section of the request body that specifies the audio parameters.</p>
    public let audio: AudioParameters?
    /// <p>The container type for the output file. Valid values include <code>flac</code>,
    ///             <code>flv</code>, <code>fmp4</code>,
    ///             <code>gif</code>, <code>mp3</code>,
    ///             <code>mp4</code>, <code>mpg</code>, <code>mxf</code>, <code>oga</code>,
    ///             <code>ogg</code>, <code>ts</code>, and <code>webm</code>.</p>
    public let container: String?
    /// <p>A description of the preset.</p>
    public let description: String?
    /// <p>The name of the preset. We recommend that the name be unique within the AWS account, but uniqueness is not enforced.</p>
    public let name: String?
    /// <p>A section of the request body that specifies the thumbnail parameters, if any.</p>
    public let thumbnails: Thumbnails?
    /// <p>A section of the request body that specifies the video parameters.</p>
    public let video: VideoParameters?

    public init (
        audio: AudioParameters? = nil,
        container: String? = nil,
        description: String? = nil,
        name: String? = nil,
        thumbnails: Thumbnails? = nil,
        video: VideoParameters? = nil
    )
    {
        self.audio = audio
        self.container = container
        self.description = description
        self.name = name
        self.thumbnails = thumbnails
        self.video = video
    }
}

struct CreatePresetInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let container: String?
    public let video: VideoParameters?
    public let audio: AudioParameters?
    public let thumbnails: Thumbnails?
}

extension CreatePresetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case audio = "Audio"
        case container = "Container"
        case description = "Description"
        case name = "Name"
        case thumbnails = "Thumbnails"
        case video = "Video"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let containerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .container)
        container = containerDecoded
        let videoDecoded = try containerValues.decodeIfPresent(VideoParameters.self, forKey: .video)
        video = videoDecoded
        let audioDecoded = try containerValues.decodeIfPresent(AudioParameters.self, forKey: .audio)
        audio = audioDecoded
        let thumbnailsDecoded = try containerValues.decodeIfPresent(Thumbnails.self, forKey: .thumbnails)
        thumbnails = thumbnailsDecoded
    }
}

extension CreatePresetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePresetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePresetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case limitExceededException(LimitExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePresetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePresetOutputResponse(preset: \(String(describing: preset)), warning: \(String(describing: warning)))"}
}

extension CreatePresetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePresetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.preset = output.preset
            self.warning = output.warning
        } else {
            self.preset = nil
            self.warning = nil
        }
    }
}

/// <p>The <code>CreatePresetResponse</code> structure.</p>
public struct CreatePresetOutputResponse: Equatable {
    /// <p>A section of the response body that provides information about the preset that is created.</p>
    public let preset: Preset?
    /// <p>If the preset settings don't comply with the standards for the video codec but Elastic Transcoder
    ///             created the preset, this message explains the reason the preset settings don't meet the
    ///             standard. Elastic Transcoder created the preset because the settings might produce
    ///             acceptable output.</p>
    public let warning: String?

    public init (
        preset: Preset? = nil,
        warning: String? = nil
    )
    {
        self.preset = preset
        self.warning = warning
    }
}

struct CreatePresetOutputResponseBody: Equatable {
    public let preset: Preset?
    public let warning: String?
}

extension CreatePresetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case preset = "Preset"
        case warning = "Warning"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let presetDecoded = try containerValues.decodeIfPresent(Preset.self, forKey: .preset)
        preset = presetDecoded
        let warningDecoded = try containerValues.decodeIfPresent(String.self, forKey: .warning)
        warning = warningDecoded
    }
}

extension DeletePipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePipelineInput(id: \(String(describing: id)))"}
}

extension DeletePipelineInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeletePipelineInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePipelineInput>
    public typealias MOutput = OperationOutput<DeletePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePipelineOutputError>
}

public struct DeletePipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePipelineInput>
    public typealias MOutput = OperationOutput<DeletePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePipelineOutputError>
}

/// <p>The <code>DeletePipelineRequest</code> structure.</p>
public struct DeletePipelineInput: Equatable {
    /// <p>The identifier of the pipeline that you want to delete.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeletePipelineInputBody: Equatable {
}

extension DeletePipelineInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePipelineOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePipelineOutputResponse()"}
}

extension DeletePipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The <code>DeletePipelineResponse</code> structure.</p>
public struct DeletePipelineOutputResponse: Equatable {

    public init() {}
}

struct DeletePipelineOutputResponseBody: Equatable {
}

extension DeletePipelineOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePresetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePresetInput(id: \(String(describing: id)))"}
}

extension DeletePresetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeletePresetInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePresetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePresetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePresetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePresetInput>
    public typealias MOutput = OperationOutput<DeletePresetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePresetOutputError>
}

public struct DeletePresetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePresetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePresetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePresetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePresetInput>
    public typealias MOutput = OperationOutput<DeletePresetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePresetOutputError>
}

/// <p>The <code>DeletePresetRequest</code> structure.</p>
public struct DeletePresetInput: Equatable {
    /// <p>The identifier of the preset for which you want to get detailed information.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeletePresetInputBody: Equatable {
}

extension DeletePresetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePresetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePresetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePresetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePresetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePresetOutputResponse()"}
}

extension DeletePresetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The <code>DeletePresetResponse</code> structure.</p>
public struct DeletePresetOutputResponse: Equatable {

    public init() {}
}

struct DeletePresetOutputResponseBody: Equatable {
}

extension DeletePresetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DetectedProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case durationMillis = "DurationMillis"
        case fileSize = "FileSize"
        case frameRate = "FrameRate"
        case height = "Height"
        case width = "Width"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationMillis = durationMillis {
            try encodeContainer.encode(durationMillis, forKey: .durationMillis)
        }
        if let fileSize = fileSize {
            try encodeContainer.encode(fileSize, forKey: .fileSize)
        }
        if let frameRate = frameRate {
            try encodeContainer.encode(frameRate, forKey: .frameRate)
        }
        if let height = height {
            try encodeContainer.encode(height, forKey: .height)
        }
        if let width = width {
            try encodeContainer.encode(width, forKey: .width)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let widthDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .width)
        width = widthDecoded
        let heightDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .height)
        height = heightDecoded
        let frameRateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .frameRate)
        frameRate = frameRateDecoded
        let fileSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .fileSize)
        fileSize = fileSizeDecoded
        let durationMillisDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .durationMillis)
        durationMillis = durationMillisDecoded
    }
}

extension DetectedProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectedProperties(durationMillis: \(String(describing: durationMillis)), fileSize: \(String(describing: fileSize)), frameRate: \(String(describing: frameRate)), height: \(String(describing: height)), width: \(String(describing: width)))"}
}

/// <p>The detected properties of the input file. Elastic Transcoder identifies these values from the input file.</p>
public struct DetectedProperties: Equatable {
    /// <p>The detected duration of the input file, in milliseconds.</p>
    public let durationMillis: Int?
    /// <p>The detected file size of the input file, in bytes.</p>
    public let fileSize: Int?
    /// <p>The detected frame rate of the input file, in frames per second.</p>
    public let frameRate: String?
    /// <p>The detected height of the input file, in pixels.</p>
    public let height: Int?
    /// <p>The detected width of the input file, in pixels.</p>
    public let width: Int?

    public init (
        durationMillis: Int? = nil,
        fileSize: Int? = nil,
        frameRate: String? = nil,
        height: Int? = nil,
        width: Int? = nil
    )
    {
        self.durationMillis = durationMillis
        self.fileSize = fileSize
        self.frameRate = frameRate
        self.height = height
        self.width = width
    }
}

extension Encryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case initializationVector = "InitializationVector"
        case key = "Key"
        case keyMd5 = "KeyMd5"
        case mode = "Mode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initializationVector = initializationVector {
            try encodeContainer.encode(initializationVector, forKey: .initializationVector)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let keyMd5 = keyMd5 {
            try encodeContainer.encode(keyMd5, forKey: .keyMd5)
        }
        if let mode = mode {
            try encodeContainer.encode(mode, forKey: .mode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mode)
        mode = modeDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let keyMd5Decoded = try containerValues.decodeIfPresent(String.self, forKey: .keyMd5)
        keyMd5 = keyMd5Decoded
        let initializationVectorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initializationVector)
        initializationVector = initializationVectorDecoded
    }
}

extension Encryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Encryption(initializationVector: \(String(describing: initializationVector)), key: \(String(describing: key)), keyMd5: \(String(describing: keyMd5)), mode: \(String(describing: mode)))"}
}

/// <p>The encryption settings, if any, that are used for decrypting your input files or
///             encrypting your output files. If your input file is encrypted, you must specify the mode
///             that Elastic Transcoder uses to decrypt your file, otherwise you must specify the mode you want
///             Elastic Transcoder to use to encrypt your output files.</p>
public struct Encryption: Equatable {
    /// <p>The series of random bits created by a random bit generator, unique for every encryption
    ///             operation, that you used to encrypt your input files or that you want Elastic Transcoder to use to encrypt
    ///             your output files. The initialization vector must be base64-encoded, and it must be exactly
    ///             16 bytes long before being base64-encoded.</p>
    public let initializationVector: String?
    /// <p>The data encryption key that you want Elastic Transcoder to use to encrypt your output file, or that
    ///             was used to encrypt your input file. The key must be base64-encoded and it must be one of the
    ///             following bit lengths before being base64-encoded:</p>
    ///         <p>
    ///             <code>128</code>, <code>192</code>, or <code>256</code>. </p>
    ///         <p>The key must also be encrypted by using the Amazon Key Management Service.</p>
    public let key: String?
    /// <p>The MD5 digest of the key that you used to encrypt your input file, or that you want
    ///             Elastic Transcoder to use to encrypt your output file. Elastic Transcoder uses the key digest as a
    ///             checksum to make sure your key was not corrupted in transit. The key MD5 must be base64-encoded,
    ///             and it must be exactly 16 bytes long before being base64-encoded.</p>
    public let keyMd5: String?
    /// <p>The specific server-side encryption mode that you want Elastic Transcoder to use when decrypting
    ///             your input files or encrypting your output files. Elastic Transcoder supports the following options:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>s3:</b> Amazon S3 creates and manages the
    ///                 keys used for encrypting your files.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>s3-aws-kms:</b> Amazon S3 calls the Amazon Key Management
    ///                 Service, which
    ///                 creates and manages the keys that are used for encrypting your files. If you specify
    ///                 <code>s3-aws-kms</code> and you don't want to use the default key,
    ///                 you must add the AWS-KMS key that you want to use to your pipeline.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>aes-cbc-pkcs7:</b> A padded cipher-block
    ///                 mode of operation originally used for HLS files.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>aes-ctr:</b> AES Counter Mode.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>aes-gcm:</b> AES Galois Counter Mode,
    ///                 a mode of operation that is an authenticated encryption format, meaning that a file, key,
    ///                 or initialization vector that has been tampered with fails the decryption
    ///                 process.</p>
    ///             </li>
    ///          </ul>
    ///         <p>For all three AES options, you must provide the following settings, which must be base64-encoded:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Key</b>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Key MD5</b>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Initialization Vector</b>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///         <important>
    ///             <p>For the AES modes, your private encryption keys and your unencrypted data are never
    ///              stored by AWS; therefore, it is important that you safely manage your encryption keys.
    ///              If you lose them, you won't be able to unencrypt your data.</p>
    ///          </important>
    public let mode: String?

    public init (
        initializationVector: String? = nil,
        key: String? = nil,
        keyMd5: String? = nil,
        mode: String? = nil
    )
    {
        self.initializationVector = initializationVector
        self.key = key
        self.keyMd5 = keyMd5
        self.mode = mode
    }
}

extension HlsContentProtection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case initializationVector = "InitializationVector"
        case key = "Key"
        case keyMd5 = "KeyMd5"
        case keyStoragePolicy = "KeyStoragePolicy"
        case licenseAcquisitionUrl = "LicenseAcquisitionUrl"
        case method = "Method"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initializationVector = initializationVector {
            try encodeContainer.encode(initializationVector, forKey: .initializationVector)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let keyMd5 = keyMd5 {
            try encodeContainer.encode(keyMd5, forKey: .keyMd5)
        }
        if let keyStoragePolicy = keyStoragePolicy {
            try encodeContainer.encode(keyStoragePolicy, forKey: .keyStoragePolicy)
        }
        if let licenseAcquisitionUrl = licenseAcquisitionUrl {
            try encodeContainer.encode(licenseAcquisitionUrl, forKey: .licenseAcquisitionUrl)
        }
        if let method = method {
            try encodeContainer.encode(method, forKey: .method)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let methodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .method)
        method = methodDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let keyMd5Decoded = try containerValues.decodeIfPresent(String.self, forKey: .keyMd5)
        keyMd5 = keyMd5Decoded
        let initializationVectorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initializationVector)
        initializationVector = initializationVectorDecoded
        let licenseAcquisitionUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseAcquisitionUrl)
        licenseAcquisitionUrl = licenseAcquisitionUrlDecoded
        let keyStoragePolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyStoragePolicy)
        keyStoragePolicy = keyStoragePolicyDecoded
    }
}

extension HlsContentProtection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HlsContentProtection(initializationVector: \(String(describing: initializationVector)), key: \(String(describing: key)), keyMd5: \(String(describing: keyMd5)), keyStoragePolicy: \(String(describing: keyStoragePolicy)), licenseAcquisitionUrl: \(String(describing: licenseAcquisitionUrl)), method: \(String(describing: method)))"}
}

/// <p>The HLS content protection settings, if any, that you want Elastic Transcoder to apply to your output files.</p>
public struct HlsContentProtection: Equatable {
    /// <p>If Elastic Transcoder is generating your key for you, you must leave this field blank.</p>
    ///          <p>The series of random bits created by a random bit generator, unique for every encryption operation,
    ///     that you want Elastic Transcoder to use to encrypt your output files. The initialization vector must be base64-encoded,
    ///     and it must be exactly 16 bytes before being base64-encoded.</p>
    public let initializationVector: String?
    /// <p>If you want Elastic Transcoder to generate a key for you, leave this field blank.</p>
    ///          <p>If you choose to supply your own key, you must encrypt the key by using AWS KMS. The key must be
    ///     base64-encoded, and it must be one of the following bit lengths before being base64-encoded:</p>
    ///          <p>
    ///             <code>128</code>, <code>192</code>, or <code>256</code>. </p>
    public let key: String?
    /// <p>If Elastic Transcoder is generating your key for you, you must leave this field blank.</p>
    ///          <p>The MD5 digest of the key that you want Elastic Transcoder to use to encrypt your output file, and that you want
    ///     Elastic Transcoder to use as a checksum to make sure your key was not corrupted in transit. The key MD5 must be
    ///     base64-encoded, and it must be exactly 16 bytes before being base64- encoded.</p>
    public let keyMd5: String?
    /// <p>Specify whether you want Elastic Transcoder to write your HLS license key to an Amazon S3 bucket. If
    /// you choose <code>WithVariantPlaylists</code>, <code>LicenseAcquisitionUrl</code> must be left blank and Elastic Transcoder
    /// writes your data key into the same bucket as the associated playlist.</p>
    public let keyStoragePolicy: String?
    /// <p>The location of the license key required to decrypt your HLS playlist. The URL must be an absolute
    ///     path, and is referenced in the URI attribute of the EXT-X-KEY metadata tag in the playlist file.</p>
    public let licenseAcquisitionUrl: String?
    /// <p>The content protection method for your output. The only valid value is:
    /// <code>aes-128</code>.</p>
    ///          <p>This value is written into the method attribute of the <code>EXT-X-KEY</code> metadata tag in the output
    /// playlist.</p>
    public let method: String?

    public init (
        initializationVector: String? = nil,
        key: String? = nil,
        keyMd5: String? = nil,
        keyStoragePolicy: String? = nil,
        licenseAcquisitionUrl: String? = nil,
        method: String? = nil
    )
    {
        self.initializationVector = initializationVector
        self.key = key
        self.keyMd5 = keyMd5
        self.keyStoragePolicy = keyStoragePolicy
        self.licenseAcquisitionUrl = licenseAcquisitionUrl
        self.method = method
    }
}

extension IncompatibleVersionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncompatibleVersionException(message: \(String(describing: message)))"}
}

extension IncompatibleVersionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IncompatibleVersionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct IncompatibleVersionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IncompatibleVersionExceptionBody: Equatable {
    public let message: String?
}

extension IncompatibleVersionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InputCaptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case captionSources = "CaptionSources"
        case mergePolicy = "MergePolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let captionSources = captionSources {
            var captionSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .captionSources)
            for captionsources0 in captionSources {
                try captionSourcesContainer.encode(captionsources0)
            }
        }
        if let mergePolicy = mergePolicy {
            try encodeContainer.encode(mergePolicy, forKey: .mergePolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mergePolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mergePolicy)
        mergePolicy = mergePolicyDecoded
        let captionSourcesContainer = try containerValues.decodeIfPresent([CaptionSource?].self, forKey: .captionSources)
        var captionSourcesDecoded0:[CaptionSource]? = nil
        if let captionSourcesContainer = captionSourcesContainer {
            captionSourcesDecoded0 = [CaptionSource]()
            for structure0 in captionSourcesContainer {
                if let structure0 = structure0 {
                    captionSourcesDecoded0?.append(structure0)
                }
            }
        }
        captionSources = captionSourcesDecoded0
    }
}

extension InputCaptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputCaptions(captionSources: \(String(describing: captionSources)), mergePolicy: \(String(describing: mergePolicy)))"}
}

/// <p>The captions to be created, if any.</p>
public struct InputCaptions: Equatable {
    /// <p>Source files for the input sidecar captions used during the transcoding
    ///             process. To omit all sidecar captions, leave <code>CaptionSources</code> blank.</p>
    public let captionSources: [CaptionSource]?
    /// <p>A policy that determines how Elastic Transcoder handles the existence of multiple captions.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <b>MergeOverride:</b> Elastic Transcoder transcodes both embedded
    ///                     and sidecar captions into outputs. If captions for a language are embedded in the input
    ///                     file and also appear in a sidecar file, Elastic Transcoder uses the sidecar captions and ignores the
    ///                     embedded captions for that language.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>MergeRetain:</b>  Elastic Transcoder transcodes both embedded
    ///                     and sidecar captions into outputs. If captions for a language are embedded in the input
    ///                     file and also appear in a sidecar file, Elastic Transcoder uses the embedded captions and ignores the
    ///                     sidecar captions for that language. If <code>CaptionSources</code> is empty,
    ///                     Elastic Transcoder omits all sidecar captions from the output files.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>Override:</b> Elastic Transcoder transcodes only the
    ///                     sidecar captions that you specify in <code>CaptionSources</code>.</p>
    ///             </li>
    ///          </ul>
    ///         <p>
    ///             <code>MergePolicy</code> cannot be null.</p>
    public let mergePolicy: String?

    public init (
        captionSources: [CaptionSource]? = nil,
        mergePolicy: String? = nil
    )
    {
        self.captionSources = captionSources
        self.mergePolicy = mergePolicy
    }
}

extension InternalServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceException(message: \(String(describing: message)))"}
}

extension InternalServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Elastic Transcoder encountered an unexpected exception while trying to fulfill the request.</p>
public struct InternalServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Job: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
        case input = "Input"
        case inputs = "Inputs"
        case output = "Output"
        case outputKeyPrefix = "OutputKeyPrefix"
        case outputs = "Outputs"
        case pipelineId = "PipelineId"
        case playlists = "Playlists"
        case status = "Status"
        case timing = "Timing"
        case userMetadata = "UserMetadata"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let inputs = inputs {
            var inputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputs)
            for jobinputs0 in inputs {
                try inputsContainer.encode(jobinputs0)
            }
        }
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let outputKeyPrefix = outputKeyPrefix {
            try encodeContainer.encode(outputKeyPrefix, forKey: .outputKeyPrefix)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for joboutputs0 in outputs {
                try outputsContainer.encode(joboutputs0)
            }
        }
        if let pipelineId = pipelineId {
            try encodeContainer.encode(pipelineId, forKey: .pipelineId)
        }
        if let playlists = playlists {
            var playlistsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .playlists)
            for playlists0 in playlists {
                try playlistsContainer.encode(playlists0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let timing = timing {
            try encodeContainer.encode(timing, forKey: .timing)
        }
        if let userMetadata = userMetadata {
            var userMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .userMetadata)
            for (dictKey0, usermetadata0) in userMetadata {
                try userMetadataContainer.encode(usermetadata0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let pipelineIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineId)
        pipelineId = pipelineIdDecoded
        let inputDecoded = try containerValues.decodeIfPresent(JobInput.self, forKey: .input)
        input = inputDecoded
        let inputsContainer = try containerValues.decodeIfPresent([JobInput?].self, forKey: .inputs)
        var inputsDecoded0:[JobInput]? = nil
        if let inputsContainer = inputsContainer {
            inputsDecoded0 = [JobInput]()
            for structure0 in inputsContainer {
                if let structure0 = structure0 {
                    inputsDecoded0?.append(structure0)
                }
            }
        }
        inputs = inputsDecoded0
        let outputDecoded = try containerValues.decodeIfPresent(JobOutput.self, forKey: .output)
        output = outputDecoded
        let outputsContainer = try containerValues.decodeIfPresent([JobOutput?].self, forKey: .outputs)
        var outputsDecoded0:[JobOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [JobOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let outputKeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputKeyPrefix)
        outputKeyPrefix = outputKeyPrefixDecoded
        let playlistsContainer = try containerValues.decodeIfPresent([Playlist?].self, forKey: .playlists)
        var playlistsDecoded0:[Playlist]? = nil
        if let playlistsContainer = playlistsContainer {
            playlistsDecoded0 = [Playlist]()
            for structure0 in playlistsContainer {
                if let structure0 = structure0 {
                    playlistsDecoded0?.append(structure0)
                }
            }
        }
        playlists = playlistsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let userMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .userMetadata)
        var userMetadataDecoded0: [String:String]? = nil
        if let userMetadataContainer = userMetadataContainer {
            userMetadataDecoded0 = [String:String]()
            for (key0, string0) in userMetadataContainer {
                if let string0 = string0 {
                    userMetadataDecoded0?[key0] = string0
                }
            }
        }
        userMetadata = userMetadataDecoded0
        let timingDecoded = try containerValues.decodeIfPresent(Timing.self, forKey: .timing)
        timing = timingDecoded
    }
}

extension Job: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Job(arn: \(String(describing: arn)), id: \(String(describing: id)), input: \(String(describing: input)), inputs: \(String(describing: inputs)), output: \(String(describing: output)), outputKeyPrefix: \(String(describing: outputKeyPrefix)), outputs: \(String(describing: outputs)), pipelineId: \(String(describing: pipelineId)), playlists: \(String(describing: playlists)), status: \(String(describing: status)), timing: \(String(describing: timing)), userMetadata: \(String(describing: userMetadata)))"}
}

/// <p>A section of the response body that provides information about the job that is created.</p>
public struct Job: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the job.</p>
    public let arn: String?
    /// <p>The identifier that Elastic Transcoder assigned to the job. You use this value to get settings for the job or to delete the job.</p>
    public let id: String?
    /// <p>A section of the request or response body that provides information about the file that is being transcoded.</p>
    public let input: JobInput?
    /// <p>Information about the files that you're transcoding. If you specified multiple files for this
    ///             job, Elastic Transcoder stitches the files together to make one output.</p>
    public let inputs: [JobInput]?
    /// <p>If you specified one output for a job, information about that output. If you
    /// 		specified multiple outputs for a job, the Output object lists information about the first
    /// 		output. This duplicates the information that is listed for the first output in the Outputs object.</p>
    ///          <important>
    ///             <p>Outputs recommended instead.</p>
    ///          </important>
    /// 		       <p>A section of the request or response
    ///             body that provides information about the transcoded (target) file. </p>
    public let output: JobOutput?
    /// <p>The value, if any, that you want Elastic Transcoder to prepend to the names of all files that this job
    ///             creates, including output files, thumbnails, and playlists. We recommend that you add a
    ///             / or some other delimiter to the end of the <code>OutputKeyPrefix</code>.</p>
    public let outputKeyPrefix: String?
    /// <p>Information about the output files. We recommend that you use the <code>Outputs</code>
    ///             syntax for all jobs, even when you want Elastic Transcoder to transcode a file into only
    ///             one format. Do not use both the <code>Outputs</code> and <code>Output</code> syntaxes in
    ///             the same request. You can create a maximum of 30 outputs per job. </p>
    ///         <p>If you specify more than one output for a job, Elastic Transcoder creates the files for each output
    ///             in the order in which you specify them in the job.</p>
    public let outputs: [JobOutput]?
    /// <p> The <code>Id</code> of the pipeline that you want Elastic Transcoder to use for transcoding. The
    ///             pipeline determines several settings, including the Amazon S3 bucket from which Elastic Transcoder gets the
    ///             files to transcode and the bucket into which Elastic Transcoder puts the transcoded files. </p>
    public let pipelineId: String?
    /// <important>
    ///             <p>Outputs in Fragmented MP4 or MPEG-TS format only.</p>
    ///          </important>
    /// 		       <p>If you specify a preset in
    ///                 <code>PresetId</code> for which the value of <code>Container</code> is fmp4 (Fragmented MP4) or ts (MPEG-TS),
    ///                 <code>Playlists</code> contains information about the master playlists that you want
    ///             Elastic Transcoder to create.</p>
    ///         <p>The maximum number of master playlists in a job is 30.</p>
    public let playlists: [Playlist]?
    /// <p> The status of the job: <code>Submitted</code>, <code>Progressing</code>, <code>Complete</code>,
    ///                 <code>Canceled</code>, or <code>Error</code>. </p>
    public let status: String?
    /// <p>Details about the timing of a job.</p>
    public let timing: Timing?
    /// <p>User-defined metadata that you want to associate with an Elastic Transcoder job. You specify metadata in
    ///             <code>key/value</code> pairs, and you can add up to 10 <code>key/value</code> pairs per job.
    ///             Elastic Transcoder does not guarantee that <code>key/value</code> pairs are returned in the same
    ///             order in which you specify them.</p>
    ///             <p>Metadata <code>keys</code> and <code>values</code> must use characters from the following list:</p>
    ///             <ul>
    ///             <li>
    ///                <p>
    ///                   <code>0-9</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>A-Z</code> and <code>a-z</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Space</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>The following symbols: <code>_.:/=+-%@</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let userMetadata: [String:String]?

    public init (
        arn: String? = nil,
        id: String? = nil,
        input: JobInput? = nil,
        inputs: [JobInput]? = nil,
        output: JobOutput? = nil,
        outputKeyPrefix: String? = nil,
        outputs: [JobOutput]? = nil,
        pipelineId: String? = nil,
        playlists: [Playlist]? = nil,
        status: String? = nil,
        timing: Timing? = nil,
        userMetadata: [String:String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.input = input
        self.inputs = inputs
        self.output = output
        self.outputKeyPrefix = outputKeyPrefix
        self.outputs = outputs
        self.pipelineId = pipelineId
        self.playlists = playlists
        self.status = status
        self.timing = timing
        self.userMetadata = userMetadata
    }
}

extension JobAlbumArt: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artwork = "Artwork"
        case mergePolicy = "MergePolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artwork = artwork {
            var artworkContainer = encodeContainer.nestedUnkeyedContainer(forKey: .artwork)
            for artworks0 in artwork {
                try artworkContainer.encode(artworks0)
            }
        }
        if let mergePolicy = mergePolicy {
            try encodeContainer.encode(mergePolicy, forKey: .mergePolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mergePolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mergePolicy)
        mergePolicy = mergePolicyDecoded
        let artworkContainer = try containerValues.decodeIfPresent([Artwork?].self, forKey: .artwork)
        var artworkDecoded0:[Artwork]? = nil
        if let artworkContainer = artworkContainer {
            artworkDecoded0 = [Artwork]()
            for structure0 in artworkContainer {
                if let structure0 = structure0 {
                    artworkDecoded0?.append(structure0)
                }
            }
        }
        artwork = artworkDecoded0
    }
}

extension JobAlbumArt: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobAlbumArt(artwork: \(String(describing: artwork)), mergePolicy: \(String(describing: mergePolicy)))"}
}

/// <p>The .jpg or .png file associated with an audio file.</p>
public struct JobAlbumArt: Equatable {
    /// <p>The file to be used as album art. There can be multiple artworks associated with an audio file,
    ///             to a maximum of 20. Valid formats are <code>.jpg</code> and <code>.png</code>
    ///          </p>
    public let artwork: [Artwork]?
    /// <p>A policy that determines how Elastic Transcoder handles the existence of multiple album artwork files.</p>
    ///
    ///             <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Replace:</code> The specified album art replaces any existing album art.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Prepend:</code> The specified album art is placed in front of any existing
    ///                     album art.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Append:</code> The specified album art is placed after any existing album art.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Fallback:</code> If the original input file contains artwork, Elastic Transcoder uses that
    ///                     artwork for the output. If the original input does not contain artwork, Elastic Transcoder uses the
    ///                     specified album art file.</p>
    ///             </li>
    ///          </ul>
    public let mergePolicy: String?

    public init (
        artwork: [Artwork]? = nil,
        mergePolicy: String? = nil
    )
    {
        self.artwork = artwork
        self.mergePolicy = mergePolicy
    }
}

extension JobInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aspectRatio = "AspectRatio"
        case container = "Container"
        case detectedProperties = "DetectedProperties"
        case encryption = "Encryption"
        case frameRate = "FrameRate"
        case inputCaptions = "InputCaptions"
        case interlaced = "Interlaced"
        case key = "Key"
        case resolution = "Resolution"
        case timeSpan = "TimeSpan"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aspectRatio = aspectRatio {
            try encodeContainer.encode(aspectRatio, forKey: .aspectRatio)
        }
        if let container = container {
            try encodeContainer.encode(container, forKey: .container)
        }
        if let detectedProperties = detectedProperties {
            try encodeContainer.encode(detectedProperties, forKey: .detectedProperties)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let frameRate = frameRate {
            try encodeContainer.encode(frameRate, forKey: .frameRate)
        }
        if let inputCaptions = inputCaptions {
            try encodeContainer.encode(inputCaptions, forKey: .inputCaptions)
        }
        if let interlaced = interlaced {
            try encodeContainer.encode(interlaced, forKey: .interlaced)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let resolution = resolution {
            try encodeContainer.encode(resolution, forKey: .resolution)
        }
        if let timeSpan = timeSpan {
            try encodeContainer.encode(timeSpan, forKey: .timeSpan)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let frameRateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .frameRate)
        frameRate = frameRateDecoded
        let resolutionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolution)
        resolution = resolutionDecoded
        let aspectRatioDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aspectRatio)
        aspectRatio = aspectRatioDecoded
        let interlacedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .interlaced)
        interlaced = interlacedDecoded
        let containerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .container)
        container = containerDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let timeSpanDecoded = try containerValues.decodeIfPresent(TimeSpan.self, forKey: .timeSpan)
        timeSpan = timeSpanDecoded
        let inputCaptionsDecoded = try containerValues.decodeIfPresent(InputCaptions.self, forKey: .inputCaptions)
        inputCaptions = inputCaptionsDecoded
        let detectedPropertiesDecoded = try containerValues.decodeIfPresent(DetectedProperties.self, forKey: .detectedProperties)
        detectedProperties = detectedPropertiesDecoded
    }
}

extension JobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobInput(aspectRatio: \(String(describing: aspectRatio)), container: \(String(describing: container)), detectedProperties: \(String(describing: detectedProperties)), encryption: \(String(describing: encryption)), frameRate: \(String(describing: frameRate)), inputCaptions: \(String(describing: inputCaptions)), interlaced: \(String(describing: interlaced)), key: \(String(describing: key)), resolution: \(String(describing: resolution)), timeSpan: \(String(describing: timeSpan)))"}
}

/// <p>Information about the file that you're transcoding.</p>
public struct JobInput: Equatable {
    /// <p> The aspect ratio of the input file. If you want Elastic Transcoder to automatically detect the aspect
    ///             ratio of the input file, specify <code>auto</code>. If you want to specify the aspect
    ///             ratio for the output file, enter one of the following values: </p>
    ///         <p>
    ///             <code>1:1</code>, <code>4:3</code>, <code>3:2</code>, <code>16:9</code>
    ///         </p>
    ///         <p> If you specify a value other than <code>auto</code>, Elastic Transcoder disables automatic detection
    ///             of the aspect ratio. </p>
    public let aspectRatio: String?
    /// <p>The container type for the input file. If you want Elastic Transcoder to automatically detect the
    ///             container type of the input file, specify <code>auto</code>. If you want to specify the
    ///             container type for the input file, enter one of the following values: </p>
    ///         <p>
    ///             <code>3gp</code>, <code>aac</code>, <code>asf</code>, <code>avi</code>,
    ///                 <code>divx</code>, <code>flv</code>, <code>m4a</code>, <code>mkv</code>,
    ///                 <code>mov</code>, <code>mp3</code>, <code>mp4</code>, <code>mpeg</code>,
    ///                 <code>mpeg-ps</code>, <code>mpeg-ts</code>, <code>mxf</code>, <code>ogg</code>,
    ///                 <code>vob</code>, <code>wav</code>, <code>webm</code>
    ///         </p>
    public let container: String?
    /// <p>The detected properties of the input file.</p>
    public let detectedProperties: DetectedProperties?
    /// <p>The encryption settings, if any, that are used for decrypting your input files. If
    ///             your input file is encrypted, you must specify the mode that Elastic Transcoder uses to decrypt your file.</p>
    public let encryption: Encryption?
    /// <p>The frame rate of the input file. If you want Elastic Transcoder to automatically detect the frame rate
    ///             of the input file, specify <code>auto</code>. If you want to specify the frame rate for
    ///             the input file, enter one of the following values: </p>
    ///         <p>
    ///             <code>10</code>, <code>15</code>, <code>23.97</code>, <code>24</code>, <code>25</code>,
    ///                 <code>29.97</code>, <code>30</code>, <code>60</code>
    ///         </p>
    ///         <p>If you specify a value other than <code>auto</code>, Elastic Transcoder disables automatic detection of
    ///             the frame rate.</p>
    public let frameRate: String?
    /// <p>You can configure Elastic Transcoder to transcode captions, or subtitles, from one format to another.
    ///             All captions must be in UTF-8. Elastic Transcoder supports two types of captions:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <b>Embedded:</b> Embedded captions
    ///                     are included in the same file as the audio and video. Elastic Transcoder supports
    ///                     only one embedded caption per language, to a maximum of 300 embedded captions per file.</p>
    ///                 <p>Valid input values include: <code>CEA-608 (EIA-608</code>, first non-empty channel only),
    ///                     <code>CEA-708 (EIA-708</code>, first non-empty channel only), and <code>mov-text</code>
    ///                 </p>
    ///                 <p>Valid outputs include: <code>mov-text</code>
    ///                 </p>
    ///                 <p>Elastic Transcoder supports a maximum of one embedded format per output.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>Sidecar:</b> Sidecar captions are kept in a
    ///                     separate metadata file from the audio and video data.  Sidecar captions require a player
    ///                     that is capable of understanding the relationship between the video file and the sidecar
    ///                     file. Elastic Transcoder supports only one sidecar caption per language, to a maximum of 20 sidecar
    ///                     captions per file.</p>
    ///                 <p>Valid input values include: <code>dfxp</code> (first div element only),
    ///                     <code>ebu-tt</code>, <code>scc</code>, <code>smpt</code>, <code>srt</code>,
    ///                     <code>ttml</code> (first div element only), and <code>webvtt</code>
    ///                 </p>
    ///                 <p>Valid outputs include: <code>dfxp</code> (first div element only), <code>scc</code>,
    ///                     <code>srt</code>, and <code>webvtt</code>.</p>
    ///             </li>
    ///          </ul>
    ///         <p>If you want ttml or smpte-tt compatible captions, specify dfxp as your output format.</p>
    ///         <p>Elastic Transcoder does not support OCR (Optical Character Recognition), does not accept pictures
    ///             as a valid input for captions, and is not available for audio-only transcoding. Elastic Transcoder does
    ///             not preserve text formatting (for example, italics) during the transcoding process.</p>
    ///         <p>To remove captions or leave the captions empty, set <code>Captions</code> to null. To pass through
    ///             existing captions unchanged, set the <code>MergePolicy</code> to <code>MergeRetain</code>,
    ///             and pass in a null <code>CaptionSources</code> array.</p>
    ///         <p>For more information on embedded files, see the Subtitles Wikipedia page.</p>
    ///         <p>For more information on sidecar files, see the Extensible Metadata Platform and Sidecar file Wikipedia pages.</p>
    public let inputCaptions: InputCaptions?
    /// <p>Whether the input file is interlaced. If you want Elastic Transcoder to automatically detect whether
    ///             the input file is interlaced, specify <code>auto</code>. If you want to specify whether
    ///             the input file is interlaced, enter one of the following values:</p>
    ///         <p>
    ///             <code>true</code>, <code>false</code>
    ///          </p>
    ///         <p>If you specify a value other than <code>auto</code>, Elastic Transcoder disables automatic detection of
    ///             interlacing.</p>
    public let interlaced: String?
    /// <p> The name of the file to transcode. Elsewhere in the body of the JSON block is the the ID
    ///             of the pipeline to use for processing the job. The <code>InputBucket</code> object in
    ///             that pipeline tells Elastic Transcoder which Amazon S3 bucket to get the file from. </p>
    ///         <p>If the file name includes a prefix, such as <code>cooking/lasagna.mpg</code>, include the
    ///             prefix in the key. If the file isn't in the specified bucket, Elastic Transcoder returns an error.</p>
    public let key: String?
    /// <p>This value must be <code>auto</code>, which causes Elastic Transcoder to automatically
    ///             detect the resolution of the input file.</p>
    public let resolution: String?
    /// <p>Settings for clipping an input. Each input can have different clip settings.</p>
    public let timeSpan: TimeSpan?

    public init (
        aspectRatio: String? = nil,
        container: String? = nil,
        detectedProperties: DetectedProperties? = nil,
        encryption: Encryption? = nil,
        frameRate: String? = nil,
        inputCaptions: InputCaptions? = nil,
        interlaced: String? = nil,
        key: String? = nil,
        resolution: String? = nil,
        timeSpan: TimeSpan? = nil
    )
    {
        self.aspectRatio = aspectRatio
        self.container = container
        self.detectedProperties = detectedProperties
        self.encryption = encryption
        self.frameRate = frameRate
        self.inputCaptions = inputCaptions
        self.interlaced = interlaced
        self.key = key
        self.resolution = resolution
        self.timeSpan = timeSpan
    }
}

extension JobOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case albumArt = "AlbumArt"
        case appliedColorSpaceConversion = "AppliedColorSpaceConversion"
        case captions = "Captions"
        case composition = "Composition"
        case duration = "Duration"
        case durationMillis = "DurationMillis"
        case encryption = "Encryption"
        case fileSize = "FileSize"
        case frameRate = "FrameRate"
        case height = "Height"
        case id = "Id"
        case key = "Key"
        case presetId = "PresetId"
        case rotate = "Rotate"
        case segmentDuration = "SegmentDuration"
        case status = "Status"
        case statusDetail = "StatusDetail"
        case thumbnailEncryption = "ThumbnailEncryption"
        case thumbnailPattern = "ThumbnailPattern"
        case watermarks = "Watermarks"
        case width = "Width"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let albumArt = albumArt {
            try encodeContainer.encode(albumArt, forKey: .albumArt)
        }
        if let appliedColorSpaceConversion = appliedColorSpaceConversion {
            try encodeContainer.encode(appliedColorSpaceConversion, forKey: .appliedColorSpaceConversion)
        }
        if let captions = captions {
            try encodeContainer.encode(captions, forKey: .captions)
        }
        if let composition = composition {
            var compositionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .composition)
            for composition0 in composition {
                try compositionContainer.encode(composition0)
            }
        }
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let durationMillis = durationMillis {
            try encodeContainer.encode(durationMillis, forKey: .durationMillis)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let fileSize = fileSize {
            try encodeContainer.encode(fileSize, forKey: .fileSize)
        }
        if let frameRate = frameRate {
            try encodeContainer.encode(frameRate, forKey: .frameRate)
        }
        if let height = height {
            try encodeContainer.encode(height, forKey: .height)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let presetId = presetId {
            try encodeContainer.encode(presetId, forKey: .presetId)
        }
        if let rotate = rotate {
            try encodeContainer.encode(rotate, forKey: .rotate)
        }
        if let segmentDuration = segmentDuration {
            try encodeContainer.encode(segmentDuration, forKey: .segmentDuration)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusDetail = statusDetail {
            try encodeContainer.encode(statusDetail, forKey: .statusDetail)
        }
        if let thumbnailEncryption = thumbnailEncryption {
            try encodeContainer.encode(thumbnailEncryption, forKey: .thumbnailEncryption)
        }
        if let thumbnailPattern = thumbnailPattern {
            try encodeContainer.encode(thumbnailPattern, forKey: .thumbnailPattern)
        }
        if let watermarks = watermarks {
            var watermarksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .watermarks)
            for jobwatermarks0 in watermarks {
                try watermarksContainer.encode(jobwatermarks0)
            }
        }
        if let width = width {
            try encodeContainer.encode(width, forKey: .width)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let thumbnailPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thumbnailPattern)
        thumbnailPattern = thumbnailPatternDecoded
        let thumbnailEncryptionDecoded = try containerValues.decodeIfPresent(Encryption.self, forKey: .thumbnailEncryption)
        thumbnailEncryption = thumbnailEncryptionDecoded
        let rotateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rotate)
        rotate = rotateDecoded
        let presetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .presetId)
        presetId = presetIdDecoded
        let segmentDurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .segmentDuration)
        segmentDuration = segmentDurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let statusDetailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusDetail)
        statusDetail = statusDetailDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .duration)
        duration = durationDecoded
        let widthDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .width)
        width = widthDecoded
        let heightDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .height)
        height = heightDecoded
        let frameRateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .frameRate)
        frameRate = frameRateDecoded
        let fileSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .fileSize)
        fileSize = fileSizeDecoded
        let durationMillisDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .durationMillis)
        durationMillis = durationMillisDecoded
        let watermarksContainer = try containerValues.decodeIfPresent([JobWatermark?].self, forKey: .watermarks)
        var watermarksDecoded0:[JobWatermark]? = nil
        if let watermarksContainer = watermarksContainer {
            watermarksDecoded0 = [JobWatermark]()
            for structure0 in watermarksContainer {
                if let structure0 = structure0 {
                    watermarksDecoded0?.append(structure0)
                }
            }
        }
        watermarks = watermarksDecoded0
        let albumArtDecoded = try containerValues.decodeIfPresent(JobAlbumArt.self, forKey: .albumArt)
        albumArt = albumArtDecoded
        let compositionContainer = try containerValues.decodeIfPresent([Clip?].self, forKey: .composition)
        var compositionDecoded0:[Clip]? = nil
        if let compositionContainer = compositionContainer {
            compositionDecoded0 = [Clip]()
            for structure0 in compositionContainer {
                if let structure0 = structure0 {
                    compositionDecoded0?.append(structure0)
                }
            }
        }
        composition = compositionDecoded0
        let captionsDecoded = try containerValues.decodeIfPresent(Captions.self, forKey: .captions)
        captions = captionsDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let appliedColorSpaceConversionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appliedColorSpaceConversion)
        appliedColorSpaceConversion = appliedColorSpaceConversionDecoded
    }
}

extension JobOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobOutput(albumArt: \(String(describing: albumArt)), appliedColorSpaceConversion: \(String(describing: appliedColorSpaceConversion)), captions: \(String(describing: captions)), composition: \(String(describing: composition)), duration: \(String(describing: duration)), durationMillis: \(String(describing: durationMillis)), encryption: \(String(describing: encryption)), fileSize: \(String(describing: fileSize)), frameRate: \(String(describing: frameRate)), height: \(String(describing: height)), id: \(String(describing: id)), key: \(String(describing: key)), presetId: \(String(describing: presetId)), rotate: \(String(describing: rotate)), segmentDuration: \(String(describing: segmentDuration)), status: \(String(describing: status)), statusDetail: \(String(describing: statusDetail)), thumbnailEncryption: \(String(describing: thumbnailEncryption)), thumbnailPattern: \(String(describing: thumbnailPattern)), watermarks: \(String(describing: watermarks)), width: \(String(describing: width)))"}
}

/// <important>
///             <p>Outputs recommended instead.</p>
///          </important>
/// 		       <p>If you specified one output for a job,
///             information about that output. If you specified multiple outputs for a job, the
///                 <code>Output</code> object lists information about the first output. This duplicates
///             the information that is listed for the first output in the <code>Outputs</code>
///             object.</p>
public struct JobOutput: Equatable {
    /// <p>The album art to be associated with the output file, if any.</p>
    public let albumArt: JobAlbumArt?
    /// <p>If Elastic Transcoder used a preset with a <code>ColorSpaceConversionMode</code> to transcode the output
    ///       file, the <code>AppliedColorSpaceConversion</code> parameter shows the conversion used. If no
    ///       <code>ColorSpaceConversionMode</code> was defined in the preset, this parameter is not be
    ///       included in the job response.</p>
    public let appliedColorSpaceConversion: String?
    /// <p>You can configure Elastic Transcoder to transcode captions, or subtitles, from one format to another.
    ///           All captions must be in UTF-8. Elastic Transcoder supports two types of captions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Embedded:</b> Embedded captions
    ///             are included in the same file as the audio and video. Elastic Transcoder supports
    ///             only one embedded caption per language, to a maximum of 300 embedded captions per file.</p>
    ///                <p>Valid input values include: <code>CEA-608 (EIA-608</code>, first non-empty channel only),
    ///                <code>CEA-708 (EIA-708</code>, first non-empty channel only), and <code>mov-text</code>
    ///                </p>
    ///                <p>Valid outputs include: <code>mov-text</code>
    ///                </p>
    ///                <p>Elastic Transcoder supports a maximum of one embedded format per output.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Sidecar:</b> Sidecar captions are kept in a
    ///             separate metadata file from the audio and video data.  Sidecar captions require a player
    ///             that is capable of understanding the relationship between the video file and the sidecar
    ///             file. Elastic Transcoder supports only one sidecar caption per language, to a maximum of 20 sidecar
    ///             captions per file.</p>
    ///                <p>Valid input values include: <code>dfxp</code> (first div element only),
    ///                <code>ebu-tt</code>, <code>scc</code>, <code>smpt</code>, <code>srt</code>,
    ///                <code>ttml</code> (first div element only), and <code>webvtt</code>
    ///                </p>
    ///                <p>Valid outputs include: <code>dfxp</code> (first div element only), <code>scc</code>,
    ///                <code>srt</code>, and <code>webvtt</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you want ttml or smpte-tt compatible captions, specify dfxp as your output format.</p>
    ///          <p>Elastic Transcoder does not support OCR (Optical Character Recognition), does not accept pictures
    ///              as a valid input for captions, and is not available for audio-only transcoding. Elastic Transcoder does
    ///              not preserve text formatting (for example, italics) during the transcoding process.</p>
    ///              <p>To remove captions or leave the captions empty, set <code>Captions</code> to null. To pass through
    ///              existing captions unchanged, set the <code>MergePolicy</code> to <code>MergeRetain</code>,
    ///              and pass in a null <code>CaptionSources</code> array.</p>
    ///          <p>For more information on embedded files, see the Subtitles Wikipedia page.</p>
    ///          <p>For more information on sidecar files, see the Extensible Metadata Platform and Sidecar file Wikipedia pages.</p>
    public let captions: Captions?
    /// <p>You can create an output file that contains an excerpt from the input file. This excerpt, called
    ///             a clip, can come from the beginning, middle, or end of the file. The Composition object contains settings
    ///             for the clips that make up an output file. For the current release, you can only specify settings for a
    ///             single clip per output file. The Composition object cannot be null.</p>
    @available(*, deprecated)
    public let composition: [Clip]?
    /// <p>Duration of the output file, in seconds.</p>
    public let duration: Int?
    /// <p>Duration of the output file, in milliseconds.</p>
    public let durationMillis: Int?
    /// <p>The encryption settings, if any, that you want Elastic Transcoder to apply to your output files.
    ///             If you choose to use encryption, you must specify a mode to use. If you choose not to
    ///             use encryption, Elastic Transcoder writes an unencrypted file to your Amazon S3 bucket.</p>
    public let encryption: Encryption?
    /// <p>File size of the output file, in bytes.</p>
    public let fileSize: Int?
    /// <p>Frame rate of the output file, in frames per second.</p>
    public let frameRate: String?
    /// <p>Height of the output file, in pixels.</p>
    public let height: Int?
    /// <p>A sequential counter, starting with 1, that identifies an output among the outputs from
    ///             the current job. In the Output syntax, this value is always 1.</p>
    public let id: String?
    /// <p> The name to assign to the transcoded file. Elastic Transcoder saves the file in the Amazon S3 bucket
    ///             specified by the <code>OutputBucket</code> object in the pipeline that is specified by
    ///             the pipeline ID.</p>
    public let key: String?
    /// <p>The value of the <code>Id</code> object for the preset that you want to use for this job.
    ///             The preset determines the audio, video, and thumbnail settings that Elastic Transcoder
    ///             uses for transcoding. To use a preset that you created, specify the preset ID that
    ///             Elastic Transcoder returned in the response when you created the preset. You can also
    ///             use the Elastic Transcoder system presets, which you can get with <code>ListPresets</code>.</p>
    public let presetId: String?
    /// <p>The number of degrees clockwise by which you want Elastic Transcoder to rotate the output relative
    ///             to the input. Enter one of the following values:</p>
    ///         <p>
    ///             <code>auto</code>, <code>0</code>, <code>90</code>, <code>180</code>,
    ///             <code>270</code>
    ///          </p>
    ///         <p> The value <code>auto</code> generally works only if the file that you're transcoding
    ///             contains rotation metadata.</p>
    public let rotate: String?
    /// <important>
    ///             <p>(Outputs in Fragmented MP4 or MPEG-TS format only.</p>
    ///          </important>
    /// 		       <p>If you specify a preset in
    ///                 <code>PresetId</code> for which the value of <code>Container</code> is <code>fmp4</code> (Fragmented MP4) or
    ///                 <code>ts</code> (MPEG-TS), <code>SegmentDuration</code> is the target maximum duration of
    ///             each segment in seconds. For <code>HLSv3</code> format playlists,
    ///             each media segment is stored in a separate <code>.ts</code> file. For <code>HLSv4</code>, <code>MPEG-DASH</code>, and <code>Smooth</code>
    ///             playlists, all media segments for an output are stored in a single file. Each segment is approximately the length of
    ///             the <code>SegmentDuration</code>, though individual segments might be shorter or longer.</p>
    ///
    ///             <p>The range of valid values is 1 to 60 seconds. If the duration
    ///             of the video is not evenly divisible by <code>SegmentDuration</code>, the duration of
    ///             the last segment is the remainder of total length/SegmentDuration.</p>
    ///             <p>Elastic Transcoder
    ///             creates an output-specific playlist for each output <code>HLS</code> output that you specify in OutputKeys. To
    ///             add an output to the master playlist for this job, include it in the <code>OutputKeys</code> of
    ///             the associated playlist.</p>
    public let segmentDuration: String?
    /// <p> The status of one output in a job. If you specified only one output for the job,
    ///                 <code>Outputs:Status</code> is always the same as <code>Job:Status</code>. If you
    ///             specified more than one output: </p>
    /// 			      <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Job:Status</code> and <code>Outputs:Status</code> for all of the outputs
    ///                     is Submitted until Elastic Transcoder starts to process the first output.</p>
    ///             </li>
    ///             <li>
    ///                <p>When Elastic Transcoder starts to process the first output,
    ///                         <code>Outputs:Status</code> for that output and <code>Job:Status</code> both
    ///                     change to Progressing. For each output, the value of <code>Outputs:Status</code>
    ///                     remains Submitted until Elastic Transcoder starts to process the output.</p>
    ///             </li>
    ///             <li>
    ///                <p>Job:Status remains Progressing until all of the outputs reach a terminal status,
    ///                     either Complete or Error.</p>
    ///             </li>
    ///             <li>
    ///                <p>When all of the outputs reach a terminal status, <code>Job:Status</code> changes
    ///                     to Complete only if <code>Outputs:Status</code> for all of the outputs is
    ///                         <code>Complete</code>. If <code>Outputs:Status</code> for one or more
    ///                     outputs is <code>Error</code>, the terminal status for <code>Job:Status</code>
    ///                     is also <code>Error</code>.</p>
    ///             </li>
    ///          </ul>
    /// 			      <p>The value of <code>Status</code> is one of the following: <code>Submitted</code>,
    ///                 <code>Progressing</code>, <code>Complete</code>, <code>Canceled</code>, or
    ///                 <code>Error</code>. </p>
    public let status: String?
    /// <p>Information that further explains <code>Status</code>.</p>
    public let statusDetail: String?
    /// <p>The encryption settings, if any, that you want Elastic Transcoder to apply to your thumbnail.</p>
    public let thumbnailEncryption: Encryption?
    /// <p>Whether you want Elastic Transcoder to create thumbnails for your videos and, if so, how you want
    ///             Elastic Transcoder to name the files.</p>
    ///         <p>If you don't want Elastic Transcoder to create thumbnails, specify "".</p>
    ///         <p>If you do want Elastic Transcoder to create thumbnails, specify the information that you want to
    ///             include in the file name for each thumbnail. You can specify the following values in any sequence:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <b>
    ///                      <code>{count}</code> (Required)</b>: If you want to create thumbnails, you
    ///                     must include <code>{count}</code> in the <code>ThumbnailPattern</code> object.
    ///                     Wherever you specify <code>{count}</code>, Elastic Transcoder adds a five-digit sequence
    ///                     number (beginning with <b>00001</b>) to thumbnail file names. The number
    ///                     indicates where a given thumbnail appears in the sequence of thumbnails for a
    ///                     transcoded file. </p>
    ///                 <important>
    ///                   <p>If you specify a literal value and/or <code>{resolution}</code> but you
    ///                     omit <code>{count}</code>, Elastic Transcoder returns a validation error and does not create
    ///                     the job.</p>
    ///                </important>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>Literal values (Optional)</b>: You can specify literal values anywhere in the
    ///                         <code>ThumbnailPattern</code> object. For example, you can include them as a
    ///                     file name prefix or as a delimiter between <code>{resolution}</code> and
    ///                         <code>{count}</code>. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <b>
    ///                      <code>{resolution}</code> (Optional)</b>: If you want Elastic Transcoder to include the
    ///                     resolution in the file name, include <code>{resolution}</code> in the
    ///                         <code>ThumbnailPattern</code> object. </p>
    ///             </li>
    ///          </ul>
    ///         <p>When creating thumbnails, Elastic Transcoder automatically saves the files in the format (.jpg or .png)
    ///             that appears in the preset that you specified in the <code>PresetID</code> value of
    ///                 <code>CreateJobOutput</code>. Elastic Transcoder also appends the applicable file name
    ///             extension.</p>
    public let thumbnailPattern: String?
    /// <p>Information about the watermarks that you want Elastic Transcoder to add to the video during
    ///             transcoding. You can specify up to four watermarks for each output. Settings for each
    ///             watermark must be defined in the preset that you specify in <code>Preset</code> for the
    ///             current output.</p>
    ///         <p>Watermarks are added to the output video in the sequence in which you list them
    ///             in the job output—the first watermark in the list is added to the output video first,
    ///             the second watermark in the list is added next, and so on. As a result, if the settings
    ///             in a preset cause Elastic Transcoder to place all watermarks in the same location, the second watermark
    ///             that you add covers the first one, the third one covers the second, and the
    ///             fourth one covers the third.</p>
    public let watermarks: [JobWatermark]?
    /// <p>Specifies the width of the output file in pixels.</p>
    public let width: Int?

    public init (
        albumArt: JobAlbumArt? = nil,
        appliedColorSpaceConversion: String? = nil,
        captions: Captions? = nil,
        composition: [Clip]? = nil,
        duration: Int? = nil,
        durationMillis: Int? = nil,
        encryption: Encryption? = nil,
        fileSize: Int? = nil,
        frameRate: String? = nil,
        height: Int? = nil,
        id: String? = nil,
        key: String? = nil,
        presetId: String? = nil,
        rotate: String? = nil,
        segmentDuration: String? = nil,
        status: String? = nil,
        statusDetail: String? = nil,
        thumbnailEncryption: Encryption? = nil,
        thumbnailPattern: String? = nil,
        watermarks: [JobWatermark]? = nil,
        width: Int? = nil
    )
    {
        self.albumArt = albumArt
        self.appliedColorSpaceConversion = appliedColorSpaceConversion
        self.captions = captions
        self.composition = composition
        self.duration = duration
        self.durationMillis = durationMillis
        self.encryption = encryption
        self.fileSize = fileSize
        self.frameRate = frameRate
        self.height = height
        self.id = id
        self.key = key
        self.presetId = presetId
        self.rotate = rotate
        self.segmentDuration = segmentDuration
        self.status = status
        self.statusDetail = statusDetail
        self.thumbnailEncryption = thumbnailEncryption
        self.thumbnailPattern = thumbnailPattern
        self.watermarks = watermarks
        self.width = width
    }
}

extension JobWatermark: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryption = "Encryption"
        case inputKey = "InputKey"
        case presetWatermarkId = "PresetWatermarkId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let inputKey = inputKey {
            try encodeContainer.encode(inputKey, forKey: .inputKey)
        }
        if let presetWatermarkId = presetWatermarkId {
            try encodeContainer.encode(presetWatermarkId, forKey: .presetWatermarkId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let presetWatermarkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .presetWatermarkId)
        presetWatermarkId = presetWatermarkIdDecoded
        let inputKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputKey)
        inputKey = inputKeyDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
    }
}

extension JobWatermark: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobWatermark(encryption: \(String(describing: encryption)), inputKey: \(String(describing: inputKey)), presetWatermarkId: \(String(describing: presetWatermarkId)))"}
}

/// <p>Watermarks can be in .png or .jpg format. If you want to display a watermark that is not
///     rectangular, use the .png format, which supports transparency.</p>
public struct JobWatermark: Equatable {
    /// <p>The encryption settings, if any, that you want Elastic Transcoder to apply to your watermarks.</p>
    public let encryption: Encryption?
    /// <p> The name of the .png or .jpg file that you want to use for the watermark. To determine
    ///     which Amazon S3 bucket contains the specified file, Elastic Transcoder checks the pipeline specified by
    ///         <code>Pipeline</code>; the <code>Input Bucket</code> object in that pipeline
    ///     identifies the bucket.</p>
    ///          <p> If the file name includes a prefix, for example, <b>logos/128x64.png</b>,
    ///     include the prefix in the key. If the file isn't in the specified bucket, Elastic Transcoder returns
    ///     an error. </p>
    public let inputKey: String?
    /// <p>The ID of the watermark settings that Elastic Transcoder uses to add watermarks to the video during transcoding.
    ///     The settings are in the preset specified by Preset for the current output. In that preset, the value
    ///     of Watermarks Id tells Elastic Transcoder which settings to use.</p>
    public let presetWatermarkId: String?

    public init (
        encryption: Encryption? = nil,
        inputKey: String? = nil,
        presetWatermarkId: String? = nil
    )
    {
        self.encryption = encryption
        self.inputKey = inputKey
        self.presetWatermarkId = presetWatermarkId
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Too many operations for a given AWS account. For example, the number of pipelines
///             exceeds the maximum allowed.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListJobsByPipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsByPipelineInput(ascending: \(String(describing: ascending)), pageToken: \(String(describing: pageToken)), pipelineId: \(String(describing: pipelineId)))"}
}

extension ListJobsByPipelineInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListJobsByPipelineInputHeadersMiddleware: Middleware {
    public let id: String = "ListJobsByPipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsByPipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsByPipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsByPipelineInput>
    public typealias MOutput = OperationOutput<ListJobsByPipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsByPipelineOutputError>
}

public struct ListJobsByPipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJobsByPipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsByPipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsByPipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageToken = input.operationInput.pageToken {
            let pageTokenQueryItem = URLQueryItem(name: "PageToken".urlPercentEncoding(), value: String(pageToken).urlPercentEncoding())
            input.builder.withQueryItem(pageTokenQueryItem)
        }
        if let ascending = input.operationInput.ascending {
            let ascendingQueryItem = URLQueryItem(name: "Ascending".urlPercentEncoding(), value: String(ascending).urlPercentEncoding())
            input.builder.withQueryItem(ascendingQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsByPipelineInput>
    public typealias MOutput = OperationOutput<ListJobsByPipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsByPipelineOutputError>
}

/// <p>The <code>ListJobsByPipelineRequest</code> structure.</p>
public struct ListJobsByPipelineInput: Equatable {
    /// <p> To list jobs in chronological order by the date and time that they were submitted, enter
    ///                 <code>true</code>. To list jobs in reverse chronological order, enter
    ///                 <code>false</code>. </p>
    public let ascending: String?
    /// <p> When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
    ///             subsequent <code>GET</code> requests to get each successive page of results. </p>
    public let pageToken: String?
    /// <p>The ID of the pipeline for which you want to get job information.</p>
    public let pipelineId: String?

    public init (
        ascending: String? = nil,
        pageToken: String? = nil,
        pipelineId: String? = nil
    )
    {
        self.ascending = ascending
        self.pageToken = pageToken
        self.pipelineId = pipelineId
    }
}

struct ListJobsByPipelineInputBody: Equatable {
}

extension ListJobsByPipelineInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListJobsByPipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsByPipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobsByPipelineOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsByPipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsByPipelineOutputResponse(jobs: \(String(describing: jobs)), nextPageToken: \(String(describing: nextPageToken)))"}
}

extension ListJobsByPipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListJobsByPipelineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobs = output.jobs
            self.nextPageToken = output.nextPageToken
        } else {
            self.jobs = nil
            self.nextPageToken = nil
        }
    }
}

/// <p>The <code>ListJobsByPipelineResponse</code> structure.</p>
public struct ListJobsByPipelineOutputResponse: Equatable {
    /// <p>An array of <code>Job</code> objects that are in the specified pipeline.</p>
    public let jobs: [Job]?
    /// <p> A value that you use to access the second and subsequent pages of results, if any. When
    ///             the jobs in the specified pipeline fit on one page or when you've reached the last page
    ///             of results, the value of <code>NextPageToken</code> is <code>null</code>. </p>
    public let nextPageToken: String?

    public init (
        jobs: [Job]? = nil,
        nextPageToken: String? = nil
    )
    {
        self.jobs = jobs
        self.nextPageToken = nextPageToken
    }
}

struct ListJobsByPipelineOutputResponseBody: Equatable {
    public let jobs: [Job]?
    public let nextPageToken: String?
}

extension ListJobsByPipelineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobs = "Jobs"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([Job?].self, forKey: .jobs)
        var jobsDecoded0:[Job]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [Job]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension ListJobsByStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsByStatusInput(ascending: \(String(describing: ascending)), pageToken: \(String(describing: pageToken)), status: \(String(describing: status)))"}
}

extension ListJobsByStatusInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListJobsByStatusInputHeadersMiddleware: Middleware {
    public let id: String = "ListJobsByStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsByStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsByStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsByStatusInput>
    public typealias MOutput = OperationOutput<ListJobsByStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsByStatusOutputError>
}

public struct ListJobsByStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJobsByStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsByStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsByStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageToken = input.operationInput.pageToken {
            let pageTokenQueryItem = URLQueryItem(name: "PageToken".urlPercentEncoding(), value: String(pageToken).urlPercentEncoding())
            input.builder.withQueryItem(pageTokenQueryItem)
        }
        if let ascending = input.operationInput.ascending {
            let ascendingQueryItem = URLQueryItem(name: "Ascending".urlPercentEncoding(), value: String(ascending).urlPercentEncoding())
            input.builder.withQueryItem(ascendingQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsByStatusInput>
    public typealias MOutput = OperationOutput<ListJobsByStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsByStatusOutputError>
}

/// <p>The <code>ListJobsByStatusRequest</code> structure.</p>
public struct ListJobsByStatusInput: Equatable {
    /// <p> To list jobs in chronological order by the date and time that they were submitted, enter
    ///                 <code>true</code>. To list jobs in reverse chronological order, enter
    ///                 <code>false</code>. </p>
    public let ascending: String?
    /// <p> When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
    ///             subsequent <code>GET</code> requests to get each successive page of results. </p>
    public let pageToken: String?
    /// <p>To get information about all of the jobs associated with the current AWS account that
    ///             have a given status, specify the following status: <code>Submitted</code>,
    ///                 <code>Progressing</code>, <code>Complete</code>, <code>Canceled</code>, or
    ///                 <code>Error</code>.</p>
    public let status: String?

    public init (
        ascending: String? = nil,
        pageToken: String? = nil,
        status: String? = nil
    )
    {
        self.ascending = ascending
        self.pageToken = pageToken
        self.status = status
    }
}

struct ListJobsByStatusInputBody: Equatable {
}

extension ListJobsByStatusInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListJobsByStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsByStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobsByStatusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsByStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsByStatusOutputResponse(jobs: \(String(describing: jobs)), nextPageToken: \(String(describing: nextPageToken)))"}
}

extension ListJobsByStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListJobsByStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobs = output.jobs
            self.nextPageToken = output.nextPageToken
        } else {
            self.jobs = nil
            self.nextPageToken = nil
        }
    }
}

/// <p>
///             The <code>ListJobsByStatusResponse</code> structure.
///         </p>
public struct ListJobsByStatusOutputResponse: Equatable {
    /// <p>An array of <code>Job</code> objects that have the specified status.</p>
    public let jobs: [Job]?
    /// <p> A value that you use to access the second and subsequent pages of results, if any. When
    ///             the jobs in the specified pipeline fit on one page or when you've reached the last page
    ///             of results, the value of <code>NextPageToken</code> is <code>null</code>. </p>
    public let nextPageToken: String?

    public init (
        jobs: [Job]? = nil,
        nextPageToken: String? = nil
    )
    {
        self.jobs = jobs
        self.nextPageToken = nextPageToken
    }
}

struct ListJobsByStatusOutputResponseBody: Equatable {
    public let jobs: [Job]?
    public let nextPageToken: String?
}

extension ListJobsByStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobs = "Jobs"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([Job?].self, forKey: .jobs)
        var jobsDecoded0:[Job]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [Job]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension ListPipelinesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPipelinesInput(ascending: \(String(describing: ascending)), pageToken: \(String(describing: pageToken)))"}
}

extension ListPipelinesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPipelinesInputHeadersMiddleware: Middleware {
    public let id: String = "ListPipelinesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPipelinesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPipelinesInput>
    public typealias MOutput = OperationOutput<ListPipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPipelinesOutputError>
}

public struct ListPipelinesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPipelinesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPipelinesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageToken = input.operationInput.pageToken {
            let pageTokenQueryItem = URLQueryItem(name: "PageToken".urlPercentEncoding(), value: String(pageToken).urlPercentEncoding())
            input.builder.withQueryItem(pageTokenQueryItem)
        }
        if let ascending = input.operationInput.ascending {
            let ascendingQueryItem = URLQueryItem(name: "Ascending".urlPercentEncoding(), value: String(ascending).urlPercentEncoding())
            input.builder.withQueryItem(ascendingQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPipelinesInput>
    public typealias MOutput = OperationOutput<ListPipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPipelinesOutputError>
}

/// <p>The <code>ListPipelineRequest</code> structure.</p>
public struct ListPipelinesInput: Equatable {
    /// <p>To list pipelines in chronological order by the date and time that they were created, enter
    ///             <code>true</code>. To list pipelines in reverse chronological order, enter
    ///             <code>false</code>.</p>
    public let ascending: String?
    /// <p>When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
    ///             subsequent <code>GET</code> requests to get each successive page of results. </p>
    public let pageToken: String?

    public init (
        ascending: String? = nil,
        pageToken: String? = nil
    )
    {
        self.ascending = ascending
        self.pageToken = pageToken
    }
}

struct ListPipelinesInputBody: Equatable {
}

extension ListPipelinesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPipelinesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPipelinesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPipelinesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPipelinesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPipelinesOutputResponse(nextPageToken: \(String(describing: nextPageToken)), pipelines: \(String(describing: pipelines)))"}
}

extension ListPipelinesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPipelinesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.pipelines = output.pipelines
        } else {
            self.nextPageToken = nil
            self.pipelines = nil
        }
    }
}

/// <p>A list of the pipelines associated with the current AWS account.</p>
public struct ListPipelinesOutputResponse: Equatable {
    /// <p>A value that you use to access the second and subsequent pages of results, if any. When
    ///             the pipelines fit on one page or when you've reached the last page
    ///             of results, the value of <code>NextPageToken</code> is <code>null</code>.</p>
    public let nextPageToken: String?
    /// <p>An array of <code>Pipeline</code> objects.</p>
    public let pipelines: [Pipeline]?

    public init (
        nextPageToken: String? = nil,
        pipelines: [Pipeline]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.pipelines = pipelines
    }
}

struct ListPipelinesOutputResponseBody: Equatable {
    public let pipelines: [Pipeline]?
    public let nextPageToken: String?
}

extension ListPipelinesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case pipelines = "Pipelines"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelinesContainer = try containerValues.decodeIfPresent([Pipeline?].self, forKey: .pipelines)
        var pipelinesDecoded0:[Pipeline]? = nil
        if let pipelinesContainer = pipelinesContainer {
            pipelinesDecoded0 = [Pipeline]()
            for structure0 in pipelinesContainer {
                if let structure0 = structure0 {
                    pipelinesDecoded0?.append(structure0)
                }
            }
        }
        pipelines = pipelinesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension ListPresetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPresetsInput(ascending: \(String(describing: ascending)), pageToken: \(String(describing: pageToken)))"}
}

extension ListPresetsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPresetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPresetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPresetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPresetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPresetsInput>
    public typealias MOutput = OperationOutput<ListPresetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPresetsOutputError>
}

public struct ListPresetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPresetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPresetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPresetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageToken = input.operationInput.pageToken {
            let pageTokenQueryItem = URLQueryItem(name: "PageToken".urlPercentEncoding(), value: String(pageToken).urlPercentEncoding())
            input.builder.withQueryItem(pageTokenQueryItem)
        }
        if let ascending = input.operationInput.ascending {
            let ascendingQueryItem = URLQueryItem(name: "Ascending".urlPercentEncoding(), value: String(ascending).urlPercentEncoding())
            input.builder.withQueryItem(ascendingQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPresetsInput>
    public typealias MOutput = OperationOutput<ListPresetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPresetsOutputError>
}

/// <p>The <code>ListPresetsRequest</code> structure.</p>
public struct ListPresetsInput: Equatable {
    /// <p>To list presets in chronological order by the date and time that they were created, enter
    ///             <code>true</code>. To list presets in reverse chronological order, enter
    ///             <code>false</code>.</p>
    public let ascending: String?
    /// <p>When Elastic Transcoder returns more than one page of results, use <code>pageToken</code> in
    ///             subsequent <code>GET</code> requests to get each successive page of results. </p>
    public let pageToken: String?

    public init (
        ascending: String? = nil,
        pageToken: String? = nil
    )
    {
        self.ascending = ascending
        self.pageToken = pageToken
    }
}

struct ListPresetsInputBody: Equatable {
}

extension ListPresetsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPresetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPresetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPresetsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPresetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPresetsOutputResponse(nextPageToken: \(String(describing: nextPageToken)), presets: \(String(describing: presets)))"}
}

extension ListPresetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPresetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.presets = output.presets
        } else {
            self.nextPageToken = nil
            self.presets = nil
        }
    }
}

/// <p>The <code>ListPresetsResponse</code> structure.</p>
public struct ListPresetsOutputResponse: Equatable {
    /// <p>A value that you use to access the second and subsequent pages of results, if any. When
    ///             the presets fit on one page or when you've reached the last page
    ///             of results, the value of <code>NextPageToken</code> is <code>null</code>.</p>
    public let nextPageToken: String?
    /// <p>An array of <code>Preset</code> objects.</p>
    public let presets: [Preset]?

    public init (
        nextPageToken: String? = nil,
        presets: [Preset]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.presets = presets
    }
}

struct ListPresetsOutputResponseBody: Equatable {
    public let presets: [Preset]?
    public let nextPageToken: String?
}

extension ListPresetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case presets = "Presets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let presetsContainer = try containerValues.decodeIfPresent([Preset?].self, forKey: .presets)
        var presetsDecoded0:[Preset]? = nil
        if let presetsContainer = presetsContainer {
            presetsDecoded0 = [Preset]()
            for structure0 in presetsContainer {
                if let structure0 = structure0 {
                    presetsDecoded0?.append(structure0)
                }
            }
        }
        presets = presetsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension Notifications: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case completed = "Completed"
        case error = "Error"
        case progressing = "Progressing"
        case warning = "Warning"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completed = completed {
            try encodeContainer.encode(completed, forKey: .completed)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let progressing = progressing {
            try encodeContainer.encode(progressing, forKey: .progressing)
        }
        if let warning = warning {
            try encodeContainer.encode(warning, forKey: .warning)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressingDecoded = try containerValues.decodeIfPresent(String.self, forKey: .progressing)
        progressing = progressingDecoded
        let completedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .completed)
        completed = completedDecoded
        let warningDecoded = try containerValues.decodeIfPresent(String.self, forKey: .warning)
        warning = warningDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
    }
}

extension Notifications: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Notifications(completed: \(String(describing: completed)), error: \(String(describing: error)), progressing: \(String(describing: progressing)), warning: \(String(describing: warning)))"}
}

/// <p>The Amazon Simple Notification Service (Amazon SNS) topic or topics to notify in order to report job status.</p>
///         <important>
///             <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
///          </important>
public struct Notifications: Equatable {
    /// <p>The Amazon SNS topic that you want to notify when Elastic Transcoder has finished processing the job.</p>
    public let completed: String?
    /// <p>The Amazon SNS topic that you want to notify when Elastic Transcoder encounters an error condition.</p>
    public let error: String?
    /// <p>The Amazon Simple Notification Service (Amazon SNS) topic that you want to notify when Elastic Transcoder has started to process the job.</p>
    public let progressing: String?
    /// <p>The Amazon SNS topic that you want to notify when Elastic Transcoder encounters a warning condition.</p>
    public let warning: String?

    public init (
        completed: String? = nil,
        error: String? = nil,
        progressing: String? = nil,
        warning: String? = nil
    )
    {
        self.completed = completed
        self.error = error
        self.progressing = progressing
        self.warning = warning
    }
}

extension Permission: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case access = "Access"
        case grantee = "Grantee"
        case granteeType = "GranteeType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let access = access {
            var accessContainer = encodeContainer.nestedUnkeyedContainer(forKey: .access)
            for accesscontrols0 in access {
                try accessContainer.encode(accesscontrols0)
            }
        }
        if let grantee = grantee {
            try encodeContainer.encode(grantee, forKey: .grantee)
        }
        if let granteeType = granteeType {
            try encodeContainer.encode(granteeType, forKey: .granteeType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let granteeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .granteeType)
        granteeType = granteeTypeDecoded
        let granteeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grantee)
        grantee = granteeDecoded
        let accessContainer = try containerValues.decodeIfPresent([String?].self, forKey: .access)
        var accessDecoded0:[String]? = nil
        if let accessContainer = accessContainer {
            accessDecoded0 = [String]()
            for string0 in accessContainer {
                if let string0 = string0 {
                    accessDecoded0?.append(string0)
                }
            }
        }
        access = accessDecoded0
    }
}

extension Permission: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Permission(access: \(String(describing: access)), grantee: \(String(describing: grantee)), granteeType: \(String(describing: granteeType)))"}
}

/// <p>The <code>Permission</code> structure.</p>
public struct Permission: Equatable {
    /// <p> The permission that you want to give to the AWS user that is listed in Grantee. Valid
    ///             values include: </p>
    /// 			      <ul>
    ///             <li>
    ///                <p>
    ///                   <code>READ</code>: The grantee can read the thumbnails and metadata for
    ///                     thumbnails that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>READ_ACP</code>: The grantee can read the object ACL for thumbnails that
    ///                     Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>WRITE_ACP</code>: The grantee can write the ACL for the thumbnails that
    ///                     Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FULL_CONTROL</code>: The grantee has READ, READ_ACP, and WRITE_ACP
    ///                     permissions for the thumbnails that Elastic Transcoder adds to the Amazon S3
    ///                     bucket.</p>
    ///             </li>
    ///          </ul>
    public let access: [String]?
    /// <p>The AWS user or group that you want to have access to transcoded files and playlists. To
    ///             identify the user or group, you can specify the canonical user ID for an AWS account, an origin
    ///             access identity for a CloudFront distribution, the registered email address of an AWS account,
    ///             or a predefined Amazon S3 group.</p>
    public let grantee: String?
    /// <p>The type of value that appears in the Grantee object:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Canonical</code>: Either the canonical user ID for an AWS account or an
    ///                     origin access identity for an Amazon CloudFront distribution.</p>
    /// 					          <important>
    ///                   <p>A
    ///                         canonical user ID is not the same as an AWS account number.</p>
    ///                </important>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Email</code>: The registered email address of an AWS account.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Group</code>: One of the following predefined Amazon S3 groups:
    ///                         <code>AllUsers</code>, <code>AuthenticatedUsers</code>, or
    ///                         <code>LogDelivery</code>.</p>
    ///             </li>
    ///          </ul>
    public let granteeType: String?

    public init (
        access: [String]? = nil,
        grantee: String? = nil,
        granteeType: String? = nil
    )
    {
        self.access = access
        self.grantee = grantee
        self.granteeType = granteeType
    }
}

extension Pipeline: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case awsKmsKeyArn = "AwsKmsKeyArn"
        case contentConfig = "ContentConfig"
        case id = "Id"
        case inputBucket = "InputBucket"
        case name = "Name"
        case notifications = "Notifications"
        case outputBucket = "OutputBucket"
        case role = "Role"
        case status = "Status"
        case thumbnailConfig = "ThumbnailConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let awsKmsKeyArn = awsKmsKeyArn {
            try encodeContainer.encode(awsKmsKeyArn, forKey: .awsKmsKeyArn)
        }
        if let contentConfig = contentConfig {
            try encodeContainer.encode(contentConfig, forKey: .contentConfig)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let inputBucket = inputBucket {
            try encodeContainer.encode(inputBucket, forKey: .inputBucket)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notifications = notifications {
            try encodeContainer.encode(notifications, forKey: .notifications)
        }
        if let outputBucket = outputBucket {
            try encodeContainer.encode(outputBucket, forKey: .outputBucket)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let thumbnailConfig = thumbnailConfig {
            try encodeContainer.encode(thumbnailConfig, forKey: .thumbnailConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let inputBucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputBucket)
        inputBucket = inputBucketDecoded
        let outputBucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputBucket)
        outputBucket = outputBucketDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let awsKmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsKmsKeyArn)
        awsKmsKeyArn = awsKmsKeyArnDecoded
        let notificationsDecoded = try containerValues.decodeIfPresent(Notifications.self, forKey: .notifications)
        notifications = notificationsDecoded
        let contentConfigDecoded = try containerValues.decodeIfPresent(PipelineOutputConfig.self, forKey: .contentConfig)
        contentConfig = contentConfigDecoded
        let thumbnailConfigDecoded = try containerValues.decodeIfPresent(PipelineOutputConfig.self, forKey: .thumbnailConfig)
        thumbnailConfig = thumbnailConfigDecoded
    }
}

extension Pipeline: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Pipeline(arn: \(String(describing: arn)), awsKmsKeyArn: \(String(describing: awsKmsKeyArn)), contentConfig: \(String(describing: contentConfig)), id: \(String(describing: id)), inputBucket: \(String(describing: inputBucket)), name: \(String(describing: name)), notifications: \(String(describing: notifications)), outputBucket: \(String(describing: outputBucket)), role: \(String(describing: role)), status: \(String(describing: status)), thumbnailConfig: \(String(describing: thumbnailConfig)))"}
}

/// <p>The pipeline (queue) that is used to manage jobs.</p>
public struct Pipeline: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the pipeline.</p>
    public let arn: String?
    /// <p>The AWS Key Management Service (AWS KMS) key that you want to use with this pipeline.</p>
    ///         <p>If you use either <code>s3</code> or <code>s3-aws-kms</code> as your
    ///             <code>Encryption:Mode</code>, you don't need to provide a key with
    ///             your job because a default key, known as an AWS-KMS key, is created for you automatically.
    ///             You need to provide an AWS-KMS key only if you want to use a non-default AWS-KMS key, or if you are
    ///             using an <code>Encryption:Mode</code> of <code>aes-cbc-pkcs7</code>, <code>aes-ctr</code>,
    ///             or <code>aes-gcm</code>.</p>
    public let awsKmsKeyArn: String?
    /// <p>Information about the Amazon S3 bucket in which you want Elastic Transcoder to save
    ///             transcoded files and playlists. Either you specify both <code>ContentConfig</code> and
    ///                 <code>ThumbnailConfig</code>, or you specify <code>OutputBucket</code>.</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
    ///                 transcoded files and playlists.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Permissions</b>: A list of the users and/or predefined Amazon S3 groups you want
    ///                 to have access to transcoded files and playlists, and the type of access that you
    ///                 want them to have. </p>
    /// 				           <ul>
    ///                   <li>
    ///                      <p>GranteeType: The type of value that appears in the <code>Grantee</code>
    ///                         object: </p>
    ///                      <ul>
    ///                         <li>
    ///                            <p>
    ///                               <code>Canonical</code>: Either the canonical user ID for an AWS
    ///                                 account or an origin access identity for an Amazon CloudFront
    ///                                 distribution.</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>Email</code>: The registered email address of an AWS
    ///                                 account.</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>Group</code>: One of the following predefined Amazon S3
    ///                                 groups: <code>AllUsers</code>, <code>AuthenticatedUsers</code>, or
    ///                                     <code>LogDelivery</code>.</p>
    ///                         </li>
    ///                      </ul>
    ///                     </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>Grantee</code>: The AWS user or group that you want to have access to
    ///                         transcoded files and playlists.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>Access</code>: The permission that you want to give to the AWS user
    ///                         that is listed in <code>Grantee</code>. Valid values include:</p>
    /// 						               <ul>
    ///                         <li>
    ///                            <p>
    ///                               <code>READ</code>: The grantee can read the objects and metadata for
    ///                                 objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>READ_ACP</code>: The grantee can read the object ACL for
    ///                                 objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>WRITE_ACP</code>: The grantee can write the ACL for the
    ///                                 objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
    ///                                     <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions
    ///                                 for the objects that Elastic Transcoder adds to the Amazon S3
    ///                                 bucket.</p>
    ///                         </li>
    ///                      </ul>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>StorageClass</b>: The Amazon S3 storage class, Standard or ReducedRedundancy,
    ///                 that you want Elastic Transcoder to assign to the video files and playlists that it
    ///                 stores in your Amazon S3 bucket. </p>
    ///             </li>
    ///          </ul>
    public let contentConfig: PipelineOutputConfig?
    /// <p>The identifier for the pipeline. You use this value to identify the pipeline in
    ///             which you want to perform a variety of operations, such as creating a job or a preset.</p>
    public let id: String?
    /// <p>The Amazon S3 bucket from which Elastic Transcoder gets media files for transcoding and the graphics
    ///             files, if any, that you want to use for watermarks.</p>
    public let inputBucket: String?
    /// <p>The name of the pipeline. We recommend that the name be unique within the AWS account,
    ///             but uniqueness is not enforced.</p>
    ///         <p>Constraints: Maximum 40 characters</p>
    public let name: String?
    /// <p>The Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status.</p>
    ///         <important>
    ///             <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
    ///          </important>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Progressing</b> (optional): The Amazon Simple Notification Service (Amazon SNS) topic that you want to notify
    ///                 when Elastic Transcoder has started to process the job.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Complete</b> (optional): The Amazon SNS topic that you want to notify when Elastic Transcoder has
    ///                 finished processing the job.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Warning</b> (optional): The Amazon SNS topic that you want to notify when Elastic Transcoder
    ///                 encounters a warning condition.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Error</b> (optional): The Amazon SNS topic that you want to notify when Elastic Transcoder
    ///                 encounters an error condition.</p>
    ///             </li>
    ///          </ul>
    public let notifications: Notifications?
    /// <p>The Amazon S3 bucket in which you want Elastic Transcoder to save transcoded files,
    ///             thumbnails, and playlists. Either you specify this value, or you specify both
    ///                 <code>ContentConfig</code> and <code>ThumbnailConfig</code>.</p>
    public let outputBucket: String?
    /// <p>The IAM Amazon Resource Name (ARN) for the role that Elastic Transcoder uses to transcode jobs for this pipeline.</p>
    public let role: String?
    /// <p>The current status of the pipeline:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Active</code>: The pipeline is processing jobs.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Paused</code>: The pipeline is not currently processing jobs.</p>
    ///             </li>
    ///          </ul>
    public let status: String?
    /// <p>Information about the Amazon S3 bucket in which you want Elastic Transcoder to save
    ///             thumbnail files. Either you specify both <code>ContentConfig</code> and
    ///                 <code>ThumbnailConfig</code>, or you specify <code>OutputBucket</code>.</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Bucket</code>: The Amazon S3 bucket in which you want Elastic Transcoder to
    ///                 save thumbnail files. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Permissions</code>: A list of the users and/or predefined Amazon S3 groups you
    ///                 want to have access to thumbnail files, and the type of access that you want them to
    ///                 have. </p>
    /// 				           <ul>
    ///                   <li>
    ///                      <p>GranteeType: The type of value that appears in the Grantee object:</p>
    /// 					                <ul>
    ///                         <li>
    ///                            <p>
    ///                               <code>Canonical</code>: Either the canonical user ID for an AWS
    ///                                 account or an origin access identity for an Amazon CloudFront
    ///                                 distribution.</p>
    ///                            <important>
    ///                               <p>A canonical user ID is not the same as an
    ///                                     AWS account number.</p>
    ///                            </important>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>Email</code>: The registered email address of an AWS
    ///                                 account.</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>Group</code>: One of the following predefined Amazon S3
    ///                                 groups: <code>AllUsers</code>, <code>AuthenticatedUsers</code>, or
    ///                                     <code>LogDelivery</code>.</p>
    ///                         </li>
    ///                      </ul>
    ///                     </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>Grantee</code>: The AWS user or group that you want to have access to
    ///                         thumbnail files.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Access: The permission that you want to give to the AWS user that is listed
    ///                         in Grantee. Valid values include: </p>
    /// 						               <ul>
    ///                         <li>
    ///                            <p>
    ///                               <code>READ</code>: The grantee can read the thumbnails and metadata
    ///                                 for thumbnails that Elastic Transcoder adds to the Amazon S3
    ///                                 bucket.</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>READ_ACP</code>: The grantee can read the object ACL for
    ///                                 thumbnails that Elastic Transcoder adds to the Amazon S3
    ///                                 bucket.</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>WRITE_ACP</code>: The grantee can write the ACL for the
    ///                                 thumbnails that Elastic Transcoder adds to the Amazon S3
    ///                                 bucket.</p>
    ///                         </li>
    ///                         <li>
    ///                            <p>
    ///                               <code>FULL_CONTROL</code>: The grantee has READ, READ_ACP, and
    ///                                 WRITE_ACP permissions for the thumbnails that Elastic Transcoder
    ///                                 adds to the Amazon S3 bucket.</p>
    ///                         </li>
    ///                      </ul>
    ///                     </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>StorageClass</code>: The Amazon S3 storage class, <code>Standard</code> or
    ///                     <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
    ///                 the thumbnails that it stores in your Amazon S3 bucket.</p>
    ///             </li>
    ///          </ul>
    public let thumbnailConfig: PipelineOutputConfig?

    public init (
        arn: String? = nil,
        awsKmsKeyArn: String? = nil,
        contentConfig: PipelineOutputConfig? = nil,
        id: String? = nil,
        inputBucket: String? = nil,
        name: String? = nil,
        notifications: Notifications? = nil,
        outputBucket: String? = nil,
        role: String? = nil,
        status: String? = nil,
        thumbnailConfig: PipelineOutputConfig? = nil
    )
    {
        self.arn = arn
        self.awsKmsKeyArn = awsKmsKeyArn
        self.contentConfig = contentConfig
        self.id = id
        self.inputBucket = inputBucket
        self.name = name
        self.notifications = notifications
        self.outputBucket = outputBucket
        self.role = role
        self.status = status
        self.thumbnailConfig = thumbnailConfig
    }
}

extension PipelineOutputConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case permissions = "Permissions"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permissions0 in permissions {
                try permissionsContainer.encode(permissions0)
            }
        }
        if let storageClass = storageClass {
            try encodeContainer.encode(storageClass, forKey: .storageClass)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Permission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
    }
}

extension PipelineOutputConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineOutputConfig(bucket: \(String(describing: bucket)), permissions: \(String(describing: permissions)), storageClass: \(String(describing: storageClass)))"}
}

/// <p>The <code>PipelineOutputConfig</code> structure.</p>
public struct PipelineOutputConfig: Equatable {
    /// <p> The Amazon S3 bucket in which you want Elastic Transcoder to save the transcoded files. Specify this
    ///             value when all of the following are true:</p>
    /// 			      <ul>
    ///             <li>
    ///                <p>You want to save transcoded files, thumbnails (if any), and playlists (if any)
    ///                     together in one bucket.</p>
    ///             </li>
    ///             <li>
    ///                <p>You do not want to specify the users or groups who have access to the transcoded
    ///                     files, thumbnails, and playlists.</p>
    ///             </li>
    ///             <li>
    ///                <p>You do not want to specify the permissions that Elastic Transcoder grants to the files.</p>
    ///             </li>
    ///             <li>
    ///                <p>You want to associate the transcoded files and thumbnails with the Amazon S3
    ///                     Standard storage class.</p>
    ///             </li>
    ///          </ul>
    /// 			      <p>If you want to save transcoded files and playlists in one bucket and thumbnails in
    ///             another bucket, specify which users can access the transcoded files or the permissions
    ///             the users have, or change the Amazon S3 storage class, omit OutputBucket and specify
    ///             values for <code>ContentConfig</code> and <code>ThumbnailConfig</code> instead. </p>
    public let bucket: String?
    /// <p>Optional. The <code>Permissions</code> object specifies which users and/or predefined
    ///             Amazon S3 groups you want to have access to transcoded files and playlists, and the type
    ///             of access you want them to have. You can grant permissions to a maximum of 30 users
    ///             and/or predefined Amazon S3 groups.</p>
    ///         <p>If you include <code>Permissions</code>, Elastic Transcoder grants only the permissions that you
    ///             specify. It does not grant full permissions to the owner of the role specified by
    ///                 <code>Role</code>. If you want that user to have full control, you must explicitly
    ///             grant full control to the user.</p>
    ///         <p> If you omit <code>Permissions</code>, Elastic Transcoder grants full control over the transcoded files
    ///             and playlists to the owner of the role specified by <code>Role</code>, and grants no
    ///             other permissions to any other user or group.</p>
    public let permissions: [Permission]?
    /// <p> The Amazon S3 storage class, <code>Standard</code> or <code>ReducedRedundancy</code>,
    ///             that you want Elastic Transcoder to assign to the video files and playlists that it stores in your
    ///             Amazon S3 bucket. </p>
    public let storageClass: String?

    public init (
        bucket: String? = nil,
        permissions: [Permission]? = nil,
        storageClass: String? = nil
    )
    {
        self.bucket = bucket
        self.permissions = permissions
        self.storageClass = storageClass
    }
}

extension PlayReadyDrm: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case format = "Format"
        case initializationVector = "InitializationVector"
        case key = "Key"
        case keyId = "KeyId"
        case keyMd5 = "KeyMd5"
        case licenseAcquisitionUrl = "LicenseAcquisitionUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let initializationVector = initializationVector {
            try encodeContainer.encode(initializationVector, forKey: .initializationVector)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let keyMd5 = keyMd5 {
            try encodeContainer.encode(keyMd5, forKey: .keyMd5)
        }
        if let licenseAcquisitionUrl = licenseAcquisitionUrl {
            try encodeContainer.encode(licenseAcquisitionUrl, forKey: .licenseAcquisitionUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .format)
        format = formatDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let keyMd5Decoded = try containerValues.decodeIfPresent(String.self, forKey: .keyMd5)
        keyMd5 = keyMd5Decoded
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let initializationVectorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .initializationVector)
        initializationVector = initializationVectorDecoded
        let licenseAcquisitionUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseAcquisitionUrl)
        licenseAcquisitionUrl = licenseAcquisitionUrlDecoded
    }
}

extension PlayReadyDrm: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlayReadyDrm(format: \(String(describing: format)), initializationVector: \(String(describing: initializationVector)), key: \(String(describing: key)), keyId: \(String(describing: keyId)), keyMd5: \(String(describing: keyMd5)), licenseAcquisitionUrl: \(String(describing: licenseAcquisitionUrl)))"}
}

/// <p>The PlayReady DRM settings, if any, that you want Elastic Transcoder to apply to the output files associated with this playlist.</p>
///          <p>PlayReady DRM encrypts your media files
/// using <code>aes-ctr</code> encryption.</p>
///          <p>If you use DRM for an <code>HLSv3</code> playlist, your outputs must have a master playlist.</p>
public struct PlayReadyDrm: Equatable {
    /// <p>The type of DRM, if any, that you want Elastic Transcoder to apply to the output files associated with this playlist.</p>
    public let format: String?
    /// <p>The series of random bits created by a random bit generator, unique for every encryption operation,
    ///     that you want Elastic Transcoder to use to encrypt your files. The initialization vector must be base64-encoded, and it
    ///     must be exactly 8 bytes long before being base64-encoded. If no initialization vector is provided, Elastic Transcoder
    ///     generates one for you.</p>
    public let initializationVector: String?
    /// <p>The DRM key for your file, provided by your DRM license provider. The key must be base64-encoded,
    ///     and it must be one of the following bit lengths before being base64-encoded:</p>
    ///          <p>
    ///             <code>128</code>, <code>192</code>, or <code>256</code>. </p>
    ///          <p>The key must also be encrypted by using AWS KMS.</p>
    public let key: String?
    /// <p>The ID for your DRM key, so that your DRM license provider knows which key to provide.</p>
    ///          <p>The key ID must be provided in big endian, and Elastic Transcoder converts it to little endian before inserting
    ///     it into the PlayReady DRM headers. If you are unsure whether your license server provides your key ID in
    ///     big or little endian, check with your DRM provider.</p>
    public let keyId: String?
    /// <p>The MD5 digest of the key used for DRM on your file, and that you want Elastic Transcoder to use as a checksum
    ///     to make sure your key was not corrupted in transit. The key MD5 must be base64-encoded, and it must be
    ///     exactly 16 bytes before being base64-encoded.</p>
    public let keyMd5: String?
    /// <p>The location of the license key required to play DRM content. The URL must be an absolute path,
    /// and is referenced by the PlayReady header. The PlayReady header is referenced in the protection
    /// header of the client manifest for Smooth Streaming outputs, and in the EXT-X-DXDRM and EXT-XDXDRMINFO
    /// metadata tags for HLS playlist outputs. An example URL looks like this:
    /// <code>https://www.example.com/exampleKey/</code>
    ///          </p>
    public let licenseAcquisitionUrl: String?

    public init (
        format: String? = nil,
        initializationVector: String? = nil,
        key: String? = nil,
        keyId: String? = nil,
        keyMd5: String? = nil,
        licenseAcquisitionUrl: String? = nil
    )
    {
        self.format = format
        self.initializationVector = initializationVector
        self.key = key
        self.keyId = keyId
        self.keyMd5 = keyMd5
        self.licenseAcquisitionUrl = licenseAcquisitionUrl
    }
}

extension Playlist: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case format = "Format"
        case hlsContentProtection = "HlsContentProtection"
        case name = "Name"
        case outputKeys = "OutputKeys"
        case playReadyDrm = "PlayReadyDrm"
        case status = "Status"
        case statusDetail = "StatusDetail"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let hlsContentProtection = hlsContentProtection {
            try encodeContainer.encode(hlsContentProtection, forKey: .hlsContentProtection)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputKeys = outputKeys {
            var outputKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputKeys)
            for outputkeys0 in outputKeys {
                try outputKeysContainer.encode(outputkeys0)
            }
        }
        if let playReadyDrm = playReadyDrm {
            try encodeContainer.encode(playReadyDrm, forKey: .playReadyDrm)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusDetail = statusDetail {
            try encodeContainer.encode(statusDetail, forKey: .statusDetail)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .format)
        format = formatDecoded
        let outputKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .outputKeys)
        var outputKeysDecoded0:[String]? = nil
        if let outputKeysContainer = outputKeysContainer {
            outputKeysDecoded0 = [String]()
            for string0 in outputKeysContainer {
                if let string0 = string0 {
                    outputKeysDecoded0?.append(string0)
                }
            }
        }
        outputKeys = outputKeysDecoded0
        let hlsContentProtectionDecoded = try containerValues.decodeIfPresent(HlsContentProtection.self, forKey: .hlsContentProtection)
        hlsContentProtection = hlsContentProtectionDecoded
        let playReadyDrmDecoded = try containerValues.decodeIfPresent(PlayReadyDrm.self, forKey: .playReadyDrm)
        playReadyDrm = playReadyDrmDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let statusDetailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusDetail)
        statusDetail = statusDetailDecoded
    }
}

extension Playlist: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Playlist(format: \(String(describing: format)), hlsContentProtection: \(String(describing: hlsContentProtection)), name: \(String(describing: name)), outputKeys: \(String(describing: outputKeys)), playReadyDrm: \(String(describing: playReadyDrm)), status: \(String(describing: status)), statusDetail: \(String(describing: statusDetail)))"}
}

/// <p> Use Only for Fragmented MP4 or MPEG-TS Outputs. If you specify a preset for which the value of Container
///             is <code>fmp4</code> (Fragmented MP4) or <code>ts</code> (MPEG-TS), Playlists
///             contains information about the master playlists
///             that you want Elastic Transcoder to create. We recommend that you create only one master
///             playlist per output format. The maximum number of master playlists in a job is 30. </p>
public struct Playlist: Equatable {
    /// <p>The format of the output playlist. Valid formats include <code>HLSv3</code>, <code>HLSv4</code>,
    /// and <code>Smooth</code>.</p>
    public let format: String?
    /// <p>The HLS content protection settings, if any, that you want Elastic Transcoder to apply to the output files associated with this playlist.</p>
    public let hlsContentProtection: HlsContentProtection?
    /// <p>The name that you want Elastic Transcoder to assign to the master playlist, for example,
    ///             nyc-vacation.m3u8. If the name includes a <code>/</code> character, the
    ///             section of the name before the last <code>/</code> must be identical for all
    ///             <code>Name</code> objects. If you create more than one
    ///             master playlist, the values of all <code>Name</code> objects must be
    ///             unique.</p>
    ///         <note>
    ///             <p>Elastic Transcoder automatically appends the relevant file extension to the file name (<code>.m3u8</code>
    ///     for <code>HLSv3</code> and <code>HLSv4</code> playlists, and
    ///     <code>.ism</code> and <code>.ismc</code> for <code>Smooth</code> playlists).
    ///     If you include a file extension in <code>Name</code>, the file name will have
    ///     two extensions.</p>
    ///          </note>
    public let name: String?
    /// <p>For each output in this job that you want to include in a master playlist, the value of the Outputs:Key object.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If your output is not <code>HLS</code> or does not have a segment duration set,
    ///             the name of the output file is a concatenation of <code>OutputKeyPrefix</code>
    ///             and <code>Outputs:Key</code>:</p>
    ///                <p>OutputKeyPrefix<code>Outputs:Key</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>If your output is <code>HLSv3</code> and has a segment duration set, or is not included in a
    ///             playlist, Elastic Transcoder creates an output playlist file with a file extension of <code>.m3u8</code>, and a
    ///             series of <code>.ts</code> files that include a five-digit
    ///             sequential counter beginning with 00000:</p>
    ///                <p>OutputKeyPrefix<code>Outputs:Key</code>.m3u8</p>
    ///                <p>OutputKeyPrefix<code>Outputs:Key</code>00000.ts</p>
    ///             </li>
    ///             <li>
    ///                <p>If your output is <code>HLSv4</code>, has a segment duration set, and is included in an
    ///             <code>HLSv4</code> playlist, Elastic Transcoder creates an output playlist file with a file extension
    ///             of <code>_v4.m3u8</code>. If the output is video, Elastic Transcoder also creates an output file with
    ///             an extension of <code>_iframe.m3u8</code>:</p>
    ///                <p>OutputKeyPrefix<code>Outputs:Key</code>_v4.m3u8</p>
    ///                <p>OutputKeyPrefix<code>Outputs:Key</code>_iframe.m3u8</p>
    ///                <p>OutputKeyPrefix<code>Outputs:Key</code>.ts</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>Elastic Transcoder automatically appends the relevant file extension to the file name. If you include a file
    ///     extension in Output Key, the file name will have two extensions.</p>
    ///          <p>If you include more than one output in a playlist,
    ///     any segment duration settings, clip settings, or caption settings must be the
    ///     same for all outputs in the playlist. For <code>Smooth</code> playlists, the <code>Audio:Profile</code>,
    ///     <code>Video:Profile</code>, and <code>Video:FrameRate</code> to
    ///     <code>Video:KeyframesMaxDist</code> ratio must be the same for all outputs.</p>
    public let outputKeys: [String]?
    /// <p>The DRM settings, if any, that you want Elastic Transcoder to apply to the output files associated with this playlist.</p>
    public let playReadyDrm: PlayReadyDrm?
    /// <p>The status of the job with which the playlist is associated.</p>
    public let status: String?
    /// <p>Information that further explains the status.</p>
    public let statusDetail: String?

    public init (
        format: String? = nil,
        hlsContentProtection: HlsContentProtection? = nil,
        name: String? = nil,
        outputKeys: [String]? = nil,
        playReadyDrm: PlayReadyDrm? = nil,
        status: String? = nil,
        statusDetail: String? = nil
    )
    {
        self.format = format
        self.hlsContentProtection = hlsContentProtection
        self.name = name
        self.outputKeys = outputKeys
        self.playReadyDrm = playReadyDrm
        self.status = status
        self.statusDetail = statusDetail
    }
}

extension Preset: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case audio = "Audio"
        case container = "Container"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case thumbnails = "Thumbnails"
        case type = "Type"
        case video = "Video"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let audio = audio {
            try encodeContainer.encode(audio, forKey: .audio)
        }
        if let container = container {
            try encodeContainer.encode(container, forKey: .container)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let thumbnails = thumbnails {
            try encodeContainer.encode(thumbnails, forKey: .thumbnails)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let video = video {
            try encodeContainer.encode(video, forKey: .video)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let containerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .container)
        container = containerDecoded
        let audioDecoded = try containerValues.decodeIfPresent(AudioParameters.self, forKey: .audio)
        audio = audioDecoded
        let videoDecoded = try containerValues.decodeIfPresent(VideoParameters.self, forKey: .video)
        video = videoDecoded
        let thumbnailsDecoded = try containerValues.decodeIfPresent(Thumbnails.self, forKey: .thumbnails)
        thumbnails = thumbnailsDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension Preset: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Preset(arn: \(String(describing: arn)), audio: \(String(describing: audio)), container: \(String(describing: container)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), thumbnails: \(String(describing: thumbnails)), type: \(String(describing: type)), video: \(String(describing: video)))"}
}

/// <p>Presets are templates that contain most of the settings for transcoding media files
///             from one format to another. Elastic Transcoder includes some default presets for common formats, for
///             example, several iPod and iPhone versions. You can also create your own presets for formats
///             that aren't included among the default presets. You specify which preset you want to use
///             when you create a job.</p>
public struct Preset: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the preset.</p>
    public let arn: String?
    /// <p>A section of the response body that provides information about the audio preset values.</p>
    public let audio: AudioParameters?
    /// <p>The container type for the output file. Valid values include <code>flac</code>,
    ///             <code>flv</code>, <code>fmp4</code>, <code>gif</code>, <code>mp3</code>,
    ///             <code>mp4</code>, <code>mpg</code>, <code>mxf</code>, <code>oga</code>,
    ///             <code>ogg</code>, <code>ts</code>, and <code>webm</code>.</p>
    public let container: String?
    /// <p>A description of the preset.</p>
    public let description: String?
    /// <p>Identifier for the new preset. You use this value to get settings for the preset or to delete it.</p>
    public let id: String?
    /// <p>The name of the preset.</p>
    public let name: String?
    /// <p>A section of the response body that provides information about the thumbnail preset values, if any.</p>
    public let thumbnails: Thumbnails?
    /// <p>Whether the preset is a default preset provided by Elastic Transcoder
    ///                 (<code>System</code>) or a preset that you have defined (<code>Custom</code>).</p>
    public let type: String?
    /// <p>A section of the response body that provides information about the video preset values.</p>
    public let video: VideoParameters?

    public init (
        arn: String? = nil,
        audio: AudioParameters? = nil,
        container: String? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        thumbnails: Thumbnails? = nil,
        type: String? = nil,
        video: VideoParameters? = nil
    )
    {
        self.arn = arn
        self.audio = audio
        self.container = container
        self.description = description
        self.id = id
        self.name = name
        self.thumbnails = thumbnails
        self.type = type
        self.video = video
    }
}

extension PresetWatermark: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case horizontalAlign = "HorizontalAlign"
        case horizontalOffset = "HorizontalOffset"
        case id = "Id"
        case maxHeight = "MaxHeight"
        case maxWidth = "MaxWidth"
        case opacity = "Opacity"
        case sizingPolicy = "SizingPolicy"
        case target = "Target"
        case verticalAlign = "VerticalAlign"
        case verticalOffset = "VerticalOffset"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let horizontalAlign = horizontalAlign {
            try encodeContainer.encode(horizontalAlign, forKey: .horizontalAlign)
        }
        if let horizontalOffset = horizontalOffset {
            try encodeContainer.encode(horizontalOffset, forKey: .horizontalOffset)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let maxHeight = maxHeight {
            try encodeContainer.encode(maxHeight, forKey: .maxHeight)
        }
        if let maxWidth = maxWidth {
            try encodeContainer.encode(maxWidth, forKey: .maxWidth)
        }
        if let opacity = opacity {
            try encodeContainer.encode(opacity, forKey: .opacity)
        }
        if let sizingPolicy = sizingPolicy {
            try encodeContainer.encode(sizingPolicy, forKey: .sizingPolicy)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let verticalAlign = verticalAlign {
            try encodeContainer.encode(verticalAlign, forKey: .verticalAlign)
        }
        if let verticalOffset = verticalOffset {
            try encodeContainer.encode(verticalOffset, forKey: .verticalOffset)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let maxWidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxWidth)
        maxWidth = maxWidthDecoded
        let maxHeightDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxHeight)
        maxHeight = maxHeightDecoded
        let sizingPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sizingPolicy)
        sizingPolicy = sizingPolicyDecoded
        let horizontalAlignDecoded = try containerValues.decodeIfPresent(String.self, forKey: .horizontalAlign)
        horizontalAlign = horizontalAlignDecoded
        let horizontalOffsetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .horizontalOffset)
        horizontalOffset = horizontalOffsetDecoded
        let verticalAlignDecoded = try containerValues.decodeIfPresent(String.self, forKey: .verticalAlign)
        verticalAlign = verticalAlignDecoded
        let verticalOffsetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .verticalOffset)
        verticalOffset = verticalOffsetDecoded
        let opacityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opacity)
        opacity = opacityDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
    }
}

extension PresetWatermark: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PresetWatermark(horizontalAlign: \(String(describing: horizontalAlign)), horizontalOffset: \(String(describing: horizontalOffset)), id: \(String(describing: id)), maxHeight: \(String(describing: maxHeight)), maxWidth: \(String(describing: maxWidth)), opacity: \(String(describing: opacity)), sizingPolicy: \(String(describing: sizingPolicy)), target: \(String(describing: target)), verticalAlign: \(String(describing: verticalAlign)), verticalOffset: \(String(describing: verticalOffset)))"}
}

/// <p>Settings for the size, location, and opacity of graphics that you want Elastic Transcoder to
///             overlay over videos that are transcoded using this preset. You can specify settings
///             for up to four watermarks. Watermarks appear in the specified size and location, and
///             with the specified opacity for the duration of the transcoded video.</p>
///         <p>Watermarks can be in .png or .jpg format. If you want to display a watermark that
///             is not rectangular, use the .png format, which supports transparency.</p>
///         <p>When you create a job that uses this preset, you specify the .png or .jpg graphics
///             that you want Elastic Transcoder to include in the transcoded videos. You can specify fewer graphics
///             in the job than you specify watermark settings in the preset, which allows you to use
///             the same preset for up to four watermarks that have different dimensions.</p>
public struct PresetWatermark: Equatable {
    /// <p>The horizontal position of the watermark unless you specify a non-zero value for
    ///                 <code>HorizontalOffset</code>: </p>
    /// 			      <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Left</b>: The left edge of the watermark is aligned with the left border of
    ///                     the video.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Right</b>: The right edge of the watermark is aligned with the right border
    ///                     of the video.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Center</b>: The watermark is centered between the left and right
    ///                     borders.</p>
    ///             </li>
    ///          </ul>
    public let horizontalAlign: String?
    /// <p>The amount by which you want the horizontal position of the watermark to be offset from
    ///             the position specified by HorizontalAlign: </p>
    /// 			      <ul>
    ///             <li>
    ///                <p>number of pixels (px): The minimum value is 0 pixels, and the maximum value is
    ///                     the value of MaxWidth.</p>
    ///             </li>
    ///             <li>
    ///                <p>integer percentage (%): The range of valid values is 0 to 100.</p>
    ///             </li>
    ///          </ul>
    /// 			      <p>For example, if you specify Left for <code>HorizontalAlign</code> and 5px for
    ///                 <code>HorizontalOffset</code>, the left side of the watermark appears 5 pixels from
    ///             the left border of the output video.</p>
    ///         <p>
    ///             <code>HorizontalOffset</code> is only valid when the value of
    ///                 <code>HorizontalAlign</code> is <code>Left</code> or <code>Right</code>. If you
    ///             specify an offset that causes the watermark to extend beyond the left or right border
    ///             and Elastic Transcoder has not added black bars, the watermark is cropped. If Elastic
    ///             Transcoder has added black bars, the watermark extends into the black bars. If the
    ///             watermark extends beyond the black bars, it is cropped.</p>
    ///         <p>Use the value of <code>Target</code> to specify whether you want to include the black
    ///             bars that are added by Elastic Transcoder, if any, in the offset calculation.</p>
    public let horizontalOffset: String?
    /// <p> A unique identifier for the settings for one
    ///         watermark. The value of <code>Id</code> can be up to 40 characters long. </p>
    public let id: String?
    /// <p>The maximum height of the watermark in one of the following formats: </p>
    /// 		       <ul>
    ///             <li>
    ///                <p>number of pixels (px): The minimum value is 16 pixels, and the maximum value is
    ///                     the value of <code>MaxHeight</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>integer percentage (%): The range of valid values is 0 to 100. Use the value of
    ///                         <code>Target</code> to specify whether you want Elastic Transcoder to include the black
    ///                     bars that are added by Elastic Transcoder, if any, in the calculation.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you specify the value in pixels, it must be less than or equal to the value of
    ///                 <code>MaxHeight</code>.</p>
    public let maxHeight: String?
    /// <p>The maximum width of the watermark in one of the following formats: </p>
    /// 		       <ul>
    ///             <li>
    ///                <p>number of pixels (px): The minimum value is 16 pixels, and the maximum value is
    ///                     the value of <code>MaxWidth</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>integer percentage (%): The range of valid values is 0 to 100. Use the value of
    ///                         <code>Target</code> to specify whether you want Elastic Transcoder to include the black
    ///                     bars that are added by Elastic Transcoder, if any, in the calculation.</p>
    /// 					          <p>If
    ///                 you specify the value in pixels, it must be less than or equal to the value of
    ///                     <code>MaxWidth</code>.</p>
    ///             </li>
    ///          </ul>
    public let maxWidth: String?
    /// <p>A percentage that indicates how much you want a watermark to obscure the video in the
    ///             location where it appears. Valid values are 0 (the watermark is invisible) to 100 (the
    ///             watermark completely obscures the video in the specified location). The datatype of
    ///                 <code>Opacity</code> is float.</p>
    ///         <p>Elastic Transcoder supports transparent .png graphics. If you use a transparent .png, the transparent
    ///             portion of the video appears as if you had specified a value of 0 for
    ///                 <code>Opacity</code>. The .jpg file format doesn't support transparency.</p>
    public let opacity: String?
    /// <p>A value that controls scaling of the watermark: </p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Fit</b>: Elastic Transcoder scales the watermark so it matches the value that
    ///                     you specified in either <code>MaxWidth</code> or <code>MaxHeight</code> without
    ///                     exceeding the other value.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Stretch</b>: Elastic Transcoder stretches the watermark to match the values
    ///                     that you specified for <code>MaxWidth</code> and <code>MaxHeight</code>. If the
    ///                     relative proportions of the watermark and the values of <code>MaxWidth</code>
    ///                     and <code>MaxHeight</code> are different, the watermark will be distorted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>ShrinkToFit</b>: Elastic Transcoder scales the watermark down so that its
    ///                     dimensions match the values that you specified for at least one of
    ///                         <code>MaxWidth</code> and <code>MaxHeight</code> without exceeding either
    ///                     value. If you specify this option, Elastic Transcoder does not scale the
    ///                     watermark up.</p>
    ///             </li>
    ///          </ul>
    public let sizingPolicy: String?
    /// <p>A value that determines how Elastic Transcoder interprets values that you specified for
    ///                 <code>HorizontalOffset</code>, <code>VerticalOffset</code>, <code>MaxWidth</code>,
    ///             and <code>MaxHeight</code>:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Content</b>: <code>HorizontalOffset</code> and
    ///                         <code>VerticalOffset</code> values are calculated based on the borders of
    ///                     the video excluding black bars added by Elastic Transcoder, if any. In addition,
    ///                         <code>MaxWidth</code> and <code>MaxHeight</code>, if specified as a
    ///                     percentage, are calculated based on the borders of the video excluding black
    ///                     bars added by Elastic Transcoder, if any.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Frame</b>: <code>HorizontalOffset</code> and <code>VerticalOffset</code>
    ///                     values are calculated based on the borders of the video including black bars
    ///                     added by Elastic Transcoder, if any. In addition, <code>MaxWidth</code> and
    ///                     <code>MaxHeight</code>, if specified as a percentage, are calculated based on
    ///                 the borders of the video including black bars added by Elastic Transcoder, if any.</p>
    ///             </li>
    ///          </ul>
    public let target: String?
    /// <p>The vertical position of the watermark unless you specify a non-zero value for
    ///                 <code>VerticalOffset</code>: </p>
    /// 			      <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Top</b>: The top edge of the watermark is aligned with the top border of the
    ///                     video.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Bottom</b>: The bottom edge of the watermark is aligned with the bottom
    ///                     border of the video.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Center</b>: The watermark is centered between the top and bottom
    ///                     borders.</p>
    ///             </li>
    ///          </ul>
    public let verticalAlign: String?
    /// <p>
    ///             <code>VerticalOffset</code>
    ///          </p>
    ///         <p>The amount by which you want the vertical position of the watermark to be offset from the
    ///             position specified by VerticalAlign:</p>
    /// 			      <ul>
    ///             <li>
    ///                <p>number of pixels (px): The minimum value is 0 pixels, and the maximum value is
    ///                     the value of <code>MaxHeight</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>integer percentage (%): The range of valid values is 0 to 100.</p>
    ///             </li>
    ///          </ul>
    /// 			      <p>For example, if you specify <code>Top</code> for <code>VerticalAlign</code> and
    ///                 <code>5px</code> for <code>VerticalOffset</code>, the top of the watermark appears 5
    ///             pixels from the top border of the output video.</p>
    ///         <p>
    ///             <code>VerticalOffset</code> is only valid when the value of VerticalAlign is Top or
    ///             Bottom.</p>
    ///         <p>If you specify an offset that causes the watermark to extend beyond the top or
    ///             bottom border and Elastic Transcoder has not added black bars, the watermark is cropped. If Elastic Transcoder has
    ///             added black bars, the watermark extends into the black bars. If the watermark extends
    ///             beyond the black bars, it is cropped.</p>
    ///
    ///         <p>Use the value of <code>Target</code> to specify whether you want Elastic Transcoder to
    ///             include the black bars that are added by Elastic Transcoder, if any, in the offset
    ///             calculation.</p>
    public let verticalOffset: String?

    public init (
        horizontalAlign: String? = nil,
        horizontalOffset: String? = nil,
        id: String? = nil,
        maxHeight: String? = nil,
        maxWidth: String? = nil,
        opacity: String? = nil,
        sizingPolicy: String? = nil,
        target: String? = nil,
        verticalAlign: String? = nil,
        verticalOffset: String? = nil
    )
    {
        self.horizontalAlign = horizontalAlign
        self.horizontalOffset = horizontalOffset
        self.id = id
        self.maxHeight = maxHeight
        self.maxWidth = maxWidth
        self.opacity = opacity
        self.sizingPolicy = sizingPolicy
        self.target = target
        self.verticalAlign = verticalAlign
        self.verticalOffset = verticalOffset
    }
}

extension ReadJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReadJobInput(id: \(String(describing: id)))"}
}

extension ReadJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ReadJobInputHeadersMiddleware: Middleware {
    public let id: String = "ReadJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReadJobInput>,
                  next: H) -> Swift.Result<OperationOutput<ReadJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReadJobInput>
    public typealias MOutput = OperationOutput<ReadJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReadJobOutputError>
}

public struct ReadJobInputQueryItemMiddleware: Middleware {
    public let id: String = "ReadJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReadJobInput>,
                  next: H) -> Swift.Result<OperationOutput<ReadJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReadJobInput>
    public typealias MOutput = OperationOutput<ReadJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReadJobOutputError>
}

/// <p>The <code>ReadJobRequest</code> structure.</p>
public struct ReadJobInput: Equatable {
    /// <p>The identifier of the job for which you want to get detailed information.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct ReadJobInputBody: Equatable {
}

extension ReadJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ReadJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReadJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReadJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReadJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReadJobOutputResponse(job: \(String(describing: job)))"}
}

extension ReadJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReadJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

/// <p>The <code>ReadJobResponse</code> structure.</p>
public struct ReadJobOutputResponse: Equatable {
    /// <p>A section of the response body that provides information about the job.</p>
    public let job: Job?

    public init (
        job: Job? = nil
    )
    {
        self.job = job
    }
}

struct ReadJobOutputResponseBody: Equatable {
    public let job: Job?
}

extension ReadJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case job = "Job"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(Job.self, forKey: .job)
        job = jobDecoded
    }
}

extension ReadPipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReadPipelineInput(id: \(String(describing: id)))"}
}

extension ReadPipelineInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ReadPipelineInputHeadersMiddleware: Middleware {
    public let id: String = "ReadPipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReadPipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<ReadPipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReadPipelineInput>
    public typealias MOutput = OperationOutput<ReadPipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReadPipelineOutputError>
}

public struct ReadPipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "ReadPipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReadPipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<ReadPipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReadPipelineInput>
    public typealias MOutput = OperationOutput<ReadPipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReadPipelineOutputError>
}

/// <p>The <code>ReadPipelineRequest</code> structure.</p>
public struct ReadPipelineInput: Equatable {
    /// <p>The identifier of the pipeline to read.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct ReadPipelineInputBody: Equatable {
}

extension ReadPipelineInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ReadPipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReadPipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReadPipelineOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReadPipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReadPipelineOutputResponse(pipeline: \(String(describing: pipeline)), warnings: \(String(describing: warnings)))"}
}

extension ReadPipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReadPipelineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pipeline = output.pipeline
            self.warnings = output.warnings
        } else {
            self.pipeline = nil
            self.warnings = nil
        }
    }
}

/// <p>The <code>ReadPipelineResponse</code> structure.</p>
public struct ReadPipelineOutputResponse: Equatable {
    /// <p>A section of the response body that provides information about the pipeline.</p>
    public let pipeline: Pipeline?
    /// <p>Elastic Transcoder returns a warning if the resources used by your pipeline are not in the same region
    ///             as the pipeline.</p>
    ///         <p>Using resources in the same region, such as your Amazon S3 buckets, Amazon SNS notification topics,
    ///             and AWS KMS key, reduces processing time and prevents cross-regional charges.</p>
    public let warnings: [Warning]?

    public init (
        pipeline: Pipeline? = nil,
        warnings: [Warning]? = nil
    )
    {
        self.pipeline = pipeline
        self.warnings = warnings
    }
}

struct ReadPipelineOutputResponseBody: Equatable {
    public let pipeline: Pipeline?
    public let warnings: [Warning]?
}

extension ReadPipelineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipeline = "Pipeline"
        case warnings = "Warnings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(Pipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Warning?].self, forKey: .warnings)
        var warningsDecoded0:[Warning]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Warning]()
            for structure0 in warningsContainer {
                if let structure0 = structure0 {
                    warningsDecoded0?.append(structure0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

extension ReadPresetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReadPresetInput(id: \(String(describing: id)))"}
}

extension ReadPresetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ReadPresetInputHeadersMiddleware: Middleware {
    public let id: String = "ReadPresetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReadPresetInput>,
                  next: H) -> Swift.Result<OperationOutput<ReadPresetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReadPresetInput>
    public typealias MOutput = OperationOutput<ReadPresetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReadPresetOutputError>
}

public struct ReadPresetInputQueryItemMiddleware: Middleware {
    public let id: String = "ReadPresetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ReadPresetInput>,
                  next: H) -> Swift.Result<OperationOutput<ReadPresetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ReadPresetInput>
    public typealias MOutput = OperationOutput<ReadPresetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ReadPresetOutputError>
}

/// <p>The <code>ReadPresetRequest</code> structure.</p>
public struct ReadPresetInput: Equatable {
    /// <p>The identifier of the preset for which you want to get detailed information.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct ReadPresetInputBody: Equatable {
}

extension ReadPresetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ReadPresetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ReadPresetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ReadPresetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ReadPresetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReadPresetOutputResponse(preset: \(String(describing: preset)))"}
}

extension ReadPresetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReadPresetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.preset = output.preset
        } else {
            self.preset = nil
        }
    }
}

/// <p>The <code>ReadPresetResponse</code> structure.</p>
public struct ReadPresetOutputResponse: Equatable {
    /// <p>A section of the response body that provides information about the preset.</p>
    public let preset: Preset?

    public init (
        preset: Preset? = nil
    )
    {
        self.preset = preset
    }
}

struct ReadPresetOutputResponseBody: Equatable {
    public let preset: Preset?
}

extension ReadPresetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case preset = "Preset"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let presetDecoded = try containerValues.decodeIfPresent(Preset.self, forKey: .preset)
        preset = presetDecoded
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource you are attempting to change is in use. For example, you are attempting
///             to delete a pipeline that is currently in use.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource does not exist or is not available. For example, the pipeline
///             to which you're trying to add a job doesn't exist or is still being created.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TestRoleInputBodyMiddleware: Middleware {
    public let id: String = "TestRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<TestRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestRoleInput>
    public typealias MOutput = OperationOutput<TestRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestRoleOutputError>
}

extension TestRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestRoleInput(inputBucket: \(String(describing: inputBucket)), outputBucket: \(String(describing: outputBucket)), role: \(String(describing: role)), topics: \(String(describing: topics)))"}
}

extension TestRoleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputBucket = "InputBucket"
        case outputBucket = "OutputBucket"
        case role = "Role"
        case topics = "Topics"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputBucket = inputBucket {
            try encodeContainer.encode(inputBucket, forKey: .inputBucket)
        }
        if let outputBucket = outputBucket {
            try encodeContainer.encode(outputBucket, forKey: .outputBucket)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let topics = topics {
            var topicsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topics)
            for snstopics0 in topics {
                try topicsContainer.encode(snstopics0)
            }
        }
    }
}

public struct TestRoleInputHeadersMiddleware: Middleware {
    public let id: String = "TestRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<TestRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestRoleInput>
    public typealias MOutput = OperationOutput<TestRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestRoleOutputError>
}

public struct TestRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "TestRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<TestRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestRoleInput>
    public typealias MOutput = OperationOutput<TestRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestRoleOutputError>
}

/// <p> The <code>TestRoleRequest</code> structure. </p>
@available(*, deprecated)
public struct TestRoleInput: Equatable {
    /// <p>The Amazon S3 bucket that contains media files to be transcoded. The action attempts to read from this bucket.</p>
    public let inputBucket: String?
    /// <p>The Amazon S3 bucket that Elastic Transcoder writes transcoded media files to. The action attempts to read from this bucket.</p>
    public let outputBucket: String?
    /// <p>The IAM Amazon Resource Name (ARN) for the role that you want Elastic Transcoder to test.</p>
    public let role: String?
    /// <p>The ARNs of one or more Amazon Simple Notification Service (Amazon SNS) topics that you want the action to send a test notification to.</p>
    public let topics: [String]?

    public init (
        inputBucket: String? = nil,
        outputBucket: String? = nil,
        role: String? = nil,
        topics: [String]? = nil
    )
    {
        self.inputBucket = inputBucket
        self.outputBucket = outputBucket
        self.role = role
        self.topics = topics
    }
}

struct TestRoleInputBody: Equatable {
    public let role: String?
    public let inputBucket: String?
    public let outputBucket: String?
    public let topics: [String]?
}

extension TestRoleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inputBucket = "InputBucket"
        case outputBucket = "OutputBucket"
        case role = "Role"
        case topics = "Topics"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let inputBucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputBucket)
        inputBucket = inputBucketDecoded
        let outputBucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outputBucket)
        outputBucket = outputBucketDecoded
        let topicsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .topics)
        var topicsDecoded0:[String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
    }
}

extension TestRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestRoleOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestRoleOutputResponse(messages: \(String(describing: messages)), success: \(String(describing: success)))"}
}

extension TestRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TestRoleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.messages = output.messages
            self.success = output.success
        } else {
            self.messages = nil
            self.success = nil
        }
    }
}

/// <p>The <code>TestRoleResponse</code> structure.</p>
@available(*, deprecated)
public struct TestRoleOutputResponse: Equatable {
    /// <p>If the <code>Success</code> element contains <code>false</code>, this value is an array
    ///             of one or more error messages that were generated during the test process.</p>
    public let messages: [String]?
    /// <p>If the operation is successful, this value is <code>true</code>; otherwise, the value is
    ///                 <code>false</code>.</p>
    public let success: String?

    public init (
        messages: [String]? = nil,
        success: String? = nil
    )
    {
        self.messages = messages
        self.success = success
    }
}

struct TestRoleOutputResponseBody: Equatable {
    public let success: String?
    public let messages: [String]?
}

extension TestRoleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messages = "Messages"
        case success = "Success"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successDecoded = try containerValues.decodeIfPresent(String.self, forKey: .success)
        success = successDecoded
        let messagesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .messages)
        var messagesDecoded0:[String]? = nil
        if let messagesContainer = messagesContainer {
            messagesDecoded0 = [String]()
            for string0 in messagesContainer {
                if let string0 = string0 {
                    messagesDecoded0?.append(string0)
                }
            }
        }
        messages = messagesDecoded0
    }
}

extension Thumbnails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aspectRatio = "AspectRatio"
        case format = "Format"
        case interval = "Interval"
        case maxHeight = "MaxHeight"
        case maxWidth = "MaxWidth"
        case paddingPolicy = "PaddingPolicy"
        case resolution = "Resolution"
        case sizingPolicy = "SizingPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aspectRatio = aspectRatio {
            try encodeContainer.encode(aspectRatio, forKey: .aspectRatio)
        }
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let interval = interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let maxHeight = maxHeight {
            try encodeContainer.encode(maxHeight, forKey: .maxHeight)
        }
        if let maxWidth = maxWidth {
            try encodeContainer.encode(maxWidth, forKey: .maxWidth)
        }
        if let paddingPolicy = paddingPolicy {
            try encodeContainer.encode(paddingPolicy, forKey: .paddingPolicy)
        }
        if let resolution = resolution {
            try encodeContainer.encode(resolution, forKey: .resolution)
        }
        if let sizingPolicy = sizingPolicy {
            try encodeContainer.encode(sizingPolicy, forKey: .sizingPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .format)
        format = formatDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .interval)
        interval = intervalDecoded
        let resolutionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolution)
        resolution = resolutionDecoded
        let aspectRatioDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aspectRatio)
        aspectRatio = aspectRatioDecoded
        let maxWidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxWidth)
        maxWidth = maxWidthDecoded
        let maxHeightDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxHeight)
        maxHeight = maxHeightDecoded
        let sizingPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sizingPolicy)
        sizingPolicy = sizingPolicyDecoded
        let paddingPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paddingPolicy)
        paddingPolicy = paddingPolicyDecoded
    }
}

extension Thumbnails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Thumbnails(aspectRatio: \(String(describing: aspectRatio)), format: \(String(describing: format)), interval: \(String(describing: interval)), maxHeight: \(String(describing: maxHeight)), maxWidth: \(String(describing: maxWidth)), paddingPolicy: \(String(describing: paddingPolicy)), resolution: \(String(describing: resolution)), sizingPolicy: \(String(describing: sizingPolicy)))"}
}

/// <p>Thumbnails for videos.</p>
public struct Thumbnails: Equatable {
    /// <important>
    ///             <p>To better control resolution and aspect ratio of thumbnails, we recommend that you
    ///                 use the values <code>MaxWidth</code>, <code>MaxHeight</code>,
    ///                     <code>SizingPolicy</code>, and <code>PaddingPolicy</code> instead of
    ///                     <code>Resolution</code> and <code>AspectRatio</code>. The two groups of settings
    ///                 are mutually exclusive. Do not use them together.</p>
    ///         </important>
    ///         <p>The aspect ratio of thumbnails. Valid values include:</p>
    ///         <p>
    ///             <code>auto</code>, <code>1:1</code>, <code>4:3</code>, <code>3:2</code>,
    ///                 <code>16:9</code>
    ///          </p>
    ///         <p>If you specify <code>auto</code>, Elastic Transcoder tries to preserve the aspect ratio of the video in
    ///             the output file.</p>
    public let aspectRatio: String?
    /// <p>The format of thumbnails, if any. Valid values are <code>jpg</code> and <code>png</code>. </p>
    ///         <p>You specify whether you want Elastic Transcoder to create thumbnails when you create a job.</p>
    public let format: String?
    /// <p>The approximate number of seconds between thumbnails. Specify an integer value.</p>
    public let interval: String?
    /// <p>The maximum height of thumbnails in pixels. If you specify auto, Elastic Transcoder uses 1080
    ///             (Full HD) as the default value. If you specify a numeric value, enter an even integer
    ///             between 32 and 3072.</p>
    public let maxHeight: String?
    /// <p>The maximum width of thumbnails in pixels. If you specify auto, Elastic Transcoder uses 1920 (Full HD)
    ///             as the default value. If you specify a numeric value, enter an even integer between 32 and 4096.</p>
    public let maxWidth: String?
    /// <p>When you set <code>PaddingPolicy</code> to <code>Pad</code>, Elastic Transcoder may add
    ///             black bars to the top and bottom and/or left and right sides of thumbnails to make the
    ///             total size of the thumbnails match the values that you specified for thumbnail
    ///                 <code>MaxWidth</code> and <code>MaxHeight</code> settings.</p>
    public let paddingPolicy: String?
    /// <important>
    ///             <p>To better control resolution and aspect ratio of thumbnails, we recommend that you
    ///                 use the values <code>MaxWidth</code>, <code>MaxHeight</code>,
    ///                     <code>SizingPolicy</code>, and <code>PaddingPolicy</code> instead of
    ///                     <code>Resolution</code> and <code>AspectRatio</code>. The two groups of settings
    ///                 are mutually exclusive. Do not use them together.</p>
    ///         </important>
    ///         <p>The width and height of thumbnail files in pixels. Specify a value in the format
    ///                     <code>
    ///                <i>width</i>
    ///             </code> x <code>
    ///                <i>height</i>
    ///             </code> where both values are
    ///             even integers. The values cannot exceed the width and height that you specified in the
    ///                 <code>Video:Resolution</code> object.</p>
    public let resolution: String?
    /// <p>Specify one of the following values to control scaling of thumbnails:</p>
    ///
    ///             <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Fit</code>: Elastic Transcoder scales thumbnails so they match the value
    ///                     that you specified in thumbnail MaxWidth or MaxHeight settings without exceeding
    ///                     the other value. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Fill</code>: Elastic Transcoder scales thumbnails so they match the value
    ///                     that you specified in thumbnail <code>MaxWidth</code> or <code>MaxHeight</code>
    ///                     settings and matches or exceeds the other value. Elastic Transcoder centers the
    ///                     image in thumbnails and then crops in the dimension (if any) that exceeds the
    ///                     maximum value.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Stretch</code>: Elastic Transcoder stretches thumbnails to match the
    ///                     values that you specified for thumbnail <code>MaxWidth</code> and
    ///                         <code>MaxHeight</code> settings. If the relative proportions of the input
    ///                     video and thumbnails are different, the thumbnails will be distorted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Keep</code>: Elastic Transcoder does not scale thumbnails. If either
    ///                     dimension of the input video exceeds the values that you specified for thumbnail
    ///                         <code>MaxWidth</code> and <code>MaxHeight</code> settings, Elastic
    ///                     Transcoder crops the thumbnails.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ShrinkToFit</code>: Elastic Transcoder scales thumbnails down so that
    ///                     their dimensions match the values that you specified for at least one of
    ///                     thumbnail <code>MaxWidth</code> and <code>MaxHeight</code> without exceeding
    ///                     either value. If you specify this option, Elastic Transcoder does not scale
    ///                     thumbnails up.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ShrinkToFill</code>: Elastic Transcoder scales thumbnails down so that
    ///                     their dimensions match the values that you specified for at least one of
    ///                         <code>MaxWidth</code> and <code>MaxHeight</code> without dropping below
    ///                     either value. If you specify this option, Elastic Transcoder does not scale
    ///                     thumbnails up.</p>
    ///             </li>
    ///          </ul>
    public let sizingPolicy: String?

    public init (
        aspectRatio: String? = nil,
        format: String? = nil,
        interval: String? = nil,
        maxHeight: String? = nil,
        maxWidth: String? = nil,
        paddingPolicy: String? = nil,
        resolution: String? = nil,
        sizingPolicy: String? = nil
    )
    {
        self.aspectRatio = aspectRatio
        self.format = format
        self.interval = interval
        self.maxHeight = maxHeight
        self.maxWidth = maxWidth
        self.paddingPolicy = paddingPolicy
        self.resolution = resolution
        self.sizingPolicy = sizingPolicy
    }
}

extension TimeSpan: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case duration = "Duration"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .duration)
        duration = durationDecoded
    }
}

extension TimeSpan: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimeSpan(duration: \(String(describing: duration)), startTime: \(String(describing: startTime)))"}
}

/// <p>Settings that determine when a clip begins and how long it lasts.</p>
public struct TimeSpan: Equatable {
    /// <p>The duration of the clip. The format can be either HH:mm:ss.SSS (maximum value: 23:59:59.999;
    ///            SSS is thousandths of a second) or sssss.SSS (maximum value: 86399.999). If you don't specify a
    ///            value, Elastic Transcoder creates an output file from StartTime to the end of the file.</p>
    ///          <p>If you specify a value longer than the duration of the input file, Elastic Transcoder transcodes the
    ///            file and returns a warning message.</p>
    public let duration: String?
    /// <p>The place in the input file where you want a clip to start. The format can be either
    ///            HH:mm:ss.SSS (maximum value: 23:59:59.999; SSS is thousandths of a second) or sssss.SSS
    ///            (maximum value: 86399.999). If you don't specify a value, Elastic Transcoder starts at the beginning of
    ///            the input file.</p>
    public let startTime: String?

    public init (
        duration: String? = nil,
        startTime: String? = nil
    )
    {
        self.duration = duration
        self.startTime = startTime
    }
}

extension Timing: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case finishTimeMillis = "FinishTimeMillis"
        case startTimeMillis = "StartTimeMillis"
        case submitTimeMillis = "SubmitTimeMillis"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finishTimeMillis = finishTimeMillis {
            try encodeContainer.encode(finishTimeMillis, forKey: .finishTimeMillis)
        }
        if let startTimeMillis = startTimeMillis {
            try encodeContainer.encode(startTimeMillis, forKey: .startTimeMillis)
        }
        if let submitTimeMillis = submitTimeMillis {
            try encodeContainer.encode(submitTimeMillis, forKey: .submitTimeMillis)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let submitTimeMillisDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .submitTimeMillis)
        submitTimeMillis = submitTimeMillisDecoded
        let startTimeMillisDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .startTimeMillis)
        startTimeMillis = startTimeMillisDecoded
        let finishTimeMillisDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .finishTimeMillis)
        finishTimeMillis = finishTimeMillisDecoded
    }
}

extension Timing: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Timing(finishTimeMillis: \(String(describing: finishTimeMillis)), startTimeMillis: \(String(describing: startTimeMillis)), submitTimeMillis: \(String(describing: submitTimeMillis)))"}
}

/// <p>Details about the timing of a job.</p>
public struct Timing: Equatable {
    /// <p>The time the job finished transcoding, in epoch milliseconds.</p>
    public let finishTimeMillis: Int?
    /// <p>The time the job began transcoding, in epoch milliseconds.</p>
    public let startTimeMillis: Int?
    /// <p>The time the job was submitted to Elastic Transcoder, in epoch milliseconds.</p>
    public let submitTimeMillis: Int?

    public init (
        finishTimeMillis: Int? = nil,
        startTimeMillis: Int? = nil,
        submitTimeMillis: Int? = nil
    )
    {
        self.finishTimeMillis = finishTimeMillis
        self.startTimeMillis = startTimeMillis
        self.submitTimeMillis = submitTimeMillis
    }
}

public struct UpdatePipelineInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePipelineInput>
    public typealias MOutput = OperationOutput<UpdatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePipelineOutputError>
}

extension UpdatePipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePipelineInput(awsKmsKeyArn: \(String(describing: awsKmsKeyArn)), contentConfig: \(String(describing: contentConfig)), id: \(String(describing: id)), inputBucket: \(String(describing: inputBucket)), name: \(String(describing: name)), notifications: \(String(describing: notifications)), role: \(String(describing: role)), thumbnailConfig: \(String(describing: thumbnailConfig)))"}
}

extension UpdatePipelineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsKmsKeyArn = "AwsKmsKeyArn"
        case contentConfig = "ContentConfig"
        case inputBucket = "InputBucket"
        case name = "Name"
        case notifications = "Notifications"
        case role = "Role"
        case thumbnailConfig = "ThumbnailConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsKmsKeyArn = awsKmsKeyArn {
            try encodeContainer.encode(awsKmsKeyArn, forKey: .awsKmsKeyArn)
        }
        if let contentConfig = contentConfig {
            try encodeContainer.encode(contentConfig, forKey: .contentConfig)
        }
        if let inputBucket = inputBucket {
            try encodeContainer.encode(inputBucket, forKey: .inputBucket)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notifications = notifications {
            try encodeContainer.encode(notifications, forKey: .notifications)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let thumbnailConfig = thumbnailConfig {
            try encodeContainer.encode(thumbnailConfig, forKey: .thumbnailConfig)
        }
    }
}

public struct UpdatePipelineInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePipelineInput>
    public typealias MOutput = OperationOutput<UpdatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePipelineOutputError>
}

public struct UpdatePipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePipelineInput>
    public typealias MOutput = OperationOutput<UpdatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePipelineOutputError>
}

/// <p>The <code>UpdatePipelineRequest</code> structure.</p>
public struct UpdatePipelineInput: Equatable {
    /// <p>The AWS Key Management Service (AWS KMS) key that you want to use with this pipeline.</p>
    ///         <p>If you use either <code>s3</code> or <code>s3-aws-kms</code> as your <code>Encryption:Mode</code>,
    ///         you don't need to provide a key with your job because a default key, known as an AWS-KMS key, is
    ///         created for you automatically. You need to provide an AWS-KMS key only if you want to use a non-default
    ///         AWS-KMS key, or if you are using an <code>Encryption:Mode</code> of <code>aes-cbc-pkcs7</code>, <code>aes-ctr</code>,
    ///             or <code>aes-gcm</code>.</p>
    public let awsKmsKeyArn: String?
    /// <p>The optional <code>ContentConfig</code> object specifies information about the Amazon S3
    ///             bucket in which you want Elastic Transcoder to save transcoded files and playlists:
    ///             which bucket to use, which users you want to have access to the files, the type of
    ///             access you want users to have, and the storage class that you want to assign to the
    ///             files.</p>
    ///         <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
    ///                 <code>ThumbnailConfig</code>.</p>
    ///         <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
    ///             omit the <code>OutputBucket</code> object.</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
    ///                 transcoded files and playlists.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Permissions</b> (Optional): The Permissions object specifies which users you want
    ///                 to have access to transcoded files and the type of access you want them to have. You
    ///                 can grant permissions to a maximum of 30 users and/or predefined Amazon S3
    ///                 groups.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Grantee Type</b>: Specify the type of value that appears in the
    ///                     <code>Grantee</code> object:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
    ///                         canonical user ID for an AWS account or an origin access identity for an
    ///                         Amazon CloudFront distribution. For more information about canonical user
    ///                         IDs, see Access Control List (ACL) Overview in the Amazon Simple Storage
    ///                         Service Developer Guide. For more information about using CloudFront origin
    ///                         access identities to require that users use CloudFront URLs instead of
    ///                         Amazon S3 URLs, see Using an Origin Access Identity to Restrict Access to
    ///                         Your Amazon S3 Content.</p>
    ///                      <important>
    ///                         <p>A canonical user ID is not the same as an
    ///                             AWS account number.</p>
    ///                      </important>
    ///                     </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>Email</b>: The value in the <code>Grantee</code> object is the registered
    ///                         email address of an AWS account.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>Group</b>: The value in the <code>Grantee</code> object is one of the
    ///                         following predefined Amazon S3 groups: <code>AllUsers</code>,
    ///                             <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Grantee</b>: The AWS user or group that you want to have access to transcoded
    ///                 files and playlists. To identify the user or group, you can specify the canonical
    ///                 user ID for an AWS account, an origin access identity for a CloudFront distribution,
    ///                 the registered email address of an AWS account, or a predefined Amazon S3 group </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Access</b>: The permission that you want to give to the AWS user that you
    ///                 specified in <code>Grantee</code>. Permissions are granted on the files that Elastic
    ///                 Transcoder adds to the bucket, including playlists and video files. Valid values
    ///                 include: </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>READ</code>: The grantee can read the objects and metadata for objects
    ///                         that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>READ_ACP</code>: The grantee can read the object ACL for objects that
    ///                         Elastic Transcoder adds to the Amazon S3 bucket. </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>WRITE_ACP</code>: The grantee can write the ACL for the objects that
    ///                         Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
    ///                             <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
    ///                         objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
    ///                     <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
    ///                 the video files and playlists that it stores in your Amazon S3 bucket.</p>
    ///             </li>
    ///          </ul>
    public let contentConfig: PipelineOutputConfig?
    /// <p>The ID of the pipeline that you want to update.</p>
    public let id: String?
    /// <p>The Amazon S3 bucket in which you saved the media files that you want to transcode and the graphics
    ///             that you want to use as watermarks.</p>
    public let inputBucket: String?
    /// <p>The name of the pipeline. We recommend that the name be unique within the AWS account, but
    ///             uniqueness is not enforced.</p>
    ///         <p>Constraints: Maximum 40 characters</p>
    public let name: String?
    /// <p>The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status.</p>
    ///         <important>
    ///             <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
    ///         </important>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Progressing</b>: The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to
    ///                 notify when Elastic Transcoder has started to process jobs that are added to this pipeline. This
    ///                 is the ARN that Amazon SNS returned when you created the topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Complete</b>: The topic ARN for the Amazon SNS topic that you want to notify when
    ///                 Elastic Transcoder has finished processing a job. This is the ARN that Amazon SNS returned when
    ///                 you created the topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Warning</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
    ///                 encounters a warning condition. This is the ARN that Amazon SNS returned when you
    ///                 created the topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Error</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
    ///                 encounters an error condition. This is the ARN that Amazon SNS returned when you
    ///                 created the topic.</p>
    ///             </li>
    ///          </ul>
    public let notifications: Notifications?
    /// <p>The IAM Amazon Resource Name (ARN) for the role that you want Elastic Transcoder to use to transcode jobs for
    ///             this pipeline.</p>
    public let role: String?
    /// <p>The <code>ThumbnailConfig</code> object specifies several values, including the Amazon S3
    ///             bucket in which you want Elastic Transcoder to save thumbnail files, which users you want to have
    ///             access to the files, the type of access you want users to have, and the storage class
    ///             that you want to assign to the files.</p>
    ///         <p>If you specify values for <code>ContentConfig</code>, you must also specify values for
    ///                 <code>ThumbnailConfig</code> even if you don't want to create thumbnails.</p>
    ///         <p>If you specify values for <code>ContentConfig</code> and <code>ThumbnailConfig</code>,
    ///             omit the <code>OutputBucket</code> object.</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Bucket</b>: The Amazon S3 bucket in which you want Elastic Transcoder to save
    ///                 thumbnail files.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Permissions</b> (Optional): The <code>Permissions</code> object specifies which
    ///                 users and/or predefined Amazon S3 groups you want to have access to thumbnail files,
    ///                 and the type of access you want them to have. You can grant permissions to a maximum
    ///                 of 30 users and/or predefined Amazon S3 groups.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>GranteeType</b>: Specify the type of value that appears in the Grantee object:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <b>Canonical</b>: The value in the <code>Grantee</code> object is either the
    ///                         canonical user ID for an AWS account or an origin access identity for an
    ///                         Amazon CloudFront distribution.</p>
    ///                      <important>
    ///                         <p>A canonical user ID is not the
    ///                             same as an AWS account number.</p>
    ///                      </important>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>Email</b>: The value in the <code>Grantee</code> object is the registered
    ///                         email address of an AWS account.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <b>Group</b>: The value in the <code>Grantee</code> object is one of the
    ///                         following predefined Amazon S3 groups: <code>AllUsers</code>,
    ///                             <code>AuthenticatedUsers</code>, or <code>LogDelivery</code>.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Grantee</b>: The AWS user or group that you want to have access to thumbnail
    ///                 files. To identify the user or group, you can specify the canonical user ID for an
    ///                 AWS account, an origin access identity for a CloudFront distribution, the registered
    ///                 email address of an AWS account, or a predefined Amazon S3 group. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Access</b>: The permission that you want to give to the AWS user that you
    ///                 specified in <code>Grantee</code>. Permissions are granted on the thumbnail files
    ///                 that Elastic Transcoder adds to the bucket. Valid values include: </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>READ</code>: The grantee can read the thumbnails and metadata for
    ///                         objects that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>READ_ACP</code>: The grantee can read the object ACL for thumbnails
    ///                         that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>WRITE_ACP</code>: The grantee can write the ACL for the thumbnails
    ///                         that Elastic Transcoder adds to the Amazon S3 bucket.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>FULL_CONTROL</code>: The grantee has <code>READ</code>,
    ///                             <code>READ_ACP</code>, and <code>WRITE_ACP</code> permissions for the
    ///                         thumbnails that Elastic Transcoder adds to the Amazon S3 bucket. </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>StorageClass</b>: The Amazon S3 storage class, <code>Standard</code> or
    ///                     <code>ReducedRedundancy</code>, that you want Elastic Transcoder to assign to
    ///                 the thumbnails that it stores in your Amazon S3 bucket.</p>
    ///             </li>
    ///          </ul>
    public let thumbnailConfig: PipelineOutputConfig?

    public init (
        awsKmsKeyArn: String? = nil,
        contentConfig: PipelineOutputConfig? = nil,
        id: String? = nil,
        inputBucket: String? = nil,
        name: String? = nil,
        notifications: Notifications? = nil,
        role: String? = nil,
        thumbnailConfig: PipelineOutputConfig? = nil
    )
    {
        self.awsKmsKeyArn = awsKmsKeyArn
        self.contentConfig = contentConfig
        self.id = id
        self.inputBucket = inputBucket
        self.name = name
        self.notifications = notifications
        self.role = role
        self.thumbnailConfig = thumbnailConfig
    }
}

struct UpdatePipelineInputBody: Equatable {
    public let name: String?
    public let inputBucket: String?
    public let role: String?
    public let awsKmsKeyArn: String?
    public let notifications: Notifications?
    public let contentConfig: PipelineOutputConfig?
    public let thumbnailConfig: PipelineOutputConfig?
}

extension UpdatePipelineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case awsKmsKeyArn = "AwsKmsKeyArn"
        case contentConfig = "ContentConfig"
        case inputBucket = "InputBucket"
        case name = "Name"
        case notifications = "Notifications"
        case role = "Role"
        case thumbnailConfig = "ThumbnailConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let inputBucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputBucket)
        inputBucket = inputBucketDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let awsKmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsKmsKeyArn)
        awsKmsKeyArn = awsKmsKeyArnDecoded
        let notificationsDecoded = try containerValues.decodeIfPresent(Notifications.self, forKey: .notifications)
        notifications = notificationsDecoded
        let contentConfigDecoded = try containerValues.decodeIfPresent(PipelineOutputConfig.self, forKey: .contentConfig)
        contentConfig = contentConfigDecoded
        let thumbnailConfigDecoded = try containerValues.decodeIfPresent(PipelineOutputConfig.self, forKey: .thumbnailConfig)
        thumbnailConfig = thumbnailConfigDecoded
    }
}

public struct UpdatePipelineNotificationsInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePipelineNotificationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePipelineNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePipelineNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePipelineNotificationsInput>
    public typealias MOutput = OperationOutput<UpdatePipelineNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePipelineNotificationsOutputError>
}

extension UpdatePipelineNotificationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePipelineNotificationsInput(id: \(String(describing: id)), notifications: \(String(describing: notifications)))"}
}

extension UpdatePipelineNotificationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case notifications = "Notifications"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notifications = notifications {
            try encodeContainer.encode(notifications, forKey: .notifications)
        }
    }
}

public struct UpdatePipelineNotificationsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePipelineNotificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePipelineNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePipelineNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePipelineNotificationsInput>
    public typealias MOutput = OperationOutput<UpdatePipelineNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePipelineNotificationsOutputError>
}

public struct UpdatePipelineNotificationsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePipelineNotificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePipelineNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePipelineNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePipelineNotificationsInput>
    public typealias MOutput = OperationOutput<UpdatePipelineNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePipelineNotificationsOutputError>
}

/// <p>The <code>UpdatePipelineNotificationsRequest</code> structure.</p>
public struct UpdatePipelineNotificationsInput: Equatable {
    /// <p>The identifier of the pipeline for which you want to change notification settings.</p>
    public let id: String?
    /// <p>The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to notify to report job status.</p>
    ///         <important>
    ///             <p>To receive notifications, you must also subscribe to the new topic in the Amazon SNS console.</p>
    ///          </important>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Progressing</b>: The topic ARN for the Amazon Simple Notification Service (Amazon SNS) topic that you want to
    ///                 notify when Elastic Transcoder has started to process jobs that are added to this pipeline. This
    ///                 is the ARN that Amazon SNS returned when you created the topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Complete</b>: The topic ARN for the Amazon SNS topic that you want to notify when
    ///                 Elastic Transcoder has finished processing a job. This is the ARN that Amazon SNS returned when
    ///                 you created the topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Warning</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
    ///                 encounters a warning condition. This is the ARN that Amazon SNS returned when you
    ///                 created the topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Error</b>: The topic ARN for the Amazon SNS topic that you want to notify when Elastic Transcoder
    ///                 encounters an error condition. This is the ARN that Amazon SNS returned when you
    ///                 created the topic.</p>
    ///             </li>
    ///          </ul>
    public let notifications: Notifications?

    public init (
        id: String? = nil,
        notifications: Notifications? = nil
    )
    {
        self.id = id
        self.notifications = notifications
    }
}

struct UpdatePipelineNotificationsInputBody: Equatable {
    public let notifications: Notifications?
}

extension UpdatePipelineNotificationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case notifications = "Notifications"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationsDecoded = try containerValues.decodeIfPresent(Notifications.self, forKey: .notifications)
        notifications = notificationsDecoded
    }
}

extension UpdatePipelineNotificationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePipelineNotificationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePipelineNotificationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePipelineNotificationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePipelineNotificationsOutputResponse(pipeline: \(String(describing: pipeline)))"}
}

extension UpdatePipelineNotificationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdatePipelineNotificationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pipeline = output.pipeline
        } else {
            self.pipeline = nil
        }
    }
}

/// <p>The <code>UpdatePipelineNotificationsResponse</code> structure.</p>
public struct UpdatePipelineNotificationsOutputResponse: Equatable {
    /// <p>A section of the response body that provides information about the pipeline associated
    ///             with this notification.</p>
    public let pipeline: Pipeline?

    public init (
        pipeline: Pipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct UpdatePipelineNotificationsOutputResponseBody: Equatable {
    public let pipeline: Pipeline?
}

extension UpdatePipelineNotificationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipeline = "Pipeline"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(Pipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

extension UpdatePipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePipelineOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePipelineOutputResponse(pipeline: \(String(describing: pipeline)), warnings: \(String(describing: warnings)))"}
}

extension UpdatePipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdatePipelineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pipeline = output.pipeline
            self.warnings = output.warnings
        } else {
            self.pipeline = nil
            self.warnings = nil
        }
    }
}

/// <p>When you update a pipeline, Elastic Transcoder returns the values that you specified in the request.</p>
public struct UpdatePipelineOutputResponse: Equatable {
    /// <p>The pipeline updated by this <code>UpdatePipelineResponse</code> call.</p>
    public let pipeline: Pipeline?
    /// <p>Elastic Transcoder returns a warning if the resources used by your pipeline are not in the same region as the
    ///             pipeline.</p>
    ///         <p>Using resources in the same region, such as your Amazon S3 buckets, Amazon SNS notification topics, and
    ///             AWS KMS key, reduces processing time and prevents cross-regional charges.</p>
    public let warnings: [Warning]?

    public init (
        pipeline: Pipeline? = nil,
        warnings: [Warning]? = nil
    )
    {
        self.pipeline = pipeline
        self.warnings = warnings
    }
}

struct UpdatePipelineOutputResponseBody: Equatable {
    public let pipeline: Pipeline?
    public let warnings: [Warning]?
}

extension UpdatePipelineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipeline = "Pipeline"
        case warnings = "Warnings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(Pipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Warning?].self, forKey: .warnings)
        var warningsDecoded0:[Warning]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Warning]()
            for structure0 in warningsContainer {
                if let structure0 = structure0 {
                    warningsDecoded0?.append(structure0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

public struct UpdatePipelineStatusInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePipelineStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePipelineStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePipelineStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePipelineStatusInput>
    public typealias MOutput = OperationOutput<UpdatePipelineStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePipelineStatusOutputError>
}

extension UpdatePipelineStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePipelineStatusInput(id: \(String(describing: id)), status: \(String(describing: status)))"}
}

extension UpdatePipelineStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }
}

public struct UpdatePipelineStatusInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePipelineStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePipelineStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePipelineStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePipelineStatusInput>
    public typealias MOutput = OperationOutput<UpdatePipelineStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePipelineStatusOutputError>
}

public struct UpdatePipelineStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePipelineStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePipelineStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePipelineStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePipelineStatusInput>
    public typealias MOutput = OperationOutput<UpdatePipelineStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePipelineStatusOutputError>
}

/// <p>The <code>UpdatePipelineStatusRequest</code> structure.</p>
public struct UpdatePipelineStatusInput: Equatable {
    /// <p>The identifier of the pipeline to update.</p>
    public let id: String?
    /// <p>The desired status of the pipeline:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Active</code>: The pipeline is processing jobs.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Paused</code>: The pipeline is not currently processing jobs.</p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        id: String? = nil,
        status: String? = nil
    )
    {
        self.id = id
        self.status = status
    }
}

struct UpdatePipelineStatusInputBody: Equatable {
    public let status: String?
}

extension UpdatePipelineStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdatePipelineStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePipelineStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleVersionException" : self = .incompatibleVersionException(try IncompatibleVersionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePipelineStatusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case incompatibleVersionException(IncompatibleVersionException)
    case internalServiceException(InternalServiceException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePipelineStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePipelineStatusOutputResponse(pipeline: \(String(describing: pipeline)))"}
}

extension UpdatePipelineStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdatePipelineStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pipeline = output.pipeline
        } else {
            self.pipeline = nil
        }
    }
}

/// <p>When you update status for a pipeline,
///             Elastic Transcoder returns the values that you specified in the request.</p>
public struct UpdatePipelineStatusOutputResponse: Equatable {
    /// <p>A section of the response body that provides information about the pipeline.</p>
    public let pipeline: Pipeline?

    public init (
        pipeline: Pipeline? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct UpdatePipelineStatusOutputResponseBody: Equatable {
    public let pipeline: Pipeline?
}

extension UpdatePipelineStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipeline = "Pipeline"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(Pipeline.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more required parameter values were not provided in the request.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VideoParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aspectRatio = "AspectRatio"
        case bitRate = "BitRate"
        case codec = "Codec"
        case codecOptions = "CodecOptions"
        case displayAspectRatio = "DisplayAspectRatio"
        case fixedGOP = "FixedGOP"
        case frameRate = "FrameRate"
        case keyframesMaxDist = "KeyframesMaxDist"
        case maxFrameRate = "MaxFrameRate"
        case maxHeight = "MaxHeight"
        case maxWidth = "MaxWidth"
        case paddingPolicy = "PaddingPolicy"
        case resolution = "Resolution"
        case sizingPolicy = "SizingPolicy"
        case watermarks = "Watermarks"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aspectRatio = aspectRatio {
            try encodeContainer.encode(aspectRatio, forKey: .aspectRatio)
        }
        if let bitRate = bitRate {
            try encodeContainer.encode(bitRate, forKey: .bitRate)
        }
        if let codec = codec {
            try encodeContainer.encode(codec, forKey: .codec)
        }
        if let codecOptions = codecOptions {
            var codecOptionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .codecOptions)
            for (dictKey0, codecoptions0) in codecOptions {
                try codecOptionsContainer.encode(codecoptions0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let displayAspectRatio = displayAspectRatio {
            try encodeContainer.encode(displayAspectRatio, forKey: .displayAspectRatio)
        }
        if let fixedGOP = fixedGOP {
            try encodeContainer.encode(fixedGOP, forKey: .fixedGOP)
        }
        if let frameRate = frameRate {
            try encodeContainer.encode(frameRate, forKey: .frameRate)
        }
        if let keyframesMaxDist = keyframesMaxDist {
            try encodeContainer.encode(keyframesMaxDist, forKey: .keyframesMaxDist)
        }
        if let maxFrameRate = maxFrameRate {
            try encodeContainer.encode(maxFrameRate, forKey: .maxFrameRate)
        }
        if let maxHeight = maxHeight {
            try encodeContainer.encode(maxHeight, forKey: .maxHeight)
        }
        if let maxWidth = maxWidth {
            try encodeContainer.encode(maxWidth, forKey: .maxWidth)
        }
        if let paddingPolicy = paddingPolicy {
            try encodeContainer.encode(paddingPolicy, forKey: .paddingPolicy)
        }
        if let resolution = resolution {
            try encodeContainer.encode(resolution, forKey: .resolution)
        }
        if let sizingPolicy = sizingPolicy {
            try encodeContainer.encode(sizingPolicy, forKey: .sizingPolicy)
        }
        if let watermarks = watermarks {
            var watermarksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .watermarks)
            for presetwatermarks0 in watermarks {
                try watermarksContainer.encode(presetwatermarks0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codecDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codec)
        codec = codecDecoded
        let codecOptionsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .codecOptions)
        var codecOptionsDecoded0: [String:String]? = nil
        if let codecOptionsContainer = codecOptionsContainer {
            codecOptionsDecoded0 = [String:String]()
            for (key0, codecoption0) in codecOptionsContainer {
                if let codecoption0 = codecoption0 {
                    codecOptionsDecoded0?[key0] = codecoption0
                }
            }
        }
        codecOptions = codecOptionsDecoded0
        let keyframesMaxDistDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyframesMaxDist)
        keyframesMaxDist = keyframesMaxDistDecoded
        let fixedGOPDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fixedGOP)
        fixedGOP = fixedGOPDecoded
        let bitRateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bitRate)
        bitRate = bitRateDecoded
        let frameRateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .frameRate)
        frameRate = frameRateDecoded
        let maxFrameRateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxFrameRate)
        maxFrameRate = maxFrameRateDecoded
        let resolutionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolution)
        resolution = resolutionDecoded
        let aspectRatioDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aspectRatio)
        aspectRatio = aspectRatioDecoded
        let maxWidthDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxWidth)
        maxWidth = maxWidthDecoded
        let maxHeightDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxHeight)
        maxHeight = maxHeightDecoded
        let displayAspectRatioDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayAspectRatio)
        displayAspectRatio = displayAspectRatioDecoded
        let sizingPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sizingPolicy)
        sizingPolicy = sizingPolicyDecoded
        let paddingPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .paddingPolicy)
        paddingPolicy = paddingPolicyDecoded
        let watermarksContainer = try containerValues.decodeIfPresent([PresetWatermark?].self, forKey: .watermarks)
        var watermarksDecoded0:[PresetWatermark]? = nil
        if let watermarksContainer = watermarksContainer {
            watermarksDecoded0 = [PresetWatermark]()
            for structure0 in watermarksContainer {
                if let structure0 = structure0 {
                    watermarksDecoded0?.append(structure0)
                }
            }
        }
        watermarks = watermarksDecoded0
    }
}

extension VideoParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VideoParameters(aspectRatio: \(String(describing: aspectRatio)), bitRate: \(String(describing: bitRate)), codec: \(String(describing: codec)), codecOptions: \(String(describing: codecOptions)), displayAspectRatio: \(String(describing: displayAspectRatio)), fixedGOP: \(String(describing: fixedGOP)), frameRate: \(String(describing: frameRate)), keyframesMaxDist: \(String(describing: keyframesMaxDist)), maxFrameRate: \(String(describing: maxFrameRate)), maxHeight: \(String(describing: maxHeight)), maxWidth: \(String(describing: maxWidth)), paddingPolicy: \(String(describing: paddingPolicy)), resolution: \(String(describing: resolution)), sizingPolicy: \(String(describing: sizingPolicy)), watermarks: \(String(describing: watermarks)))"}
}

/// <p>The <code>VideoParameters</code> structure.</p>
public struct VideoParameters: Equatable {
    /// <important>
    ///             <p>To better control resolution and aspect ratio of output videos, we recommend that you
    ///                 use the values <code>MaxWidth</code>, <code>MaxHeight</code>,
    ///                     <code>SizingPolicy</code>, <code>PaddingPolicy</code>, and
    ///                     <code>DisplayAspectRatio</code> instead of <code>Resolution</code> and
    ///                     <code>AspectRatio</code>. The two groups of settings are mutually exclusive. Do
    ///                 not use them together.</p>
    ///         </important>
    ///         <p>The display aspect ratio of the video in the output file. Valid values include:</p>
    ///         <p>
    ///             <code>auto</code>, <code>1:1</code>, <code>4:3</code>, <code>3:2</code>,
    ///                 <code>16:9</code>
    ///          </p>
    ///         <p>If you specify <code>auto</code>, Elastic Transcoder tries to preserve the aspect ratio of the input
    ///             file.</p>
    ///         <p>If you specify an aspect ratio for the output file that differs from aspect ratio
    ///             of the input file, Elastic Transcoder adds pillarboxing (black bars on the sides) or letterboxing
    ///             (black bars on the top and bottom) to maintain the aspect ratio of the active region
    ///             of the video.</p>
    public let aspectRatio: String?
    /// <p>The bit rate of the video stream in the output file, in kilobits/second. Valid values
    ///             depend on the values of <code>Level</code> and <code>Profile</code>. If you specify
    ///                 <code>auto</code>, Elastic Transcoder uses the detected bit rate of the input source. If you
    ///             specify a value other than <code>auto</code>, we recommend that you specify a value less
    ///             than or equal to the maximum H.264-compliant value listed for your level and
    ///             profile:</p>
    ///         <p>
    ///             <i>Level - Maximum video bit rate in kilobits/second (baseline and main Profile) :
    ///                 maximum video bit rate in kilobits/second (high Profile)</i>
    ///         </p>
    ///         <ul>
    ///             <li>
    ///                <p>1 - 64 : 80</p>
    ///             </li>
    ///             <li>
    ///                <p>1b - 128 : 160</p>
    ///             </li>
    ///             <li>
    ///                <p>1.1 - 192 : 240</p>
    ///             </li>
    ///             <li>
    ///                <p>1.2 - 384 : 480</p>
    ///             </li>
    ///             <li>
    ///                <p>1.3 - 768 : 960</p>
    ///             </li>
    ///             <li>
    ///                <p>2 - 2000 : 2500</p>
    ///             </li>
    ///             <li>
    ///                <p>3 - 10000 : 12500</p>
    ///             </li>
    ///             <li>
    ///                <p>3.1 - 14000 : 17500</p>
    ///             </li>
    ///             <li>
    ///                <p>3.2 - 20000 : 25000</p>
    ///             </li>
    ///             <li>
    ///                <p>4 - 20000 : 25000</p>
    ///             </li>
    ///             <li>
    ///                <p>4.1 - 50000 : 62500</p>
    ///             </li>
    ///          </ul>
    public let bitRate: String?
    /// <p>The video codec for the output file. Valid values include <code>gif</code>,
    ///                 <code>H.264</code>, <code>mpeg2</code>, <code>vp8</code>, and <code>vp9</code>.
    ///                 You can only specify <code>vp8</code> and <code>vp9</code> when the container type is
    ///                 <code>webm</code>, <code>gif</code> when the container type is <code>gif</code>,
    ///                 and <code>mpeg2</code> when the container type is <code>mpg</code>.</p>
    public let codec: String?
    /// <p>
    ///             <b>Profile (H.264/VP8/VP9 Only)</b>
    ///         </p>
    ///         <p>The H.264 profile that you want to use for the output file. Elastic Transcoder supports the following profiles:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>baseline</code>: The profile most commonly used for videoconferencing and for
    ///                 mobile applications.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>main</code>: The profile used for standard-definition digital TV
    ///                 broadcasts.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>high</code>: The profile used for high-definition digital TV broadcasts and
    ///                 for Blu-ray discs.</p>
    ///             </li>
    ///          </ul>
    ///         <p>
    ///             <b>Level (H.264 Only)</b>
    ///         </p>
    ///         <p>The H.264 level that you want to use for the output file. Elastic Transcoder supports the following levels:</p>
    ///         <p>
    ///             <code>1</code>, <code>1b</code>, <code>1.1</code>, <code>1.2</code>, <code>1.3</code>,
    ///                 <code>2</code>, <code>2.1</code>, <code>2.2</code>, <code>3</code>,
    ///             <code>3.1</code>, <code>3.2</code>, <code>4</code>, <code>4.1</code>
    ///          </p>
    ///         <p>
    ///             <b>MaxReferenceFrames (H.264 Only)</b>
    ///         </p>
    ///         <p>Applicable only when the value of Video:Codec is H.264. The maximum number of
    ///             previously decoded frames to use as a reference for decoding future frames. Valid
    ///             values are integers 0 through 16, but we recommend that you not use a value greater
    ///             than the following:</p>
    ///         <p>
    ///             <code>Min(Floor(Maximum decoded picture buffer in macroblocks * 256 / (Width in pixels *
    ///                 Height in pixels)), 16)</code>
    ///         </p>
    ///         <p>where <i>Width in pixels</i> and <i>Height in pixels</i> represent either MaxWidth and
    ///             MaxHeight, or Resolution. <i>Maximum decoded picture buffer in macroblocks</i> depends
    ///             on the value of the <code>Level</code> object. See the list below. (A macroblock is a
    ///             block of pixels measuring 16x16.) </p>
    ///         <ul>
    ///             <li>
    ///                <p>1 - 396</p>
    ///             </li>
    ///             <li>
    ///                <p>1b - 396</p>
    ///             </li>
    ///             <li>
    ///                <p>1.1 - 900</p>
    ///             </li>
    ///             <li>
    ///                <p>1.2 - 2376</p>
    ///             </li>
    ///             <li>
    ///                <p>1.3 - 2376</p>
    ///             </li>
    ///             <li>
    ///                <p>2 - 2376</p>
    ///             </li>
    ///             <li>
    ///                <p>2.1 - 4752</p>
    ///             </li>
    ///             <li>
    ///                <p>2.2 - 8100</p>
    ///             </li>
    ///             <li>
    ///                <p>3 - 8100</p>
    ///             </li>
    ///             <li>
    ///                <p>3.1 - 18000</p>
    ///             </li>
    ///             <li>
    ///                <p>3.2 - 20480</p>
    ///             </li>
    ///             <li>
    ///                <p>4 - 32768</p>
    ///             </li>
    ///             <li>
    ///                <p>4.1 - 32768</p>
    ///             </li>
    ///          </ul>
    ///         <p>
    ///             <b>MaxBitRate (Optional, H.264/MPEG2/VP8/VP9 only)</b>
    ///         </p>
    ///         <p>The maximum number of bits per second in a video buffer; the size of the buffer is
    ///             specified by <code>BufferSize</code>. Specify a value between 16 and 62,500. You can
    ///             reduce the bandwidth required to stream a video by reducing the maximum bit rate, but
    ///             this also reduces the quality of the video.</p>
    ///         <p>
    ///             <b>BufferSize (Optional, H.264/MPEG2/VP8/VP9 only)</b>
    ///         </p>
    ///         <p>The maximum number of bits in any x seconds of the output video. This window is commonly
    ///             10 seconds, the standard segment duration when you're using FMP4 or MPEG-TS for the container
    ///             type of the output video. Specify an integer greater than 0. If you specify
    ///                 <code>MaxBitRate</code> and omit <code>BufferSize</code>, Elastic Transcoder sets
    ///                 <code>BufferSize</code> to 10 times the value of <code>MaxBitRate</code>.</p>
    ///         <p>
    ///             <b>InterlacedMode (Optional, H.264/MPEG2 Only)</b>
    ///         </p>
    ///         <p>The interlace mode for the output video.</p>
    ///         <p>Interlaced video is used to double the perceived frame rate for a video by interlacing
    ///             two fields (one field on every other line, the other field on the other lines) so that the
    ///             human eye registers multiple pictures per frame. Interlacing reduces the bandwidth required
    ///             for transmitting a video, but can result in blurred images and flickering.</p>
    ///         <p>Valid values include <code>Progressive</code> (no interlacing, top to bottom),
    ///             <code>TopFirst</code> (top field first), <code>BottomFirst</code> (bottom field
    ///             first), and <code>Auto</code>.</p>
    ///         <p>If <code>InterlaceMode</code> is not specified, Elastic Transcoder uses <code>Progressive</code> for the output. If
    ///             <code>Auto</code> is specified, Elastic Transcoder interlaces the output.</p>
    ///         <p>
    ///             <b>ColorSpaceConversionMode (Optional, H.264/MPEG2 Only)</b>
    ///         </p>
    ///         <p>The color space conversion Elastic Transcoder applies to the output video. Color spaces are the algorithms
    ///             used by the computer to store information about how to render color. <code>Bt.601</code> is the
    ///             standard for standard definition video, while <code>Bt.709</code> is the standard for high definition
    ///             video.</p>
    ///         <p>Valid values include <code>None</code>,
    ///             <code>Bt709toBt601</code>, <code>Bt601toBt709</code>, and <code>Auto</code>.</p>
    ///         <p>If you chose <code>Auto</code> for <code>ColorSpaceConversionMode</code> and your output
    ///             is interlaced, your frame rate is one of <code>23.97</code>, <code>24</code>,
    ///             <code>25</code>, <code>29.97</code>, <code>50</code>, or <code>60</code>, your
    ///             <code>SegmentDuration</code> is null, and you are using one of the resolution
    ///             changes from the list below, Elastic Transcoder applies the following color space
    ///             conversions:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <i>Standard to HD, 720x480 to 1920x1080</i> - Elastic Transcoder applies <code>Bt601ToBt709</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>Standard to HD, 720x576 to 1920x1080</i> - Elastic Transcoder applies <code>Bt601ToBt709</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>HD to Standard, 1920x1080 to 720x480</i> - Elastic Transcoder applies <code>Bt709ToBt601</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>HD to Standard, 1920x1080 to 720x576</i> - Elastic Transcoder applies <code>Bt709ToBt601</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///         <note>
    ///             <p>Elastic Transcoder may change the behavior of the <code>ColorspaceConversionMode</code>
    ///                <code>Auto</code> mode in the future. All outputs in a playlist must use the same
    ///             <code>ColorSpaceConversionMode</code>.</p>
    ///          </note>
    ///         <p>If you do not specify a <code>ColorSpaceConversionMode</code>, Elastic Transcoder does not change the
    ///             color space of a file. If you are unsure what <code>ColorSpaceConversionMode</code> was applied to
    ///             your output file, you can check the <code>AppliedColorSpaceConversion</code> parameter included in
    ///             your job response. If your job does not have an <code>AppliedColorSpaceConversion</code> in its
    ///             response, no <code>ColorSpaceConversionMode</code> was applied.</p>
    ///          <p>
    ///              <b>ChromaSubsampling</b>
    ///          </p>
    ///          <p>The sampling pattern for the chroma (color) channels of the output video.
    ///              Valid values include <code>yuv420p</code> and <code>yuv422p</code>.</p>
    ///          <p>
    ///             <code>yuv420p</code> samples the chroma information of every other horizontal and every other vertical
    ///              line, <code>yuv422p</code> samples the color information of every horizontal line and every other
    ///              vertical line.</p>
    ///
    ///          <p>
    ///              <b>LoopCount (Gif Only)</b>
    ///          </p>
    ///          <p>The number of times you want the output gif to loop. Valid values include <code>Infinite</code> and
    ///              integers between <code>0</code> and <code>100</code>, inclusive.</p>
    public let codecOptions: [String:String]?
    /// <p>The value that Elastic Transcoder adds to the metadata in the output file.</p>
    public let displayAspectRatio: String?
    /// <p>Applicable only when the value of Video:Codec is one of <code>H.264</code>, <code>MPEG2</code>,
    ///             or <code>VP8</code>.</p>
    ///         <p>Whether to use a fixed value for <code>FixedGOP</code>. Valid values are
    ///                 <code>true</code> and <code>false</code>:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>true</code>: Elastic Transcoder uses the value of <code>KeyframesMaxDist</code> for the
    ///                 distance between key frames (the number of frames in a group of pictures, or
    ///                 GOP).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>false</code>: The distance between key frames can vary.</p>
    ///             </li>
    ///          </ul>
    ///         <important>
    ///             <p>
    ///                <code>FixedGOP</code> must be set to <code>true</code> for <code>fmp4</code> containers.</p>
    ///          </important>
    public let fixedGOP: String?
    /// <p>The frames per second for the video stream in the output file. Valid values include:</p>
    ///         <p>
    ///             <code>auto</code>, <code>10</code>, <code>15</code>, <code>23.97</code>, <code>24</code>,
    ///                 <code>25</code>, <code>29.97</code>, <code>30</code>, <code>60</code>
    ///          </p>
    ///         <p>If you specify <code>auto</code>, Elastic Transcoder uses the detected frame rate of the input source.
    ///             If you specify a frame rate, we recommend that you perform the following
    ///             calculation:</p>
    ///         <p>
    ///             <code>Frame rate = maximum recommended decoding speed in luma samples/second / (width in
    ///                 pixels * height in pixels)</code>
    ///         </p>
    ///         <p>where:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <i>width in pixels</i> and <i>height in pixels</i> represent the Resolution of the
    ///                 output video.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>maximum recommended decoding speed in Luma samples/second</i> is less than or
    ///                 equal to the maximum value listed in the following table, based on the value that
    ///                 you specified for Level.</p>
    ///             </li>
    ///          </ul>
    ///         <p>The maximum recommended decoding speed in Luma samples/second for each level is described
    ///             in the following list (<i>Level - Decoding speed</i>):</p>
    ///         <ul>
    ///             <li>
    ///                <p>1 - 380160</p>
    ///             </li>
    ///             <li>
    ///                <p>1b - 380160</p>
    ///             </li>
    ///             <li>
    ///                <p>1.1 - 76800</p>
    ///             </li>
    ///             <li>
    ///                <p>1.2 - 1536000</p>
    ///             </li>
    ///             <li>
    ///                <p>1.3 - 3041280</p>
    ///             </li>
    ///             <li>
    ///                <p>2 - 3041280</p>
    ///             </li>
    ///             <li>
    ///                <p>2.1 - 5068800</p>
    ///             </li>
    ///             <li>
    ///                <p>2.2 - 5184000</p>
    ///             </li>
    ///             <li>
    ///                <p>3 - 10368000</p>
    ///             </li>
    ///             <li>
    ///                <p>3.1 - 27648000</p>
    ///             </li>
    ///             <li>
    ///                <p>3.2 - 55296000</p>
    ///             </li>
    ///             <li>
    ///                <p>4 - 62914560</p>
    ///             </li>
    ///             <li>
    ///                <p>4.1 - 62914560</p>
    ///             </li>
    ///          </ul>
    public let frameRate: String?
    /// <p>Applicable only when the value of Video:Codec is one of <code>H.264</code>, <code>MPEG2</code>,
    ///             or <code>VP8</code>.</p>
    ///         <p>The maximum number of frames between key frames. Key frames are fully encoded frames;
    ///             the frames between key frames are encoded based, in part, on the content of the key frames.
    ///             The value is an integer formatted as a string; valid values are between 1 (every frame is a
    ///             key frame) and 100000, inclusive. A higher value results in higher compression but may also
    ///             discernibly decrease video quality.</p>
    ///         <p>For <code>Smooth</code> outputs, the <code>FrameRate</code> must have a constant ratio to the
    ///             <code>KeyframesMaxDist</code>. This allows <code>Smooth</code> playlists to switch between different quality levels
    ///             while the file is being played.</p>
    ///         <p>For example, an input file can have a <code>FrameRate</code> of
    ///             30 with a <code>KeyframesMaxDist</code> of 90. The output file then needs to have a ratio of 1:3.
    ///             Valid outputs would have <code>FrameRate</code> of 30, 25, and 10, and <code>KeyframesMaxDist</code>
    ///             of 90, 75, and 30, respectively.</p>
    ///         <p>Alternately, this can be achieved by setting <code>FrameRate</code>
    ///             to auto and having the same values for <code>MaxFrameRate</code> and <code>KeyframesMaxDist</code>.</p>
    public let keyframesMaxDist: String?
    /// <p>If you specify <code>auto</code> for <code>FrameRate</code>, Elastic Transcoder uses the frame rate of
    ///             the input video for the frame rate of the output video. Specify the maximum frame rate
    ///             that you want Elastic Transcoder to use when the frame rate of the input video is greater than the
    ///             desired maximum frame rate of the output video. Valid values include: <code>10</code>,
    ///                 <code>15</code>, <code>23.97</code>, <code>24</code>, <code>25</code>,
    ///                 <code>29.97</code>, <code>30</code>, <code>60</code>.</p>
    public let maxFrameRate: String?
    /// <p>The maximum height of the output video in pixels. If you specify <code>auto</code>, Elastic Transcoder
    ///             uses 1080 (Full HD) as the default value. If you specify a numeric value, enter an even
    ///             integer between 96 and 3072.</p>
    public let maxHeight: String?
    /// <p> The maximum width of the output video in pixels. If you specify <code>auto</code>, Elastic Transcoder
    ///             uses 1920 (Full HD) as the default value. If you specify a numeric value, enter an even
    ///             integer between 128 and 4096. </p>
    public let maxWidth: String?
    /// <p>When you set <code>PaddingPolicy</code> to <code>Pad</code>, Elastic Transcoder may add black bars to
    ///             the top and bottom and/or left and right sides of the output video to make the total
    ///             size of the output video match the values that you specified for <code>MaxWidth</code>
    ///             and <code>MaxHeight</code>.</p>
    public let paddingPolicy: String?
    /// <important>
    ///             <p>To better control resolution and aspect ratio of output videos, we recommend that you
    ///                 use the values <code>MaxWidth</code>, <code>MaxHeight</code>,
    ///                     <code>SizingPolicy</code>, <code>PaddingPolicy</code>, and
    ///                     <code>DisplayAspectRatio</code> instead of <code>Resolution</code> and
    ///                     <code>AspectRatio</code>. The two groups of settings are mutually exclusive. Do
    ///                 not use them together.</p>
    ///         </important>
    ///         <p>The width and height of the video in the output file, in pixels. Valid values are
    ///                 <code>auto</code> and <i>width</i> x <i>height</i>:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>auto</code>: Elastic Transcoder attempts to preserve the width and height of the input file,
    ///                 subject to the following rules.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>
    ///                      <i>width</i> x <i>height</i>
    ///                   </code>: The width and height of the output video
    ///                 in pixels.</p>
    ///             </li>
    ///          </ul>
    ///         <p>Note the following about specifying the width and height:</p>
    ///         <ul>
    ///             <li>
    ///                <p>The width must be an even integer between 128 and 4096, inclusive.</p>
    ///             </li>
    ///             <li>
    ///                <p>The height must be an even integer between 96 and 3072, inclusive.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you specify a resolution that is less than the resolution of the input file, Elastic Transcoder
    ///                 rescales the output file to the lower resolution.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you specify a resolution that is greater than the resolution of the input file,
    ///                 Elastic Transcoder rescales the output to the higher resolution.</p>
    ///             </li>
    ///             <li>
    ///                <p>We recommend that you specify a resolution for which the product of width and height
    ///                 is less than or equal to the applicable value in the following list (<i>List - Max
    ///                     width x height value</i>):</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>1 - 25344</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>1b - 25344</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>1.1 - 101376</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>1.2 - 101376</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>1.3 - 101376</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>2 - 101376</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>2.1 - 202752</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>2.2 - 404720</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>3 - 404720</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>3.1 - 921600</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>3.2 - 1310720</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>4 - 2097152</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>4.1 - 2097152</p>
    ///                   </li>
    ///                </ul>
    /// 			         </li>
    ///          </ul>
    public let resolution: String?
    /// <p>Specify one of the following values to control scaling of the output video:</p>
    ///
    ///             <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Fit</code>: Elastic Transcoder scales the output video so it matches the value that you
    ///                     specified in either <code>MaxWidth</code> or <code>MaxHeight</code> without
    ///                     exceeding the other value.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Fill</code>: Elastic Transcoder scales the output video so it matches the value that you
    ///                     specified in either <code>MaxWidth</code> or <code>MaxHeight</code> and matches
    ///                     or exceeds the other value. Elastic Transcoder centers the output video and then crops it in
    ///                     the dimension (if any) that exceeds the maximum value.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Stretch</code>: Elastic Transcoder stretches the output video to match the values that
    ///                     you specified for <code>MaxWidth</code> and <code>MaxHeight</code>. If the
    ///                     relative proportions of the input video and the output video are different, the
    ///                     output video will be distorted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Keep</code>: Elastic Transcoder does not scale the output video. If either
    ///                     dimension of the input video exceeds the values that you specified for
    ///                         <code>MaxWidth</code> and <code>MaxHeight</code>, Elastic Transcoder crops the output
    ///                     video.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ShrinkToFit</code>: Elastic Transcoder scales the output video down so that its
    ///                     dimensions match the values that you specified for at least one of
    ///                         <code>MaxWidth</code> and <code>MaxHeight</code> without exceeding either
    ///                     value. If you specify this option, Elastic Transcoder does not scale the video up.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ShrinkToFill</code>: Elastic Transcoder scales the output video down so that its
    ///                     dimensions match the values that you specified for at least one of
    ///                         <code>MaxWidth</code> and <code>MaxHeight</code> without dropping below
    ///                     either value. If you specify this option, Elastic Transcoder does not scale the video up.</p>
    ///             </li>
    ///          </ul>
    public let sizingPolicy: String?
    /// <p>Settings for the size, location, and opacity of graphics that you want Elastic Transcoder to overlay
    ///             over videos that are transcoded using this preset. You can specify settings for up to four
    ///             watermarks. Watermarks appear in the specified size and location, and with the specified
    ///             opacity for the duration of the transcoded video.</p>
    ///         <p>Watermarks can be in .png or .jpg format. If you want to display a watermark that is not
    ///             rectangular, use the .png format, which supports transparency.</p>
    ///         <p>When you create a job that uses this preset, you specify the .png or .jpg graphics that
    ///             you want Elastic Transcoder to include in the transcoded videos. You can specify fewer graphics in the job
    ///             than you specify watermark settings in the preset, which allows you to use the same preset
    ///             for up to four watermarks that have different dimensions.</p>
    public let watermarks: [PresetWatermark]?

    public init (
        aspectRatio: String? = nil,
        bitRate: String? = nil,
        codec: String? = nil,
        codecOptions: [String:String]? = nil,
        displayAspectRatio: String? = nil,
        fixedGOP: String? = nil,
        frameRate: String? = nil,
        keyframesMaxDist: String? = nil,
        maxFrameRate: String? = nil,
        maxHeight: String? = nil,
        maxWidth: String? = nil,
        paddingPolicy: String? = nil,
        resolution: String? = nil,
        sizingPolicy: String? = nil,
        watermarks: [PresetWatermark]? = nil
    )
    {
        self.aspectRatio = aspectRatio
        self.bitRate = bitRate
        self.codec = codec
        self.codecOptions = codecOptions
        self.displayAspectRatio = displayAspectRatio
        self.fixedGOP = fixedGOP
        self.frameRate = frameRate
        self.keyframesMaxDist = keyframesMaxDist
        self.maxFrameRate = maxFrameRate
        self.maxHeight = maxHeight
        self.maxWidth = maxWidth
        self.paddingPolicy = paddingPolicy
        self.resolution = resolution
        self.sizingPolicy = sizingPolicy
        self.watermarks = watermarks
    }
}

extension Warning: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Warning: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Warning(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

/// <p>Elastic Transcoder returns a warning if the resources used by your pipeline are not in the same region
///             as the pipeline.</p>
///         <p>Using resources in the same region, such as your Amazon S3 buckets, Amazon SNS notification topics,
///             and AWS KMS key, reduces processing time and prevents cross-regional charges.</p>
public struct Warning: Equatable {
    /// <p>The code of the cross-regional warning.</p>
    public let code: String?
    /// <p>The message explaining what resources are in a different region from the pipeline.</p>
    ///         <note>
    ///             <p>AWS KMS keys must be in the same region as the pipeline.</p>
    ///          </note>
    public let message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}
