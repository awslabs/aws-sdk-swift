// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AbortMultipartUploadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AbortMultipartUploadInput(accountId: \(String(describing: accountId)), uploadId: \(String(describing: uploadId)), vaultName: \(String(describing: vaultName)))"}
}

extension AbortMultipartUploadInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct AbortMultipartUploadInputHeadersMiddleware: Middleware {
    public let id: String = "AbortMultipartUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AbortMultipartUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<AbortMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AbortMultipartUploadInput>
    public typealias MOutput = OperationOutput<AbortMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AbortMultipartUploadOutputError>
}

public struct AbortMultipartUploadInputQueryItemMiddleware: Middleware {
    public let id: String = "AbortMultipartUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AbortMultipartUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<AbortMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AbortMultipartUploadInput>
    public typealias MOutput = OperationOutput<AbortMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AbortMultipartUploadOutputError>
}

/// <p>Provides options to abort a multipart upload identified by the upload ID.</p>
///
///          <p>For information about the underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-multipart-abort-upload.html">Abort Multipart
///             Upload</a>. For conceptual information, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html">Working with Archives in
///             Amazon S3 Glacier</a>.</p>
public struct AbortMultipartUploadInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: String?
    /// <p>The upload ID of the multipart upload to delete.</p>
    public let uploadId: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        uploadId: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.uploadId = uploadId
        self.vaultName = vaultName
    }
}

struct AbortMultipartUploadInputBody: Equatable {
}

extension AbortMultipartUploadInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AbortMultipartUploadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AbortMultipartUploadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AbortMultipartUploadOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AbortMultipartUploadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AbortMultipartUploadOutputResponse()"}
}

extension AbortMultipartUploadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AbortMultipartUploadOutputResponse: Equatable {

    public init() {}
}

struct AbortMultipartUploadOutputResponseBody: Equatable {
}

extension AbortMultipartUploadOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AbortVaultLockInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AbortVaultLockInput(accountId: \(String(describing: accountId)), vaultName: \(String(describing: vaultName)))"}
}

extension AbortVaultLockInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct AbortVaultLockInputHeadersMiddleware: Middleware {
    public let id: String = "AbortVaultLockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AbortVaultLockInput>,
                  next: H) -> Swift.Result<OperationOutput<AbortVaultLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AbortVaultLockInput>
    public typealias MOutput = OperationOutput<AbortVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AbortVaultLockOutputError>
}

public struct AbortVaultLockInputQueryItemMiddleware: Middleware {
    public let id: String = "AbortVaultLockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AbortVaultLockInput>,
                  next: H) -> Swift.Result<OperationOutput<AbortVaultLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AbortVaultLockInput>
    public typealias MOutput = OperationOutput<AbortVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AbortVaultLockOutputError>
}

/// <p>The input values for <code>AbortVaultLock</code>.</p>
public struct AbortVaultLockInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID. This value must match the AWS
    ///          account ID associated with the credentials used to sign the request. You can either specify
    ///          an AWS account ID or optionally a single '<code>-</code>' (hyphen), in which case Amazon
    ///          Glacier uses the AWS account ID associated with the credentials used to sign the request.
    ///          If you specify your account ID, do not include any hyphens ('-') in the ID.</p>
    public let accountId: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct AbortVaultLockInputBody: Equatable {
}

extension AbortVaultLockInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AbortVaultLockOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AbortVaultLockOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AbortVaultLockOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AbortVaultLockOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AbortVaultLockOutputResponse()"}
}

extension AbortVaultLockOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AbortVaultLockOutputResponse: Equatable {

    public init() {}
}

struct AbortVaultLockOutputResponseBody: Equatable {
}

extension AbortVaultLockOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum ActionCode {
    case archiveretrieval
    case inventoryretrieval
    case select
    case sdkUnknown(String)
}

extension ActionCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActionCode] {
        return [
            .archiveretrieval,
            .inventoryretrieval,
            .select,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .archiveretrieval: return "ArchiveRetrieval"
        case .inventoryretrieval: return "InventoryRetrieval"
        case .select: return "Select"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActionCode(rawValue: rawValue) ?? ActionCode.sdkUnknown(rawValue)
    }
}

public struct AddTagsToVaultInputBodyMiddleware: Middleware {
    public let id: String = "AddTagsToVaultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToVaultInput>
    public typealias MOutput = OperationOutput<AddTagsToVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToVaultOutputError>
}

extension AddTagsToVaultInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsToVaultInput(tags: \(String(describing: tags)), accountId: \(String(describing: accountId)), vaultName: \(String(describing: vaultName)))"}
}

extension AddTagsToVaultInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct AddTagsToVaultInputHeadersMiddleware: Middleware {
    public let id: String = "AddTagsToVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToVaultInput>
    public typealias MOutput = OperationOutput<AddTagsToVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToVaultOutputError>
}

public struct AddTagsToVaultInputQueryItemMiddleware: Middleware {
    public let id: String = "AddTagsToVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsToVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsToVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "operation", value: "add"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsToVaultInput>
    public typealias MOutput = OperationOutput<AddTagsToVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsToVaultOutputError>
}

/// <p>The input values for <code>AddTagsToVault</code>.</p>
public struct AddTagsToVaultInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: String?
    /// <p>The tags to add to the vault. Each tag is composed of a key and a value. The value
    ///          can be an empty string.</p>
    public let tags: [String:String]?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        tags: [String:String]? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.tags = tags
        self.vaultName = vaultName
    }
}

struct AddTagsToVaultInputBody: Equatable {
    public let tags: [String:String]?
}

extension AddTagsToVaultInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AddTagsToVaultOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsToVaultOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsToVaultOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsToVaultOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsToVaultOutputResponse()"}
}

extension AddTagsToVaultOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddTagsToVaultOutputResponse: Equatable {

    public init() {}
}

struct AddTagsToVaultOutputResponseBody: Equatable {
}

extension AddTagsToVaultOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CSVInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comments = "Comments"
        case fieldDelimiter = "FieldDelimiter"
        case fileHeaderInfo = "FileHeaderInfo"
        case quoteCharacter = "QuoteCharacter"
        case quoteEscapeCharacter = "QuoteEscapeCharacter"
        case recordDelimiter = "RecordDelimiter"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comments = comments {
            try encodeContainer.encode(comments, forKey: .comments)
        }
        if let fieldDelimiter = fieldDelimiter {
            try encodeContainer.encode(fieldDelimiter, forKey: .fieldDelimiter)
        }
        if let fileHeaderInfo = fileHeaderInfo {
            try encodeContainer.encode(fileHeaderInfo.rawValue, forKey: .fileHeaderInfo)
        }
        if let quoteCharacter = quoteCharacter {
            try encodeContainer.encode(quoteCharacter, forKey: .quoteCharacter)
        }
        if let quoteEscapeCharacter = quoteEscapeCharacter {
            try encodeContainer.encode(quoteEscapeCharacter, forKey: .quoteEscapeCharacter)
        }
        if let recordDelimiter = recordDelimiter {
            try encodeContainer.encode(recordDelimiter, forKey: .recordDelimiter)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileHeaderInfoDecoded = try containerValues.decodeIfPresent(FileHeaderInfo.self, forKey: .fileHeaderInfo)
        fileHeaderInfo = fileHeaderInfoDecoded
        let commentsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comments)
        comments = commentsDecoded
        let quoteEscapeCharacterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quoteEscapeCharacter)
        quoteEscapeCharacter = quoteEscapeCharacterDecoded
        let recordDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordDelimiter)
        recordDelimiter = recordDelimiterDecoded
        let fieldDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fieldDelimiter)
        fieldDelimiter = fieldDelimiterDecoded
        let quoteCharacterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quoteCharacter)
        quoteCharacter = quoteCharacterDecoded
    }
}

extension CSVInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CSVInput(comments: \(String(describing: comments)), fieldDelimiter: \(String(describing: fieldDelimiter)), fileHeaderInfo: \(String(describing: fileHeaderInfo)), quoteCharacter: \(String(describing: quoteCharacter)), quoteEscapeCharacter: \(String(describing: quoteEscapeCharacter)), recordDelimiter: \(String(describing: recordDelimiter)))"}
}

/// <p>Contains information about the comma-separated value (CSV) file to select from.</p>
public struct CSVInput: Equatable {
    /// <p>A single character used to indicate that a row should be ignored when the character is
    ///             present at the start of that row.</p>
    public let comments: String?
    /// <p>A value used to separate individual fields from each other within a record.</p>
    public let fieldDelimiter: String?
    /// <p>Describes the first line of input. Valid values are <code>None</code>,
    ///                 <code>Ignore</code>, and <code>Use</code>.</p>
    public let fileHeaderInfo: FileHeaderInfo?
    /// <p>A value used as an escape character where the field delimiter is part of the
    ///             value.</p>
    public let quoteCharacter: String?
    /// <p>A single character used for escaping the quotation-mark character inside an already
    ///             escaped value.</p>
    public let quoteEscapeCharacter: String?
    /// <p>A value used to separate individual records from each other.</p>
    public let recordDelimiter: String?

    public init (
        comments: String? = nil,
        fieldDelimiter: String? = nil,
        fileHeaderInfo: FileHeaderInfo? = nil,
        quoteCharacter: String? = nil,
        quoteEscapeCharacter: String? = nil,
        recordDelimiter: String? = nil
    )
    {
        self.comments = comments
        self.fieldDelimiter = fieldDelimiter
        self.fileHeaderInfo = fileHeaderInfo
        self.quoteCharacter = quoteCharacter
        self.quoteEscapeCharacter = quoteEscapeCharacter
        self.recordDelimiter = recordDelimiter
    }
}

extension CSVOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldDelimiter = "FieldDelimiter"
        case quoteCharacter = "QuoteCharacter"
        case quoteEscapeCharacter = "QuoteEscapeCharacter"
        case quoteFields = "QuoteFields"
        case recordDelimiter = "RecordDelimiter"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldDelimiter = fieldDelimiter {
            try encodeContainer.encode(fieldDelimiter, forKey: .fieldDelimiter)
        }
        if let quoteCharacter = quoteCharacter {
            try encodeContainer.encode(quoteCharacter, forKey: .quoteCharacter)
        }
        if let quoteEscapeCharacter = quoteEscapeCharacter {
            try encodeContainer.encode(quoteEscapeCharacter, forKey: .quoteEscapeCharacter)
        }
        if let quoteFields = quoteFields {
            try encodeContainer.encode(quoteFields.rawValue, forKey: .quoteFields)
        }
        if let recordDelimiter = recordDelimiter {
            try encodeContainer.encode(recordDelimiter, forKey: .recordDelimiter)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quoteFieldsDecoded = try containerValues.decodeIfPresent(QuoteFields.self, forKey: .quoteFields)
        quoteFields = quoteFieldsDecoded
        let quoteEscapeCharacterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quoteEscapeCharacter)
        quoteEscapeCharacter = quoteEscapeCharacterDecoded
        let recordDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordDelimiter)
        recordDelimiter = recordDelimiterDecoded
        let fieldDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fieldDelimiter)
        fieldDelimiter = fieldDelimiterDecoded
        let quoteCharacterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quoteCharacter)
        quoteCharacter = quoteCharacterDecoded
    }
}

extension CSVOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CSVOutput(fieldDelimiter: \(String(describing: fieldDelimiter)), quoteCharacter: \(String(describing: quoteCharacter)), quoteEscapeCharacter: \(String(describing: quoteEscapeCharacter)), quoteFields: \(String(describing: quoteFields)), recordDelimiter: \(String(describing: recordDelimiter)))"}
}

/// <p>Contains information about the comma-separated value (CSV) file that the job results
///             are stored in.</p>
public struct CSVOutput: Equatable {
    /// <p>A value used to separate individual fields from each other within a record.</p>
    public let fieldDelimiter: String?
    /// <p>A value used as an escape character where the field delimiter is part of the
    ///             value.</p>
    public let quoteCharacter: String?
    /// <p>A single character used for escaping the quotation-mark character inside an already
    ///             escaped value.</p>
    public let quoteEscapeCharacter: String?
    /// <p>A value that indicates whether all output fields should be contained within quotation
    ///             marks.</p>
    public let quoteFields: QuoteFields?
    /// <p>A value used to separate individual records from each other.</p>
    public let recordDelimiter: String?

    public init (
        fieldDelimiter: String? = nil,
        quoteCharacter: String? = nil,
        quoteEscapeCharacter: String? = nil,
        quoteFields: QuoteFields? = nil,
        recordDelimiter: String? = nil
    )
    {
        self.fieldDelimiter = fieldDelimiter
        self.quoteCharacter = quoteCharacter
        self.quoteEscapeCharacter = quoteEscapeCharacter
        self.quoteFields = quoteFields
        self.recordDelimiter = recordDelimiter
    }
}

public enum CannedACL {
    case authenticatedread
    case awsexecread
    case bucketownerfullcontrol
    case bucketownerread
    case `private`
    case publicread
    case publicreadwrite
    case sdkUnknown(String)
}

extension CannedACL : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CannedACL] {
        return [
            .authenticatedread,
            .awsexecread,
            .bucketownerfullcontrol,
            .bucketownerread,
            .private,
            .publicread,
            .publicreadwrite,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .authenticatedread: return "authenticated-read"
        case .awsexecread: return "aws-exec-read"
        case .bucketownerfullcontrol: return "bucket-owner-full-control"
        case .bucketownerread: return "bucket-owner-read"
        case .private: return "private"
        case .publicread: return "public-read"
        case .publicreadwrite: return "public-read-write"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CannedACL(rawValue: rawValue) ?? CannedACL.sdkUnknown(rawValue)
    }
}

extension CompleteMultipartUploadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompleteMultipartUploadInput(accountId: \(String(describing: accountId)), archiveSize: \(String(describing: archiveSize)), checksum: \(String(describing: checksum)), uploadId: \(String(describing: uploadId)), vaultName: \(String(describing: vaultName)))"}
}

extension CompleteMultipartUploadInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CompleteMultipartUploadInputHeadersMiddleware: Middleware {
    public let id: String = "CompleteMultipartUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CompleteMultipartUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CompleteMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let archiveSize = input.operationInput.archiveSize {
            input.builder.withHeader(name: "x-amz-archive-size", value: String(archiveSize))
        }
        if let checksum = input.operationInput.checksum {
            input.builder.withHeader(name: "x-amz-sha256-tree-hash", value: String(checksum))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CompleteMultipartUploadInput>
    public typealias MOutput = OperationOutput<CompleteMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CompleteMultipartUploadOutputError>
}

public struct CompleteMultipartUploadInputQueryItemMiddleware: Middleware {
    public let id: String = "CompleteMultipartUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CompleteMultipartUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CompleteMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CompleteMultipartUploadInput>
    public typealias MOutput = OperationOutput<CompleteMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CompleteMultipartUploadOutputError>
}

/// <p>Provides options to complete a multipart upload operation. This informs Amazon
///          Glacier that all the archive parts have been uploaded and Amazon S3 Glacier (Glacier) can now assemble
///          the archive from the uploaded parts. After assembling and saving the archive to the vault,
///          Glacier returns the URI path of the newly created archive resource.</p>
public struct CompleteMultipartUploadInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: String?
    /// <p>The total size, in bytes, of the entire archive. This value should be the sum of all
    ///          the sizes of the individual parts that you uploaded.</p>
    public let archiveSize: String?
    /// <p>The SHA256 tree hash of the entire archive. It is the tree hash of SHA256 tree hash
    ///          of the individual parts. If the value you specify in the request does not match the SHA256
    ///          tree hash of the final assembled archive as computed by Amazon S3 Glacier (Glacier),
    ///          Glacier returns an error and the request fails.</p>
    public let checksum: String?
    /// <p>The upload ID of the multipart upload.</p>
    public let uploadId: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        archiveSize: String? = nil,
        checksum: String? = nil,
        uploadId: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.archiveSize = archiveSize
        self.checksum = checksum
        self.uploadId = uploadId
        self.vaultName = vaultName
    }
}

struct CompleteMultipartUploadInputBody: Equatable {
}

extension CompleteMultipartUploadInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CompleteMultipartUploadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CompleteMultipartUploadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CompleteMultipartUploadOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CompleteMultipartUploadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompleteMultipartUploadOutputResponse(archiveId: \(String(describing: archiveId)), checksum: \(String(describing: checksum)), location: \(String(describing: location)))"}
}

extension CompleteMultipartUploadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let archiveIdHeaderValue = httpResponse.headers.value(for: "x-amz-archive-id") {
            self.archiveId = archiveIdHeaderValue
        } else {
            self.archiveId = nil
        }
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-sha256-tree-hash") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
///          <p>For information about the underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-post.html">Upload Archive</a>. For
///          conceptual information, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html">Working with Archives in
///             Amazon S3 Glacier</a>.</p>
public struct CompleteMultipartUploadOutputResponse: Equatable {
    /// <p>The ID of the archive. This value is also included as part of the location.</p>
    public let archiveId: String?
    /// <p>The checksum of the archive computed by Amazon S3 Glacier.</p>
    public let checksum: String?
    /// <p>The relative URI path of the newly added archive resource.</p>
    public let location: String?

    public init (
        archiveId: String? = nil,
        checksum: String? = nil,
        location: String? = nil
    )
    {
        self.archiveId = archiveId
        self.checksum = checksum
        self.location = location
    }
}

struct CompleteMultipartUploadOutputResponseBody: Equatable {
}

extension CompleteMultipartUploadOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CompleteVaultLockInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompleteVaultLockInput(accountId: \(String(describing: accountId)), lockId: \(String(describing: lockId)), vaultName: \(String(describing: vaultName)))"}
}

extension CompleteVaultLockInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CompleteVaultLockInputHeadersMiddleware: Middleware {
    public let id: String = "CompleteVaultLockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CompleteVaultLockInput>,
                  next: H) -> Swift.Result<OperationOutput<CompleteVaultLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CompleteVaultLockInput>
    public typealias MOutput = OperationOutput<CompleteVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CompleteVaultLockOutputError>
}

public struct CompleteVaultLockInputQueryItemMiddleware: Middleware {
    public let id: String = "CompleteVaultLockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CompleteVaultLockInput>,
                  next: H) -> Swift.Result<OperationOutput<CompleteVaultLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CompleteVaultLockInput>
    public typealias MOutput = OperationOutput<CompleteVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CompleteVaultLockOutputError>
}

/// <p>The input values for <code>CompleteVaultLock</code>.</p>
public struct CompleteVaultLockInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID. This value must match the AWS
    ///          account ID associated with the credentials used to sign the request. You can either specify
    ///          an AWS account ID or optionally a single '<code>-</code>' (hyphen), in which case Amazon
    ///          Glacier uses the AWS account ID associated with the credentials used to sign the request.
    ///          If you specify your account ID, do not include any hyphens ('-') in the ID.</p>
    public let accountId: String?
    /// <p>The <code>lockId</code> value is the lock ID obtained from a <a>InitiateVaultLock</a> request.</p>
    public let lockId: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        lockId: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.lockId = lockId
        self.vaultName = vaultName
    }
}

struct CompleteVaultLockInputBody: Equatable {
}

extension CompleteVaultLockInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CompleteVaultLockOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CompleteVaultLockOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CompleteVaultLockOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CompleteVaultLockOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompleteVaultLockOutputResponse()"}
}

extension CompleteVaultLockOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CompleteVaultLockOutputResponse: Equatable {

    public init() {}
}

struct CompleteVaultLockOutputResponseBody: Equatable {
}

extension CompleteVaultLockOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreateVaultInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVaultInput(accountId: \(String(describing: accountId)), vaultName: \(String(describing: vaultName)))"}
}

extension CreateVaultInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CreateVaultInputHeadersMiddleware: Middleware {
    public let id: String = "CreateVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVaultInput>
    public typealias MOutput = OperationOutput<CreateVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVaultOutputError>
}

public struct CreateVaultInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVaultInput>
    public typealias MOutput = OperationOutput<CreateVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVaultOutputError>
}

/// <p>Provides options to create a vault.</p>
public struct CreateVaultInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID. This value must match the AWS
    ///          account ID associated with the credentials used to sign the request. You can either specify
    ///          an AWS account ID or optionally a single '<code>-</code>' (hyphen), in which case Amazon S3
    ///          Glacier uses the AWS account ID associated with the credentials used to sign the request.
    ///          If you specify your account ID, do not include any hyphens ('-') in the ID.</p>
    public let accountId: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct CreateVaultInputBody: Equatable {
}

extension CreateVaultInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreateVaultOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVaultOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVaultOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVaultOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVaultOutputResponse(location: \(String(describing: location)))"}
}

extension CreateVaultOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct CreateVaultOutputResponse: Equatable {
    /// <p>The URI of the vault that was created.</p>
    public let location: String?

    public init (
        location: String? = nil
    )
    {
        self.location = location
    }
}

struct CreateVaultOutputResponseBody: Equatable {
}

extension CreateVaultOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DataRetrievalPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rules = "Rules"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for dataretrievalruleslist0 in rules {
                try rulesContainer.encode(dataretrievalruleslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([DataRetrievalRule?].self, forKey: .rules)
        var rulesDecoded0:[DataRetrievalRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [DataRetrievalRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension DataRetrievalPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataRetrievalPolicy(rules: \(String(describing: rules)))"}
}

/// <p>Data retrieval policy.</p>
public struct DataRetrievalPolicy: Equatable {
    /// <p>The policy rule. Although this is a list type, currently there must be only one rule,
    ///          which contains a Strategy field and optionally a BytesPerHour field.</p>
    public let rules: [DataRetrievalRule]?

    public init (
        rules: [DataRetrievalRule]? = nil
    )
    {
        self.rules = rules
    }
}

extension DataRetrievalRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bytesPerHour = "BytesPerHour"
        case strategy = "Strategy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bytesPerHour = bytesPerHour {
            try encodeContainer.encode(bytesPerHour, forKey: .bytesPerHour)
        }
        if let strategy = strategy {
            try encodeContainer.encode(strategy, forKey: .strategy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let strategyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .strategy)
        strategy = strategyDecoded
        let bytesPerHourDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .bytesPerHour)
        bytesPerHour = bytesPerHourDecoded
    }
}

extension DataRetrievalRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataRetrievalRule(bytesPerHour: \(String(describing: bytesPerHour)), strategy: \(String(describing: strategy)))"}
}

/// <p>Data retrieval policy rule.</p>
public struct DataRetrievalRule: Equatable {
    /// <p>The maximum number of bytes that can be retrieved in an hour.</p>
    ///          <p>This field is required only if the value of the Strategy field is
    ///             <code>BytesPerHour</code>. Your PUT operation will be rejected if the Strategy field is
    ///          not set to <code>BytesPerHour</code> and you set this field.</p>
    public let bytesPerHour: Int?
    /// <p>The type of data retrieval policy to set.</p>
    ///          <p>Valid values: BytesPerHour|FreeTier|None</p>
    public let strategy: String?

    public init (
        bytesPerHour: Int? = nil,
        strategy: String? = nil
    )
    {
        self.bytesPerHour = bytesPerHour
        self.strategy = strategy
    }
}

extension DeleteArchiveInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteArchiveInput(accountId: \(String(describing: accountId)), archiveId: \(String(describing: archiveId)), vaultName: \(String(describing: vaultName)))"}
}

extension DeleteArchiveInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteArchiveInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteArchiveInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteArchiveInput>
    public typealias MOutput = OperationOutput<DeleteArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteArchiveOutputError>
}

public struct DeleteArchiveInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteArchiveInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteArchiveInput>
    public typealias MOutput = OperationOutput<DeleteArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteArchiveOutputError>
}

/// <p>Provides options for deleting an archive from an Amazon S3 Glacier vault.</p>
public struct DeleteArchiveInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: String?
    /// <p>The ID of the archive to delete.</p>
    public let archiveId: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        archiveId: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.archiveId = archiveId
        self.vaultName = vaultName
    }
}

struct DeleteArchiveInputBody: Equatable {
}

extension DeleteArchiveInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteArchiveOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteArchiveOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteArchiveOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteArchiveOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteArchiveOutputResponse()"}
}

extension DeleteArchiveOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteArchiveOutputResponse: Equatable {

    public init() {}
}

struct DeleteArchiveOutputResponseBody: Equatable {
}

extension DeleteArchiveOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVaultAccessPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVaultAccessPolicyInput(accountId: \(String(describing: accountId)), vaultName: \(String(describing: vaultName)))"}
}

extension DeleteVaultAccessPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteVaultAccessPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVaultAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVaultAccessPolicyInput>
    public typealias MOutput = OperationOutput<DeleteVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVaultAccessPolicyOutputError>
}

public struct DeleteVaultAccessPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVaultAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVaultAccessPolicyInput>
    public typealias MOutput = OperationOutput<DeleteVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVaultAccessPolicyOutputError>
}

/// <p>DeleteVaultAccessPolicy input.</p>
public struct DeleteVaultAccessPolicyInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct DeleteVaultAccessPolicyInputBody: Equatable {
}

extension DeleteVaultAccessPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVaultAccessPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVaultAccessPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVaultAccessPolicyOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVaultAccessPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVaultAccessPolicyOutputResponse()"}
}

extension DeleteVaultAccessPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVaultAccessPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteVaultAccessPolicyOutputResponseBody: Equatable {
}

extension DeleteVaultAccessPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVaultInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVaultInput(accountId: \(String(describing: accountId)), vaultName: \(String(describing: vaultName)))"}
}

extension DeleteVaultInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteVaultInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVaultInput>
    public typealias MOutput = OperationOutput<DeleteVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVaultOutputError>
}

public struct DeleteVaultInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVaultInput>
    public typealias MOutput = OperationOutput<DeleteVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVaultOutputError>
}

/// <p>Provides options for deleting a vault from Amazon S3 Glacier.</p>
public struct DeleteVaultInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct DeleteVaultInputBody: Equatable {
}

extension DeleteVaultInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVaultNotificationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVaultNotificationsInput(accountId: \(String(describing: accountId)), vaultName: \(String(describing: vaultName)))"}
}

extension DeleteVaultNotificationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteVaultNotificationsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVaultNotificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVaultNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVaultNotificationsInput>
    public typealias MOutput = OperationOutput<DeleteVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVaultNotificationsOutputError>
}

public struct DeleteVaultNotificationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVaultNotificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVaultNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVaultNotificationsInput>
    public typealias MOutput = OperationOutput<DeleteVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVaultNotificationsOutputError>
}

/// <p>Provides options for deleting a vault notification configuration from an Amazon
///          Glacier vault.</p>
public struct DeleteVaultNotificationsInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct DeleteVaultNotificationsInputBody: Equatable {
}

extension DeleteVaultNotificationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVaultNotificationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVaultNotificationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVaultNotificationsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVaultNotificationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVaultNotificationsOutputResponse()"}
}

extension DeleteVaultNotificationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVaultNotificationsOutputResponse: Equatable {

    public init() {}
}

struct DeleteVaultNotificationsOutputResponseBody: Equatable {
}

extension DeleteVaultNotificationsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVaultOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVaultOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVaultOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVaultOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVaultOutputResponse()"}
}

extension DeleteVaultOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVaultOutputResponse: Equatable {

    public init() {}
}

struct DeleteVaultOutputResponseBody: Equatable {
}

extension DeleteVaultOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobInput(accountId: \(String(describing: accountId)), jobId: \(String(describing: jobId)), vaultName: \(String(describing: vaultName)))"}
}

extension DescribeJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobInput>
    public typealias MOutput = OperationOutput<DescribeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobOutputError>
}

public struct DescribeJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobInput>
    public typealias MOutput = OperationOutput<DescribeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobOutputError>
}

/// <p>Provides options for retrieving a job description.</p>
public struct DescribeJobInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: String?
    /// <p>The ID of the job to describe.</p>
    public let jobId: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        jobId: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
        self.vaultName = vaultName
    }
}

struct DescribeJobInputBody: Equatable {
}

extension DescribeJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobOutputResponse(action: \(String(describing: action)), archiveId: \(String(describing: archiveId)), archiveSHA256TreeHash: \(String(describing: archiveSHA256TreeHash)), archiveSizeInBytes: \(String(describing: archiveSizeInBytes)), completed: \(String(describing: completed)), completionDate: \(String(describing: completionDate)), creationDate: \(String(describing: creationDate)), inventoryRetrievalParameters: \(String(describing: inventoryRetrievalParameters)), inventorySizeInBytes: \(String(describing: inventorySizeInBytes)), jobDescription: \(String(describing: jobDescription)), jobId: \(String(describing: jobId)), jobOutputPath: \(String(describing: jobOutputPath)), outputLocation: \(String(describing: outputLocation)), retrievalByteRange: \(String(describing: retrievalByteRange)), sHA256TreeHash: \(String(describing: sHA256TreeHash)), sNSTopic: \(String(describing: sNSTopic)), selectParameters: \(String(describing: selectParameters)), statusCode: \(String(describing: statusCode)), statusMessage: \(String(describing: statusMessage)), tier: \(String(describing: tier)), vaultARN: \(String(describing: vaultARN)))"}
}

extension DescribeJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.action = output.action
            self.archiveId = output.archiveId
            self.archiveSHA256TreeHash = output.archiveSHA256TreeHash
            self.archiveSizeInBytes = output.archiveSizeInBytes
            self.completed = output.completed
            self.completionDate = output.completionDate
            self.creationDate = output.creationDate
            self.inventoryRetrievalParameters = output.inventoryRetrievalParameters
            self.inventorySizeInBytes = output.inventorySizeInBytes
            self.jobDescription = output.jobDescription
            self.jobId = output.jobId
            self.jobOutputPath = output.jobOutputPath
            self.outputLocation = output.outputLocation
            self.retrievalByteRange = output.retrievalByteRange
            self.sHA256TreeHash = output.sHA256TreeHash
            self.sNSTopic = output.sNSTopic
            self.selectParameters = output.selectParameters
            self.statusCode = output.statusCode
            self.statusMessage = output.statusMessage
            self.tier = output.tier
            self.vaultARN = output.vaultARN
        } else {
            self.action = nil
            self.archiveId = nil
            self.archiveSHA256TreeHash = nil
            self.archiveSizeInBytes = nil
            self.completed = false
            self.completionDate = nil
            self.creationDate = nil
            self.inventoryRetrievalParameters = nil
            self.inventorySizeInBytes = nil
            self.jobDescription = nil
            self.jobId = nil
            self.jobOutputPath = nil
            self.outputLocation = nil
            self.retrievalByteRange = nil
            self.sHA256TreeHash = nil
            self.sNSTopic = nil
            self.selectParameters = nil
            self.statusCode = nil
            self.statusMessage = nil
            self.tier = nil
            self.vaultARN = nil
        }
    }
}

/// <p>Contains the description of an Amazon S3 Glacier job.</p>
public struct DescribeJobOutputResponse: Equatable {
    /// <p>The job type. This value is either <code>ArchiveRetrieval</code>,
    ///                 <code>InventoryRetrieval</code>, or
    ///             <code>Select</code>. </p>
    public let action: ActionCode?
    /// <p>The archive ID requested for a select job or archive retrieval. Otherwise, this
    ///             field is null.</p>
    public let archiveId: String?
    /// <p>The SHA256 tree hash of the entire archive for an archive retrieval. For inventory
    ///             retrieval or select jobs, this field is null.</p>
    public let archiveSHA256TreeHash: String?
    /// <p>For an archive retrieval job, this value is the size in bytes of the archive being
    ///             requested for download. For an inventory retrieval or select job, this value is
    ///             null.</p>
    public let archiveSizeInBytes: Int?
    /// <p>The job status. When a job is completed, you get the job's output using Get Job
    ///             Output (GET output).</p>
    public let completed: Bool
    /// <p>The UTC time that the job request completed. While the job is in progress, the
    ///             value is null.</p>
    public let completionDate: String?
    /// <p>The UTC date when the job was created. This value is a string representation of ISO
    ///             8601 date format, for example <code>"2012-03-20T17:03:43.221Z"</code>.</p>
    public let creationDate: String?
    /// <p>Parameters used for range inventory retrieval.</p>
    public let inventoryRetrievalParameters: InventoryRetrievalJobDescription?
    /// <p>For an inventory retrieval job, this value is the size in bytes of the inventory
    ///             requested for download. For an archive retrieval or select job, this value is
    ///             null.</p>
    public let inventorySizeInBytes: Int?
    /// <p>The job description provided when initiating the job.</p>
    public let jobDescription: String?
    /// <p>An opaque string that identifies an Amazon S3 Glacier job.</p>
    public let jobId: String?
    /// <p>Contains the job output location.</p>
    public let jobOutputPath: String?
    /// <p>Contains the location where the data from the select job is stored.</p>
    public let outputLocation: OutputLocation?
    /// <p>The retrieved byte range for archive retrieval jobs in the form
    ///                 <i>StartByteValue</i>-<i>EndByteValue</i>. If no range
    ///             was specified in the archive retrieval, then the whole archive is retrieved. In this
    ///             case, <i>StartByteValue</i> equals 0 and <i>EndByteValue</i>
    ///             equals the size of the archive minus 1. For inventory retrieval or select jobs, this
    ///             field is null. </p>
    public let retrievalByteRange: String?
    /// <p>For an archive retrieval job, this value is the checksum of the archive. Otherwise,
    ///             this value is null.</p>
    ///         <p>The SHA256 tree hash value for the requested range of an archive. If the <b>InitiateJob</b> request for an archive specified a tree-hash
    ///             aligned range, then this field returns a value.</p>
    ///         <p>If the whole archive is retrieved, this value is the same as the
    ///             ArchiveSHA256TreeHash value.</p>
    ///         <p>This field is null for the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Archive retrieval jobs that specify a range that is not tree-hash
    ///                     aligned</p>
    ///             </li>
    ///          </ul>
    ///         <ul>
    ///             <li>
    ///                 <p>Archival jobs that specify a range that is equal to the whole archive, when
    ///                     the job status is <code>InProgress</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///         <ul>
    ///             <li>
    ///                 <p>Inventory jobs</p>
    ///             </li>
    ///             <li>
    ///                 <p>Select jobs</p>
    ///             </li>
    ///          </ul>
    public let sHA256TreeHash: String?
    /// <p>An Amazon SNS topic that receives notification.</p>
    public let sNSTopic: String?
    /// <p>Contains the parameters used for a select.</p>
    public let selectParameters: SelectParameters?
    /// <p>The status code can be <code>InProgress</code>, <code>Succeeded</code>, or
    ///                 <code>Failed</code>, and indicates the status of the job.</p>
    public let statusCode: StatusCode?
    /// <p>A friendly message that describes the job status.</p>
    public let statusMessage: String?
    /// <p>The tier to use for a select or an archive retrieval. Valid values are
    ///                 <code>Expedited</code>, <code>Standard</code>, or <code>Bulk</code>.
    ///                 <code>Standard</code> is the default.</p>
    public let tier: String?
    /// <p>The Amazon Resource Name (ARN) of the vault from which an archive retrieval was
    ///             requested.</p>
    public let vaultARN: String?

    public init (
        action: ActionCode? = nil,
        archiveId: String? = nil,
        archiveSHA256TreeHash: String? = nil,
        archiveSizeInBytes: Int? = nil,
        completed: Bool = false,
        completionDate: String? = nil,
        creationDate: String? = nil,
        inventoryRetrievalParameters: InventoryRetrievalJobDescription? = nil,
        inventorySizeInBytes: Int? = nil,
        jobDescription: String? = nil,
        jobId: String? = nil,
        jobOutputPath: String? = nil,
        outputLocation: OutputLocation? = nil,
        retrievalByteRange: String? = nil,
        sHA256TreeHash: String? = nil,
        sNSTopic: String? = nil,
        selectParameters: SelectParameters? = nil,
        statusCode: StatusCode? = nil,
        statusMessage: String? = nil,
        tier: String? = nil,
        vaultARN: String? = nil
    )
    {
        self.action = action
        self.archiveId = archiveId
        self.archiveSHA256TreeHash = archiveSHA256TreeHash
        self.archiveSizeInBytes = archiveSizeInBytes
        self.completed = completed
        self.completionDate = completionDate
        self.creationDate = creationDate
        self.inventoryRetrievalParameters = inventoryRetrievalParameters
        self.inventorySizeInBytes = inventorySizeInBytes
        self.jobDescription = jobDescription
        self.jobId = jobId
        self.jobOutputPath = jobOutputPath
        self.outputLocation = outputLocation
        self.retrievalByteRange = retrievalByteRange
        self.sHA256TreeHash = sHA256TreeHash
        self.sNSTopic = sNSTopic
        self.selectParameters = selectParameters
        self.statusCode = statusCode
        self.statusMessage = statusMessage
        self.tier = tier
        self.vaultARN = vaultARN
    }
}

struct DescribeJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobDescription: String?
    public let action: ActionCode?
    public let archiveId: String?
    public let vaultARN: String?
    public let creationDate: String?
    public let completed: Bool
    public let statusCode: StatusCode?
    public let statusMessage: String?
    public let archiveSizeInBytes: Int?
    public let inventorySizeInBytes: Int?
    public let sNSTopic: String?
    public let completionDate: String?
    public let sHA256TreeHash: String?
    public let archiveSHA256TreeHash: String?
    public let retrievalByteRange: String?
    public let tier: String?
    public let inventoryRetrievalParameters: InventoryRetrievalJobDescription?
    public let jobOutputPath: String?
    public let selectParameters: SelectParameters?
    public let outputLocation: OutputLocation?
}

extension DescribeJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case archiveId = "ArchiveId"
        case archiveSHA256TreeHash = "ArchiveSHA256TreeHash"
        case archiveSizeInBytes = "ArchiveSizeInBytes"
        case completed = "Completed"
        case completionDate = "CompletionDate"
        case creationDate = "CreationDate"
        case inventoryRetrievalParameters = "InventoryRetrievalParameters"
        case inventorySizeInBytes = "InventorySizeInBytes"
        case jobDescription = "JobDescription"
        case jobId = "JobId"
        case jobOutputPath = "JobOutputPath"
        case outputLocation = "OutputLocation"
        case retrievalByteRange = "RetrievalByteRange"
        case sHA256TreeHash = "SHA256TreeHash"
        case sNSTopic = "SNSTopic"
        case selectParameters = "SelectParameters"
        case statusCode = "StatusCode"
        case statusMessage = "StatusMessage"
        case tier = "Tier"
        case vaultARN = "VaultARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobDescription)
        jobDescription = jobDescriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(ActionCode.self, forKey: .action)
        action = actionDecoded
        let archiveIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .archiveId)
        archiveId = archiveIdDecoded
        let vaultARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vaultARN)
        vaultARN = vaultARNDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completedDecoded = try containerValues.decode(Bool.self, forKey: .completed)
        completed = completedDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(StatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let archiveSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .archiveSizeInBytes)
        archiveSizeInBytes = archiveSizeInBytesDecoded
        let inventorySizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .inventorySizeInBytes)
        inventorySizeInBytes = inventorySizeInBytesDecoded
        let sNSTopicDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sNSTopic)
        sNSTopic = sNSTopicDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let sHA256TreeHashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sHA256TreeHash)
        sHA256TreeHash = sHA256TreeHashDecoded
        let archiveSHA256TreeHashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .archiveSHA256TreeHash)
        archiveSHA256TreeHash = archiveSHA256TreeHashDecoded
        let retrievalByteRangeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .retrievalByteRange)
        retrievalByteRange = retrievalByteRangeDecoded
        let tierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tier)
        tier = tierDecoded
        let inventoryRetrievalParametersDecoded = try containerValues.decodeIfPresent(InventoryRetrievalJobDescription.self, forKey: .inventoryRetrievalParameters)
        inventoryRetrievalParameters = inventoryRetrievalParametersDecoded
        let jobOutputPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobOutputPath)
        jobOutputPath = jobOutputPathDecoded
        let selectParametersDecoded = try containerValues.decodeIfPresent(SelectParameters.self, forKey: .selectParameters)
        selectParameters = selectParametersDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
    }
}

extension DescribeVaultInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVaultInput(accountId: \(String(describing: accountId)), vaultName: \(String(describing: vaultName)))"}
}

extension DescribeVaultInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeVaultInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVaultInput>
    public typealias MOutput = OperationOutput<DescribeVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVaultOutputError>
}

public struct DescribeVaultInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVaultInput>
    public typealias MOutput = OperationOutput<DescribeVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVaultOutputError>
}

/// <p>Provides options for retrieving metadata for a specific vault in Amazon
///          Glacier.</p>
public struct DescribeVaultInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct DescribeVaultInputBody: Equatable {
}

extension DescribeVaultInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeVaultOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case lastInventoryDate = "LastInventoryDate"
        case numberOfArchives = "NumberOfArchives"
        case sizeInBytes = "SizeInBytes"
        case vaultARN = "VaultARN"
        case vaultName = "VaultName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let lastInventoryDate = lastInventoryDate {
            try encodeContainer.encode(lastInventoryDate, forKey: .lastInventoryDate)
        }
        if numberOfArchives != 0 {
            try encodeContainer.encode(numberOfArchives, forKey: .numberOfArchives)
        }
        if sizeInBytes != 0 {
            try encodeContainer.encode(sizeInBytes, forKey: .sizeInBytes)
        }
        if let vaultARN = vaultARN {
            try encodeContainer.encode(vaultARN, forKey: .vaultARN)
        }
        if let vaultName = vaultName {
            try encodeContainer.encode(vaultName, forKey: .vaultName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vaultARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vaultARN)
        vaultARN = vaultARNDecoded
        let vaultNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vaultName)
        vaultName = vaultNameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastInventoryDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastInventoryDate)
        lastInventoryDate = lastInventoryDateDecoded
        let numberOfArchivesDecoded = try containerValues.decode(Int.self, forKey: .numberOfArchives)
        numberOfArchives = numberOfArchivesDecoded
        let sizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
    }
}

extension DescribeVaultOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVaultOutput(creationDate: \(String(describing: creationDate)), lastInventoryDate: \(String(describing: lastInventoryDate)), numberOfArchives: \(String(describing: numberOfArchives)), sizeInBytes: \(String(describing: sizeInBytes)), vaultARN: \(String(describing: vaultARN)), vaultName: \(String(describing: vaultName)))"}
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct DescribeVaultOutput: Equatable {
    /// <p>The Universal Coordinated Time (UTC) date when the vault was created. This value
    ///          should be a string in the ISO 8601 date format, for example
    ///             <code>2012-03-20T17:03:43.221Z</code>.</p>
    public let creationDate: String?
    /// <p>The Universal Coordinated Time (UTC) date when Amazon S3 Glacier completed the last
    ///          vault inventory.  This value should be a string in the ISO 8601 date format, for example
    ///             <code>2012-03-20T17:03:43.221Z</code>.</p>
    public let lastInventoryDate: String?
    /// <p>The number of archives in the vault as of the last inventory date. This field will
    ///          return <code>null</code> if an inventory has not yet run on the vault, for example if you
    ///          just created the vault.</p>
    public let numberOfArchives: Int
    /// <p>Total size, in bytes, of the archives in the vault as of the last inventory date.
    ///          This field will return null if an inventory has not yet run on the vault, for example if
    ///          you just created the vault.</p>
    public let sizeInBytes: Int
    /// <p>The Amazon Resource Name (ARN) of the vault.</p>
    public let vaultARN: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        creationDate: String? = nil,
        lastInventoryDate: String? = nil,
        numberOfArchives: Int = 0,
        sizeInBytes: Int = 0,
        vaultARN: String? = nil,
        vaultName: String? = nil
    )
    {
        self.creationDate = creationDate
        self.lastInventoryDate = lastInventoryDate
        self.numberOfArchives = numberOfArchives
        self.sizeInBytes = sizeInBytes
        self.vaultARN = vaultARN
        self.vaultName = vaultName
    }
}

extension DescribeVaultOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVaultOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVaultOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVaultOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVaultOutputResponse(creationDate: \(String(describing: creationDate)), lastInventoryDate: \(String(describing: lastInventoryDate)), numberOfArchives: \(String(describing: numberOfArchives)), sizeInBytes: \(String(describing: sizeInBytes)), vaultARN: \(String(describing: vaultARN)), vaultName: \(String(describing: vaultName)))"}
}

extension DescribeVaultOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeVaultOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDate = output.creationDate
            self.lastInventoryDate = output.lastInventoryDate
            self.numberOfArchives = output.numberOfArchives
            self.sizeInBytes = output.sizeInBytes
            self.vaultARN = output.vaultARN
            self.vaultName = output.vaultName
        } else {
            self.creationDate = nil
            self.lastInventoryDate = nil
            self.numberOfArchives = 0
            self.sizeInBytes = 0
            self.vaultARN = nil
            self.vaultName = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct DescribeVaultOutputResponse: Equatable {
    /// <p>The Universal Coordinated Time (UTC) date when the vault was created. This value
    ///          should be a string in the ISO 8601 date format, for example
    ///             <code>2012-03-20T17:03:43.221Z</code>.</p>
    public let creationDate: String?
    /// <p>The Universal Coordinated Time (UTC) date when Amazon S3 Glacier completed the last
    ///          vault inventory.  This value should be a string in the ISO 8601 date format, for example
    ///             <code>2012-03-20T17:03:43.221Z</code>.</p>
    public let lastInventoryDate: String?
    /// <p>The number of archives in the vault as of the last inventory date. This field will
    ///          return <code>null</code> if an inventory has not yet run on the vault, for example if you
    ///          just created the vault.</p>
    public let numberOfArchives: Int
    /// <p>Total size, in bytes, of the archives in the vault as of the last inventory date.
    ///          This field will return null if an inventory has not yet run on the vault, for example if
    ///          you just created the vault.</p>
    public let sizeInBytes: Int
    /// <p>The Amazon Resource Name (ARN) of the vault.</p>
    public let vaultARN: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        creationDate: String? = nil,
        lastInventoryDate: String? = nil,
        numberOfArchives: Int = 0,
        sizeInBytes: Int = 0,
        vaultARN: String? = nil,
        vaultName: String? = nil
    )
    {
        self.creationDate = creationDate
        self.lastInventoryDate = lastInventoryDate
        self.numberOfArchives = numberOfArchives
        self.sizeInBytes = sizeInBytes
        self.vaultARN = vaultARN
        self.vaultName = vaultName
    }
}

struct DescribeVaultOutputResponseBody: Equatable {
    public let vaultARN: String?
    public let vaultName: String?
    public let creationDate: String?
    public let lastInventoryDate: String?
    public let numberOfArchives: Int
    public let sizeInBytes: Int
}

extension DescribeVaultOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case lastInventoryDate = "LastInventoryDate"
        case numberOfArchives = "NumberOfArchives"
        case sizeInBytes = "SizeInBytes"
        case vaultARN = "VaultARN"
        case vaultName = "VaultName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vaultARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vaultARN)
        vaultARN = vaultARNDecoded
        let vaultNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vaultName)
        vaultName = vaultNameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastInventoryDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastInventoryDate)
        lastInventoryDate = lastInventoryDateDecoded
        let numberOfArchivesDecoded = try containerValues.decode(Int.self, forKey: .numberOfArchives)
        numberOfArchives = numberOfArchivesDecoded
        let sizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
    }
}

extension Encryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionType = "EncryptionType"
        case kMSContext = "KMSContext"
        case kMSKeyId = "KMSKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let kMSContext = kMSContext {
            try encodeContainer.encode(kMSContext, forKey: .kMSContext)
        }
        if let kMSKeyId = kMSKeyId {
            try encodeContainer.encode(kMSKeyId, forKey: .kMSKeyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kMSKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKeyId)
        kMSKeyId = kMSKeyIdDecoded
        let kMSContextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSContext)
        kMSContext = kMSContextDecoded
    }
}

extension Encryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Encryption(encryptionType: \(String(describing: encryptionType)), kMSContext: \(String(describing: kMSContext)), kMSKeyId: \(String(describing: kMSKeyId)))"}
}

/// <p>Contains information about the encryption used to store the job results in Amazon S3. </p>
public struct Encryption: Equatable {
    /// <p>The server-side encryption algorithm used when storing job results in Amazon S3, for
    ///             example <code>AES256</code> or <code>aws:kms</code>.</p>
    public let encryptionType: EncryptionType?
    /// <p>Optional. If the encryption type is <code>aws:kms</code>, you can use this value to
    ///             specify the encryption context for the job results.</p>
    public let kMSContext: String?
    /// <p>The AWS KMS key ID to use for object encryption. All GET and PUT requests for an
    ///             object protected by AWS KMS fail if not made by using Secure Sockets Layer (SSL) or
    ///             Signature Version 4. </p>
    public let kMSKeyId: String?

    public init (
        encryptionType: EncryptionType? = nil,
        kMSContext: String? = nil,
        kMSKeyId: String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.kMSContext = kMSContext
        self.kMSKeyId = kMSKeyId
    }
}

public enum EncryptionType {
    case kms
    case s3
    case sdkUnknown(String)
}

extension EncryptionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncryptionType] {
        return [
            .kms,
            .s3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .kms: return "aws:kms"
        case .s3: return "AES256"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
    }
}

public enum ExpressionType {
    case sql
    case sdkUnknown(String)
}

extension ExpressionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExpressionType] {
        return [
            .sql,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sql: return "SQL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExpressionType(rawValue: rawValue) ?? ExpressionType.sdkUnknown(rawValue)
    }
}

public enum FileHeaderInfo {
    case ignore
    case `none`
    case use
    case sdkUnknown(String)
}

extension FileHeaderInfo : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FileHeaderInfo] {
        return [
            .ignore,
            .none,
            .use,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ignore: return "IGNORE"
        case .none: return "NONE"
        case .use: return "USE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FileHeaderInfo(rawValue: rawValue) ?? FileHeaderInfo.sdkUnknown(rawValue)
    }
}

extension GetDataRetrievalPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDataRetrievalPolicyInput(accountId: \(String(describing: accountId)))"}
}

extension GetDataRetrievalPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDataRetrievalPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetDataRetrievalPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataRetrievalPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataRetrievalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataRetrievalPolicyInput>
    public typealias MOutput = OperationOutput<GetDataRetrievalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataRetrievalPolicyOutputError>
}

public struct GetDataRetrievalPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDataRetrievalPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataRetrievalPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataRetrievalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataRetrievalPolicyInput>
    public typealias MOutput = OperationOutput<GetDataRetrievalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataRetrievalPolicyOutputError>
}

/// <p>Input for GetDataRetrievalPolicy.</p>
public struct GetDataRetrievalPolicyInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID. This value must match the AWS
    ///          account ID associated with the credentials used to sign the request. You can either specify
    ///          an AWS account ID or optionally a single '<code>-</code>' (hyphen), in which case Amazon
    ///          Glacier uses the AWS account ID associated with the credentials used to sign the request.
    ///          If you specify your account ID, do not include any hyphens ('-') in the ID. </p>
    public let accountId: String?

    public init (
        accountId: String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct GetDataRetrievalPolicyInputBody: Equatable {
}

extension GetDataRetrievalPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDataRetrievalPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataRetrievalPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDataRetrievalPolicyOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataRetrievalPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDataRetrievalPolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension GetDataRetrievalPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDataRetrievalPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to the <code>GetDataRetrievalPolicy</code>
///          request.</p>
public struct GetDataRetrievalPolicyOutputResponse: Equatable {
    /// <p>Contains the returned data retrieval policy in JSON format.</p>
    public let policy: DataRetrievalPolicy?

    public init (
        policy: DataRetrievalPolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetDataRetrievalPolicyOutputResponseBody: Equatable {
    public let policy: DataRetrievalPolicy?
}

extension GetDataRetrievalPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(DataRetrievalPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetJobOutputInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobOutputInput(accountId: \(String(describing: accountId)), jobId: \(String(describing: jobId)), range: \(String(describing: range)), vaultName: \(String(describing: vaultName)))"}
}

extension GetJobOutputInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetJobOutputInputHeadersMiddleware: Middleware {
    public let id: String = "GetJobOutputInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let range = input.operationInput.range {
            input.builder.withHeader(name: "Range", value: String(range))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobOutputInput>
    public typealias MOutput = OperationOutput<GetJobOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobOutputOutputError>
}

public struct GetJobOutputInputQueryItemMiddleware: Middleware {
    public let id: String = "GetJobOutputInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobOutputInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobOutputOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobOutputInput>
    public typealias MOutput = OperationOutput<GetJobOutputOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobOutputOutputError>
}

/// <p>Provides options for downloading output of an Amazon S3 Glacier job.</p>
public struct GetJobOutputInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: String?
    /// <p>The job ID whose data is downloaded.</p>
    public let jobId: String?
    /// <p>The range of bytes to retrieve from the output. For example, if you want to download
    ///          the first 1,048,576 bytes, specify the range as <code>bytes=0-1048575</code>. By default, this operation
    ///          downloads the entire output.</p>
    ///
    ///          <p>If the job output is large, then you can use a range to
    ///          retrieve a portion of the output. This allows you to download the entire output in smaller
    ///          chunks of bytes. For example, suppose you have 1 GB of job output you want to download and
    ///          you decide to download 128 MB chunks of data at a time, which is a total of eight Get Job
    ///          Output requests. You use the following process to download the job output:</p>
    ///
    ///          <ol>
    ///             <li>
    ///                <p>Download a 128 MB chunk of output by specifying the appropriate byte range.
    ///                   Verify that all 128 MB of data was received.</p>
    ///             </li>
    ///             <li>
    ///                <p>Along with the data, the response includes a SHA256 tree hash of the payload.
    ///                   You compute the checksum of the payload on the client and compare it with the
    ///                   checksum you received in the response to ensure you received all the expected
    ///                   data.</p>
    ///             </li>
    ///             <li>
    ///                <p>Repeat steps 1 and 2 for all the eight 128 MB chunks of output data, each time
    ///                   specifying the appropriate byte range.</p>
    ///             </li>
    ///             <li>
    ///                <p>After downloading all the parts of the job output, you have a list of eight
    ///                   checksum values. Compute the tree hash of these values to find the checksum of the
    ///                   entire output. Using the <a>DescribeJob</a> API, obtain job information of
    ///                   the job that provided you the output. The response includes the checksum of the
    ///                   entire archive stored in Amazon S3 Glacier. You compare this value with the checksum you
    ///                   computed to ensure you have downloaded the entire archive content with no
    ///                   errors.</p>
    ///                <p></p>
    ///             </li>
    ///          </ol>
    public let range: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        jobId: String? = nil,
        range: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.jobId = jobId
        self.range = range
        self.vaultName = vaultName
    }
}

struct GetJobOutputInputBody: Equatable {
}

extension GetJobOutputInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetJobOutputOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobOutputOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobOutputOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobOutputOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobOutputOutputResponse(acceptRanges: \(String(describing: acceptRanges)), archiveDescription: \(String(describing: archiveDescription)), body: \(String(describing: body)), checksum: \(String(describing: checksum)), contentRange: \(String(describing: contentRange)), contentType: \(String(describing: contentType)), status: \(String(describing: status)))"}
}

extension GetJobOutputOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let acceptRangesHeaderValue = httpResponse.headers.value(for: "Accept-Ranges") {
            self.acceptRanges = acceptRangesHeaderValue
        } else {
            self.acceptRanges = nil
        }
        if let archiveDescriptionHeaderValue = httpResponse.headers.value(for: "x-amz-archive-description") {
            self.archiveDescription = archiveDescriptionHeaderValue
        } else {
            self.archiveDescription = nil
        }
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-sha256-tree-hash") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
        if let contentRangeHeaderValue = httpResponse.headers.value(for: "Content-Range") {
            self.contentRange = contentRangeHeaderValue
        } else {
            self.contentRange = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.body = unwrappedData
        } else {
            self.body = nil
        }
        self.status = httpResponse.statusCode.rawValue
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct GetJobOutputOutputResponse: Equatable {
    /// <p>Indicates the range units accepted. For more information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">RFC2616</a>. </p>
    public let acceptRanges: String?
    /// <p>The description of an archive.</p>
    public let archiveDescription: String?
    /// <p>The job data, either archive data or inventory data.</p>
    public let body: Data?
    /// <p>The checksum of the data in the response. This header is returned only when
    ///          retrieving the output for an archive retrieval job. Furthermore, this header appears only
    ///          under the following conditions:</p>
    ///          <ul>
    ///             <li>
    ///                 <p>You get the entire range of the archive.</p>
    ///             </li>
    ///             <li>
    ///                <p>You request a range to return of the archive that starts and ends on a multiple
    ///                of 1 MB. For example, if you have an 3.1 MB archive and you specify a range to return
    ///                that starts at 1 MB and ends at 2 MB, then the x-amz-sha256-tree-hash is returned as
    ///                a response header.</p>
    ///             </li>
    ///             <li>
    ///                <p>You request a range of the archive to return that starts on a multiple of 1 MB
    ///                and goes to the end of the archive. For example, if you have a 3.1 MB archive and you
    ///                specify a range that starts at 2 MB and ends at 3.1 MB (the end of the archive), then
    ///                the x-amz-sha256-tree-hash is returned as a response header.</p>
    ///             </li>
    ///          </ul>
    public let checksum: String?
    /// <p>The range of bytes returned by Amazon S3 Glacier. If only partial output is downloaded,
    ///          the response provides the range of bytes Amazon S3 Glacier returned. For example, bytes
    ///          0-1048575/8388608 returns the first 1 MB from 8 MB.</p>
    public let contentRange: String?
    /// <p>The Content-Type depends on whether the job output is an archive or a vault
    ///          inventory. For archive data, the Content-Type is application/octet-stream. For vault
    ///          inventory, if you requested CSV format when you initiated the job, the Content-Type is
    ///          text/csv. Otherwise, by default, vault inventory is returned as JSON, and the Content-Type
    ///          is application/json.</p>
    public let contentType: String?
    /// <p>The HTTP response code for a job output request. The value depends on whether a range
    ///          was specified in the request.</p>
    public let status: Int

    public init (
        acceptRanges: String? = nil,
        archiveDescription: String? = nil,
        body: Data? = nil,
        checksum: String? = nil,
        contentRange: String? = nil,
        contentType: String? = nil,
        status: Int = 0
    )
    {
        self.acceptRanges = acceptRanges
        self.archiveDescription = archiveDescription
        self.body = body
        self.checksum = checksum
        self.contentRange = contentRange
        self.contentType = contentType
        self.status = status
    }
}

struct GetJobOutputOutputResponseBody: Equatable {
    public let body: Data?
    public let status: Int
}

extension GetJobOutputOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
        body = bodyDecoded
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetVaultAccessPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVaultAccessPolicyInput(accountId: \(String(describing: accountId)), vaultName: \(String(describing: vaultName)))"}
}

extension GetVaultAccessPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetVaultAccessPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetVaultAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVaultAccessPolicyInput>
    public typealias MOutput = OperationOutput<GetVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVaultAccessPolicyOutputError>
}

public struct GetVaultAccessPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetVaultAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVaultAccessPolicyInput>
    public typealias MOutput = OperationOutput<GetVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVaultAccessPolicyOutputError>
}

/// <p>Input for GetVaultAccessPolicy.</p>
public struct GetVaultAccessPolicyInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct GetVaultAccessPolicyInputBody: Equatable {
}

extension GetVaultAccessPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetVaultAccessPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVaultAccessPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVaultAccessPolicyOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVaultAccessPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVaultAccessPolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension GetVaultAccessPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VaultAccessPolicy = try responseDecoder.decode(responseBody: unwrappedData)
                self.policy = output
            } else {
                self.policy = nil
            }
        } else {
            self.policy = nil
        }
    }
}

/// <p>Output for GetVaultAccessPolicy.</p>
public struct GetVaultAccessPolicyOutputResponse: Equatable {
    /// <p>Contains the returned vault access policy as a JSON string.</p>
    public let policy: VaultAccessPolicy?

    public init (
        policy: VaultAccessPolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetVaultAccessPolicyOutputResponseBody: Equatable {
    public let policy: VaultAccessPolicy?
}

extension GetVaultAccessPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(VaultAccessPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetVaultLockInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVaultLockInput(accountId: \(String(describing: accountId)), vaultName: \(String(describing: vaultName)))"}
}

extension GetVaultLockInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetVaultLockInputHeadersMiddleware: Middleware {
    public let id: String = "GetVaultLockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVaultLockInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVaultLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVaultLockInput>
    public typealias MOutput = OperationOutput<GetVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVaultLockOutputError>
}

public struct GetVaultLockInputQueryItemMiddleware: Middleware {
    public let id: String = "GetVaultLockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVaultLockInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVaultLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVaultLockInput>
    public typealias MOutput = OperationOutput<GetVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVaultLockOutputError>
}

/// <p>The input values for <code>GetVaultLock</code>.</p>
public struct GetVaultLockInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct GetVaultLockInputBody: Equatable {
}

extension GetVaultLockInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetVaultLockOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVaultLockOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVaultLockOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVaultLockOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVaultLockOutputResponse(creationDate: \(String(describing: creationDate)), expirationDate: \(String(describing: expirationDate)), policy: \(String(describing: policy)), state: \(String(describing: state)))"}
}

extension GetVaultLockOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetVaultLockOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDate = output.creationDate
            self.expirationDate = output.expirationDate
            self.policy = output.policy
            self.state = output.state
        } else {
            self.creationDate = nil
            self.expirationDate = nil
            self.policy = nil
            self.state = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct GetVaultLockOutputResponse: Equatable {
    /// <p>The UTC date and time at which the vault lock was put into the
    ///             <code>InProgress</code> state.</p>
    public let creationDate: String?
    /// <p>The UTC date and time at which the lock ID expires. This value can be
    ///             <code>null</code> if the vault lock is in a <code>Locked</code> state.</p>
    public let expirationDate: String?
    /// <p>The vault lock policy as a JSON string, which uses "\" as an escape
    ///          character.</p>
    public let policy: String?
    /// <p>The state of the vault lock. <code>InProgress</code> or
    ///          <code>Locked</code>.</p>
    public let state: String?

    public init (
        creationDate: String? = nil,
        expirationDate: String? = nil,
        policy: String? = nil,
        state: String? = nil
    )
    {
        self.creationDate = creationDate
        self.expirationDate = expirationDate
        self.policy = policy
        self.state = state
    }
}

struct GetVaultLockOutputResponseBody: Equatable {
    public let policy: String?
    public let state: String?
    public let expirationDate: String?
    public let creationDate: String?
}

extension GetVaultLockOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case expirationDate = "ExpirationDate"
        case policy = "Policy"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension GetVaultNotificationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVaultNotificationsInput(accountId: \(String(describing: accountId)), vaultName: \(String(describing: vaultName)))"}
}

extension GetVaultNotificationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetVaultNotificationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetVaultNotificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVaultNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVaultNotificationsInput>
    public typealias MOutput = OperationOutput<GetVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVaultNotificationsOutputError>
}

public struct GetVaultNotificationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetVaultNotificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVaultNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVaultNotificationsInput>
    public typealias MOutput = OperationOutput<GetVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVaultNotificationsOutputError>
}

/// <p>Provides options for retrieving the notification configuration set on an Amazon
///          Glacier vault.</p>
public struct GetVaultNotificationsInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct GetVaultNotificationsInputBody: Equatable {
}

extension GetVaultNotificationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetVaultNotificationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVaultNotificationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVaultNotificationsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVaultNotificationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVaultNotificationsOutputResponse(vaultNotificationConfig: \(String(describing: vaultNotificationConfig)))"}
}

extension GetVaultNotificationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VaultNotificationConfig = try responseDecoder.decode(responseBody: unwrappedData)
                self.vaultNotificationConfig = output
            } else {
                self.vaultNotificationConfig = nil
            }
        } else {
            self.vaultNotificationConfig = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct GetVaultNotificationsOutputResponse: Equatable {
    /// <p>Returns the notification configuration set on the vault.</p>
    public let vaultNotificationConfig: VaultNotificationConfig?

    public init (
        vaultNotificationConfig: VaultNotificationConfig? = nil
    )
    {
        self.vaultNotificationConfig = vaultNotificationConfig
    }
}

struct GetVaultNotificationsOutputResponseBody: Equatable {
    public let vaultNotificationConfig: VaultNotificationConfig?
}

extension GetVaultNotificationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case vaultNotificationConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vaultNotificationConfigDecoded = try containerValues.decodeIfPresent(VaultNotificationConfig.self, forKey: .vaultNotificationConfig)
        vaultNotificationConfig = vaultNotificationConfigDecoded
    }
}

extension GlacierJobDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case archiveId = "ArchiveId"
        case archiveSHA256TreeHash = "ArchiveSHA256TreeHash"
        case archiveSizeInBytes = "ArchiveSizeInBytes"
        case completed = "Completed"
        case completionDate = "CompletionDate"
        case creationDate = "CreationDate"
        case inventoryRetrievalParameters = "InventoryRetrievalParameters"
        case inventorySizeInBytes = "InventorySizeInBytes"
        case jobDescription = "JobDescription"
        case jobId = "JobId"
        case jobOutputPath = "JobOutputPath"
        case outputLocation = "OutputLocation"
        case retrievalByteRange = "RetrievalByteRange"
        case sHA256TreeHash = "SHA256TreeHash"
        case sNSTopic = "SNSTopic"
        case selectParameters = "SelectParameters"
        case statusCode = "StatusCode"
        case statusMessage = "StatusMessage"
        case tier = "Tier"
        case vaultARN = "VaultARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let archiveId = archiveId {
            try encodeContainer.encode(archiveId, forKey: .archiveId)
        }
        if let archiveSHA256TreeHash = archiveSHA256TreeHash {
            try encodeContainer.encode(archiveSHA256TreeHash, forKey: .archiveSHA256TreeHash)
        }
        if let archiveSizeInBytes = archiveSizeInBytes {
            try encodeContainer.encode(archiveSizeInBytes, forKey: .archiveSizeInBytes)
        }
        if completed != false {
            try encodeContainer.encode(completed, forKey: .completed)
        }
        if let completionDate = completionDate {
            try encodeContainer.encode(completionDate, forKey: .completionDate)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let inventoryRetrievalParameters = inventoryRetrievalParameters {
            try encodeContainer.encode(inventoryRetrievalParameters, forKey: .inventoryRetrievalParameters)
        }
        if let inventorySizeInBytes = inventorySizeInBytes {
            try encodeContainer.encode(inventorySizeInBytes, forKey: .inventorySizeInBytes)
        }
        if let jobDescription = jobDescription {
            try encodeContainer.encode(jobDescription, forKey: .jobDescription)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobOutputPath = jobOutputPath {
            try encodeContainer.encode(jobOutputPath, forKey: .jobOutputPath)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let retrievalByteRange = retrievalByteRange {
            try encodeContainer.encode(retrievalByteRange, forKey: .retrievalByteRange)
        }
        if let sHA256TreeHash = sHA256TreeHash {
            try encodeContainer.encode(sHA256TreeHash, forKey: .sHA256TreeHash)
        }
        if let sNSTopic = sNSTopic {
            try encodeContainer.encode(sNSTopic, forKey: .sNSTopic)
        }
        if let selectParameters = selectParameters {
            try encodeContainer.encode(selectParameters, forKey: .selectParameters)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tier = tier {
            try encodeContainer.encode(tier, forKey: .tier)
        }
        if let vaultARN = vaultARN {
            try encodeContainer.encode(vaultARN, forKey: .vaultARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobDescription)
        jobDescription = jobDescriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(ActionCode.self, forKey: .action)
        action = actionDecoded
        let archiveIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .archiveId)
        archiveId = archiveIdDecoded
        let vaultARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vaultARN)
        vaultARN = vaultARNDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let completedDecoded = try containerValues.decode(Bool.self, forKey: .completed)
        completed = completedDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(StatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let archiveSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .archiveSizeInBytes)
        archiveSizeInBytes = archiveSizeInBytesDecoded
        let inventorySizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .inventorySizeInBytes)
        inventorySizeInBytes = inventorySizeInBytesDecoded
        let sNSTopicDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sNSTopic)
        sNSTopic = sNSTopicDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let sHA256TreeHashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sHA256TreeHash)
        sHA256TreeHash = sHA256TreeHashDecoded
        let archiveSHA256TreeHashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .archiveSHA256TreeHash)
        archiveSHA256TreeHash = archiveSHA256TreeHashDecoded
        let retrievalByteRangeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .retrievalByteRange)
        retrievalByteRange = retrievalByteRangeDecoded
        let tierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tier)
        tier = tierDecoded
        let inventoryRetrievalParametersDecoded = try containerValues.decodeIfPresent(InventoryRetrievalJobDescription.self, forKey: .inventoryRetrievalParameters)
        inventoryRetrievalParameters = inventoryRetrievalParametersDecoded
        let jobOutputPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobOutputPath)
        jobOutputPath = jobOutputPathDecoded
        let selectParametersDecoded = try containerValues.decodeIfPresent(SelectParameters.self, forKey: .selectParameters)
        selectParameters = selectParametersDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
    }
}

extension GlacierJobDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GlacierJobDescription(action: \(String(describing: action)), archiveId: \(String(describing: archiveId)), archiveSHA256TreeHash: \(String(describing: archiveSHA256TreeHash)), archiveSizeInBytes: \(String(describing: archiveSizeInBytes)), completed: \(String(describing: completed)), completionDate: \(String(describing: completionDate)), creationDate: \(String(describing: creationDate)), inventoryRetrievalParameters: \(String(describing: inventoryRetrievalParameters)), inventorySizeInBytes: \(String(describing: inventorySizeInBytes)), jobDescription: \(String(describing: jobDescription)), jobId: \(String(describing: jobId)), jobOutputPath: \(String(describing: jobOutputPath)), outputLocation: \(String(describing: outputLocation)), retrievalByteRange: \(String(describing: retrievalByteRange)), sHA256TreeHash: \(String(describing: sHA256TreeHash)), sNSTopic: \(String(describing: sNSTopic)), selectParameters: \(String(describing: selectParameters)), statusCode: \(String(describing: statusCode)), statusMessage: \(String(describing: statusMessage)), tier: \(String(describing: tier)), vaultARN: \(String(describing: vaultARN)))"}
}

/// <p>Contains the description of an Amazon S3 Glacier job.</p>
public struct GlacierJobDescription: Equatable {
    /// <p>The job type. This value is either <code>ArchiveRetrieval</code>,
    ///                 <code>InventoryRetrieval</code>, or
    ///             <code>Select</code>. </p>
    public let action: ActionCode?
    /// <p>The archive ID requested for a select job or archive retrieval. Otherwise, this
    ///             field is null.</p>
    public let archiveId: String?
    /// <p>The SHA256 tree hash of the entire archive for an archive retrieval. For inventory
    ///             retrieval or select jobs, this field is null.</p>
    public let archiveSHA256TreeHash: String?
    /// <p>For an archive retrieval job, this value is the size in bytes of the archive being
    ///             requested for download. For an inventory retrieval or select job, this value is
    ///             null.</p>
    public let archiveSizeInBytes: Int?
    /// <p>The job status. When a job is completed, you get the job's output using Get Job
    ///             Output (GET output).</p>
    public let completed: Bool
    /// <p>The UTC time that the job request completed. While the job is in progress, the
    ///             value is null.</p>
    public let completionDate: String?
    /// <p>The UTC date when the job was created. This value is a string representation of ISO
    ///             8601 date format, for example <code>"2012-03-20T17:03:43.221Z"</code>.</p>
    public let creationDate: String?
    /// <p>Parameters used for range inventory retrieval.</p>
    public let inventoryRetrievalParameters: InventoryRetrievalJobDescription?
    /// <p>For an inventory retrieval job, this value is the size in bytes of the inventory
    ///             requested for download. For an archive retrieval or select job, this value is
    ///             null.</p>
    public let inventorySizeInBytes: Int?
    /// <p>The job description provided when initiating the job.</p>
    public let jobDescription: String?
    /// <p>An opaque string that identifies an Amazon S3 Glacier job.</p>
    public let jobId: String?
    /// <p>Contains the job output location.</p>
    public let jobOutputPath: String?
    /// <p>Contains the location where the data from the select job is stored.</p>
    public let outputLocation: OutputLocation?
    /// <p>The retrieved byte range for archive retrieval jobs in the form
    ///                 <i>StartByteValue</i>-<i>EndByteValue</i>. If no range
    ///             was specified in the archive retrieval, then the whole archive is retrieved. In this
    ///             case, <i>StartByteValue</i> equals 0 and <i>EndByteValue</i>
    ///             equals the size of the archive minus 1. For inventory retrieval or select jobs, this
    ///             field is null. </p>
    public let retrievalByteRange: String?
    /// <p>For an archive retrieval job, this value is the checksum of the archive. Otherwise,
    ///             this value is null.</p>
    ///         <p>The SHA256 tree hash value for the requested range of an archive. If the <b>InitiateJob</b> request for an archive specified a tree-hash
    ///             aligned range, then this field returns a value.</p>
    ///         <p>If the whole archive is retrieved, this value is the same as the
    ///             ArchiveSHA256TreeHash value.</p>
    ///         <p>This field is null for the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Archive retrieval jobs that specify a range that is not tree-hash
    ///                     aligned</p>
    ///             </li>
    ///          </ul>
    ///         <ul>
    ///             <li>
    ///                 <p>Archival jobs that specify a range that is equal to the whole archive, when
    ///                     the job status is <code>InProgress</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///         <ul>
    ///             <li>
    ///                 <p>Inventory jobs</p>
    ///             </li>
    ///             <li>
    ///                 <p>Select jobs</p>
    ///             </li>
    ///          </ul>
    public let sHA256TreeHash: String?
    /// <p>An Amazon SNS topic that receives notification.</p>
    public let sNSTopic: String?
    /// <p>Contains the parameters used for a select.</p>
    public let selectParameters: SelectParameters?
    /// <p>The status code can be <code>InProgress</code>, <code>Succeeded</code>, or
    ///                 <code>Failed</code>, and indicates the status of the job.</p>
    public let statusCode: StatusCode?
    /// <p>A friendly message that describes the job status.</p>
    public let statusMessage: String?
    /// <p>The tier to use for a select or an archive retrieval. Valid values are
    ///                 <code>Expedited</code>, <code>Standard</code>, or <code>Bulk</code>.
    ///                 <code>Standard</code> is the default.</p>
    public let tier: String?
    /// <p>The Amazon Resource Name (ARN) of the vault from which an archive retrieval was
    ///             requested.</p>
    public let vaultARN: String?

    public init (
        action: ActionCode? = nil,
        archiveId: String? = nil,
        archiveSHA256TreeHash: String? = nil,
        archiveSizeInBytes: Int? = nil,
        completed: Bool = false,
        completionDate: String? = nil,
        creationDate: String? = nil,
        inventoryRetrievalParameters: InventoryRetrievalJobDescription? = nil,
        inventorySizeInBytes: Int? = nil,
        jobDescription: String? = nil,
        jobId: String? = nil,
        jobOutputPath: String? = nil,
        outputLocation: OutputLocation? = nil,
        retrievalByteRange: String? = nil,
        sHA256TreeHash: String? = nil,
        sNSTopic: String? = nil,
        selectParameters: SelectParameters? = nil,
        statusCode: StatusCode? = nil,
        statusMessage: String? = nil,
        tier: String? = nil,
        vaultARN: String? = nil
    )
    {
        self.action = action
        self.archiveId = archiveId
        self.archiveSHA256TreeHash = archiveSHA256TreeHash
        self.archiveSizeInBytes = archiveSizeInBytes
        self.completed = completed
        self.completionDate = completionDate
        self.creationDate = creationDate
        self.inventoryRetrievalParameters = inventoryRetrievalParameters
        self.inventorySizeInBytes = inventorySizeInBytes
        self.jobDescription = jobDescription
        self.jobId = jobId
        self.jobOutputPath = jobOutputPath
        self.outputLocation = outputLocation
        self.retrievalByteRange = retrievalByteRange
        self.sHA256TreeHash = sHA256TreeHash
        self.sNSTopic = sNSTopic
        self.selectParameters = selectParameters
        self.statusCode = statusCode
        self.statusMessage = statusMessage
        self.tier = tier
        self.vaultARN = vaultARN
    }
}

extension Grant: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantee = "Grantee"
        case permission = "Permission"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantee = grantee {
            try encodeContainer.encode(grantee, forKey: .grantee)
        }
        if let permission = permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let granteeDecoded = try containerValues.decodeIfPresent(Grantee.self, forKey: .grantee)
        grantee = granteeDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(Permission.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension Grant: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Grant(grantee: \(String(describing: grantee)), permission: \(String(describing: permission)))"}
}

/// <p>Contains information about a grant.</p>
public struct Grant: Equatable {
    /// <p>The grantee.</p>
    public let grantee: Grantee?
    /// <p>Specifies the permission given to the grantee. </p>
    public let permission: Permission?

    public init (
        grantee: Grantee? = nil,
        permission: Permission? = nil
    )
    {
        self.grantee = grantee
        self.permission = permission
    }
}

extension Grantee: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName = "DisplayName"
        case emailAddress = "EmailAddress"
        case iD = "ID"
        case type = "Type"
        case uRI = "URI"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let iD = iD {
            try encodeContainer.encode(iD, forKey: .iD)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uRI = uRI {
            try encodeContainer.encode(uRI, forKey: .uRI)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let uRIDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uRI)
        uRI = uRIDecoded
        let iDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iD)
        iD = iDDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
    }
}

extension Grantee: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Grantee(displayName: \(String(describing: displayName)), emailAddress: \(String(describing: emailAddress)), iD: \(String(describing: iD)), type: \(String(describing: type)), uRI: \(String(describing: uRI)))"}
}

/// <p>Contains information about the grantee.</p>
public struct Grantee: Equatable {
    /// <p>Screen name of the grantee.</p>
    public let displayName: String?
    /// <p>Email address of the grantee.</p>
    public let emailAddress: String?
    /// <p>The canonical user ID of the grantee.</p>
    public let iD: String?
    /// <p>Type of grantee</p>
    public let type: `Type`?
    /// <p>URI of the grantee group.</p>
    public let uRI: String?

    public init (
        displayName: String? = nil,
        emailAddress: String? = nil,
        iD: String? = nil,
        type: `Type`? = nil,
        uRI: String? = nil
    )
    {
        self.displayName = displayName
        self.emailAddress = emailAddress
        self.iD = iD
        self.type = type
        self.uRI = uRI
    }
}

public struct InitiateJobInputBodyMiddleware: Middleware {
    public let id: String = "InitiateJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let jobParameters = input.operationInput.jobParameters {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(jobParameters)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateJobInput>
    public typealias MOutput = OperationOutput<InitiateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateJobOutputError>
}

extension InitiateJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitiateJobInput(accountId: \(String(describing: accountId)), jobParameters: \(String(describing: jobParameters)), vaultName: \(String(describing: vaultName)))"}
}

extension InitiateJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobParameters
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobParameters = jobParameters {
            try encodeContainer.encode(jobParameters, forKey: .jobParameters)
        }
    }
}

public struct InitiateJobInputHeadersMiddleware: Middleware {
    public let id: String = "InitiateJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateJobInput>
    public typealias MOutput = OperationOutput<InitiateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateJobOutputError>
}

public struct InitiateJobInputQueryItemMiddleware: Middleware {
    public let id: String = "InitiateJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateJobInput>
    public typealias MOutput = OperationOutput<InitiateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateJobOutputError>
}

/// <p>Provides options for initiating an Amazon S3 Glacier job.</p>
public struct InitiateJobInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: String?
    /// <p>Provides options for specifying job information.</p>
    public let jobParameters: JobParameters?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        jobParameters: JobParameters? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.jobParameters = jobParameters
        self.vaultName = vaultName
    }
}

struct InitiateJobInputBody: Equatable {
    public let jobParameters: JobParameters?
}

extension InitiateJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobParameters
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobParametersDecoded = try containerValues.decodeIfPresent(JobParameters.self, forKey: .jobParameters)
        jobParameters = jobParametersDecoded
    }
}

extension InitiateJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitiateJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientCapacityException" : self = .insufficientCapacityException(try InsufficientCapacityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyEnforcedException" : self = .policyEnforcedException(try PolicyEnforcedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InitiateJobOutputError: Equatable {
    case insufficientCapacityException(InsufficientCapacityException)
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case policyEnforcedException(PolicyEnforcedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitiateJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitiateJobOutputResponse(jobId: \(String(describing: jobId)), jobOutputPath: \(String(describing: jobOutputPath)), location: \(String(describing: location)))"}
}

extension InitiateJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let jobIdHeaderValue = httpResponse.headers.value(for: "x-amz-job-id") {
            self.jobId = jobIdHeaderValue
        } else {
            self.jobId = nil
        }
        if let jobOutputPathHeaderValue = httpResponse.headers.value(for: "x-amz-job-output-path") {
            self.jobOutputPath = jobOutputPathHeaderValue
        } else {
            self.jobOutputPath = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct InitiateJobOutputResponse: Equatable {
    /// <p>The ID of the job.</p>
    public let jobId: String?
    /// <p>The path to the location of where the select results are stored.</p>
    public let jobOutputPath: String?
    /// <p>The relative URI path of the job.</p>
    public let location: String?

    public init (
        jobId: String? = nil,
        jobOutputPath: String? = nil,
        location: String? = nil
    )
    {
        self.jobId = jobId
        self.jobOutputPath = jobOutputPath
        self.location = location
    }
}

struct InitiateJobOutputResponseBody: Equatable {
}

extension InitiateJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension InitiateMultipartUploadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitiateMultipartUploadInput(accountId: \(String(describing: accountId)), archiveDescription: \(String(describing: archiveDescription)), partSize: \(String(describing: partSize)), vaultName: \(String(describing: vaultName)))"}
}

extension InitiateMultipartUploadInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct InitiateMultipartUploadInputHeadersMiddleware: Middleware {
    public let id: String = "InitiateMultipartUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateMultipartUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let archiveDescription = input.operationInput.archiveDescription {
            input.builder.withHeader(name: "x-amz-archive-description", value: String(archiveDescription))
        }
        if let partSize = input.operationInput.partSize {
            input.builder.withHeader(name: "x-amz-part-size", value: String(partSize))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateMultipartUploadInput>
    public typealias MOutput = OperationOutput<InitiateMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateMultipartUploadOutputError>
}

public struct InitiateMultipartUploadInputQueryItemMiddleware: Middleware {
    public let id: String = "InitiateMultipartUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateMultipartUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateMultipartUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateMultipartUploadInput>
    public typealias MOutput = OperationOutput<InitiateMultipartUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateMultipartUploadOutputError>
}

/// <p>Provides options for initiating a multipart upload to an Amazon S3 Glacier
///          vault.</p>
public struct InitiateMultipartUploadInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: String?
    /// <p>The archive description that you are uploading in parts.</p>
    ///          <p>The part size must be a megabyte (1024 KB) multiplied by a power of 2, for example
    ///          1048576 (1 MB), 2097152 (2 MB), 4194304 (4 MB), 8388608 (8 MB), and so on. The minimum
    ///          allowable part size is 1 MB, and the maximum is 4 GB (4096 MB).</p>
    public let archiveDescription: String?
    /// <p>The size of each part except the last, in bytes. The last part can be smaller than
    ///          this part size.</p>
    public let partSize: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        archiveDescription: String? = nil,
        partSize: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.archiveDescription = archiveDescription
        self.partSize = partSize
        self.vaultName = vaultName
    }
}

struct InitiateMultipartUploadInputBody: Equatable {
}

extension InitiateMultipartUploadInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension InitiateMultipartUploadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitiateMultipartUploadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InitiateMultipartUploadOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitiateMultipartUploadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitiateMultipartUploadOutputResponse(location: \(String(describing: location)), uploadId: \(String(describing: uploadId)))"}
}

extension InitiateMultipartUploadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if let uploadIdHeaderValue = httpResponse.headers.value(for: "x-amz-multipart-upload-id") {
            self.uploadId = uploadIdHeaderValue
        } else {
            self.uploadId = nil
        }
    }
}

/// <p>The Amazon S3 Glacier response to your request.</p>
public struct InitiateMultipartUploadOutputResponse: Equatable {
    /// <p>The relative URI path of the multipart upload ID Amazon S3 Glacier created.</p>
    public let location: String?
    /// <p>The ID of the multipart upload. This value is also included as part of the
    ///          location.</p>
    public let uploadId: String?

    public init (
        location: String? = nil,
        uploadId: String? = nil
    )
    {
        self.location = location
        self.uploadId = uploadId
    }
}

struct InitiateMultipartUploadOutputResponseBody: Equatable {
}

extension InitiateMultipartUploadOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct InitiateVaultLockInputBodyMiddleware: Middleware {
    public let id: String = "InitiateVaultLockInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateVaultLockInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateVaultLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let policy = input.operationInput.policy {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(policy)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateVaultLockInput>
    public typealias MOutput = OperationOutput<InitiateVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateVaultLockOutputError>
}

extension InitiateVaultLockInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitiateVaultLockInput(accountId: \(String(describing: accountId)), policy: \(String(describing: policy)), vaultName: \(String(describing: vaultName)))"}
}

extension InitiateVaultLockInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct InitiateVaultLockInputHeadersMiddleware: Middleware {
    public let id: String = "InitiateVaultLockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateVaultLockInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateVaultLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateVaultLockInput>
    public typealias MOutput = OperationOutput<InitiateVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateVaultLockOutputError>
}

public struct InitiateVaultLockInputQueryItemMiddleware: Middleware {
    public let id: String = "InitiateVaultLockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateVaultLockInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateVaultLockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateVaultLockInput>
    public typealias MOutput = OperationOutput<InitiateVaultLockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateVaultLockOutputError>
}

/// <p>The input values for <code>InitiateVaultLock</code>.</p>
public struct InitiateVaultLockInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID. This value must match the AWS
    ///          account ID associated with the credentials used to sign the request. You can either specify
    ///          an AWS account ID or optionally a single '<code>-</code>' (hyphen), in which case Amazon
    ///          Glacier uses the AWS account ID associated with the credentials used to sign the request.
    ///          If you specify your account ID, do not include any hyphens ('-') in the ID.</p>
    public let accountId: String?
    /// <p>The vault lock policy as a JSON string, which uses "\" as an escape
    ///          character.</p>
    public let policy: VaultLockPolicy?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        policy: VaultLockPolicy? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.policy = policy
        self.vaultName = vaultName
    }
}

struct InitiateVaultLockInputBody: Equatable {
    public let policy: VaultLockPolicy?
}

extension InitiateVaultLockInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(VaultLockPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension InitiateVaultLockOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitiateVaultLockOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InitiateVaultLockOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitiateVaultLockOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitiateVaultLockOutputResponse(lockId: \(String(describing: lockId)))"}
}

extension InitiateVaultLockOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let lockIdHeaderValue = httpResponse.headers.value(for: "x-amz-lock-id") {
            self.lockId = lockIdHeaderValue
        } else {
            self.lockId = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct InitiateVaultLockOutputResponse: Equatable {
    /// <p>The lock ID, which is used to complete the vault locking process.</p>
    public let lockId: String?

    public init (
        lockId: String? = nil
    )
    {
        self.lockId = lockId
    }
}

struct InitiateVaultLockOutputResponseBody: Equatable {
}

extension InitiateVaultLockOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension InputSerialization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case csv
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csv = csv {
            try encodeContainer.encode(csv, forKey: .csv)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let csvDecoded = try containerValues.decodeIfPresent(CSVInput.self, forKey: .csv)
        csv = csvDecoded
    }
}

extension InputSerialization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputSerialization(csv: \(String(describing: csv)))"}
}

/// <p>Describes how the archive is serialized.</p>
public struct InputSerialization: Equatable {
    /// <p>Describes the serialization of a CSV-encoded object.</p>
    public let csv: CSVInput?

    public init (
        csv: CSVInput? = nil
    )
    {
        self.csv = csv
    }
}

extension InsufficientCapacityException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientCapacityException(code: \(String(describing: code)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension InsufficientCapacityException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InsufficientCapacityExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if there is insufficient capacity to process this expedited request. This
///          error only applies to expedited retrievals and not to standard or bulk
///          retrievals.</p>
public struct InsufficientCapacityException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var code: String?
    public var message: String?
    public var type: String?

    public init (
        code: String? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct InsufficientCapacityExceptionBody: Equatable {
    public let type: String?
    public let code: String?
    public let message: String?
}

extension InsufficientCapacityExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterValueException(code: \(String(describing: code)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension InvalidParameterValueException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if a parameter of the request is incorrectly specified.</p>
public struct InvalidParameterValueException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>400 Bad Request</p>
    public var code: String?
    /// <p>Returned if a parameter of the request is incorrectly specified.</p>
    public var message: String?
    /// <p>Client</p>
    public var type: String?

    public init (
        code: String? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct InvalidParameterValueExceptionBody: Equatable {
    public let type: String?
    public let code: String?
    public let message: String?
}

extension InvalidParameterValueExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InventoryRetrievalJobDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endDate = "EndDate"
        case format = "Format"
        case limit = "Limit"
        case marker = "Marker"
        case startDate = "StartDate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDate = endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .format)
        format = formatDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endDate)
        endDate = endDateDecoded
        let limitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension InventoryRetrievalJobDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryRetrievalJobDescription(endDate: \(String(describing: endDate)), format: \(String(describing: format)), limit: \(String(describing: limit)), marker: \(String(describing: marker)), startDate: \(String(describing: startDate)))"}
}

/// <p>Describes the options for a range inventory retrieval job.</p>
public struct InventoryRetrievalJobDescription: Equatable {
    /// <p>The end of the date range in UTC for vault inventory retrieval that includes
    ///             archives created before this date. This value should be a string in the ISO 8601 date
    ///             format, for example <code>2013-03-20T17:03:43Z</code>.</p>
    public let endDate: String?
    /// <p>The output format for the vault inventory list, which is set by the <b>InitiateJob</b> request when initiating a job to retrieve a vault
    ///             inventory. Valid values are <code>CSV</code> and <code>JSON</code>.</p>
    public let format: String?
    /// <p>The maximum number of inventory items returned per vault inventory retrieval
    ///             request. This limit is set when initiating the job with the a <b>InitiateJob</b> request. </p>
    public let limit: String?
    /// <p>An opaque string that represents where to continue pagination of the vault
    ///             inventory retrieval results. You use the marker in a new <b>InitiateJob</b> request to obtain additional inventory items. If there are
    ///             no more inventory items, this value is <code>null</code>. For more information, see
    ///                 <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-initiate-job-post.html#api-initiate-job-post-vault-inventory-list-filtering"> Range Inventory Retrieval</a>.</p>
    public let marker: String?
    /// <p>The start of the date range in Universal Coordinated Time (UTC) for vault inventory
    ///             retrieval that includes archives created on or after this date. This value should be a
    ///             string in the ISO 8601 date format, for example
    ///             <code>2013-03-20T17:03:43Z</code>.</p>
    public let startDate: String?

    public init (
        endDate: String? = nil,
        format: String? = nil,
        limit: String? = nil,
        marker: String? = nil,
        startDate: String? = nil
    )
    {
        self.endDate = endDate
        self.format = format
        self.limit = limit
        self.marker = marker
        self.startDate = startDate
    }
}

extension InventoryRetrievalJobInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endDate = "EndDate"
        case limit = "Limit"
        case marker = "Marker"
        case startDate = "StartDate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDate = endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let marker = marker {
            try encodeContainer.encode(marker, forKey: .marker)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endDate)
        endDate = endDateDecoded
        let limitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .limit)
        limit = limitDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension InventoryRetrievalJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InventoryRetrievalJobInput(endDate: \(String(describing: endDate)), limit: \(String(describing: limit)), marker: \(String(describing: marker)), startDate: \(String(describing: startDate)))"}
}

/// <p>Provides options for specifying a range inventory retrieval job.</p>
public struct InventoryRetrievalJobInput: Equatable {
    /// <p>The end of the date range in UTC for vault inventory retrieval that includes archives
    ///          created before this date. This value should be a string in the ISO 8601 date format, for
    ///          example <code>2013-03-20T17:03:43Z</code>.</p>
    public let endDate: String?
    /// <p>Specifies the maximum number of inventory items returned per vault inventory
    ///          retrieval request. Valid values are greater than or equal to 1.</p>
    public let limit: String?
    /// <p>An opaque string that represents where to continue pagination of the vault inventory
    ///          retrieval results. You use the marker in a new <b>InitiateJob</b>
    ///          request to obtain additional inventory items. If there are no more inventory items, this
    ///          value is <code>null</code>.</p>
    public let marker: String?
    /// <p>The start of the date range in UTC for vault inventory retrieval that includes
    ///          archives created on or after this date. This value should be a string in the ISO 8601 date
    ///          format, for example <code>2013-03-20T17:03:43Z</code>.</p>
    public let startDate: String?

    public init (
        endDate: String? = nil,
        limit: String? = nil,
        marker: String? = nil,
        startDate: String? = nil
    )
    {
        self.endDate = endDate
        self.limit = limit
        self.marker = marker
        self.startDate = startDate
    }
}

extension JobParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case archiveId = "ArchiveId"
        case description = "Description"
        case format = "Format"
        case inventoryRetrievalParameters = "InventoryRetrievalParameters"
        case outputLocation = "OutputLocation"
        case retrievalByteRange = "RetrievalByteRange"
        case sNSTopic = "SNSTopic"
        case selectParameters = "SelectParameters"
        case tier = "Tier"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveId = archiveId {
            try encodeContainer.encode(archiveId, forKey: .archiveId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
        if let inventoryRetrievalParameters = inventoryRetrievalParameters {
            try encodeContainer.encode(inventoryRetrievalParameters, forKey: .inventoryRetrievalParameters)
        }
        if let outputLocation = outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let retrievalByteRange = retrievalByteRange {
            try encodeContainer.encode(retrievalByteRange, forKey: .retrievalByteRange)
        }
        if let sNSTopic = sNSTopic {
            try encodeContainer.encode(sNSTopic, forKey: .sNSTopic)
        }
        if let selectParameters = selectParameters {
            try encodeContainer.encode(selectParameters, forKey: .selectParameters)
        }
        if let tier = tier {
            try encodeContainer.encode(tier, forKey: .tier)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .format)
        format = formatDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let archiveIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .archiveId)
        archiveId = archiveIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sNSTopicDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sNSTopic)
        sNSTopic = sNSTopicDecoded
        let retrievalByteRangeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .retrievalByteRange)
        retrievalByteRange = retrievalByteRangeDecoded
        let tierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tier)
        tier = tierDecoded
        let inventoryRetrievalParametersDecoded = try containerValues.decodeIfPresent(InventoryRetrievalJobInput.self, forKey: .inventoryRetrievalParameters)
        inventoryRetrievalParameters = inventoryRetrievalParametersDecoded
        let selectParametersDecoded = try containerValues.decodeIfPresent(SelectParameters.self, forKey: .selectParameters)
        selectParameters = selectParametersDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
    }
}

extension JobParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobParameters(archiveId: \(String(describing: archiveId)), description: \(String(describing: description)), format: \(String(describing: format)), inventoryRetrievalParameters: \(String(describing: inventoryRetrievalParameters)), outputLocation: \(String(describing: outputLocation)), retrievalByteRange: \(String(describing: retrievalByteRange)), sNSTopic: \(String(describing: sNSTopic)), selectParameters: \(String(describing: selectParameters)), tier: \(String(describing: tier)), type: \(String(describing: type)))"}
}

/// <p>Provides options for defining a job.</p>
public struct JobParameters: Equatable {
    /// <p>The ID of the archive that you want to retrieve. This field is required only if
    ///             <code>Type</code> is set to <code>select</code> or <code>archive-retrieval</code>code>.
    ///          An error occurs if you specify this
    ///          request parameter for an inventory retrieval job request. </p>
    public let archiveId: String?
    /// <p>The optional description for the job. The description must be less than or equal to
    ///          1,024 bytes. The allowable characters are 7-bit ASCII without control codes-specifically,
    ///          ASCII values 32-126 decimal or 0x20-0x7E hexadecimal.</p>
    public let description: String?
    /// <p>When initiating a job to retrieve a vault inventory, you can optionally add this
    ///          parameter to your request to specify the output format. If you are initiating an inventory
    ///          job and do not specify a Format field, JSON is the default format. Valid values are "CSV"
    ///          and "JSON".</p>
    public let format: String?
    /// <p>Input parameters used for range inventory retrieval.</p>
    public let inventoryRetrievalParameters: InventoryRetrievalJobInput?
    /// <p>Contains information about the location where the select job results are stored.</p>
    public let outputLocation: OutputLocation?
    /// <p>The byte range to retrieve for an archive retrieval. in the form
    ///             "<i>StartByteValue</i>-<i>EndByteValue</i>" If not
    ///          specified, the whole archive is retrieved. If specified, the byte range must be megabyte
    ///          (1024*1024) aligned which means that <i>StartByteValue</i> must be divisible
    ///          by 1 MB and <i>EndByteValue</i> plus 1 must be divisible by 1 MB or be the
    ///          end of the archive specified as the archive byte size value minus 1. If RetrievalByteRange
    ///          is not megabyte aligned, this operation returns a 400 response. </p>
    ///          <p>An error occurs if you specify this field for an inventory retrieval job
    ///          request.</p>
    public let retrievalByteRange: String?
    /// <p>The Amazon SNS topic ARN to which Amazon S3 Glacier sends a notification when the job is
    ///          completed and the output is ready for you to download. The specified topic publishes the
    ///          notification to its subscribers. The SNS topic must exist.</p>
    public let sNSTopic: String?
    /// <p>Contains the parameters that define a job.</p>
    public let selectParameters: SelectParameters?
    /// <p>The tier to use for a select or an archive retrieval job. Valid values are
    ///             <code>Expedited</code>, <code>Standard</code>, or <code>Bulk</code>.
    ///             <code>Standard</code> is the default.</p>
    public let tier: String?
    /// <p>The job type. You can initiate a job to perform a select query on an archive,
    ///          retrieve an archive, or get an inventory of a vault.
    ///          Valid values are "select", "archive-retrieval" and "inventory-retrieval".</p>
    public let type: String?

    public init (
        archiveId: String? = nil,
        description: String? = nil,
        format: String? = nil,
        inventoryRetrievalParameters: InventoryRetrievalJobInput? = nil,
        outputLocation: OutputLocation? = nil,
        retrievalByteRange: String? = nil,
        sNSTopic: String? = nil,
        selectParameters: SelectParameters? = nil,
        tier: String? = nil,
        type: String? = nil
    )
    {
        self.archiveId = archiveId
        self.description = description
        self.format = format
        self.inventoryRetrievalParameters = inventoryRetrievalParameters
        self.outputLocation = outputLocation
        self.retrievalByteRange = retrievalByteRange
        self.sNSTopic = sNSTopic
        self.selectParameters = selectParameters
        self.tier = tier
        self.type = type
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(code: \(String(describing: code)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the request results in a vault or account limit being exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>400 Bad Request</p>
    public var code: String?
    /// <p>Returned if the request results in a vault limit or tags limit being exceeded.</p>
    public var message: String?
    /// <p>Client</p>
    public var type: String?

    public init (
        code: String? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let type: String?
    public let code: String?
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsInput(accountId: \(String(describing: accountId)), completed: \(String(describing: completed)), limit: \(String(describing: limit)), marker: \(String(describing: marker)), statuscode: \(String(describing: statuscode)), vaultName: \(String(describing: vaultName)))"}
}

extension ListJobsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

public struct ListJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let statuscode = input.operationInput.statuscode {
            let statuscodeQueryItem = URLQueryItem(name: "statuscode".urlPercentEncoding(), value: String(statuscode).urlPercentEncoding())
            input.builder.withQueryItem(statuscodeQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let completed = input.operationInput.completed {
            let completedQueryItem = URLQueryItem(name: "completed".urlPercentEncoding(), value: String(completed).urlPercentEncoding())
            input.builder.withQueryItem(completedQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

/// <p>Provides options for retrieving a job list for an Amazon S3 Glacier vault.</p>
public struct ListJobsInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: String?
    /// <p>The state of the jobs to return. You can specify <code>true</code> or
    ///             <code>false</code>.</p>
    public let completed: String?
    /// <p>The maximum number of jobs to be returned. The default limit is 50. The number of
    ///          jobs returned might be fewer than the specified limit, but the number of returned jobs
    ///          never exceeds the limit.</p>
    public let limit: Int?
    /// <p>An opaque string used for pagination. This value specifies the job at which the
    ///          listing of jobs should begin. Get the marker value from a previous List Jobs response. You
    ///          only need to include the marker if you are continuing the pagination of results started in
    ///          a previous List Jobs request.</p>
    public let marker: String?
    /// <p>The type of job status to return. You can specify the following values:
    ///             <code>InProgress</code>, <code>Succeeded</code>, or <code>Failed</code>.</p>
    public let statuscode: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        completed: String? = nil,
        limit: Int? = nil,
        marker: String? = nil,
        statuscode: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.completed = completed
        self.limit = limit
        self.marker = marker
        self.statuscode = statuscode
        self.vaultName = vaultName
    }
}

struct ListJobsInputBody: Equatable {
}

extension ListJobsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsOutputResponse(jobList: \(String(describing: jobList)), marker: \(String(describing: marker)))"}
}

extension ListJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobList = output.jobList
            self.marker = output.marker
        } else {
            self.jobList = nil
            self.marker = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct ListJobsOutputResponse: Equatable {
    /// <p>A list of job objects. Each job object contains metadata describing the
    ///          job.</p>
    public let jobList: [GlacierJobDescription]?
    /// <p>	
    ///          An opaque string used for pagination that specifies the job at which the listing of jobs should begin.
    ///          You get the <code>marker</code> value from a previous List Jobs response.
    ///          You only need to include the marker if you are continuing the pagination of the results started in a
    ///          previous List Jobs request. </p>
    public let marker: String?

    public init (
        jobList: [GlacierJobDescription]? = nil,
        marker: String? = nil
    )
    {
        self.jobList = jobList
        self.marker = marker
    }
}

struct ListJobsOutputResponseBody: Equatable {
    public let jobList: [GlacierJobDescription]?
    public let marker: String?
}

extension ListJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobList = "JobList"
        case marker = "Marker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobListContainer = try containerValues.decodeIfPresent([GlacierJobDescription?].self, forKey: .jobList)
        var jobListDecoded0:[GlacierJobDescription]? = nil
        if let jobListContainer = jobListContainer {
            jobListDecoded0 = [GlacierJobDescription]()
            for structure0 in jobListContainer {
                if let structure0 = structure0 {
                    jobListDecoded0?.append(structure0)
                }
            }
        }
        jobList = jobListDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListMultipartUploadsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMultipartUploadsInput(accountId: \(String(describing: accountId)), limit: \(String(describing: limit)), marker: \(String(describing: marker)), vaultName: \(String(describing: vaultName)))"}
}

extension ListMultipartUploadsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListMultipartUploadsInputHeadersMiddleware: Middleware {
    public let id: String = "ListMultipartUploadsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMultipartUploadsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMultipartUploadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMultipartUploadsInput>
    public typealias MOutput = OperationOutput<ListMultipartUploadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMultipartUploadsOutputError>
}

public struct ListMultipartUploadsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMultipartUploadsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMultipartUploadsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMultipartUploadsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMultipartUploadsInput>
    public typealias MOutput = OperationOutput<ListMultipartUploadsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMultipartUploadsOutputError>
}

/// <p>Provides options for retrieving list of in-progress multipart uploads for an Amazon
///          Glacier vault.</p>
public struct ListMultipartUploadsInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: String?
    /// <p>Specifies the maximum number of uploads returned in the response body. If this value
    ///          is not specified, the List Uploads operation returns up to 50 uploads.</p>
    public let limit: Int?
    /// <p>An opaque string used for pagination. This value specifies the upload at which the
    ///          listing of uploads should begin. Get the marker value from a previous List Uploads
    ///          response. You need only include the marker if you are continuing the pagination of results
    ///          started in a previous List Uploads request.</p>
    public let marker: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        limit: Int? = nil,
        marker: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.limit = limit
        self.marker = marker
        self.vaultName = vaultName
    }
}

struct ListMultipartUploadsInputBody: Equatable {
}

extension ListMultipartUploadsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListMultipartUploadsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMultipartUploadsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMultipartUploadsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMultipartUploadsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMultipartUploadsOutputResponse(marker: \(String(describing: marker)), uploadsList: \(String(describing: uploadsList)))"}
}

extension ListMultipartUploadsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMultipartUploadsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.uploadsList = output.uploadsList
        } else {
            self.marker = nil
            self.uploadsList = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct ListMultipartUploadsOutputResponse: Equatable {
    /// <p>An opaque string that represents where to continue pagination of the results. You use
    ///          the marker in a new List Multipart Uploads request to obtain more uploads in the list. If
    ///          there are no more uploads, this value is <code>null</code>.</p>
    public let marker: String?
    /// <p>A list of in-progress multipart uploads.</p>
    public let uploadsList: [UploadListElement]?

    public init (
        marker: String? = nil,
        uploadsList: [UploadListElement]? = nil
    )
    {
        self.marker = marker
        self.uploadsList = uploadsList
    }
}

struct ListMultipartUploadsOutputResponseBody: Equatable {
    public let uploadsList: [UploadListElement]?
    public let marker: String?
}

extension ListMultipartUploadsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case uploadsList = "UploadsList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadsListContainer = try containerValues.decodeIfPresent([UploadListElement?].self, forKey: .uploadsList)
        var uploadsListDecoded0:[UploadListElement]? = nil
        if let uploadsListContainer = uploadsListContainer {
            uploadsListDecoded0 = [UploadListElement]()
            for structure0 in uploadsListContainer {
                if let structure0 = structure0 {
                    uploadsListDecoded0?.append(structure0)
                }
            }
        }
        uploadsList = uploadsListDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListPartsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPartsInput(accountId: \(String(describing: accountId)), limit: \(String(describing: limit)), marker: \(String(describing: marker)), uploadId: \(String(describing: uploadId)), vaultName: \(String(describing: vaultName)))"}
}

extension ListPartsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPartsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPartsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPartsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPartsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPartsInput>
    public typealias MOutput = OperationOutput<ListPartsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPartsOutputError>
}

public struct ListPartsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPartsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPartsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPartsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPartsInput>
    public typealias MOutput = OperationOutput<ListPartsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPartsOutputError>
}

/// <p>Provides options for retrieving a list of parts of an archive that have been uploaded
///          in a specific multipart upload.</p>
public struct ListPartsInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: String?
    /// <p>The maximum number of parts to be returned. The default limit is 50. The number of
    ///          parts returned might be fewer than the specified limit, but the number of returned parts
    ///          never exceeds the limit.</p>
    public let limit: Int?
    /// <p>An opaque string used for pagination. This value specifies the part at which the
    ///          listing of parts should begin. Get the marker value from the response of a previous List
    ///          Parts response. You need only include the marker if you are continuing the pagination of
    ///          results started in a previous List Parts request.</p>
    public let marker: String?
    /// <p>The upload ID of the multipart upload.</p>
    public let uploadId: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        limit: Int? = nil,
        marker: String? = nil,
        uploadId: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.limit = limit
        self.marker = marker
        self.uploadId = uploadId
        self.vaultName = vaultName
    }
}

struct ListPartsInputBody: Equatable {
}

extension ListPartsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPartsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPartsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPartsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPartsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPartsOutputResponse(archiveDescription: \(String(describing: archiveDescription)), creationDate: \(String(describing: creationDate)), marker: \(String(describing: marker)), multipartUploadId: \(String(describing: multipartUploadId)), partSizeInBytes: \(String(describing: partSizeInBytes)), parts: \(String(describing: parts)), vaultARN: \(String(describing: vaultARN)))"}
}

extension ListPartsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPartsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.archiveDescription = output.archiveDescription
            self.creationDate = output.creationDate
            self.marker = output.marker
            self.multipartUploadId = output.multipartUploadId
            self.partSizeInBytes = output.partSizeInBytes
            self.parts = output.parts
            self.vaultARN = output.vaultARN
        } else {
            self.archiveDescription = nil
            self.creationDate = nil
            self.marker = nil
            self.multipartUploadId = nil
            self.partSizeInBytes = 0
            self.parts = nil
            self.vaultARN = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct ListPartsOutputResponse: Equatable {
    /// <p>The description of the archive that was specified in the Initiate Multipart Upload
    ///          request.</p>
    public let archiveDescription: String?
    /// <p>The UTC time at which the multipart upload was initiated.</p>
    public let creationDate: String?
    /// <p>An opaque string that represents where to continue pagination of the results. You use
    ///          the marker in a new List Parts request to obtain more jobs in the list. If there are no
    ///          more parts, this value is <code>null</code>.</p>
    public let marker: String?
    /// <p>The ID of the upload to which the parts are associated.</p>
    public let multipartUploadId: String?
    /// <p>The part size in bytes. This is the same value that you specified in the Initiate
    ///          Multipart Upload request.</p>
    public let partSizeInBytes: Int
    /// <p>A list of the part sizes of the multipart upload. Each object in the array contains a
    ///          <code>RangeBytes</code> and <code>sha256-tree-hash</code> name/value
    ///          pair.</p>
    public let parts: [PartListElement]?
    /// <p>The Amazon Resource Name (ARN) of the vault to which the multipart upload was
    ///          initiated.</p>
    public let vaultARN: String?

    public init (
        archiveDescription: String? = nil,
        creationDate: String? = nil,
        marker: String? = nil,
        multipartUploadId: String? = nil,
        partSizeInBytes: Int = 0,
        parts: [PartListElement]? = nil,
        vaultARN: String? = nil
    )
    {
        self.archiveDescription = archiveDescription
        self.creationDate = creationDate
        self.marker = marker
        self.multipartUploadId = multipartUploadId
        self.partSizeInBytes = partSizeInBytes
        self.parts = parts
        self.vaultARN = vaultARN
    }
}

struct ListPartsOutputResponseBody: Equatable {
    public let multipartUploadId: String?
    public let vaultARN: String?
    public let archiveDescription: String?
    public let partSizeInBytes: Int
    public let creationDate: String?
    public let parts: [PartListElement]?
    public let marker: String?
}

extension ListPartsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case archiveDescription = "ArchiveDescription"
        case creationDate = "CreationDate"
        case marker = "Marker"
        case multipartUploadId = "MultipartUploadId"
        case partSizeInBytes = "PartSizeInBytes"
        case parts = "Parts"
        case vaultARN = "VaultARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multipartUploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .multipartUploadId)
        multipartUploadId = multipartUploadIdDecoded
        let vaultARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vaultARN)
        vaultARN = vaultARNDecoded
        let archiveDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .archiveDescription)
        archiveDescription = archiveDescriptionDecoded
        let partSizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .partSizeInBytes)
        partSizeInBytes = partSizeInBytesDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let partsContainer = try containerValues.decodeIfPresent([PartListElement?].self, forKey: .parts)
        var partsDecoded0:[PartListElement]? = nil
        if let partsContainer = partsContainer {
            partsDecoded0 = [PartListElement]()
            for structure0 in partsContainer {
                if let structure0 = structure0 {
                    partsDecoded0?.append(structure0)
                }
            }
        }
        parts = partsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension ListProvisionedCapacityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProvisionedCapacityInput(accountId: \(String(describing: accountId)))"}
}

extension ListProvisionedCapacityInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListProvisionedCapacityInputHeadersMiddleware: Middleware {
    public let id: String = "ListProvisionedCapacityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProvisionedCapacityInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProvisionedCapacityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProvisionedCapacityInput>
    public typealias MOutput = OperationOutput<ListProvisionedCapacityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProvisionedCapacityOutputError>
}

public struct ListProvisionedCapacityInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProvisionedCapacityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProvisionedCapacityInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProvisionedCapacityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProvisionedCapacityInput>
    public typealias MOutput = OperationOutput<ListProvisionedCapacityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProvisionedCapacityOutputError>
}

public struct ListProvisionedCapacityInput: Equatable {
    /// <p>The AWS account ID of the account that owns the vault. You can either specify an AWS
    ///          account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS
    ///          account ID associated with the credentials used to sign the request. If you use an account
    ///          ID, don't include any hyphens ('-') in the ID. </p>
    public let accountId: String?

    public init (
        accountId: String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct ListProvisionedCapacityInputBody: Equatable {
}

extension ListProvisionedCapacityInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListProvisionedCapacityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProvisionedCapacityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProvisionedCapacityOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProvisionedCapacityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProvisionedCapacityOutputResponse(provisionedCapacityList: \(String(describing: provisionedCapacityList)))"}
}

extension ListProvisionedCapacityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProvisionedCapacityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.provisionedCapacityList = output.provisionedCapacityList
        } else {
            self.provisionedCapacityList = nil
        }
    }
}

public struct ListProvisionedCapacityOutputResponse: Equatable {
    /// <p>The response body contains the following JSON fields.</p>
    public let provisionedCapacityList: [ProvisionedCapacityDescription]?

    public init (
        provisionedCapacityList: [ProvisionedCapacityDescription]? = nil
    )
    {
        self.provisionedCapacityList = provisionedCapacityList
    }
}

struct ListProvisionedCapacityOutputResponseBody: Equatable {
    public let provisionedCapacityList: [ProvisionedCapacityDescription]?
}

extension ListProvisionedCapacityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case provisionedCapacityList = "ProvisionedCapacityList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedCapacityListContainer = try containerValues.decodeIfPresent([ProvisionedCapacityDescription?].self, forKey: .provisionedCapacityList)
        var provisionedCapacityListDecoded0:[ProvisionedCapacityDescription]? = nil
        if let provisionedCapacityListContainer = provisionedCapacityListContainer {
            provisionedCapacityListDecoded0 = [ProvisionedCapacityDescription]()
            for structure0 in provisionedCapacityListContainer {
                if let structure0 = structure0 {
                    provisionedCapacityListDecoded0?.append(structure0)
                }
            }
        }
        provisionedCapacityList = provisionedCapacityListDecoded0
    }
}

extension ListTagsForVaultInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForVaultInput(accountId: \(String(describing: accountId)), vaultName: \(String(describing: vaultName)))"}
}

extension ListTagsForVaultInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForVaultInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForVaultInput>
    public typealias MOutput = OperationOutput<ListTagsForVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForVaultOutputError>
}

public struct ListTagsForVaultInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForVaultInput>
    public typealias MOutput = OperationOutput<ListTagsForVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForVaultOutputError>
}

/// <p>The input value for <code>ListTagsForVaultInput</code>.</p>
public struct ListTagsForVaultInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
    }
}

struct ListTagsForVaultInputBody: Equatable {
}

extension ListTagsForVaultInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForVaultOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForVaultOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForVaultOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForVaultOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForVaultOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForVaultOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForVaultOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct ListTagsForVaultOutputResponse: Equatable {
    /// <p>The tags attached to the vault. Each tag is composed of a key and a value.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForVaultOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForVaultOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListVaultsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVaultsInput(accountId: \(String(describing: accountId)), limit: \(String(describing: limit)), marker: \(String(describing: marker)))"}
}

extension ListVaultsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListVaultsInputHeadersMiddleware: Middleware {
    public let id: String = "ListVaultsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVaultsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVaultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVaultsInput>
    public typealias MOutput = OperationOutput<ListVaultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVaultsOutputError>
}

public struct ListVaultsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListVaultsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVaultsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVaultsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVaultsInput>
    public typealias MOutput = OperationOutput<ListVaultsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVaultsOutputError>
}

/// <p>Provides options to retrieve the vault list owned by the calling user's account. The
///          list provides metadata information for each vault.</p>
public struct ListVaultsInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID. This value must match the AWS
    ///          account ID associated with the credentials used to sign the request. You can either specify
    ///          an AWS account ID or optionally a single '<code>-</code>' (hyphen), in which case Amazon
    ///          Glacier uses the AWS account ID associated with the credentials used to sign the request.
    ///          If you specify your account ID, do not include any hyphens ('-') in the ID.</p>
    public let accountId: String?
    /// <p>The maximum number of vaults to be returned. The default limit is 10. The number of
    ///          vaults returned might be fewer than the specified limit, but the number of returned vaults
    ///          never exceeds the limit.</p>
    public let limit: Int?
    /// <p>A string used for pagination. The marker specifies the vault ARN after which the
    ///          listing of vaults should begin.</p>
    public let marker: String?

    public init (
        accountId: String? = nil,
        limit: Int? = nil,
        marker: String? = nil
    )
    {
        self.accountId = accountId
        self.limit = limit
        self.marker = marker
    }
}

struct ListVaultsInputBody: Equatable {
}

extension ListVaultsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListVaultsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVaultsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVaultsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVaultsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVaultsOutputResponse(marker: \(String(describing: marker)), vaultList: \(String(describing: vaultList)))"}
}

extension ListVaultsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListVaultsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.marker = output.marker
            self.vaultList = output.vaultList
        } else {
            self.marker = nil
            self.vaultList = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct ListVaultsOutputResponse: Equatable {
    /// <p>The vault ARN at which to continue pagination of the results. You use the marker in
    ///          another List Vaults request to obtain more vaults in the list.</p>
    public let marker: String?
    /// <p>List of vaults.</p>
    public let vaultList: [DescribeVaultOutput]?

    public init (
        marker: String? = nil,
        vaultList: [DescribeVaultOutput]? = nil
    )
    {
        self.marker = marker
        self.vaultList = vaultList
    }
}

struct ListVaultsOutputResponseBody: Equatable {
    public let vaultList: [DescribeVaultOutput]?
    public let marker: String?
}

extension ListVaultsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case vaultList = "VaultList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vaultListContainer = try containerValues.decodeIfPresent([DescribeVaultOutput?].self, forKey: .vaultList)
        var vaultListDecoded0:[DescribeVaultOutput]? = nil
        if let vaultListContainer = vaultListContainer {
            vaultListDecoded0 = [DescribeVaultOutput]()
            for structure0 in vaultListContainer {
                if let structure0 = structure0 {
                    vaultListDecoded0?.append(structure0)
                }
            }
        }
        vaultList = vaultListDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension MissingParameterValueException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MissingParameterValueException(code: \(String(describing: code)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension MissingParameterValueException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MissingParameterValueExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if a required header or parameter is missing from the request.</p>
public struct MissingParameterValueException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>400 Bad Request</p>
    public var code: String?
    /// <p>Returned if no authentication data is found for the request.</p>
    public var message: String?
    /// <p>Client.</p>
    public var type: String?

    public init (
        code: String? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct MissingParameterValueExceptionBody: Equatable {
    public let type: String?
    public let code: String?
    public let message: String?
}

extension MissingParameterValueExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OutputLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3 = "S3"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension OutputLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputLocation(s3: \(String(describing: s3)))"}
}

/// <p>Contains information about the location where the select job results are stored.</p>
public struct OutputLocation: Equatable {
    /// <p>Describes an S3 location that will receive the results of the job request.</p>
    public let s3: S3Location?

    public init (
        s3: S3Location? = nil
    )
    {
        self.s3 = s3
    }
}

extension OutputSerialization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case csv
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csv = csv {
            try encodeContainer.encode(csv, forKey: .csv)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let csvDecoded = try containerValues.decodeIfPresent(CSVOutput.self, forKey: .csv)
        csv = csvDecoded
    }
}

extension OutputSerialization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputSerialization(csv: \(String(describing: csv)))"}
}

/// <p>Describes how the select output is serialized.</p>
public struct OutputSerialization: Equatable {
    /// <p>Describes the serialization of CSV-encoded query results.</p>
    public let csv: CSVOutput?

    public init (
        csv: CSVOutput? = nil
    )
    {
        self.csv = csv
    }
}

extension PartListElement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rangeInBytes = "RangeInBytes"
        case sHA256TreeHash = "SHA256TreeHash"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rangeInBytes = rangeInBytes {
            try encodeContainer.encode(rangeInBytes, forKey: .rangeInBytes)
        }
        if let sHA256TreeHash = sHA256TreeHash {
            try encodeContainer.encode(sHA256TreeHash, forKey: .sHA256TreeHash)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rangeInBytesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rangeInBytes)
        rangeInBytes = rangeInBytesDecoded
        let sHA256TreeHashDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sHA256TreeHash)
        sHA256TreeHash = sHA256TreeHashDecoded
    }
}

extension PartListElement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PartListElement(rangeInBytes: \(String(describing: rangeInBytes)), sHA256TreeHash: \(String(describing: sHA256TreeHash)))"}
}

/// <p>A list of the part sizes of the multipart upload.</p>
public struct PartListElement: Equatable {
    /// <p>The byte range of a part, inclusive of the upper value of the range.</p>
    public let rangeInBytes: String?
    /// <p>The SHA256 tree hash value that Amazon S3 Glacier calculated for the part. This field is
    ///          never <code>null</code>.</p>
    public let sHA256TreeHash: String?

    public init (
        rangeInBytes: String? = nil,
        sHA256TreeHash: String? = nil
    )
    {
        self.rangeInBytes = rangeInBytes
        self.sHA256TreeHash = sHA256TreeHash
    }
}

public enum Permission {
    case fullControl
    case read
    case readAcp
    case write
    case writeAcp
    case sdkUnknown(String)
}

extension Permission : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Permission] {
        return [
            .fullControl,
            .read,
            .readAcp,
            .write,
            .writeAcp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fullControl: return "FULL_CONTROL"
        case .read: return "READ"
        case .readAcp: return "READ_ACP"
        case .write: return "WRITE"
        case .writeAcp: return "WRITE_ACP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
    }
}

extension PolicyEnforcedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyEnforcedException(code: \(String(describing: code)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension PolicyEnforcedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PolicyEnforcedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if a retrieval job would exceed the current data policy's retrieval rate
///          limit. For more information about data retrieval policies,</p>
public struct PolicyEnforcedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>PolicyEnforcedException</p>
    public var code: String?
    /// <p>InitiateJob request denied by current data retrieval policy.</p>
    public var message: String?
    /// <p>Client</p>
    public var type: String?

    public init (
        code: String? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct PolicyEnforcedExceptionBody: Equatable {
    public let type: String?
    public let code: String?
    public let message: String?
}

extension PolicyEnforcedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProvisionedCapacityDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case capacityId = "CapacityId"
        case expirationDate = "ExpirationDate"
        case startDate = "StartDate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityId = capacityId {
            try encodeContainer.encode(capacityId, forKey: .capacityId)
        }
        if let expirationDate = expirationDate {
            try encodeContainer.encode(expirationDate, forKey: .expirationDate)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .capacityId)
        capacityId = capacityIdDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startDate)
        startDate = startDateDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
    }
}

extension ProvisionedCapacityDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisionedCapacityDescription(capacityId: \(String(describing: capacityId)), expirationDate: \(String(describing: expirationDate)), startDate: \(String(describing: startDate)))"}
}

/// <p>The definition for a provisioned capacity unit.</p>
public struct ProvisionedCapacityDescription: Equatable {
    /// <p>The ID that identifies the provisioned capacity unit.</p>
    public let capacityId: String?
    /// <p>The date that the provisioned capacity unit expires, in Universal Coordinated Time (UTC).</p>
    public let expirationDate: String?
    /// <p>The date that the provisioned capacity unit was purchased, in Universal Coordinated Time (UTC).</p>
    public let startDate: String?

    public init (
        capacityId: String? = nil,
        expirationDate: String? = nil,
        startDate: String? = nil
    )
    {
        self.capacityId = capacityId
        self.expirationDate = expirationDate
        self.startDate = startDate
    }
}

extension PurchaseProvisionedCapacityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PurchaseProvisionedCapacityInput(accountId: \(String(describing: accountId)))"}
}

extension PurchaseProvisionedCapacityInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct PurchaseProvisionedCapacityInputHeadersMiddleware: Middleware {
    public let id: String = "PurchaseProvisionedCapacityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PurchaseProvisionedCapacityInput>,
                  next: H) -> Swift.Result<OperationOutput<PurchaseProvisionedCapacityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PurchaseProvisionedCapacityInput>
    public typealias MOutput = OperationOutput<PurchaseProvisionedCapacityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PurchaseProvisionedCapacityOutputError>
}

public struct PurchaseProvisionedCapacityInputQueryItemMiddleware: Middleware {
    public let id: String = "PurchaseProvisionedCapacityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PurchaseProvisionedCapacityInput>,
                  next: H) -> Swift.Result<OperationOutput<PurchaseProvisionedCapacityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PurchaseProvisionedCapacityInput>
    public typealias MOutput = OperationOutput<PurchaseProvisionedCapacityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PurchaseProvisionedCapacityOutputError>
}

public struct PurchaseProvisionedCapacityInput: Equatable {
    /// <p>The AWS account ID of the account that owns the vault. You can either specify an AWS
    ///          account ID or optionally a single '-' (hyphen), in which case Amazon S3 Glacier uses the AWS
    ///          account ID associated with the credentials used to sign the request. If you use an account
    ///          ID, don't include any hyphens ('-') in the ID. </p>
    public let accountId: String?

    public init (
        accountId: String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct PurchaseProvisionedCapacityInputBody: Equatable {
}

extension PurchaseProvisionedCapacityInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension PurchaseProvisionedCapacityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PurchaseProvisionedCapacityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PurchaseProvisionedCapacityOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case limitExceededException(LimitExceededException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PurchaseProvisionedCapacityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PurchaseProvisionedCapacityOutputResponse(capacityId: \(String(describing: capacityId)))"}
}

extension PurchaseProvisionedCapacityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let capacityIdHeaderValue = httpResponse.headers.value(for: "x-amz-capacity-id") {
            self.capacityId = capacityIdHeaderValue
        } else {
            self.capacityId = nil
        }
    }
}

public struct PurchaseProvisionedCapacityOutputResponse: Equatable {
    /// <p>The ID that identifies the provisioned capacity unit.</p>
    public let capacityId: String?

    public init (
        capacityId: String? = nil
    )
    {
        self.capacityId = capacityId
    }
}

struct PurchaseProvisionedCapacityOutputResponseBody: Equatable {
}

extension PurchaseProvisionedCapacityOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum QuoteFields {
    case always
    case asneeded
    case sdkUnknown(String)
}

extension QuoteFields : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [QuoteFields] {
        return [
            .always,
            .asneeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .always: return "ALWAYS"
        case .asneeded: return "ASNEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = QuoteFields(rawValue: rawValue) ?? QuoteFields.sdkUnknown(rawValue)
    }
}

public struct RemoveTagsFromVaultInputBodyMiddleware: Middleware {
    public let id: String = "RemoveTagsFromVaultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromVaultInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromVaultOutputError>
}

extension RemoveTagsFromVaultInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsFromVaultInput(tagKeys: \(String(describing: tagKeys)), accountId: \(String(describing: accountId)), vaultName: \(String(describing: vaultName)))"}
}

extension RemoveTagsFromVaultInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct RemoveTagsFromVaultInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveTagsFromVaultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromVaultInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromVaultOutputError>
}

public struct RemoveTagsFromVaultInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveTagsFromVaultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsFromVaultInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsFromVaultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "operation", value: "remove"))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsFromVaultInput>
    public typealias MOutput = OperationOutput<RemoveTagsFromVaultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsFromVaultOutputError>
}

/// <p>The input value for <code>RemoveTagsFromVaultInput</code>.</p>
public struct RemoveTagsFromVaultInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: String?
    /// <p>A list of tag keys. Each corresponding tag is removed from the vault.</p>
    public let tagKeys: [String]?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        tagKeys: [String]? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.tagKeys = tagKeys
        self.vaultName = vaultName
    }
}

struct RemoveTagsFromVaultInputBody: Equatable {
    public let tagKeys: [String]?
}

extension RemoveTagsFromVaultInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsFromVaultOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsFromVaultOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsFromVaultOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsFromVaultOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsFromVaultOutputResponse()"}
}

extension RemoveTagsFromVaultOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveTagsFromVaultOutputResponse: Equatable {

    public init() {}
}

struct RemoveTagsFromVaultOutputResponseBody: Equatable {
}

extension RemoveTagsFromVaultOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RequestTimeoutException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestTimeoutException(code: \(String(describing: code)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension RequestTimeoutException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RequestTimeoutExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if, when uploading an archive, Amazon S3 Glacier times out while receiving the
///          upload.</p>
public struct RequestTimeoutException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>408 Request Timeout</p>
    public var code: String?
    /// <p>Returned if, when uploading an archive, Amazon S3 Glacier times out while receiving the
    ///          upload.</p>
    public var message: String?
    /// <p>Client</p>
    public var type: String?

    public init (
        code: String? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct RequestTimeoutExceptionBody: Equatable {
    public let type: String?
    public let code: String?
    public let message: String?
}

extension RequestTimeoutExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(code: \(String(describing: code)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the specified resource (such as a vault, upload ID, or job ID) doesn't
///          exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>404 Not Found</p>
    public var code: String?
    /// <p>Returned if the specified resource (such as a vault, upload ID, or job ID) doesn't
    ///          exist.</p>
    public var message: String?
    /// <p>Client</p>
    public var type: String?

    public init (
        code: String? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let type: String?
    public let code: String?
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessControlList = "AccessControlList"
        case bucketName = "BucketName"
        case cannedACL = "CannedACL"
        case encryption = "Encryption"
        case prefix = "Prefix"
        case storageClass = "StorageClass"
        case tagging = "Tagging"
        case userMetadata = "UserMetadata"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControlList = accessControlList {
            var accessControlListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessControlList)
            for accesscontrolpolicylist0 in accessControlList {
                try accessControlListContainer.encode(accesscontrolpolicylist0)
            }
        }
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let cannedACL = cannedACL {
            try encodeContainer.encode(cannedACL.rawValue, forKey: .cannedACL)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
        if let storageClass = storageClass {
            try encodeContainer.encode(storageClass.rawValue, forKey: .storageClass)
        }
        if let tagging = tagging {
            var taggingContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tagging)
            for (dictKey0, hashmap0) in tagging {
                try taggingContainer.encode(hashmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let userMetadata = userMetadata {
            var userMetadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .userMetadata)
            for (dictKey0, hashmap0) in userMetadata {
                try userMetadataContainer.encode(hashmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let cannedACLDecoded = try containerValues.decodeIfPresent(CannedACL.self, forKey: .cannedACL)
        cannedACL = cannedACLDecoded
        let accessControlListContainer = try containerValues.decodeIfPresent([Grant?].self, forKey: .accessControlList)
        var accessControlListDecoded0:[Grant]? = nil
        if let accessControlListContainer = accessControlListContainer {
            accessControlListDecoded0 = [Grant]()
            for structure0 in accessControlListContainer {
                if let structure0 = structure0 {
                    accessControlListDecoded0?.append(structure0)
                }
            }
        }
        accessControlList = accessControlListDecoded0
        let taggingContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tagging)
        var taggingDecoded0: [String:String]? = nil
        if let taggingContainer = taggingContainer {
            taggingDecoded0 = [String:String]()
            for (key0, string0) in taggingContainer {
                if let string0 = string0 {
                    taggingDecoded0?[key0] = string0
                }
            }
        }
        tagging = taggingDecoded0
        let userMetadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .userMetadata)
        var userMetadataDecoded0: [String:String]? = nil
        if let userMetadataContainer = userMetadataContainer {
            userMetadataDecoded0 = [String:String]()
            for (key0, string0) in userMetadataContainer {
                if let string0 = string0 {
                    userMetadataDecoded0?[key0] = string0
                }
            }
        }
        userMetadata = userMetadataDecoded0
        let storageClassDecoded = try containerValues.decodeIfPresent(StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension S3Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Location(accessControlList: \(String(describing: accessControlList)), bucketName: \(String(describing: bucketName)), cannedACL: \(String(describing: cannedACL)), encryption: \(String(describing: encryption)), prefix: \(String(describing: prefix)), storageClass: \(String(describing: storageClass)), tagging: \(String(describing: tagging)), userMetadata: \(String(describing: userMetadata)))"}
}

/// <p>Contains information about the location in Amazon S3 where the select job results are stored.</p>
public struct S3Location: Equatable {
    /// <p>A list of grants that control access to the staged results.</p>
    public let accessControlList: [Grant]?
    /// <p>The name of the Amazon S3 bucket where the job results are stored.</p>
    public let bucketName: String?
    /// <p>The canned access control list (ACL) to apply to the job results.</p>
    public let cannedACL: CannedACL?
    /// <p>Contains information about the encryption used to store the job results in Amazon S3.</p>
    public let encryption: Encryption?
    /// <p>The prefix that is prepended to the results for this request.</p>
    public let prefix: String?
    /// <p>The storage class used to store the job results.</p>
    public let storageClass: StorageClass?
    /// <p>The tag-set that is applied to the job results.</p>
    public let tagging: [String:String]?
    /// <p>A map of metadata to store with the job results in Amazon S3.</p>
    public let userMetadata: [String:String]?

    public init (
        accessControlList: [Grant]? = nil,
        bucketName: String? = nil,
        cannedACL: CannedACL? = nil,
        encryption: Encryption? = nil,
        prefix: String? = nil,
        storageClass: StorageClass? = nil,
        tagging: [String:String]? = nil,
        userMetadata: [String:String]? = nil
    )
    {
        self.accessControlList = accessControlList
        self.bucketName = bucketName
        self.cannedACL = cannedACL
        self.encryption = encryption
        self.prefix = prefix
        self.storageClass = storageClass
        self.tagging = tagging
        self.userMetadata = userMetadata
    }
}

extension SelectParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case inputSerialization = "InputSerialization"
        case outputSerialization = "OutputSerialization"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionType = expressionType {
            try encodeContainer.encode(expressionType.rawValue, forKey: .expressionType)
        }
        if let inputSerialization = inputSerialization {
            try encodeContainer.encode(inputSerialization, forKey: .inputSerialization)
        }
        if let outputSerialization = outputSerialization {
            try encodeContainer.encode(outputSerialization, forKey: .outputSerialization)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSerializationDecoded = try containerValues.decodeIfPresent(InputSerialization.self, forKey: .inputSerialization)
        inputSerialization = inputSerializationDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let outputSerializationDecoded = try containerValues.decodeIfPresent(OutputSerialization.self, forKey: .outputSerialization)
        outputSerialization = outputSerializationDecoded
    }
}

extension SelectParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SelectParameters(expression: \(String(describing: expression)), expressionType: \(String(describing: expressionType)), inputSerialization: \(String(describing: inputSerialization)), outputSerialization: \(String(describing: outputSerialization)))"}
}

/// <p>Contains information about the parameters used for a select.</p>
public struct SelectParameters: Equatable {
    /// <p>The expression that is used to select the object.</p>
    public let expression: String?
    /// <p>The type of the provided expression, for example <code>SQL</code>.</p>
    public let expressionType: ExpressionType?
    /// <p>Describes the serialization format of the object.</p>
    public let inputSerialization: InputSerialization?
    /// <p>Describes how the results of the select job are serialized.</p>
    public let outputSerialization: OutputSerialization?

    public init (
        expression: String? = nil,
        expressionType: ExpressionType? = nil,
        inputSerialization: InputSerialization? = nil,
        outputSerialization: OutputSerialization? = nil
    )
    {
        self.expression = expression
        self.expressionType = expressionType
        self.inputSerialization = inputSerialization
        self.outputSerialization = outputSerialization
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(code: \(String(describing: code)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.message = output.message
            self.type = output.type
        } else {
            self.code = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Returned if the service cannot complete the request.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>500 Internal Server Error</p>
    public var code: String?
    /// <p>Returned if the service cannot complete the request.</p>
    public var message: String?
    /// <p>Server</p>
    public var type: String?

    public init (
        code: String? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.code = code
        self.message = message
        self.type = type
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let type: String?
    public let code: String?
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code
        case message
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SetDataRetrievalPolicyInputBodyMiddleware: Middleware {
    public let id: String = "SetDataRetrievalPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetDataRetrievalPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SetDataRetrievalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetDataRetrievalPolicyInput>
    public typealias MOutput = OperationOutput<SetDataRetrievalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetDataRetrievalPolicyOutputError>
}

extension SetDataRetrievalPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetDataRetrievalPolicyInput(policy: \(String(describing: policy)), accountId: \(String(describing: accountId)))"}
}

extension SetDataRetrievalPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct SetDataRetrievalPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "SetDataRetrievalPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetDataRetrievalPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SetDataRetrievalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetDataRetrievalPolicyInput>
    public typealias MOutput = OperationOutput<SetDataRetrievalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetDataRetrievalPolicyOutputError>
}

public struct SetDataRetrievalPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "SetDataRetrievalPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetDataRetrievalPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SetDataRetrievalPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetDataRetrievalPolicyInput>
    public typealias MOutput = OperationOutput<SetDataRetrievalPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetDataRetrievalPolicyOutputError>
}

/// <p>SetDataRetrievalPolicy input.</p>
public struct SetDataRetrievalPolicyInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID. This value must match the AWS
    ///          account ID associated with the credentials used to sign the request. You can either specify
    ///          an AWS account ID or optionally a single '<code>-</code>' (hyphen), in which case Amazon
    ///          Glacier uses the AWS account ID associated with the credentials used to sign the request.
    ///          If you specify your account ID, do not include any hyphens ('-') in the ID.</p>
    public let accountId: String?
    /// <p>The data retrieval policy in JSON format.</p>
    public let policy: DataRetrievalPolicy?

    public init (
        accountId: String? = nil,
        policy: DataRetrievalPolicy? = nil
    )
    {
        self.accountId = accountId
        self.policy = policy
    }
}

struct SetDataRetrievalPolicyInputBody: Equatable {
    public let policy: DataRetrievalPolicy?
}

extension SetDataRetrievalPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(DataRetrievalPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension SetDataRetrievalPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetDataRetrievalPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetDataRetrievalPolicyOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetDataRetrievalPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetDataRetrievalPolicyOutputResponse()"}
}

extension SetDataRetrievalPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetDataRetrievalPolicyOutputResponse: Equatable {

    public init() {}
}

struct SetDataRetrievalPolicyOutputResponseBody: Equatable {
}

extension SetDataRetrievalPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetVaultAccessPolicyInputBodyMiddleware: Middleware {
    public let id: String = "SetVaultAccessPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SetVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let policy = input.operationInput.policy {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(policy)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetVaultAccessPolicyInput>
    public typealias MOutput = OperationOutput<SetVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetVaultAccessPolicyOutputError>
}

extension SetVaultAccessPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetVaultAccessPolicyInput(accountId: \(String(describing: accountId)), policy: \(String(describing: policy)), vaultName: \(String(describing: vaultName)))"}
}

extension SetVaultAccessPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct SetVaultAccessPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "SetVaultAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SetVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetVaultAccessPolicyInput>
    public typealias MOutput = OperationOutput<SetVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetVaultAccessPolicyOutputError>
}

public struct SetVaultAccessPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "SetVaultAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetVaultAccessPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SetVaultAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetVaultAccessPolicyInput>
    public typealias MOutput = OperationOutput<SetVaultAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetVaultAccessPolicyOutputError>
}

/// <p>SetVaultAccessPolicy input.</p>
public struct SetVaultAccessPolicyInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: String?
    /// <p>The vault access policy as a JSON string.</p>
    public let policy: VaultAccessPolicy?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        policy: VaultAccessPolicy? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.policy = policy
        self.vaultName = vaultName
    }
}

struct SetVaultAccessPolicyInputBody: Equatable {
    public let policy: VaultAccessPolicy?
}

extension SetVaultAccessPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(VaultAccessPolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension SetVaultAccessPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetVaultAccessPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetVaultAccessPolicyOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetVaultAccessPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetVaultAccessPolicyOutputResponse()"}
}

extension SetVaultAccessPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetVaultAccessPolicyOutputResponse: Equatable {

    public init() {}
}

struct SetVaultAccessPolicyOutputResponseBody: Equatable {
}

extension SetVaultAccessPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetVaultNotificationsInputBodyMiddleware: Middleware {
    public let id: String = "SetVaultNotificationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetVaultNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let vaultNotificationConfig = input.operationInput.vaultNotificationConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(vaultNotificationConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetVaultNotificationsInput>
    public typealias MOutput = OperationOutput<SetVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetVaultNotificationsOutputError>
}

extension SetVaultNotificationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetVaultNotificationsInput(accountId: \(String(describing: accountId)), vaultName: \(String(describing: vaultName)), vaultNotificationConfig: \(String(describing: vaultNotificationConfig)))"}
}

extension SetVaultNotificationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case vaultNotificationConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vaultNotificationConfig = vaultNotificationConfig {
            try encodeContainer.encode(vaultNotificationConfig, forKey: .vaultNotificationConfig)
        }
    }
}

public struct SetVaultNotificationsInputHeadersMiddleware: Middleware {
    public let id: String = "SetVaultNotificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetVaultNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetVaultNotificationsInput>
    public typealias MOutput = OperationOutput<SetVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetVaultNotificationsOutputError>
}

public struct SetVaultNotificationsInputQueryItemMiddleware: Middleware {
    public let id: String = "SetVaultNotificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetVaultNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetVaultNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetVaultNotificationsInput>
    public typealias MOutput = OperationOutput<SetVaultNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetVaultNotificationsOutputError>
}

/// <p>Provides options to configure notifications that will be sent when specific events
///          happen to a vault.</p>
public struct SetVaultNotificationsInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID.</p>
    public let accountId: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?
    /// <p>Provides options for specifying notification configuration.</p>
    public let vaultNotificationConfig: VaultNotificationConfig?

    public init (
        accountId: String? = nil,
        vaultName: String? = nil,
        vaultNotificationConfig: VaultNotificationConfig? = nil
    )
    {
        self.accountId = accountId
        self.vaultName = vaultName
        self.vaultNotificationConfig = vaultNotificationConfig
    }
}

struct SetVaultNotificationsInputBody: Equatable {
    public let vaultNotificationConfig: VaultNotificationConfig?
}

extension SetVaultNotificationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case vaultNotificationConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vaultNotificationConfigDecoded = try containerValues.decodeIfPresent(VaultNotificationConfig.self, forKey: .vaultNotificationConfig)
        vaultNotificationConfig = vaultNotificationConfigDecoded
    }
}

extension SetVaultNotificationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetVaultNotificationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetVaultNotificationsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetVaultNotificationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetVaultNotificationsOutputResponse()"}
}

extension SetVaultNotificationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetVaultNotificationsOutputResponse: Equatable {

    public init() {}
}

struct SetVaultNotificationsOutputResponseBody: Equatable {
}

extension SetVaultNotificationsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum StatusCode {
    case failed
    case inprogress
    case succeeded
    case sdkUnknown(String)
}

extension StatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StatusCode] {
        return [
            .failed,
            .inprogress,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "Failed"
        case .inprogress: return "InProgress"
        case .succeeded: return "Succeeded"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StatusCode(rawValue: rawValue) ?? StatusCode.sdkUnknown(rawValue)
    }
}

public enum StorageClass {
    case reducedredundancy
    case standard
    case standardinfrequentaccess
    case sdkUnknown(String)
}

extension StorageClass : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StorageClass] {
        return [
            .reducedredundancy,
            .standard,
            .standardinfrequentaccess,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .reducedredundancy: return "REDUCED_REDUNDANCY"
        case .standard: return "STANDARD"
        case .standardinfrequentaccess: return "STANDARD_IA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StorageClass(rawValue: rawValue) ?? StorageClass.sdkUnknown(rawValue)
    }
}

public enum `Type` {
    case amazoncustomerbyemail
    case canonicaluser
    case group
    case sdkUnknown(String)
}

extension `Type` : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [`Type`] {
        return [
            .amazoncustomerbyemail,
            .canonicaluser,
            .group,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .amazoncustomerbyemail: return "AmazonCustomerByEmail"
        case .canonicaluser: return "CanonicalUser"
        case .group: return "Group"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = `Type`(rawValue: rawValue) ?? `Type`.sdkUnknown(rawValue)
    }
}

public struct UploadArchiveInputBodyMiddleware: Middleware {
    public let id: String = "UploadArchiveInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let body = input.operationInput.body {
            let data = body
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadArchiveInput>
    public typealias MOutput = OperationOutput<UploadArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadArchiveOutputError>
}

extension UploadArchiveInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadArchiveInput(accountId: \(String(describing: accountId)), archiveDescription: \(String(describing: archiveDescription)), body: \(String(describing: body)), checksum: \(String(describing: checksum)), vaultName: \(String(describing: vaultName)))"}
}

extension UploadArchiveInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
    }
}

public struct UploadArchiveInputHeadersMiddleware: Middleware {
    public let id: String = "UploadArchiveInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let archiveDescription = input.operationInput.archiveDescription {
            input.builder.withHeader(name: "x-amz-archive-description", value: String(archiveDescription))
        }
        if let checksum = input.operationInput.checksum {
            input.builder.withHeader(name: "x-amz-sha256-tree-hash", value: String(checksum))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadArchiveInput>
    public typealias MOutput = OperationOutput<UploadArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadArchiveOutputError>
}

public struct UploadArchiveInputQueryItemMiddleware: Middleware {
    public let id: String = "UploadArchiveInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadArchiveInput>
    public typealias MOutput = OperationOutput<UploadArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadArchiveOutputError>
}

/// <p>Provides options to add an archive to a vault.</p>
public struct UploadArchiveInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: String?
    /// <p>The optional description of the archive you are uploading.</p>
    public let archiveDescription: String?
    /// <p>The data to upload.</p>
    public let body: Data?
    /// <p>The SHA256 tree hash of the data being uploaded.</p>
    public let checksum: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        archiveDescription: String? = nil,
        body: Data? = nil,
        checksum: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.archiveDescription = archiveDescription
        self.body = body
        self.checksum = checksum
        self.vaultName = vaultName
    }
}

struct UploadArchiveInputBody: Equatable {
    public let body: Data?
}

extension UploadArchiveInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension UploadArchiveOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UploadArchiveOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UploadArchiveOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadArchiveOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadArchiveOutputResponse(archiveId: \(String(describing: archiveId)), checksum: \(String(describing: checksum)), location: \(String(describing: location)))"}
}

extension UploadArchiveOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let archiveIdHeaderValue = httpResponse.headers.value(for: "x-amz-archive-id") {
            self.archiveId = archiveIdHeaderValue
        } else {
            self.archiveId = nil
        }
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-sha256-tree-hash") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
///          <p>For information about the underlying REST API, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/api-archive-post.html">Upload Archive</a>. For
///          conceptual information, see <a href="https://docs.aws.amazon.com/amazonglacier/latest/dev/working-with-archives.html">Working with Archives in
///             Amazon S3 Glacier</a>.</p>
public struct UploadArchiveOutputResponse: Equatable {
    /// <p>The ID of the archive. This value is also included as part of the location.</p>
    public let archiveId: String?
    /// <p>The checksum of the archive computed by Amazon S3 Glacier.</p>
    public let checksum: String?
    /// <p>The relative URI path of the newly added archive resource.</p>
    public let location: String?

    public init (
        archiveId: String? = nil,
        checksum: String? = nil,
        location: String? = nil
    )
    {
        self.archiveId = archiveId
        self.checksum = checksum
        self.location = location
    }
}

struct UploadArchiveOutputResponseBody: Equatable {
}

extension UploadArchiveOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UploadListElement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case archiveDescription = "ArchiveDescription"
        case creationDate = "CreationDate"
        case multipartUploadId = "MultipartUploadId"
        case partSizeInBytes = "PartSizeInBytes"
        case vaultARN = "VaultARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveDescription = archiveDescription {
            try encodeContainer.encode(archiveDescription, forKey: .archiveDescription)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let multipartUploadId = multipartUploadId {
            try encodeContainer.encode(multipartUploadId, forKey: .multipartUploadId)
        }
        if partSizeInBytes != 0 {
            try encodeContainer.encode(partSizeInBytes, forKey: .partSizeInBytes)
        }
        if let vaultARN = vaultARN {
            try encodeContainer.encode(vaultARN, forKey: .vaultARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let multipartUploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .multipartUploadId)
        multipartUploadId = multipartUploadIdDecoded
        let vaultARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vaultARN)
        vaultARN = vaultARNDecoded
        let archiveDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .archiveDescription)
        archiveDescription = archiveDescriptionDecoded
        let partSizeInBytesDecoded = try containerValues.decode(Int.self, forKey: .partSizeInBytes)
        partSizeInBytes = partSizeInBytesDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension UploadListElement: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadListElement(archiveDescription: \(String(describing: archiveDescription)), creationDate: \(String(describing: creationDate)), multipartUploadId: \(String(describing: multipartUploadId)), partSizeInBytes: \(String(describing: partSizeInBytes)), vaultARN: \(String(describing: vaultARN)))"}
}

/// <p>A list of in-progress multipart uploads for a vault.</p>
public struct UploadListElement: Equatable {
    /// <p>The description of the archive that was specified in the Initiate Multipart Upload
    ///          request.</p>
    public let archiveDescription: String?
    /// <p>The UTC time at which the multipart upload was initiated.</p>
    public let creationDate: String?
    /// <p>The ID of a multipart upload.</p>
    public let multipartUploadId: String?
    /// <p>The part size, in bytes, specified in the Initiate Multipart Upload request. This is
    ///          the size of all the parts in the upload except the last part, which may be smaller than
    ///          this size.</p>
    public let partSizeInBytes: Int
    /// <p>The Amazon Resource Name (ARN) of the vault that contains the archive.</p>
    public let vaultARN: String?

    public init (
        archiveDescription: String? = nil,
        creationDate: String? = nil,
        multipartUploadId: String? = nil,
        partSizeInBytes: Int = 0,
        vaultARN: String? = nil
    )
    {
        self.archiveDescription = archiveDescription
        self.creationDate = creationDate
        self.multipartUploadId = multipartUploadId
        self.partSizeInBytes = partSizeInBytes
        self.vaultARN = vaultARN
    }
}

public struct UploadMultipartPartInputBodyMiddleware: Middleware {
    public let id: String = "UploadMultipartPartInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadMultipartPartInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadMultipartPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let body = input.operationInput.body {
            let data = body
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadMultipartPartInput>
    public typealias MOutput = OperationOutput<UploadMultipartPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadMultipartPartOutputError>
}

extension UploadMultipartPartInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadMultipartPartInput(accountId: \(String(describing: accountId)), body: \(String(describing: body)), checksum: \(String(describing: checksum)), range: \(String(describing: range)), uploadId: \(String(describing: uploadId)), vaultName: \(String(describing: vaultName)))"}
}

extension UploadMultipartPartInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
    }
}

public struct UploadMultipartPartInputHeadersMiddleware: Middleware {
    public let id: String = "UploadMultipartPartInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadMultipartPartInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadMultipartPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let checksum = input.operationInput.checksum {
            input.builder.withHeader(name: "x-amz-sha256-tree-hash", value: String(checksum))
        }
        if let range = input.operationInput.range {
            input.builder.withHeader(name: "Content-Range", value: String(range))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadMultipartPartInput>
    public typealias MOutput = OperationOutput<UploadMultipartPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadMultipartPartOutputError>
}

public struct UploadMultipartPartInputQueryItemMiddleware: Middleware {
    public let id: String = "UploadMultipartPartInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadMultipartPartInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadMultipartPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadMultipartPartInput>
    public typealias MOutput = OperationOutput<UploadMultipartPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadMultipartPartOutputError>
}

/// <p>Provides options to upload a part of an archive in a multipart upload
///          operation.</p>
public struct UploadMultipartPartInput: Equatable {
    /// <p>The <code>AccountId</code> value is the AWS account ID of the account that owns the
    ///          vault. You can either specify an AWS account ID or optionally a single '<code>-</code>'
    ///          (hyphen), in which case Amazon S3 Glacier uses the AWS account ID associated with the
    ///          credentials used to sign the request. If you use an account ID, do not include any hyphens
    ///          ('-') in the ID. </p>
    public let accountId: String?
    /// <p>The data to upload.</p>
    public let body: Data?
    /// <p>The SHA256 tree hash of the data being uploaded.</p>
    public let checksum: String?
    /// <p>Identifies the range of bytes in the assembled archive that will be uploaded in this
    ///          part. Amazon S3 Glacier uses this information to assemble the archive in the proper sequence.
    ///          The format of this header follows RFC 2616. An example header is Content-Range:bytes
    ///          0-4194303/*.</p>
    public let range: String?
    /// <p>The upload ID of the multipart upload.</p>
    public let uploadId: String?
    /// <p>The name of the vault.</p>
    public let vaultName: String?

    public init (
        accountId: String? = nil,
        body: Data? = nil,
        checksum: String? = nil,
        range: String? = nil,
        uploadId: String? = nil,
        vaultName: String? = nil
    )
    {
        self.accountId = accountId
        self.body = body
        self.checksum = checksum
        self.range = range
        self.uploadId = uploadId
        self.vaultName = vaultName
    }
}

struct UploadMultipartPartInputBody: Equatable {
    public let body: Data?
}

extension UploadMultipartPartInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension UploadMultipartPartOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UploadMultipartPartOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingParameterValueException" : self = .missingParameterValueException(try MissingParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UploadMultipartPartOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case missingParameterValueException(MissingParameterValueException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadMultipartPartOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadMultipartPartOutputResponse(checksum: \(String(describing: checksum)))"}
}

extension UploadMultipartPartOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-sha256-tree-hash") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
    }
}

/// <p>Contains the Amazon S3 Glacier response to your request.</p>
public struct UploadMultipartPartOutputResponse: Equatable {
    /// <p>The SHA256 tree hash that Amazon S3 Glacier computed for the uploaded part.</p>
    public let checksum: String?

    public init (
        checksum: String? = nil
    )
    {
        self.checksum = checksum
    }
}

struct UploadMultipartPartOutputResponseBody: Equatable {
}

extension UploadMultipartPartOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension VaultAccessPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension VaultAccessPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VaultAccessPolicy(policy: \(String(describing: policy)))"}
}

/// <p>Contains the vault access policy.</p>
public struct VaultAccessPolicy: Equatable {
    /// <p>The vault access policy.</p>
    public let policy: String?

    public init (
        policy: String? = nil
    )
    {
        self.policy = policy
    }
}

extension VaultLockPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension VaultLockPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VaultLockPolicy(policy: \(String(describing: policy)))"}
}

/// <p>Contains the vault lock policy.</p>
public struct VaultLockPolicy: Equatable {
    /// <p>The vault lock policy.</p>
    public let policy: String?

    public init (
        policy: String? = nil
    )
    {
        self.policy = policy
    }
}

extension VaultNotificationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case events = "Events"
        case sNSTopic = "SNSTopic"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for notificationeventlist0 in events {
                try eventsContainer.encode(notificationeventlist0)
            }
        }
        if let sNSTopic = sNSTopic {
            try encodeContainer.encode(sNSTopic, forKey: .sNSTopic)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sNSTopicDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sNSTopic)
        sNSTopic = sNSTopicDecoded
        let eventsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .events)
        var eventsDecoded0:[String]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [String]()
            for string0 in eventsContainer {
                if let string0 = string0 {
                    eventsDecoded0?.append(string0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension VaultNotificationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VaultNotificationConfig(events: \(String(describing: events)), sNSTopic: \(String(describing: sNSTopic)))"}
}

/// <p>Represents a vault's notification configuration.</p>
public struct VaultNotificationConfig: Equatable {
    /// <p>A list of one or more events for which Amazon S3 Glacier will send a notification to the
    ///          specified Amazon SNS topic.</p>
    public let events: [String]?
    /// <p>The Amazon Simple Notification Service (Amazon SNS) topic Amazon Resource Name
    ///          (ARN).</p>
    public let sNSTopic: String?

    public init (
        events: [String]? = nil,
        sNSTopic: String? = nil
    )
    {
        self.events = events
        self.sNSTopic = sNSTopic
    }
}
