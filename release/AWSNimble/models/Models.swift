// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcceptEulasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eulaIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eulaIds = eulaIds {
            var eulaIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eulaIds)
            for eulaidlist0 in eulaIds {
                try eulaIdsContainer.encode(eulaidlist0)
            }
        }
    }
}

extension AcceptEulasInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension AcceptEulasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/eula-acceptances"
    }
}

///
public struct AcceptEulasInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The EULA ID.
    public var eulaIds: [Swift.String]?
    /// A collection of EULA IDs.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        eulaIds: [Swift.String]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.eulaIds = eulaIds
        self.studioId = studioId
    }
}

struct AcceptEulasInputBody: Swift.Equatable {
    let eulaIds: [Swift.String]?
}

extension AcceptEulasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eulaIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulaIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eulaIds)
        var eulaIdsDecoded0:[Swift.String]? = nil
        if let eulaIdsContainer = eulaIdsContainer {
            eulaIdsDecoded0 = [Swift.String]()
            for string0 in eulaIdsContainer {
                if let string0 = string0 {
                    eulaIdsDecoded0?.append(string0)
                }
            }
        }
        eulaIds = eulaIdsDecoded0
    }
}

extension AcceptEulasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptEulasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptEulasOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptEulasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AcceptEulasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eulaAcceptances = output.eulaAcceptances
        } else {
            self.eulaAcceptances = nil
        }
    }
}

///
public struct AcceptEulasOutputResponse: Swift.Equatable {
    /// A collection of EULA acceptances.
    public var eulaAcceptances: [NimbleClientTypes.EulaAcceptance]?

    public init (
        eulaAcceptances: [NimbleClientTypes.EulaAcceptance]? = nil
    )
    {
        self.eulaAcceptances = eulaAcceptances
    }
}

struct AcceptEulasOutputResponseBody: Swift.Equatable {
    let eulaAcceptances: [NimbleClientTypes.EulaAcceptance]?
}

extension AcceptEulasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eulaAcceptances
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulaAcceptancesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.EulaAcceptance?].self, forKey: .eulaAcceptances)
        var eulaAcceptancesDecoded0:[NimbleClientTypes.EulaAcceptance]? = nil
        if let eulaAcceptancesContainer = eulaAcceptancesContainer {
            eulaAcceptancesDecoded0 = [NimbleClientTypes.EulaAcceptance]()
            for structure0 in eulaAcceptancesContainer {
                if let structure0 = structure0 {
                    eulaAcceptancesDecoded0?.append(structure0)
                }
            }
        }
        eulaAcceptances = eulaAcceptancesDecoded0
    }
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are not authorized to perform this operation. Check your IAM policies, and ensure that you are using the correct access keys.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A more specific error code.
    public var code: Swift.String?
    /// The exception context.
    public var context: [Swift.String:Swift.String]?
    /// A human-readable description of the error.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let context: [Swift.String:Swift.String]?
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case context
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NimbleClientTypes.ActiveDirectoryComputerAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension NimbleClientTypes {
    /// An LDAP attribute of an Active Directory computer account, in the form of a name:value pair.
    public struct ActiveDirectoryComputerAttribute: Swift.Equatable {
        /// The name for the LDAP attribute.
        public var name: Swift.String?
        /// The value for the LDAP attribute.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension NimbleClientTypes.ActiveDirectoryConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computerAttributes
        case directoryId
        case organizationalUnitDistinguishedName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computerAttributes = computerAttributes {
            var computerAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .computerAttributes)
            for activedirectorycomputerattributelist0 in computerAttributes {
                try computerAttributesContainer.encode(activedirectorycomputerattributelist0)
            }
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let organizationalUnitDistinguishedName = organizationalUnitDistinguishedName {
            try encodeContainer.encode(organizationalUnitDistinguishedName, forKey: .organizationalUnitDistinguishedName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computerAttributesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.ActiveDirectoryComputerAttribute?].self, forKey: .computerAttributes)
        var computerAttributesDecoded0:[NimbleClientTypes.ActiveDirectoryComputerAttribute]? = nil
        if let computerAttributesContainer = computerAttributesContainer {
            computerAttributesDecoded0 = [NimbleClientTypes.ActiveDirectoryComputerAttribute]()
            for structure0 in computerAttributesContainer {
                if let structure0 = structure0 {
                    computerAttributesDecoded0?.append(structure0)
                }
            }
        }
        computerAttributes = computerAttributesDecoded0
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let organizationalUnitDistinguishedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnitDistinguishedName)
        organizationalUnitDistinguishedName = organizationalUnitDistinguishedNameDecoded
    }
}

extension NimbleClientTypes {
    /// The configuration for a Microsoft Active Directory (Microsoft AD) studio resource.
    public struct ActiveDirectoryConfiguration: Swift.Equatable {
        /// A collection of custom attributes for an Active Directory computer.
        public var computerAttributes: [NimbleClientTypes.ActiveDirectoryComputerAttribute]?
        /// The directory ID of the Directory Service for Microsoft Active Directory to access using this studio component.
        public var directoryId: Swift.String?
        /// The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.
        public var organizationalUnitDistinguishedName: Swift.String?

        public init (
            computerAttributes: [NimbleClientTypes.ActiveDirectoryComputerAttribute]? = nil,
            directoryId: Swift.String? = nil,
            organizationalUnitDistinguishedName: Swift.String? = nil
        )
        {
            self.computerAttributes = computerAttributes
            self.directoryId = directoryId
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
        }
    }

}

extension NimbleClientTypes.ComputeFarmConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDirectoryUser
        case endpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDirectoryUser = activeDirectoryUser {
            try encodeContainer.encode(activeDirectoryUser, forKey: .activeDirectoryUser)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDirectoryUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activeDirectoryUser)
        activeDirectoryUser = activeDirectoryUserDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension NimbleClientTypes.ComputeFarmConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComputeFarmConfiguration(activeDirectoryUser: \(Swift.String(describing: activeDirectoryUser)), endpoint: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// The configuration for a render farm that is associated with a studio resource.
    public struct ComputeFarmConfiguration: Swift.Equatable {
        /// The name of an Active Directory user that is used on ComputeFarm worker instances.
        public var activeDirectoryUser: Swift.String?
        /// The endpoint of the ComputeFarm that is accessed by the studio component resource.
        public var endpoint: Swift.String?

        public init (
            activeDirectoryUser: Swift.String? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.activeDirectoryUser = activeDirectoryUser
            self.endpoint = endpoint
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Another operation is in progress.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A more specific error code.
    public var code: Swift.String?
    /// The exception context.
    public var context: [Swift.String:Swift.String]?
    /// A human-readable description of the error.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let context: [Swift.String:Swift.String]?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case context
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateLaunchProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case ec2SubnetIds
        case launchProfileProtocolVersions
        case name
        case streamConfiguration
        case studioComponentIds
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SubnetIds = ec2SubnetIds {
            var ec2SubnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SubnetIds)
            for ec2subnetidlist0 in ec2SubnetIds {
                try ec2SubnetIdsContainer.encode(ec2subnetidlist0)
            }
        }
        if let launchProfileProtocolVersions = launchProfileProtocolVersions {
            var launchProfileProtocolVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchProfileProtocolVersions)
            for launchprofileprotocolversionlist0 in launchProfileProtocolVersions {
                try launchProfileProtocolVersionsContainer.encode(launchprofileprotocolversionlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let streamConfiguration = streamConfiguration {
            try encodeContainer.encode(streamConfiguration, forKey: .streamConfiguration)
        }
        if let studioComponentIds = studioComponentIds {
            var studioComponentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .studioComponentIds)
            for launchprofilestudiocomponentidlist0 in studioComponentIds {
                try studioComponentIdsContainer.encode(launchprofilestudiocomponentidlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateLaunchProfileInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateLaunchProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles"
    }
}

///
public struct CreateLaunchProfileInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// Specifies the IDs of the EC2 subnets where streaming sessions will be accessible from. These subnets must support the specified instance types.
    /// This member is required.
    public var ec2SubnetIds: [Swift.String]?
    /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
    /// This member is required.
    public var launchProfileProtocolVersions: [Swift.String]?
    /// The name for the launch profile.
    /// This member is required.
    public var name: Swift.String?
    /// A configuration for a streaming session.
    /// This member is required.
    public var streamConfiguration: NimbleClientTypes.StreamConfigurationCreate?
    /// Unique identifiers for a collection of studio components that can be used with this launch profile.
    /// This member is required.
    public var studioComponentIds: [Swift.String]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// A collection of labels, in the form of key:value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        ec2SubnetIds: [Swift.String]? = nil,
        launchProfileProtocolVersions: [Swift.String]? = nil,
        name: Swift.String? = nil,
        streamConfiguration: NimbleClientTypes.StreamConfigurationCreate? = nil,
        studioComponentIds: [Swift.String]? = nil,
        studioId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.ec2SubnetIds = ec2SubnetIds
        self.launchProfileProtocolVersions = launchProfileProtocolVersions
        self.name = name
        self.streamConfiguration = streamConfiguration
        self.studioComponentIds = studioComponentIds
        self.studioId = studioId
        self.tags = tags
    }
}

struct CreateLaunchProfileInputBody: Swift.Equatable {
    let description: Swift.String?
    let ec2SubnetIds: [Swift.String]?
    let launchProfileProtocolVersions: [Swift.String]?
    let name: Swift.String?
    let streamConfiguration: NimbleClientTypes.StreamConfigurationCreate?
    let studioComponentIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateLaunchProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case ec2SubnetIds
        case launchProfileProtocolVersions
        case name
        case streamConfiguration
        case studioComponentIds
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SubnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SubnetIds)
        var ec2SubnetIdsDecoded0:[Swift.String]? = nil
        if let ec2SubnetIdsContainer = ec2SubnetIdsContainer {
            ec2SubnetIdsDecoded0 = [Swift.String]()
            for string0 in ec2SubnetIdsContainer {
                if let string0 = string0 {
                    ec2SubnetIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SubnetIds = ec2SubnetIdsDecoded0
        let launchProfileProtocolVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .launchProfileProtocolVersions)
        var launchProfileProtocolVersionsDecoded0:[Swift.String]? = nil
        if let launchProfileProtocolVersionsContainer = launchProfileProtocolVersionsContainer {
            launchProfileProtocolVersionsDecoded0 = [Swift.String]()
            for string0 in launchProfileProtocolVersionsContainer {
                if let string0 = string0 {
                    launchProfileProtocolVersionsDecoded0?.append(string0)
                }
            }
        }
        launchProfileProtocolVersions = launchProfileProtocolVersionsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let streamConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamConfigurationCreate.self, forKey: .streamConfiguration)
        streamConfiguration = streamConfigurationDecoded
        let studioComponentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .studioComponentIds)
        var studioComponentIdsDecoded0:[Swift.String]? = nil
        if let studioComponentIdsContainer = studioComponentIdsContainer {
            studioComponentIdsDecoded0 = [Swift.String]()
            for string0 in studioComponentIdsContainer {
                if let string0 = string0 {
                    studioComponentIdsDecoded0?.append(string0)
                }
            }
        }
        studioComponentIds = studioComponentIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLaunchProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLaunchProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLaunchProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLaunchProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLaunchProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
        } else {
            self.launchProfile = nil
        }
    }
}

///
public struct CreateLaunchProfileOutputResponse: Swift.Equatable {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?

    public init (
        launchProfile: NimbleClientTypes.LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

struct CreateLaunchProfileOutputResponseBody: Swift.Equatable {
    let launchProfile: NimbleClientTypes.LaunchProfile?
}

extension CreateLaunchProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
    }
}

extension CreateStreamingImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingImageInput(clientToken: \(Swift.String(describing: clientToken)), ec2ImageId: \(Swift.String(describing: ec2ImageId)), studioId: \(Swift.String(describing: studioId)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateStreamingImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case ec2ImageId
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2ImageId = ec2ImageId {
            try encodeContainer.encode(ec2ImageId, forKey: .ec2ImageId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateStreamingImageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateStreamingImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images"
    }
}

///
public struct CreateStreamingImageInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// A human-readable description of the streaming image.
    public var description: Swift.String?
    /// The ID of an EC2 machine image with which to create this streaming image.
    /// This member is required.
    public var ec2ImageId: Swift.String?
    /// A friendly name for a streaming image resource.
    /// This member is required.
    public var name: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// A collection of labels, in the form of key:value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        ec2ImageId: Swift.String? = nil,
        name: Swift.String? = nil,
        studioId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.ec2ImageId = ec2ImageId
        self.name = name
        self.studioId = studioId
        self.tags = tags
    }
}

struct CreateStreamingImageInputBody: Swift.Equatable {
    let description: Swift.String?
    let ec2ImageId: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStreamingImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case ec2ImageId
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2ImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2ImageId)
        ec2ImageId = ec2ImageIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStreamingImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamingImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingImageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStreamingImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingImage = output.streamingImage
        } else {
            self.streamingImage = nil
        }
    }
}

///
public struct CreateStreamingImageOutputResponse: Swift.Equatable {
    /// The streaming image.
    public var streamingImage: NimbleClientTypes.StreamingImage?

    public init (
        streamingImage: NimbleClientTypes.StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

struct CreateStreamingImageOutputResponseBody: Swift.Equatable {
    let streamingImage: NimbleClientTypes.StreamingImage?
}

extension CreateStreamingImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingImage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingImageDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImage.self, forKey: .streamingImage)
        streamingImage = streamingImageDecoded
    }
}

extension CreateStreamingSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2InstanceType
        case launchProfileId
        case ownedBy
        case streamingImageId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2InstanceType = ec2InstanceType {
            try encodeContainer.encode(ec2InstanceType.rawValue, forKey: .ec2InstanceType)
        }
        if let launchProfileId = launchProfileId {
            try encodeContainer.encode(launchProfileId, forKey: .launchProfileId)
        }
        if let ownedBy = ownedBy {
            try encodeContainer.encode(ownedBy, forKey: .ownedBy)
        }
        if let streamingImageId = streamingImageId {
            try encodeContainer.encode(streamingImageId, forKey: .streamingImageId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateStreamingSessionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateStreamingSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions"
    }
}

///
public struct CreateStreamingSessionInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The EC2 Instance type used for the streaming session.
    public var ec2InstanceType: NimbleClientTypes.StreamingInstanceType?
    /// The launch profile ID.
    public var launchProfileId: Swift.String?
    /// The user ID of the user that owns the streaming session.
    public var ownedBy: Swift.String?
    /// The ID of the streaming image.
    public var streamingImageId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// A collection of labels, in the form of key:value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        ec2InstanceType: NimbleClientTypes.StreamingInstanceType? = nil,
        launchProfileId: Swift.String? = nil,
        ownedBy: Swift.String? = nil,
        streamingImageId: Swift.String? = nil,
        studioId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.ec2InstanceType = ec2InstanceType
        self.launchProfileId = launchProfileId
        self.ownedBy = ownedBy
        self.streamingImageId = streamingImageId
        self.studioId = studioId
        self.tags = tags
    }
}

struct CreateStreamingSessionInputBody: Swift.Equatable {
    let ec2InstanceType: NimbleClientTypes.StreamingInstanceType?
    let launchProfileId: Swift.String?
    let ownedBy: Swift.String?
    let streamingImageId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStreamingSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2InstanceType
        case launchProfileId
        case ownedBy
        case streamingImageId
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2InstanceTypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingInstanceType.self, forKey: .ec2InstanceType)
        ec2InstanceType = ec2InstanceTypeDecoded
        let launchProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileId)
        launchProfileId = launchProfileIdDecoded
        let ownedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownedBy)
        ownedBy = ownedByDecoded
        let streamingImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingImageId)
        streamingImageId = streamingImageIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStreamingSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamingSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStreamingSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

///
public struct CreateStreamingSessionOutputResponse: Swift.Equatable {
    /// The session.
    public var session: NimbleClientTypes.StreamingSession?

    public init (
        session: NimbleClientTypes.StreamingSession? = nil
    )
    {
        self.session = session
    }
}

struct CreateStreamingSessionOutputResponseBody: Swift.Equatable {
    let session: NimbleClientTypes.StreamingSession?
}

extension CreateStreamingSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSession.self, forKey: .session)
        session = sessionDecoded
    }
}

extension CreateStreamingSessionStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expirationInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expirationInSeconds = expirationInSeconds {
            try encodeContainer.encode(expirationInSeconds, forKey: .expirationInSeconds)
        }
    }
}

extension CreateStreamingSessionStreamInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateStreamingSessionStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())/streams"
    }
}

///
public struct CreateStreamingSessionStreamInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The expiration time in seconds.
    public var expirationInSeconds: Swift.Int?
    /// The streaming session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        expirationInSeconds: Swift.Int? = nil,
        sessionId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.expirationInSeconds = expirationInSeconds
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

struct CreateStreamingSessionStreamInputBody: Swift.Equatable {
    let expirationInSeconds: Swift.Int?
}

extension CreateStreamingSessionStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expirationInSeconds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expirationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expirationInSeconds)
        expirationInSeconds = expirationInSecondsDecoded
    }
}

extension CreateStreamingSessionStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamingSessionStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingSessionStreamOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingSessionStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStreamingSessionStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stream = output.stream
        } else {
            self.stream = nil
        }
    }
}

///
public struct CreateStreamingSessionStreamOutputResponse: Swift.Equatable {
    /// The stream.
    public var stream: NimbleClientTypes.StreamingSessionStream?

    public init (
        stream: NimbleClientTypes.StreamingSessionStream? = nil
    )
    {
        self.stream = stream
    }
}

struct CreateStreamingSessionStreamOutputResponseBody: Swift.Equatable {
    let stream: NimbleClientTypes.StreamingSessionStream?
}

extension CreateStreamingSessionStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stream
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionStream.self, forKey: .stream)
        stream = streamDecoded
    }
}

extension CreateStudioComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case description
        case ec2SecurityGroupIds
        case initializationScripts
        case name
        case scriptParameters
        case subtype
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SecurityGroupIds = ec2SecurityGroupIds {
            var ec2SecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SecurityGroupIds)
            for studiocomponentsecuritygroupidlist0 in ec2SecurityGroupIds {
                try ec2SecurityGroupIdsContainer.encode(studiocomponentsecuritygroupidlist0)
            }
        }
        if let initializationScripts = initializationScripts {
            var initializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .initializationScripts)
            for studiocomponentinitializationscriptlist0 in initializationScripts {
                try initializationScriptsContainer.encode(studiocomponentinitializationscriptlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scriptParameters = scriptParameters {
            var scriptParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scriptParameters)
            for studiocomponentscriptparameterkeyvaluelist0 in scriptParameters {
                try scriptParametersContainer.encode(studiocomponentscriptparameterkeyvaluelist0)
            }
        }
        if let subtype = subtype {
            try encodeContainer.encode(subtype.rawValue, forKey: .subtype)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateStudioComponentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateStudioComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components"
    }
}

///
public struct CreateStudioComponentInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The configuration of the studio component, based on component type.
    public var configuration: NimbleClientTypes.StudioComponentConfiguration?
    /// The description.
    public var description: Swift.String?
    /// The EC2 security groups that control access to the studio component.
    public var ec2SecurityGroupIds: [Swift.String]?
    /// Initialization scripts for studio components.
    public var initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]?
    /// The name for the studio component.
    /// This member is required.
    public var name: Swift.String?
    /// Parameters for the studio component scripts.
    public var scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// The specific subtype of a studio component.
    public var subtype: NimbleClientTypes.StudioComponentSubtype?
    /// A collection of labels, in the form of key:value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the studio component.
    /// This member is required.
    public var type: NimbleClientTypes.StudioComponentType?

    public init (
        clientToken: Swift.String? = nil,
        configuration: NimbleClientTypes.StudioComponentConfiguration? = nil,
        description: Swift.String? = nil,
        ec2SecurityGroupIds: [Swift.String]? = nil,
        initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]? = nil,
        name: Swift.String? = nil,
        scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]? = nil,
        studioId: Swift.String? = nil,
        subtype: NimbleClientTypes.StudioComponentSubtype? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: NimbleClientTypes.StudioComponentType? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.ec2SecurityGroupIds = ec2SecurityGroupIds
        self.initializationScripts = initializationScripts
        self.name = name
        self.scriptParameters = scriptParameters
        self.studioId = studioId
        self.subtype = subtype
        self.tags = tags
        self.type = type
    }
}

struct CreateStudioComponentInputBody: Swift.Equatable {
    let configuration: NimbleClientTypes.StudioComponentConfiguration?
    let description: Swift.String?
    let ec2SecurityGroupIds: [Swift.String]?
    let initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]?
    let name: Swift.String?
    let scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]?
    let subtype: NimbleClientTypes.StudioComponentSubtype?
    let tags: [Swift.String:Swift.String]?
    let type: NimbleClientTypes.StudioComponentType?
}

extension CreateStudioComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case description
        case ec2SecurityGroupIds
        case initializationScripts
        case name
        case scriptParameters
        case subtype
        case tags
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SecurityGroupIds)
        var ec2SecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let ec2SecurityGroupIdsContainer = ec2SecurityGroupIdsContainer {
            ec2SecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in ec2SecurityGroupIdsContainer {
                if let string0 = string0 {
                    ec2SecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SecurityGroupIds = ec2SecurityGroupIdsDecoded0
        let initializationScriptsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioComponentInitializationScript?].self, forKey: .initializationScripts)
        var initializationScriptsDecoded0:[NimbleClientTypes.StudioComponentInitializationScript]? = nil
        if let initializationScriptsContainer = initializationScriptsContainer {
            initializationScriptsDecoded0 = [NimbleClientTypes.StudioComponentInitializationScript]()
            for structure0 in initializationScriptsContainer {
                if let structure0 = structure0 {
                    initializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        initializationScripts = initializationScriptsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let scriptParametersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.ScriptParameterKeyValue?].self, forKey: .scriptParameters)
        var scriptParametersDecoded0:[NimbleClientTypes.ScriptParameterKeyValue]? = nil
        if let scriptParametersContainer = scriptParametersContainer {
            scriptParametersDecoded0 = [NimbleClientTypes.ScriptParameterKeyValue]()
            for structure0 in scriptParametersContainer {
                if let structure0 = structure0 {
                    scriptParametersDecoded0?.append(structure0)
                }
            }
        }
        scriptParameters = scriptParametersDecoded0
        let subtypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentSubtype.self, forKey: .subtype)
        subtype = subtypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateStudioComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStudioComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStudioComponentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStudioComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStudioComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studioComponent = output.studioComponent
        } else {
            self.studioComponent = nil
        }
    }
}

///
public struct CreateStudioComponentOutputResponse: Swift.Equatable {
    /// Information about the studio component.
    public var studioComponent: NimbleClientTypes.StudioComponent?

    public init (
        studioComponent: NimbleClientTypes.StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

struct CreateStudioComponentOutputResponseBody: Swift.Equatable {
    let studioComponent: NimbleClientTypes.StudioComponent?
}

extension CreateStudioComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studioComponent
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioComponentDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponent.self, forKey: .studioComponent)
        studioComponent = studioComponentDecoded
    }
}

extension CreateStudioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStudioInput(adminRoleArn: \(Swift.String(describing: adminRoleArn)), clientToken: \(Swift.String(describing: clientToken)), studioEncryptionConfiguration: \(Swift.String(describing: studioEncryptionConfiguration)), studioName: \(Swift.String(describing: studioName)), tags: \(Swift.String(describing: tags)), userRoleArn: \(Swift.String(describing: userRoleArn)), displayName: \"CONTENT_REDACTED\")"}
}

extension CreateStudioInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminRoleArn
        case displayName
        case studioEncryptionConfiguration
        case studioName
        case tags
        case userRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminRoleArn = adminRoleArn {
            try encodeContainer.encode(adminRoleArn, forKey: .adminRoleArn)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let studioEncryptionConfiguration = studioEncryptionConfiguration {
            try encodeContainer.encode(studioEncryptionConfiguration, forKey: .studioEncryptionConfiguration)
        }
        if let studioName = studioName {
            try encodeContainer.encode(studioName, forKey: .studioName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let userRoleArn = userRoleArn {
            try encodeContainer.encode(userRoleArn, forKey: .userRoleArn)
        }
    }
}

extension CreateStudioInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateStudioInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-08-01/studios"
    }
}

///
public struct CreateStudioInput: Swift.Equatable {
    /// The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.
    /// This member is required.
    public var adminRoleArn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// A friendly name for the studio.
    /// This member is required.
    public var displayName: Swift.String?
    /// The studio encryption configuration.
    public var studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration?
    /// The studio name that is used in the URL of the Nimble Studio portal when accessed by Nimble Studio users.
    /// This member is required.
    public var studioName: Swift.String?
    /// A collection of labels, in the form of key:value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.
    /// This member is required.
    public var userRoleArn: Swift.String?

    public init (
        adminRoleArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration? = nil,
        studioName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userRoleArn: Swift.String? = nil
    )
    {
        self.adminRoleArn = adminRoleArn
        self.clientToken = clientToken
        self.displayName = displayName
        self.studioEncryptionConfiguration = studioEncryptionConfiguration
        self.studioName = studioName
        self.tags = tags
        self.userRoleArn = userRoleArn
    }
}

struct CreateStudioInputBody: Swift.Equatable {
    let adminRoleArn: Swift.String?
    let displayName: Swift.String?
    let studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration?
    let studioName: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let userRoleArn: Swift.String?
}

extension CreateStudioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminRoleArn
        case displayName
        case studioEncryptionConfiguration
        case studioName
        case tags
        case userRoleArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminRoleArn)
        adminRoleArn = adminRoleArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let studioEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioEncryptionConfiguration.self, forKey: .studioEncryptionConfiguration)
        studioEncryptionConfiguration = studioEncryptionConfigurationDecoded
        let studioNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioName)
        studioName = studioNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let userRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userRoleArn)
        userRoleArn = userRoleArnDecoded
    }
}

extension CreateStudioOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStudioOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStudioOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStudioOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStudioOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

///
public struct CreateStudioOutputResponse: Swift.Equatable {
    /// Information about a studio.
    public var studio: NimbleClientTypes.Studio?

    public init (
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct CreateStudioOutputResponseBody: Swift.Equatable {
    let studio: NimbleClientTypes.Studio?
}

extension CreateStudioOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studio
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

extension DeleteLaunchProfileInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteLaunchProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())"
    }
}

public struct DeleteLaunchProfileInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The Launch Profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.launchProfileId = launchProfileId
        self.studioId = studioId
    }
}

struct DeleteLaunchProfileInputBody: Swift.Equatable {
}

extension DeleteLaunchProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLaunchProfileMemberInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteLaunchProfileMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        guard let principalId = principalId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
    }
}

public struct DeleteLaunchProfileMemberInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The Launch Profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The principal ID. This currently supports a Amazon Web Services SSO UserId.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.launchProfileId = launchProfileId
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct DeleteLaunchProfileMemberInputBody: Swift.Equatable {
}

extension DeleteLaunchProfileMemberInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLaunchProfileMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLaunchProfileMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLaunchProfileMemberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLaunchProfileMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct DeleteLaunchProfileMemberOutputResponse: Swift.Equatable {

}

extension DeleteLaunchProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLaunchProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLaunchProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLaunchProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteLaunchProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
        } else {
            self.launchProfile = nil
        }
    }
}

///
public struct DeleteLaunchProfileOutputResponse: Swift.Equatable {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?

    public init (
        launchProfile: NimbleClientTypes.LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

struct DeleteLaunchProfileOutputResponseBody: Swift.Equatable {
    let launchProfile: NimbleClientTypes.LaunchProfile?
}

extension DeleteLaunchProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
    }
}

extension DeleteStreamingImageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteStreamingImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let streamingImageId = streamingImageId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images/\(streamingImageId.urlPercentEncoding())"
    }
}

public struct DeleteStreamingImageInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The streaming image ID.
    /// This member is required.
    public var streamingImageId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        streamingImageId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.streamingImageId = streamingImageId
        self.studioId = studioId
    }
}

struct DeleteStreamingImageInputBody: Swift.Equatable {
}

extension DeleteStreamingImageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStreamingImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStreamingImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStreamingImageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamingImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteStreamingImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingImage = output.streamingImage
        } else {
            self.streamingImage = nil
        }
    }
}

///
public struct DeleteStreamingImageOutputResponse: Swift.Equatable {
    /// The streaming image.
    public var streamingImage: NimbleClientTypes.StreamingImage?

    public init (
        streamingImage: NimbleClientTypes.StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

struct DeleteStreamingImageOutputResponseBody: Swift.Equatable {
    let streamingImage: NimbleClientTypes.StreamingImage?
}

extension DeleteStreamingImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingImage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingImageDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImage.self, forKey: .streamingImage)
        streamingImage = streamingImageDecoded
    }
}

extension DeleteStreamingSessionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteStreamingSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())"
    }
}

public struct DeleteStreamingSessionInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The streaming session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

struct DeleteStreamingSessionInputBody: Swift.Equatable {
}

extension DeleteStreamingSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStreamingSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStreamingSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStreamingSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamingSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteStreamingSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

///
public struct DeleteStreamingSessionOutputResponse: Swift.Equatable {
    /// The session.
    public var session: NimbleClientTypes.StreamingSession?

    public init (
        session: NimbleClientTypes.StreamingSession? = nil
    )
    {
        self.session = session
    }
}

struct DeleteStreamingSessionOutputResponseBody: Swift.Equatable {
    let session: NimbleClientTypes.StreamingSession?
}

extension DeleteStreamingSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSession.self, forKey: .session)
        session = sessionDecoded
    }
}

extension DeleteStudioComponentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteStudioComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let studioComponentId = studioComponentId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components/\(studioComponentId.urlPercentEncoding())"
    }
}

public struct DeleteStudioComponentInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The studio component ID.
    /// This member is required.
    public var studioComponentId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        studioComponentId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.studioComponentId = studioComponentId
        self.studioId = studioId
    }
}

struct DeleteStudioComponentInputBody: Swift.Equatable {
}

extension DeleteStudioComponentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStudioComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStudioComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStudioComponentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStudioComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteStudioComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studioComponent = output.studioComponent
        } else {
            self.studioComponent = nil
        }
    }
}

///
public struct DeleteStudioComponentOutputResponse: Swift.Equatable {
    /// Information about the studio component.
    public var studioComponent: NimbleClientTypes.StudioComponent?

    public init (
        studioComponent: NimbleClientTypes.StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

struct DeleteStudioComponentOutputResponseBody: Swift.Equatable {
    let studioComponent: NimbleClientTypes.StudioComponent?
}

extension DeleteStudioComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studioComponent
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioComponentDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponent.self, forKey: .studioComponent)
        studioComponent = studioComponentDecoded
    }
}

extension DeleteStudioInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteStudioInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())"
    }
}

public struct DeleteStudioInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.studioId = studioId
    }
}

struct DeleteStudioInputBody: Swift.Equatable {
}

extension DeleteStudioInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStudioMemberInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteStudioMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let principalId = principalId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
    }
}

public struct DeleteStudioMemberInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The principal ID. This currently supports a Amazon Web Services SSO UserId.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct DeleteStudioMemberInputBody: Swift.Equatable {
}

extension DeleteStudioMemberInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStudioMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStudioMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStudioMemberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStudioMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct DeleteStudioMemberOutputResponse: Swift.Equatable {

}

extension DeleteStudioOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStudioOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStudioOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStudioOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteStudioOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

///
public struct DeleteStudioOutputResponse: Swift.Equatable {
    /// Information about a studio.
    /// This member is required.
    public var studio: NimbleClientTypes.Studio?

    public init (
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct DeleteStudioOutputResponseBody: Swift.Equatable {
    let studio: NimbleClientTypes.Studio?
}

extension DeleteStudioOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studio
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

extension NimbleClientTypes.Eula: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case createdAt
        case eulaId
        case name
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let eulaId = eulaId {
            try encodeContainer.encode(eulaId, forKey: .eulaId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let eulaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eulaId)
        eulaId = eulaIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension NimbleClientTypes {
    /// Represents a EULA resource.
    public struct Eula: Swift.Equatable {
        /// The EULA content.
        public var content: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The EULA ID.
        public var eulaId: Swift.String?
        /// The name for the EULA.
        public var name: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        public var updatedAt: ClientRuntime.Date?

        public init (
            content: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            eulaId: Swift.String? = nil,
            name: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.content = content
            self.createdAt = createdAt
            self.eulaId = eulaId
            self.name = name
            self.updatedAt = updatedAt
        }
    }

}

extension NimbleClientTypes.EulaAcceptance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptedAt
        case acceptedBy
        case accepteeId
        case eulaAcceptanceId
        case eulaId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptedAt = acceptedAt {
            try encodeContainer.encode(acceptedAt.timeIntervalSince1970, forKey: .acceptedAt)
        }
        if let acceptedBy = acceptedBy {
            try encodeContainer.encode(acceptedBy, forKey: .acceptedBy)
        }
        if let accepteeId = accepteeId {
            try encodeContainer.encode(accepteeId, forKey: .accepteeId)
        }
        if let eulaAcceptanceId = eulaAcceptanceId {
            try encodeContainer.encode(eulaAcceptanceId, forKey: .eulaAcceptanceId)
        }
        if let eulaId = eulaId {
            try encodeContainer.encode(eulaId, forKey: .eulaId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .acceptedAt)
        acceptedAt = acceptedAtDecoded
        let acceptedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptedBy)
        acceptedBy = acceptedByDecoded
        let accepteeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accepteeId)
        accepteeId = accepteeIdDecoded
        let eulaAcceptanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eulaAcceptanceId)
        eulaAcceptanceId = eulaAcceptanceIdDecoded
        let eulaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eulaId)
        eulaId = eulaIdDecoded
    }
}

extension NimbleClientTypes {
    /// The acceptance of a EULA, required to use Amazon-provided streaming images.
    public struct EulaAcceptance: Swift.Equatable {
        /// The Unix epoch timestamp in seconds for when the EULA was accepted.
        public var acceptedAt: ClientRuntime.Date?
        /// The ID of the person who accepted the EULA.
        public var acceptedBy: Swift.String?
        /// The ID of the acceptee.
        public var accepteeId: Swift.String?
        /// The EULA acceptance ID.
        public var eulaAcceptanceId: Swift.String?
        /// The EULA ID.
        public var eulaId: Swift.String?

        public init (
            acceptedAt: ClientRuntime.Date? = nil,
            acceptedBy: Swift.String? = nil,
            accepteeId: Swift.String? = nil,
            eulaAcceptanceId: Swift.String? = nil,
            eulaId: Swift.String? = nil
        )
        {
            self.acceptedAt = acceptedAt
            self.acceptedBy = acceptedBy
            self.accepteeId = accepteeId
            self.eulaAcceptanceId = eulaAcceptanceId
            self.eulaId = eulaId
        }
    }

}

extension GetEulaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let eulaId = eulaId else {
            return nil
        }
        return "/2020-08-01/eulas/\(eulaId.urlPercentEncoding())"
    }
}

public struct GetEulaInput: Swift.Equatable {
    /// The EULA ID.
    /// This member is required.
    public var eulaId: Swift.String?

    public init (
        eulaId: Swift.String? = nil
    )
    {
        self.eulaId = eulaId
    }
}

struct GetEulaInputBody: Swift.Equatable {
}

extension GetEulaInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEulaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEulaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEulaOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEulaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEulaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eula = output.eula
        } else {
            self.eula = nil
        }
    }
}

///
public struct GetEulaOutputResponse: Swift.Equatable {
    /// The EULA.
    public var eula: NimbleClientTypes.Eula?

    public init (
        eula: NimbleClientTypes.Eula? = nil
    )
    {
        self.eula = eula
    }
}

struct GetEulaOutputResponseBody: Swift.Equatable {
    let eula: NimbleClientTypes.Eula?
}

extension GetEulaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eula
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulaDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.Eula.self, forKey: .eula)
        eula = eulaDecoded
    }
}

extension GetLaunchProfileDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/details"
    }
}

public struct GetLaunchProfileDetailsInput: Swift.Equatable {
    /// The Launch Profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        launchProfileId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.studioId = studioId
    }
}

struct GetLaunchProfileDetailsInputBody: Swift.Equatable {
}

extension GetLaunchProfileDetailsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLaunchProfileDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLaunchProfileDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLaunchProfileDetailsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLaunchProfileDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLaunchProfileDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
            self.streamingImages = output.streamingImages
            self.studioComponentSummaries = output.studioComponentSummaries
        } else {
            self.launchProfile = nil
            self.streamingImages = nil
            self.studioComponentSummaries = nil
        }
    }
}

///
public struct GetLaunchProfileDetailsOutputResponse: Swift.Equatable {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?
    /// A collection of streaming images.
    public var streamingImages: [NimbleClientTypes.StreamingImage]?
    /// A collection of studio component summaries.
    public var studioComponentSummaries: [NimbleClientTypes.StudioComponentSummary]?

    public init (
        launchProfile: NimbleClientTypes.LaunchProfile? = nil,
        streamingImages: [NimbleClientTypes.StreamingImage]? = nil,
        studioComponentSummaries: [NimbleClientTypes.StudioComponentSummary]? = nil
    )
    {
        self.launchProfile = launchProfile
        self.streamingImages = streamingImages
        self.studioComponentSummaries = studioComponentSummaries
    }
}

struct GetLaunchProfileDetailsOutputResponseBody: Swift.Equatable {
    let launchProfile: NimbleClientTypes.LaunchProfile?
    let streamingImages: [NimbleClientTypes.StreamingImage]?
    let studioComponentSummaries: [NimbleClientTypes.StudioComponentSummary]?
}

extension GetLaunchProfileDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfile
        case streamingImages
        case studioComponentSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
        let streamingImagesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StreamingImage?].self, forKey: .streamingImages)
        var streamingImagesDecoded0:[NimbleClientTypes.StreamingImage]? = nil
        if let streamingImagesContainer = streamingImagesContainer {
            streamingImagesDecoded0 = [NimbleClientTypes.StreamingImage]()
            for structure0 in streamingImagesContainer {
                if let structure0 = structure0 {
                    streamingImagesDecoded0?.append(structure0)
                }
            }
        }
        streamingImages = streamingImagesDecoded0
        let studioComponentSummariesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioComponentSummary?].self, forKey: .studioComponentSummaries)
        var studioComponentSummariesDecoded0:[NimbleClientTypes.StudioComponentSummary]? = nil
        if let studioComponentSummariesContainer = studioComponentSummariesContainer {
            studioComponentSummariesDecoded0 = [NimbleClientTypes.StudioComponentSummary]()
            for structure0 in studioComponentSummariesContainer {
                if let structure0 = structure0 {
                    studioComponentSummariesDecoded0?.append(structure0)
                }
            }
        }
        studioComponentSummaries = studioComponentSummariesDecoded0
    }
}

extension GetLaunchProfileInitializationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let launchProfileProtocolVersions = launchProfileProtocolVersions {
            launchProfileProtocolVersions.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "launchProfileProtocolVersions".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let launchPurpose = launchPurpose {
            let launchPurposeQueryItem = ClientRuntime.URLQueryItem(name: "launchPurpose".urlPercentEncoding(), value: Swift.String(launchPurpose).urlPercentEncoding())
            items.append(launchPurposeQueryItem)
        }
        if let platform = platform {
            let platformQueryItem = ClientRuntime.URLQueryItem(name: "platform".urlPercentEncoding(), value: Swift.String(platform).urlPercentEncoding())
            items.append(platformQueryItem)
        }
        return items
    }
}

extension GetLaunchProfileInitializationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/init"
    }
}

public struct GetLaunchProfileInitializationInput: Swift.Equatable {
    /// The Launch Profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The launch profile protocol versions supported by the client.
    /// This member is required.
    public var launchProfileProtocolVersions: [Swift.String]?
    /// The launch purpose.
    /// This member is required.
    public var launchPurpose: Swift.String?
    /// The platform where this Launch Profile will be used, either WINDOWS or LINUX.
    /// This member is required.
    public var platform: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        launchProfileId: Swift.String? = nil,
        launchProfileProtocolVersions: [Swift.String]? = nil,
        launchPurpose: Swift.String? = nil,
        platform: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.launchProfileProtocolVersions = launchProfileProtocolVersions
        self.launchPurpose = launchPurpose
        self.platform = platform
        self.studioId = studioId
    }
}

struct GetLaunchProfileInitializationInputBody: Swift.Equatable {
}

extension GetLaunchProfileInitializationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLaunchProfileInitializationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLaunchProfileInitializationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLaunchProfileInitializationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLaunchProfileInitializationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLaunchProfileInitializationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfileInitialization = output.launchProfileInitialization
        } else {
            self.launchProfileInitialization = nil
        }
    }
}

///
public struct GetLaunchProfileInitializationOutputResponse: Swift.Equatable {
    /// The launch profile initialization.
    public var launchProfileInitialization: NimbleClientTypes.LaunchProfileInitialization?

    public init (
        launchProfileInitialization: NimbleClientTypes.LaunchProfileInitialization? = nil
    )
    {
        self.launchProfileInitialization = launchProfileInitialization
    }
}

struct GetLaunchProfileInitializationOutputResponseBody: Swift.Equatable {
    let launchProfileInitialization: NimbleClientTypes.LaunchProfileInitialization?
}

extension GetLaunchProfileInitializationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfileInitialization
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileInitializationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileInitialization.self, forKey: .launchProfileInitialization)
        launchProfileInitialization = launchProfileInitializationDecoded
    }
}

extension GetLaunchProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())"
    }
}

public struct GetLaunchProfileInput: Swift.Equatable {
    /// The Launch Profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        launchProfileId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.studioId = studioId
    }
}

struct GetLaunchProfileInputBody: Swift.Equatable {
}

extension GetLaunchProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLaunchProfileMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        guard let principalId = principalId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
    }
}

public struct GetLaunchProfileMemberInput: Swift.Equatable {
    /// The Launch Profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The principal ID. This currently supports a Amazon Web Services SSO UserId.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        launchProfileId: Swift.String? = nil,
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct GetLaunchProfileMemberInputBody: Swift.Equatable {
}

extension GetLaunchProfileMemberInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLaunchProfileMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLaunchProfileMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLaunchProfileMemberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLaunchProfileMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLaunchProfileMemberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.member = output.member
        } else {
            self.member = nil
        }
    }
}

///
public struct GetLaunchProfileMemberOutputResponse: Swift.Equatable {
    /// The member.
    public var member: NimbleClientTypes.LaunchProfileMembership?

    public init (
        member: NimbleClientTypes.LaunchProfileMembership? = nil
    )
    {
        self.member = member
    }
}

struct GetLaunchProfileMemberOutputResponseBody: Swift.Equatable {
    let member: NimbleClientTypes.LaunchProfileMembership?
}

extension GetLaunchProfileMemberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileMembership.self, forKey: .member)
        member = memberDecoded
    }
}

extension GetLaunchProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLaunchProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLaunchProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLaunchProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLaunchProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
        } else {
            self.launchProfile = nil
        }
    }
}

///
public struct GetLaunchProfileOutputResponse: Swift.Equatable {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?

    public init (
        launchProfile: NimbleClientTypes.LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

struct GetLaunchProfileOutputResponseBody: Swift.Equatable {
    let launchProfile: NimbleClientTypes.LaunchProfile?
}

extension GetLaunchProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
    }
}

extension GetStreamingImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let streamingImageId = streamingImageId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images/\(streamingImageId.urlPercentEncoding())"
    }
}

public struct GetStreamingImageInput: Swift.Equatable {
    /// The streaming image ID.
    /// This member is required.
    public var streamingImageId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        streamingImageId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.streamingImageId = streamingImageId
        self.studioId = studioId
    }
}

struct GetStreamingImageInputBody: Swift.Equatable {
}

extension GetStreamingImageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStreamingImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStreamingImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamingImageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamingImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStreamingImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingImage = output.streamingImage
        } else {
            self.streamingImage = nil
        }
    }
}

///
public struct GetStreamingImageOutputResponse: Swift.Equatable {
    /// The streaming image.
    public var streamingImage: NimbleClientTypes.StreamingImage?

    public init (
        streamingImage: NimbleClientTypes.StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

struct GetStreamingImageOutputResponseBody: Swift.Equatable {
    let streamingImage: NimbleClientTypes.StreamingImage?
}

extension GetStreamingImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingImage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingImageDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImage.self, forKey: .streamingImage)
        streamingImage = streamingImageDecoded
    }
}

extension GetStreamingSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())"
    }
}

public struct GetStreamingSessionInput: Swift.Equatable {
    /// The streaming session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        sessionId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

struct GetStreamingSessionInputBody: Swift.Equatable {
}

extension GetStreamingSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStreamingSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStreamingSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamingSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamingSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStreamingSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

///
public struct GetStreamingSessionOutputResponse: Swift.Equatable {
    /// The session.
    public var session: NimbleClientTypes.StreamingSession?

    public init (
        session: NimbleClientTypes.StreamingSession? = nil
    )
    {
        self.session = session
    }
}

struct GetStreamingSessionOutputResponseBody: Swift.Equatable {
    let session: NimbleClientTypes.StreamingSession?
}

extension GetStreamingSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSession.self, forKey: .session)
        session = sessionDecoded
    }
}

extension GetStreamingSessionStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        guard let streamId = streamId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())/streams/\(streamId.urlPercentEncoding())"
    }
}

public struct GetStreamingSessionStreamInput: Swift.Equatable {
    /// The streaming session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The streaming session stream ID.
    /// This member is required.
    public var streamId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        sessionId: Swift.String? = nil,
        streamId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
        self.streamId = streamId
        self.studioId = studioId
    }
}

struct GetStreamingSessionStreamInputBody: Swift.Equatable {
}

extension GetStreamingSessionStreamInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStreamingSessionStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStreamingSessionStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamingSessionStreamOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamingSessionStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStreamingSessionStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stream = output.stream
        } else {
            self.stream = nil
        }
    }
}

///
public struct GetStreamingSessionStreamOutputResponse: Swift.Equatable {
    /// The stream.
    public var stream: NimbleClientTypes.StreamingSessionStream?

    public init (
        stream: NimbleClientTypes.StreamingSessionStream? = nil
    )
    {
        self.stream = stream
    }
}

struct GetStreamingSessionStreamOutputResponseBody: Swift.Equatable {
    let stream: NimbleClientTypes.StreamingSessionStream?
}

extension GetStreamingSessionStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stream
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionStream.self, forKey: .stream)
        stream = streamDecoded
    }
}

extension GetStudioComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let studioComponentId = studioComponentId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components/\(studioComponentId.urlPercentEncoding())"
    }
}

public struct GetStudioComponentInput: Swift.Equatable {
    /// The studio component ID.
    /// This member is required.
    public var studioComponentId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        studioComponentId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.studioComponentId = studioComponentId
        self.studioId = studioId
    }
}

struct GetStudioComponentInputBody: Swift.Equatable {
}

extension GetStudioComponentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStudioComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStudioComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStudioComponentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStudioComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStudioComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studioComponent = output.studioComponent
        } else {
            self.studioComponent = nil
        }
    }
}

///
public struct GetStudioComponentOutputResponse: Swift.Equatable {
    /// Information about the studio component.
    public var studioComponent: NimbleClientTypes.StudioComponent?

    public init (
        studioComponent: NimbleClientTypes.StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

struct GetStudioComponentOutputResponseBody: Swift.Equatable {
    let studioComponent: NimbleClientTypes.StudioComponent?
}

extension GetStudioComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studioComponent
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioComponentDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponent.self, forKey: .studioComponent)
        studioComponent = studioComponentDecoded
    }
}

extension GetStudioInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())"
    }
}

public struct GetStudioInput: Swift.Equatable {
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        studioId: Swift.String? = nil
    )
    {
        self.studioId = studioId
    }
}

struct GetStudioInputBody: Swift.Equatable {
}

extension GetStudioInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStudioMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let principalId = principalId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
    }
}

public struct GetStudioMemberInput: Swift.Equatable {
    /// The principal ID. This currently supports a Amazon Web Services SSO UserId.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct GetStudioMemberInputBody: Swift.Equatable {
}

extension GetStudioMemberInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStudioMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStudioMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStudioMemberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStudioMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStudioMemberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.member = output.member
        } else {
            self.member = nil
        }
    }
}

///
public struct GetStudioMemberOutputResponse: Swift.Equatable {
    /// The member.
    public var member: NimbleClientTypes.StudioMembership?

    public init (
        member: NimbleClientTypes.StudioMembership? = nil
    )
    {
        self.member = member
    }
}

struct GetStudioMemberOutputResponseBody: Swift.Equatable {
    let member: NimbleClientTypes.StudioMembership?
}

extension GetStudioMemberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioMembership.self, forKey: .member)
        member = memberDecoded
    }
}

extension GetStudioOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStudioOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStudioOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStudioOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStudioOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

///
public struct GetStudioOutputResponse: Swift.Equatable {
    /// Information about a studio.
    /// This member is required.
    public var studio: NimbleClientTypes.Studio?

    public init (
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct GetStudioOutputResponseBody: Swift.Equatable {
    let studio: NimbleClientTypes.Studio?
}

extension GetStudioOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studio
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal error has occurred. Please retry your request.
public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// A more specific error code.
    public var code: Swift.String?
    /// The exception context.
    public var context: [Swift.String:Swift.String]?
    /// A human-readable description of the error.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let context: [Swift.String:Swift.String]?
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case context
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NimbleClientTypes.LaunchProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case createdBy
        case description
        case ec2SubnetIds
        case launchProfileId
        case launchProfileProtocolVersions
        case name
        case state
        case statusCode
        case statusMessage
        case streamConfiguration
        case studioComponentIds
        case tags
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SubnetIds = ec2SubnetIds {
            var ec2SubnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SubnetIds)
            for ec2subnetidlist0 in ec2SubnetIds {
                try ec2SubnetIdsContainer.encode(ec2subnetidlist0)
            }
        }
        if let launchProfileId = launchProfileId {
            try encodeContainer.encode(launchProfileId, forKey: .launchProfileId)
        }
        if let launchProfileProtocolVersions = launchProfileProtocolVersions {
            var launchProfileProtocolVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchProfileProtocolVersions)
            for launchprofileprotocolversionlist0 in launchProfileProtocolVersions {
                try launchProfileProtocolVersionsContainer.encode(launchprofileprotocolversionlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let streamConfiguration = streamConfiguration {
            try encodeContainer.encode(streamConfiguration, forKey: .streamConfiguration)
        }
        if let studioComponentIds = studioComponentIds {
            var studioComponentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .studioComponentIds)
            for launchprofilestudiocomponentidlist0 in studioComponentIds {
                try studioComponentIdsContainer.encode(launchprofilestudiocomponentidlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let updatedBy = updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SubnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SubnetIds)
        var ec2SubnetIdsDecoded0:[Swift.String]? = nil
        if let ec2SubnetIdsContainer = ec2SubnetIdsContainer {
            ec2SubnetIdsDecoded0 = [Swift.String]()
            for string0 in ec2SubnetIdsContainer {
                if let string0 = string0 {
                    ec2SubnetIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SubnetIds = ec2SubnetIdsDecoded0
        let launchProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileId)
        launchProfileId = launchProfileIdDecoded
        let launchProfileProtocolVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .launchProfileProtocolVersions)
        var launchProfileProtocolVersionsDecoded0:[Swift.String]? = nil
        if let launchProfileProtocolVersionsContainer = launchProfileProtocolVersionsContainer {
            launchProfileProtocolVersionsDecoded0 = [Swift.String]()
            for string0 in launchProfileProtocolVersionsContainer {
                if let string0 = string0 {
                    launchProfileProtocolVersionsDecoded0?.append(string0)
                }
            }
        }
        launchProfileProtocolVersions = launchProfileProtocolVersionsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let streamConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamConfiguration.self, forKey: .streamConfiguration)
        streamConfiguration = streamConfigurationDecoded
        let studioComponentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .studioComponentIds)
        var studioComponentIdsDecoded0:[Swift.String]? = nil
        if let studioComponentIdsContainer = studioComponentIdsContainer {
            studioComponentIdsDecoded0 = [Swift.String]()
            for string0 in studioComponentIdsContainer {
                if let string0 = string0 {
                    studioComponentIdsDecoded0?.append(string0)
                }
            }
        }
        studioComponentIds = studioComponentIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension NimbleClientTypes {
    /// A launch profile controls your artist workforce’s access to studio components, like compute farms, shared file systems, managed file systems, and license server configurations, as well as instance types and Amazon Machine Images (AMIs). Studio administrators create launch profiles in the Nimble Studio console. Artists can use their launch profiles to launch an instance from the Nimble Studio portal. Each user’s launch profile defines how they can launch a streaming session. By default, studio admins can use all launch profiles.
    public struct LaunchProfile: Swift.Equatable {
        /// The ARN of the resource.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The user ID of the user that created the launch profile.
        public var createdBy: Swift.String?
        /// A human-readable description of the launch profile.
        public var description: Swift.String?
        /// Unique identifiers for a collection of EC2 subnets.
        public var ec2SubnetIds: [Swift.String]?
        /// The launch profile ID.
        public var launchProfileId: Swift.String?
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public var launchProfileProtocolVersions: [Swift.String]?
        /// A friendly name for the launch profile.
        public var name: Swift.String?
        /// The current state.
        public var state: NimbleClientTypes.LaunchProfileState?
        /// The status code.
        public var statusCode: NimbleClientTypes.LaunchProfileStatusCode?
        /// The status message for the launch profile.
        public var statusMessage: Swift.String?
        /// A configuration for a streaming session.
        public var streamConfiguration: NimbleClientTypes.StreamConfiguration?
        /// Unique identifiers for a collection of studio components that can be used with this launch profile.
        public var studioComponentIds: [Swift.String]?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user ID of the user that most recently updated the resource.
        public var updatedBy: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            ec2SubnetIds: [Swift.String]? = nil,
            launchProfileId: Swift.String? = nil,
            launchProfileProtocolVersions: [Swift.String]? = nil,
            name: Swift.String? = nil,
            state: NimbleClientTypes.LaunchProfileState? = nil,
            statusCode: NimbleClientTypes.LaunchProfileStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            streamConfiguration: NimbleClientTypes.StreamConfiguration? = nil,
            studioComponentIds: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.ec2SubnetIds = ec2SubnetIds
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.name = name
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.streamConfiguration = streamConfiguration
            self.studioComponentIds = studioComponentIds
            self.tags = tags
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension NimbleClientTypes.LaunchProfileInitialization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDirectory
        case ec2SecurityGroupIds
        case launchProfileId
        case launchProfileProtocolVersion
        case launchPurpose
        case name
        case platform
        case systemInitializationScripts
        case userInitializationScripts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDirectory = activeDirectory {
            try encodeContainer.encode(activeDirectory, forKey: .activeDirectory)
        }
        if let ec2SecurityGroupIds = ec2SecurityGroupIds {
            var ec2SecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SecurityGroupIds)
            for launchprofilesecuritygroupidlist0 in ec2SecurityGroupIds {
                try ec2SecurityGroupIdsContainer.encode(launchprofilesecuritygroupidlist0)
            }
        }
        if let launchProfileId = launchProfileId {
            try encodeContainer.encode(launchProfileId, forKey: .launchProfileId)
        }
        if let launchProfileProtocolVersion = launchProfileProtocolVersion {
            try encodeContainer.encode(launchProfileProtocolVersion, forKey: .launchProfileProtocolVersion)
        }
        if let launchPurpose = launchPurpose {
            try encodeContainer.encode(launchPurpose, forKey: .launchPurpose)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let systemInitializationScripts = systemInitializationScripts {
            var systemInitializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .systemInitializationScripts)
            for launchprofileinitializationscriptlist0 in systemInitializationScripts {
                try systemInitializationScriptsContainer.encode(launchprofileinitializationscriptlist0)
            }
        }
        if let userInitializationScripts = userInitializationScripts {
            var userInitializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userInitializationScripts)
            for launchprofileinitializationscriptlist0 in userInitializationScripts {
                try userInitializationScriptsContainer.encode(launchprofileinitializationscriptlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDirectoryDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileInitializationActiveDirectory.self, forKey: .activeDirectory)
        activeDirectory = activeDirectoryDecoded
        let ec2SecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SecurityGroupIds)
        var ec2SecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let ec2SecurityGroupIdsContainer = ec2SecurityGroupIdsContainer {
            ec2SecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in ec2SecurityGroupIdsContainer {
                if let string0 = string0 {
                    ec2SecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SecurityGroupIds = ec2SecurityGroupIdsDecoded0
        let launchProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileId)
        launchProfileId = launchProfileIdDecoded
        let launchProfileProtocolVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileProtocolVersion)
        launchProfileProtocolVersion = launchProfileProtocolVersionDecoded
        let launchPurposeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchPurpose)
        launchPurpose = launchPurposeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let platformDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfilePlatform.self, forKey: .platform)
        platform = platformDecoded
        let systemInitializationScriptsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.LaunchProfileInitializationScript?].self, forKey: .systemInitializationScripts)
        var systemInitializationScriptsDecoded0:[NimbleClientTypes.LaunchProfileInitializationScript]? = nil
        if let systemInitializationScriptsContainer = systemInitializationScriptsContainer {
            systemInitializationScriptsDecoded0 = [NimbleClientTypes.LaunchProfileInitializationScript]()
            for structure0 in systemInitializationScriptsContainer {
                if let structure0 = structure0 {
                    systemInitializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        systemInitializationScripts = systemInitializationScriptsDecoded0
        let userInitializationScriptsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.LaunchProfileInitializationScript?].self, forKey: .userInitializationScripts)
        var userInitializationScriptsDecoded0:[NimbleClientTypes.LaunchProfileInitializationScript]? = nil
        if let userInitializationScriptsContainer = userInitializationScriptsContainer {
            userInitializationScriptsDecoded0 = [NimbleClientTypes.LaunchProfileInitializationScript]()
            for structure0 in userInitializationScriptsContainer {
                if let structure0 = structure0 {
                    userInitializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        userInitializationScripts = userInitializationScriptsDecoded0
    }
}

extension NimbleClientTypes {
    /// A Launch Profile Initialization contains information required for a workstation or server to connect to a launch profile This includes scripts, endpoints, security groups, subnets, and other configuration.
    public struct LaunchProfileInitialization: Swift.Equatable {
        /// A LaunchProfileInitializationActiveDirectory resource.
        public var activeDirectory: NimbleClientTypes.LaunchProfileInitializationActiveDirectory?
        /// The EC2 security groups that control access to the studio component.
        public var ec2SecurityGroupIds: [Swift.String]?
        /// The launch profile ID.
        public var launchProfileId: Swift.String?
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public var launchProfileProtocolVersion: Swift.String?
        /// The launch purpose.
        public var launchPurpose: Swift.String?
        /// The name for the launch profile.
        public var name: Swift.String?
        /// The platform of the launch platform, either WINDOWS or LINUX.
        public var platform: NimbleClientTypes.LaunchProfilePlatform?
        /// The system initializtion scripts.
        public var systemInitializationScripts: [NimbleClientTypes.LaunchProfileInitializationScript]?
        /// The user initializtion scripts.
        public var userInitializationScripts: [NimbleClientTypes.LaunchProfileInitializationScript]?

        public init (
            activeDirectory: NimbleClientTypes.LaunchProfileInitializationActiveDirectory? = nil,
            ec2SecurityGroupIds: [Swift.String]? = nil,
            launchProfileId: Swift.String? = nil,
            launchProfileProtocolVersion: Swift.String? = nil,
            launchPurpose: Swift.String? = nil,
            name: Swift.String? = nil,
            platform: NimbleClientTypes.LaunchProfilePlatform? = nil,
            systemInitializationScripts: [NimbleClientTypes.LaunchProfileInitializationScript]? = nil,
            userInitializationScripts: [NimbleClientTypes.LaunchProfileInitializationScript]? = nil
        )
        {
            self.activeDirectory = activeDirectory
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersion = launchProfileProtocolVersion
            self.launchPurpose = launchPurpose
            self.name = name
            self.platform = platform
            self.systemInitializationScripts = systemInitializationScripts
            self.userInitializationScripts = userInitializationScripts
        }
    }

}

extension NimbleClientTypes.LaunchProfileInitializationActiveDirectory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computerAttributes
        case directoryId
        case directoryName
        case dnsIpAddresses
        case organizationalUnitDistinguishedName
        case studioComponentId
        case studioComponentName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computerAttributes = computerAttributes {
            var computerAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .computerAttributes)
            for activedirectorycomputerattributelist0 in computerAttributes {
                try computerAttributesContainer.encode(activedirectorycomputerattributelist0)
            }
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let dnsIpAddresses = dnsIpAddresses {
            var dnsIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIpAddresses)
            for activedirectorydnsipaddresslist0 in dnsIpAddresses {
                try dnsIpAddressesContainer.encode(activedirectorydnsipaddresslist0)
            }
        }
        if let organizationalUnitDistinguishedName = organizationalUnitDistinguishedName {
            try encodeContainer.encode(organizationalUnitDistinguishedName, forKey: .organizationalUnitDistinguishedName)
        }
        if let studioComponentId = studioComponentId {
            try encodeContainer.encode(studioComponentId, forKey: .studioComponentId)
        }
        if let studioComponentName = studioComponentName {
            try encodeContainer.encode(studioComponentName, forKey: .studioComponentName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computerAttributesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.ActiveDirectoryComputerAttribute?].self, forKey: .computerAttributes)
        var computerAttributesDecoded0:[NimbleClientTypes.ActiveDirectoryComputerAttribute]? = nil
        if let computerAttributesContainer = computerAttributesContainer {
            computerAttributesDecoded0 = [NimbleClientTypes.ActiveDirectoryComputerAttribute]()
            for structure0 in computerAttributesContainer {
                if let structure0 = structure0 {
                    computerAttributesDecoded0?.append(structure0)
                }
            }
        }
        computerAttributes = computerAttributesDecoded0
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let dnsIpAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dnsIpAddresses)
        var dnsIpAddressesDecoded0:[Swift.String]? = nil
        if let dnsIpAddressesContainer = dnsIpAddressesContainer {
            dnsIpAddressesDecoded0 = [Swift.String]()
            for string0 in dnsIpAddressesContainer {
                if let string0 = string0 {
                    dnsIpAddressesDecoded0?.append(string0)
                }
            }
        }
        dnsIpAddresses = dnsIpAddressesDecoded0
        let organizationalUnitDistinguishedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnitDistinguishedName)
        organizationalUnitDistinguishedName = organizationalUnitDistinguishedNameDecoded
        let studioComponentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentId)
        studioComponentId = studioComponentIdDecoded
        let studioComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentName)
        studioComponentName = studioComponentNameDecoded
    }
}

extension NimbleClientTypes {
    ///
    public struct LaunchProfileInitializationActiveDirectory: Swift.Equatable {
        /// A collection of custom attributes for an Active Directory computer.
        public var computerAttributes: [NimbleClientTypes.ActiveDirectoryComputerAttribute]?
        /// The directory ID of the Directory Service for Microsoft Active Directory to access using this launch profile.
        public var directoryId: Swift.String?
        /// The directory name.
        public var directoryName: Swift.String?
        /// The DNS IP address.
        public var dnsIpAddresses: [Swift.String]?
        /// The name for the organizational unit distinguished name.
        public var organizationalUnitDistinguishedName: Swift.String?
        /// The unique identifier for a studio component resource.
        public var studioComponentId: Swift.String?
        /// The name for the studio component.
        public var studioComponentName: Swift.String?

        public init (
            computerAttributes: [NimbleClientTypes.ActiveDirectoryComputerAttribute]? = nil,
            directoryId: Swift.String? = nil,
            directoryName: Swift.String? = nil,
            dnsIpAddresses: [Swift.String]? = nil,
            organizationalUnitDistinguishedName: Swift.String? = nil,
            studioComponentId: Swift.String? = nil,
            studioComponentName: Swift.String? = nil
        )
        {
            self.computerAttributes = computerAttributes
            self.directoryId = directoryId
            self.directoryName = directoryName
            self.dnsIpAddresses = dnsIpAddresses
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
            self.studioComponentId = studioComponentId
            self.studioComponentName = studioComponentName
        }
    }

}

extension NimbleClientTypes.LaunchProfileInitializationScript: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case script
        case studioComponentId
        case studioComponentName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let script = script {
            try encodeContainer.encode(script, forKey: .script)
        }
        if let studioComponentId = studioComponentId {
            try encodeContainer.encode(studioComponentId, forKey: .studioComponentId)
        }
        if let studioComponentName = studioComponentName {
            try encodeContainer.encode(studioComponentName, forKey: .studioComponentName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .script)
        script = scriptDecoded
        let studioComponentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentId)
        studioComponentId = studioComponentIdDecoded
        let studioComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentName)
        studioComponentName = studioComponentNameDecoded
    }
}

extension NimbleClientTypes {
    ///
    public struct LaunchProfileInitializationScript: Swift.Equatable {
        /// The initialization script.
        public var script: Swift.String?
        /// The unique identifier for a studio component resource.
        public var studioComponentId: Swift.String?
        /// The name for the studio component.
        public var studioComponentName: Swift.String?

        public init (
            script: Swift.String? = nil,
            studioComponentId: Swift.String? = nil,
            studioComponentName: Swift.String? = nil
        )
        {
            self.script = script
            self.studioComponentId = studioComponentId
            self.studioComponentName = studioComponentName
        }
    }

}

extension NimbleClientTypes.LaunchProfileMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case persona
        case principalId
        case sid
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let persona = persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let sid = sid {
            try encodeContainer.encode(sid, forKey: .sid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let personaDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfilePersona.self, forKey: .persona)
        persona = personaDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let sidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sid)
        sid = sidDecoded
    }
}

extension NimbleClientTypes {
    ///
    public struct LaunchProfileMembership: Swift.Equatable {
        /// The ID of the identity store.
        public var identityStoreId: Swift.String?
        /// The persona.
        public var persona: NimbleClientTypes.LaunchProfilePersona?
        /// The principal ID.
        public var principalId: Swift.String?
        /// The Active Directory Security Identifier for this user, if available.
        public var sid: Swift.String?

        public init (
            identityStoreId: Swift.String? = nil,
            persona: NimbleClientTypes.LaunchProfilePersona? = nil,
            principalId: Swift.String? = nil,
            sid: Swift.String? = nil
        )
        {
            self.identityStoreId = identityStoreId
            self.persona = persona
            self.principalId = principalId
            self.sid = sid
        }
    }

}

extension NimbleClientTypes {
    ///
    public enum LaunchProfilePersona: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfilePersona] {
            return [
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchProfilePersona(rawValue: rawValue) ?? LaunchProfilePersona.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    ///
    public enum LaunchProfilePlatform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfilePlatform] {
            return [
                .linux,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchProfilePlatform(rawValue: rawValue) ?? LaunchProfilePlatform.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    ///
    public enum LaunchProfileState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfileState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchProfileState(rawValue: rawValue) ?? LaunchProfileState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    ///
    public enum LaunchProfileStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case encryptionKeyAccessDenied
        case encryptionKeyNotFound
        case internalError
        case invalidSubnetsProvided
        case launchProfileCreated
        case launchProfileCreateInProgress
        case launchProfileDeleted
        case launchProfileDeleteInProgress
        case launchProfileUpdated
        case launchProfileUpdateInProgress
        case launchProfileWithStreamSessionsNotDeleted
        case streamingImageNotFound
        case streamingImageNotReady
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfileStatusCode] {
            return [
                .encryptionKeyAccessDenied,
                .encryptionKeyNotFound,
                .internalError,
                .invalidSubnetsProvided,
                .launchProfileCreated,
                .launchProfileCreateInProgress,
                .launchProfileDeleted,
                .launchProfileDeleteInProgress,
                .launchProfileUpdated,
                .launchProfileUpdateInProgress,
                .launchProfileWithStreamSessionsNotDeleted,
                .streamingImageNotFound,
                .streamingImageNotReady,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .encryptionKeyAccessDenied: return "ENCRYPTION_KEY_ACCESS_DENIED"
            case .encryptionKeyNotFound: return "ENCRYPTION_KEY_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidSubnetsProvided: return "INVALID_SUBNETS_PROVIDED"
            case .launchProfileCreated: return "LAUNCH_PROFILE_CREATED"
            case .launchProfileCreateInProgress: return "LAUNCH_PROFILE_CREATE_IN_PROGRESS"
            case .launchProfileDeleted: return "LAUNCH_PROFILE_DELETED"
            case .launchProfileDeleteInProgress: return "LAUNCH_PROFILE_DELETE_IN_PROGRESS"
            case .launchProfileUpdated: return "LAUNCH_PROFILE_UPDATED"
            case .launchProfileUpdateInProgress: return "LAUNCH_PROFILE_UPDATE_IN_PROGRESS"
            case .launchProfileWithStreamSessionsNotDeleted: return "LAUNCH_PROFILE_WITH_STREAM_SESSIONS_NOT_DELETED"
            case .streamingImageNotFound: return "STREAMING_IMAGE_NOT_FOUND"
            case .streamingImageNotReady: return "STREAMING_IMAGE_NOT_READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchProfileStatusCode(rawValue: rawValue) ?? LaunchProfileStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.LicenseServiceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension NimbleClientTypes.LicenseServiceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LicenseServiceConfiguration(endpoint: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// The configuration for a license service that is associated with a studio resource.
    public struct LicenseServiceConfiguration: Swift.Equatable {
        /// The endpoint of the license service that is accessed by the studio component resource.
        public var endpoint: Swift.String?

        public init (
            endpoint: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
        }
    }

}

extension ListEulaAcceptancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let eulaIds = eulaIds {
            eulaIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "eulaIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListEulaAcceptancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/eula-acceptances"
    }
}

public struct ListEulaAcceptancesInput: Swift.Equatable {
    /// The list of EULA IDs that have been previously accepted.
    public var eulaIds: [Swift.String]?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        eulaIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.eulaIds = eulaIds
        self.nextToken = nextToken
        self.studioId = studioId
    }
}

struct ListEulaAcceptancesInputBody: Swift.Equatable {
}

extension ListEulaAcceptancesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListEulaAcceptancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEulaAcceptancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEulaAcceptancesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEulaAcceptancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEulaAcceptancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eulaAcceptances = output.eulaAcceptances
            self.nextToken = output.nextToken
        } else {
            self.eulaAcceptances = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListEulaAcceptancesOutputResponse: Swift.Equatable {
    /// A collection of EULA acceptances.
    public var eulaAcceptances: [NimbleClientTypes.EulaAcceptance]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        eulaAcceptances: [NimbleClientTypes.EulaAcceptance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eulaAcceptances = eulaAcceptances
        self.nextToken = nextToken
    }
}

struct ListEulaAcceptancesOutputResponseBody: Swift.Equatable {
    let eulaAcceptances: [NimbleClientTypes.EulaAcceptance]?
    let nextToken: Swift.String?
}

extension ListEulaAcceptancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eulaAcceptances
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulaAcceptancesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.EulaAcceptance?].self, forKey: .eulaAcceptances)
        var eulaAcceptancesDecoded0:[NimbleClientTypes.EulaAcceptance]? = nil
        if let eulaAcceptancesContainer = eulaAcceptancesContainer {
            eulaAcceptancesDecoded0 = [NimbleClientTypes.EulaAcceptance]()
            for structure0 in eulaAcceptancesContainer {
                if let structure0 = structure0 {
                    eulaAcceptancesDecoded0?.append(structure0)
                }
            }
        }
        eulaAcceptances = eulaAcceptancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEulasInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let eulaIds = eulaIds {
            eulaIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "eulaIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListEulasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-08-01/eulas"
    }
}

public struct ListEulasInput: Swift.Equatable {
    /// The list of EULA IDs that should be returned
    public var eulaIds: [Swift.String]?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        eulaIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eulaIds = eulaIds
        self.nextToken = nextToken
    }
}

struct ListEulasInputBody: Swift.Equatable {
}

extension ListEulasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListEulasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEulasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEulasOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEulasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEulasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eulas = output.eulas
            self.nextToken = output.nextToken
        } else {
            self.eulas = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListEulasOutputResponse: Swift.Equatable {
    /// A collection of EULA resources.
    public var eulas: [NimbleClientTypes.Eula]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        eulas: [NimbleClientTypes.Eula]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eulas = eulas
        self.nextToken = nextToken
    }
}

struct ListEulasOutputResponseBody: Swift.Equatable {
    let eulas: [NimbleClientTypes.Eula]?
    let nextToken: Swift.String?
}

extension ListEulasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eulas
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulasContainer = try containerValues.decodeIfPresent([NimbleClientTypes.Eula?].self, forKey: .eulas)
        var eulasDecoded0:[NimbleClientTypes.Eula]? = nil
        if let eulasContainer = eulasContainer {
            eulasDecoded0 = [NimbleClientTypes.Eula]()
            for structure0 in eulasContainer {
                if let structure0 = structure0 {
                    eulasDecoded0?.append(structure0)
                }
            }
        }
        eulas = eulasDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLaunchProfileMembersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListLaunchProfileMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership"
    }
}

public struct ListLaunchProfileMembersInput: Swift.Equatable {
    /// The Launch Profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The max number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        launchProfileId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.studioId = studioId
    }
}

struct ListLaunchProfileMembersInputBody: Swift.Equatable {
}

extension ListLaunchProfileMembersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLaunchProfileMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLaunchProfileMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLaunchProfileMembersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLaunchProfileMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLaunchProfileMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListLaunchProfileMembersOutputResponse: Swift.Equatable {
    /// A list of members.
    public var members: [NimbleClientTypes.LaunchProfileMembership]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        members: [NimbleClientTypes.LaunchProfileMembership]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListLaunchProfileMembersOutputResponseBody: Swift.Equatable {
    let members: [NimbleClientTypes.LaunchProfileMembership]?
    let nextToken: Swift.String?
}

extension ListLaunchProfileMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.LaunchProfileMembership?].self, forKey: .members)
        var membersDecoded0:[NimbleClientTypes.LaunchProfileMembership]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [NimbleClientTypes.LaunchProfileMembership]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLaunchProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let principalId = principalId {
            let principalIdQueryItem = ClientRuntime.URLQueryItem(name: "principalId".urlPercentEncoding(), value: Swift.String(principalId).urlPercentEncoding())
            items.append(principalIdQueryItem)
        }
        if let states = states {
            states.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListLaunchProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles"
    }
}

public struct ListLaunchProfilesInput: Swift.Equatable {
    /// The max number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The principal ID. This currently supports a Amazon Web Services SSO UserId.
    public var principalId: Swift.String?
    /// Filter this request to launch profiles in any of the given states.
    public var states: [Swift.String]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        states: [Swift.String]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalId = principalId
        self.states = states
        self.studioId = studioId
    }
}

struct ListLaunchProfilesInputBody: Swift.Equatable {
}

extension ListLaunchProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLaunchProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLaunchProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLaunchProfilesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLaunchProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLaunchProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfiles = output.launchProfiles
            self.nextToken = output.nextToken
        } else {
            self.launchProfiles = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListLaunchProfilesOutputResponse: Swift.Equatable {
    /// A collection of launch profiles.
    public var launchProfiles: [NimbleClientTypes.LaunchProfile]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        launchProfiles: [NimbleClientTypes.LaunchProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.launchProfiles = launchProfiles
        self.nextToken = nextToken
    }
}

struct ListLaunchProfilesOutputResponseBody: Swift.Equatable {
    let launchProfiles: [NimbleClientTypes.LaunchProfile]?
    let nextToken: Swift.String?
}

extension ListLaunchProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfiles
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfilesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.LaunchProfile?].self, forKey: .launchProfiles)
        var launchProfilesDecoded0:[NimbleClientTypes.LaunchProfile]? = nil
        if let launchProfilesContainer = launchProfilesContainer {
            launchProfilesDecoded0 = [NimbleClientTypes.LaunchProfile]()
            for structure0 in launchProfilesContainer {
                if let structure0 = structure0 {
                    launchProfilesDecoded0?.append(structure0)
                }
            }
        }
        launchProfiles = launchProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStreamingImagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let owner = owner {
            let ownerQueryItem = ClientRuntime.URLQueryItem(name: "owner".urlPercentEncoding(), value: Swift.String(owner).urlPercentEncoding())
            items.append(ownerQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListStreamingImagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images"
    }
}

public struct ListStreamingImagesInput: Swift.Equatable {
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// Filter this request to streaming images with the given owner
    public var owner: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        owner: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.owner = owner
        self.studioId = studioId
    }
}

struct ListStreamingImagesInputBody: Swift.Equatable {
}

extension ListStreamingImagesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListStreamingImagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamingImagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamingImagesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamingImagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStreamingImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.streamingImages = output.streamingImages
        } else {
            self.nextToken = nil
            self.streamingImages = nil
        }
    }
}

///
public struct ListStreamingImagesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A collection of streaming images.
    public var streamingImages: [NimbleClientTypes.StreamingImage]?

    public init (
        nextToken: Swift.String? = nil,
        streamingImages: [NimbleClientTypes.StreamingImage]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamingImages = streamingImages
    }
}

struct ListStreamingImagesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let streamingImages: [NimbleClientTypes.StreamingImage]?
}

extension ListStreamingImagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case streamingImages
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let streamingImagesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StreamingImage?].self, forKey: .streamingImages)
        var streamingImagesDecoded0:[NimbleClientTypes.StreamingImage]? = nil
        if let streamingImagesContainer = streamingImagesContainer {
            streamingImagesDecoded0 = [NimbleClientTypes.StreamingImage]()
            for structure0 in streamingImagesContainer {
                if let structure0 = structure0 {
                    streamingImagesDecoded0?.append(structure0)
                }
            }
        }
        streamingImages = streamingImagesDecoded0
    }
}

extension ListStreamingSessionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let createdBy = createdBy {
            let createdByQueryItem = ClientRuntime.URLQueryItem(name: "createdBy".urlPercentEncoding(), value: Swift.String(createdBy).urlPercentEncoding())
            items.append(createdByQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let ownedBy = ownedBy {
            let ownedByQueryItem = ClientRuntime.URLQueryItem(name: "ownedBy".urlPercentEncoding(), value: Swift.String(ownedBy).urlPercentEncoding())
            items.append(ownedByQueryItem)
        }
        if let sessionIds = sessionIds {
            let sessionIdsQueryItem = ClientRuntime.URLQueryItem(name: "sessionIds".urlPercentEncoding(), value: Swift.String(sessionIds).urlPercentEncoding())
            items.append(sessionIdsQueryItem)
        }
        return items
    }
}

extension ListStreamingSessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions"
    }
}

public struct ListStreamingSessionsInput: Swift.Equatable {
    /// Filters the request to streaming sessions created by the given user.
    public var createdBy: Swift.String?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// Filters the request to streaming session owned by the given user
    public var ownedBy: Swift.String?
    /// Filters the request to only the provided session IDs.
    public var sessionIds: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        createdBy: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        ownedBy: Swift.String? = nil,
        sessionIds: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.createdBy = createdBy
        self.nextToken = nextToken
        self.ownedBy = ownedBy
        self.sessionIds = sessionIds
        self.studioId = studioId
    }
}

struct ListStreamingSessionsInputBody: Swift.Equatable {
}

extension ListStreamingSessionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListStreamingSessionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamingSessionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamingSessionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamingSessionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStreamingSessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sessions = output.sessions
        } else {
            self.nextToken = nil
            self.sessions = nil
        }
    }
}

///
public struct ListStreamingSessionsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A collection of streaming sessions.
    public var sessions: [NimbleClientTypes.StreamingSession]?

    public init (
        nextToken: Swift.String? = nil,
        sessions: [NimbleClientTypes.StreamingSession]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

struct ListStreamingSessionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let sessions: [NimbleClientTypes.StreamingSession]?
}

extension ListStreamingSessionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sessions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sessionsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StreamingSession?].self, forKey: .sessions)
        var sessionsDecoded0:[NimbleClientTypes.StreamingSession]? = nil
        if let sessionsContainer = sessionsContainer {
            sessionsDecoded0 = [NimbleClientTypes.StreamingSession]()
            for structure0 in sessionsContainer {
                if let structure0 = structure0 {
                    sessionsDecoded0?.append(structure0)
                }
            }
        }
        sessions = sessionsDecoded0
    }
}

extension ListStudioComponentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let types = types {
            types.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "types".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let states = states {
            states.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListStudioComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components"
    }
}

public struct ListStudioComponentsInput: Swift.Equatable {
    /// The max number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// Filters the request to studio components that are in one of the given states.
    public var states: [Swift.String]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// Filters the request to studio components that are of one of the given types.
    public var types: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        states: [Swift.String]? = nil,
        studioId: Swift.String? = nil,
        types: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.states = states
        self.studioId = studioId
        self.types = types
    }
}

struct ListStudioComponentsInputBody: Swift.Equatable {
}

extension ListStudioComponentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListStudioComponentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStudioComponentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStudioComponentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStudioComponentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStudioComponentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.studioComponents = output.studioComponents
        } else {
            self.nextToken = nil
            self.studioComponents = nil
        }
    }
}

///
public struct ListStudioComponentsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A collection of studio components.
    public var studioComponents: [NimbleClientTypes.StudioComponent]?

    public init (
        nextToken: Swift.String? = nil,
        studioComponents: [NimbleClientTypes.StudioComponent]? = nil
    )
    {
        self.nextToken = nextToken
        self.studioComponents = studioComponents
    }
}

struct ListStudioComponentsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let studioComponents: [NimbleClientTypes.StudioComponent]?
}

extension ListStudioComponentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case studioComponents
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let studioComponentsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioComponent?].self, forKey: .studioComponents)
        var studioComponentsDecoded0:[NimbleClientTypes.StudioComponent]? = nil
        if let studioComponentsContainer = studioComponentsContainer {
            studioComponentsDecoded0 = [NimbleClientTypes.StudioComponent]()
            for structure0 in studioComponentsContainer {
                if let structure0 = structure0 {
                    studioComponentsDecoded0?.append(structure0)
                }
            }
        }
        studioComponents = studioComponentsDecoded0
    }
}

extension ListStudioMembersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListStudioMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/membership"
    }
}

public struct ListStudioMembersInput: Swift.Equatable {
    /// The max number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.studioId = studioId
    }
}

struct ListStudioMembersInputBody: Swift.Equatable {
}

extension ListStudioMembersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListStudioMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStudioMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStudioMembersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStudioMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStudioMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListStudioMembersOutputResponse: Swift.Equatable {
    /// A list of members.
    public var members: [NimbleClientTypes.StudioMembership]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        members: [NimbleClientTypes.StudioMembership]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListStudioMembersOutputResponseBody: Swift.Equatable {
    let members: [NimbleClientTypes.StudioMembership]?
    let nextToken: Swift.String?
}

extension ListStudioMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioMembership?].self, forKey: .members)
        var membersDecoded0:[NimbleClientTypes.StudioMembership]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [NimbleClientTypes.StudioMembership]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStudiosInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListStudiosInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-08-01/studios"
    }
}

public struct ListStudiosInput: Swift.Equatable {
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListStudiosInputBody: Swift.Equatable {
}

extension ListStudiosInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListStudiosOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStudiosOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStudiosOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStudiosOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStudiosOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.studios = output.studios
        } else {
            self.nextToken = nil
            self.studios = nil
        }
    }
}

///
public struct ListStudiosOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A collection of studios.
    /// This member is required.
    public var studios: [NimbleClientTypes.Studio]?

    public init (
        nextToken: Swift.String? = nil,
        studios: [NimbleClientTypes.Studio]? = nil
    )
    {
        self.nextToken = nextToken
        self.studios = studios
    }
}

struct ListStudiosOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let studios: [NimbleClientTypes.Studio]?
}

extension ListStudiosOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case studios
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let studiosContainer = try containerValues.decodeIfPresent([NimbleClientTypes.Studio?].self, forKey: .studios)
        var studiosDecoded0:[NimbleClientTypes.Studio]? = nil
        if let studiosContainer = studiosContainer {
            studiosDecoded0 = [NimbleClientTypes.Studio]()
            for structure0 in studiosContainer {
                if let structure0 = structure0 {
                    studiosDecoded0?.append(structure0)
                }
            }
        }
        studios = studiosDecoded0
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/2020-08-01/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource for which you want to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

///
public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A collection of labels, in the form of key:value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NimbleClientTypes.NewLaunchProfileMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case persona
        case principalId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let persona = persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let personaDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfilePersona.self, forKey: .persona)
        persona = personaDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension NimbleClientTypes {
    ///
    public struct NewLaunchProfileMember: Swift.Equatable {
        /// The persona.
        /// This member is required.
        public var persona: NimbleClientTypes.LaunchProfilePersona?
        /// The principal ID.
        /// This member is required.
        public var principalId: Swift.String?

        public init (
            persona: NimbleClientTypes.LaunchProfilePersona? = nil,
            principalId: Swift.String? = nil
        )
        {
            self.persona = persona
            self.principalId = principalId
        }
    }

}

extension NimbleClientTypes.NewStudioMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case persona
        case principalId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let persona = persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let personaDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioPersona.self, forKey: .persona)
        persona = personaDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension NimbleClientTypes {
    ///
    public struct NewStudioMember: Swift.Equatable {
        /// The persona.
        /// This member is required.
        public var persona: NimbleClientTypes.StudioPersona?
        /// The principal ID.
        /// This member is required.
        public var principalId: Swift.String?

        public init (
            persona: NimbleClientTypes.StudioPersona? = nil,
            principalId: Swift.String? = nil
        )
        {
            self.persona = persona
            self.principalId = principalId
        }
    }

}

extension PutLaunchProfileMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case members
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for newlaunchprofilememberlist0 in members {
                try membersContainer.encode(newlaunchprofilememberlist0)
            }
        }
    }
}

extension PutLaunchProfileMembersInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension PutLaunchProfileMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership"
    }
}

///
public struct PutLaunchProfileMembersInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The ID of the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The Launch Profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// A list of members.
    /// This member is required.
    public var members: [NimbleClientTypes.NewLaunchProfileMember]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        members: [NimbleClientTypes.NewLaunchProfileMember]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.identityStoreId = identityStoreId
        self.launchProfileId = launchProfileId
        self.members = members
        self.studioId = studioId
    }
}

struct PutLaunchProfileMembersInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let members: [NimbleClientTypes.NewLaunchProfileMember]?
}

extension PutLaunchProfileMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case members
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.NewLaunchProfileMember?].self, forKey: .members)
        var membersDecoded0:[NimbleClientTypes.NewLaunchProfileMember]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [NimbleClientTypes.NewLaunchProfileMember]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
    }
}

extension PutLaunchProfileMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLaunchProfileMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLaunchProfileMembersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLaunchProfileMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutLaunchProfileMembersOutputResponse: Swift.Equatable {

}

extension PutStudioMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case members
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for newstudiomemberlist0 in members {
                try membersContainer.encode(newstudiomemberlist0)
            }
        }
    }
}

extension PutStudioMembersInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension PutStudioMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/membership"
    }
}

///
public struct PutStudioMembersInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The ID of the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// A list of members.
    /// This member is required.
    public var members: [NimbleClientTypes.NewStudioMember]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        members: [NimbleClientTypes.NewStudioMember]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.identityStoreId = identityStoreId
        self.members = members
        self.studioId = studioId
    }
}

struct PutStudioMembersInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let members: [NimbleClientTypes.NewStudioMember]?
}

extension PutStudioMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case members
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.NewStudioMember?].self, forKey: .members)
        var membersDecoded0:[NimbleClientTypes.NewStudioMember]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [NimbleClientTypes.NewStudioMember]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
    }
}

extension PutStudioMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutStudioMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutStudioMembersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutStudioMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

///
public struct PutStudioMembersOutputResponse: Swift.Equatable {

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A more specific error code.
    public var code: Swift.String?
    /// The exception context.
    public var context: [Swift.String:Swift.String]?
    /// A human-readable description of the error.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let context: [Swift.String:Swift.String]?
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case context
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NimbleClientTypes.ScriptParameterKeyValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension NimbleClientTypes {
    /// A parameter for a studio component script, in the form of a key:value pair.
    public struct ScriptParameterKeyValue: Swift.Equatable {
        /// A script parameter key.
        public var key: Swift.String?
        /// A script parameter value.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your current quota does not allow you to perform the request action. You can request increases for some quotas, and other quotas cannot be increased. Please use AWS Service Quotas to request an increase.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A more specific error code.
    public var code: Swift.String?
    /// The exception context.
    public var context: [Swift.String:Swift.String]?
    /// A human-readable description of the error.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let context: [Swift.String:Swift.String]?
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case context
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NimbleClientTypes.SharedFileSystemConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
        case fileSystemId
        case linuxMountPoint
        case shareName
        case windowsMountDrive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let linuxMountPoint = linuxMountPoint {
            try encodeContainer.encode(linuxMountPoint, forKey: .linuxMountPoint)
        }
        if let shareName = shareName {
            try encodeContainer.encode(shareName, forKey: .shareName)
        }
        if let windowsMountDrive = windowsMountDrive {
            try encodeContainer.encode(windowsMountDrive, forKey: .windowsMountDrive)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let linuxMountPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linuxMountPoint)
        linuxMountPoint = linuxMountPointDecoded
        let shareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareName)
        shareName = shareNameDecoded
        let windowsMountDriveDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowsMountDrive)
        windowsMountDrive = windowsMountDriveDecoded
    }
}

extension NimbleClientTypes.SharedFileSystemConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SharedFileSystemConfiguration(fileSystemId: \(Swift.String(describing: fileSystemId)), linuxMountPoint: \(Swift.String(describing: linuxMountPoint)), windowsMountDrive: \(Swift.String(describing: windowsMountDrive)), endpoint: \"CONTENT_REDACTED\", shareName: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// The configuration for a shared file storage system that is associated with a studio resource.
    public struct SharedFileSystemConfiguration: Swift.Equatable {
        /// The endpoint of the shared file system that is accessed by the studio component resource.
        public var endpoint: Swift.String?
        /// The unique identifier for a file system.
        public var fileSystemId: Swift.String?
        /// The mount location for a shared file system on a Linux virtual workstation.
        public var linuxMountPoint: Swift.String?
        /// The name of the file share.
        public var shareName: Swift.String?
        /// The mount location for a shared file system on a Windows virtual workstation.
        public var windowsMountDrive: Swift.String?

        public init (
            endpoint: Swift.String? = nil,
            fileSystemId: Swift.String? = nil,
            linuxMountPoint: Swift.String? = nil,
            shareName: Swift.String? = nil,
            windowsMountDrive: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
            self.fileSystemId = fileSystemId
            self.linuxMountPoint = linuxMountPoint
            self.shareName = shareName
            self.windowsMountDrive = windowsMountDrive
        }
    }

}

extension StartStreamingSessionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension StartStreamingSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())/start"
    }
}

public struct StartStreamingSessionInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The streaming session ID for the StartStreamingSessionRequest.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The studio ID for the StartStreamingSessionRequest.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

struct StartStreamingSessionInputBody: Swift.Equatable {
}

extension StartStreamingSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StartStreamingSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartStreamingSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartStreamingSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartStreamingSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartStreamingSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct StartStreamingSessionOutputResponse: Swift.Equatable {
    /// A streaming session is a virtual workstation created using a particular launch profile.
    public var session: NimbleClientTypes.StreamingSession?

    public init (
        session: NimbleClientTypes.StreamingSession? = nil
    )
    {
        self.session = session
    }
}

struct StartStreamingSessionOutputResponseBody: Swift.Equatable {
    let session: NimbleClientTypes.StreamingSession?
}

extension StartStreamingSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSession.self, forKey: .session)
        session = sessionDecoded
    }
}

extension StartStudioSSOConfigurationRepairInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension StartStudioSSOConfigurationRepairInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/sso-configuration"
    }
}

public struct StartStudioSSOConfigurationRepairInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.studioId = studioId
    }
}

struct StartStudioSSOConfigurationRepairInputBody: Swift.Equatable {
}

extension StartStudioSSOConfigurationRepairInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StartStudioSSOConfigurationRepairOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartStudioSSOConfigurationRepairOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartStudioSSOConfigurationRepairOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartStudioSSOConfigurationRepairOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartStudioSSOConfigurationRepairOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

///
public struct StartStudioSSOConfigurationRepairOutputResponse: Swift.Equatable {
    /// Information about a studio.
    /// This member is required.
    public var studio: NimbleClientTypes.Studio?

    public init (
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct StartStudioSSOConfigurationRepairOutputResponseBody: Swift.Equatable {
    let studio: NimbleClientTypes.Studio?
}

extension StartStudioSSOConfigurationRepairOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studio
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

extension StopStreamingSessionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension StopStreamingSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())/stop"
    }
}

public struct StopStreamingSessionInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The streaming session ID for the StopStreamingSessionRequest.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The studioId for the StopStreamingSessionRequest.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

struct StopStreamingSessionInputBody: Swift.Equatable {
}

extension StopStreamingSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopStreamingSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopStreamingSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopStreamingSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopStreamingSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopStreamingSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct StopStreamingSessionOutputResponse: Swift.Equatable {
    /// A streaming session is a virtual workstation created using a particular launch profile.
    public var session: NimbleClientTypes.StreamingSession?

    public init (
        session: NimbleClientTypes.StreamingSession? = nil
    )
    {
        self.session = session
    }
}

struct StopStreamingSessionOutputResponseBody: Swift.Equatable {
    let session: NimbleClientTypes.StreamingSession?
}

extension StopStreamingSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSession.self, forKey: .session)
        session = sessionDecoded
    }
}

extension NimbleClientTypes.StreamConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clipboardMode
        case ec2InstanceTypes
        case maxSessionLengthInMinutes
        case maxStoppedSessionLengthInMinutes
        case streamingImageIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clipboardMode = clipboardMode {
            try encodeContainer.encode(clipboardMode.rawValue, forKey: .clipboardMode)
        }
        if let ec2InstanceTypes = ec2InstanceTypes {
            var ec2InstanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceTypes)
            for streaminginstancetypelist0 in ec2InstanceTypes {
                try ec2InstanceTypesContainer.encode(streaminginstancetypelist0.rawValue)
            }
        }
        if let maxSessionLengthInMinutes = maxSessionLengthInMinutes {
            try encodeContainer.encode(maxSessionLengthInMinutes, forKey: .maxSessionLengthInMinutes)
        }
        if let maxStoppedSessionLengthInMinutes = maxStoppedSessionLengthInMinutes {
            try encodeContainer.encode(maxStoppedSessionLengthInMinutes, forKey: .maxStoppedSessionLengthInMinutes)
        }
        if let streamingImageIds = streamingImageIds {
            var streamingImageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .streamingImageIds)
            for streamingimageidlist0 in streamingImageIds {
                try streamingImageIdsContainer.encode(streamingimageidlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clipboardModeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingClipboardMode.self, forKey: .clipboardMode)
        clipboardMode = clipboardModeDecoded
        let ec2InstanceTypesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StreamingInstanceType?].self, forKey: .ec2InstanceTypes)
        var ec2InstanceTypesDecoded0:[NimbleClientTypes.StreamingInstanceType]? = nil
        if let ec2InstanceTypesContainer = ec2InstanceTypesContainer {
            ec2InstanceTypesDecoded0 = [NimbleClientTypes.StreamingInstanceType]()
            for string0 in ec2InstanceTypesContainer {
                if let string0 = string0 {
                    ec2InstanceTypesDecoded0?.append(string0)
                }
            }
        }
        ec2InstanceTypes = ec2InstanceTypesDecoded0
        let maxSessionLengthInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSessionLengthInMinutes)
        maxSessionLengthInMinutes = maxSessionLengthInMinutesDecoded
        let streamingImageIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .streamingImageIds)
        var streamingImageIdsDecoded0:[Swift.String]? = nil
        if let streamingImageIdsContainer = streamingImageIdsContainer {
            streamingImageIdsDecoded0 = [Swift.String]()
            for string0 in streamingImageIdsContainer {
                if let string0 = string0 {
                    streamingImageIdsDecoded0?.append(string0)
                }
            }
        }
        streamingImageIds = streamingImageIdsDecoded0
        let maxStoppedSessionLengthInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxStoppedSessionLengthInMinutes)
        maxStoppedSessionLengthInMinutes = maxStoppedSessionLengthInMinutesDecoded
    }
}

extension NimbleClientTypes {
    /// A configuration for a streaming session.
    public struct StreamConfiguration: Swift.Equatable {
        /// Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.
        /// This member is required.
        public var clipboardMode: NimbleClientTypes.StreamingClipboardMode?
        /// The EC2 instance types that users can select from when launching a streaming session with this launch profile.
        /// This member is required.
        public var ec2InstanceTypes: [NimbleClientTypes.StreamingInstanceType]?
        /// The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.
        public var maxSessionLengthInMinutes: Swift.Int?
        /// Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760. If the value is missing or set to 0, your sessions can’t be stopped. If you then call StopStreamingSession, the session fails. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be terminated by AWS (instead of stopped). If the value is set to a positive number, the session can be stopped. You can call StopStreamingSession to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be stopped by AWS (instead of terminated).
        public var maxStoppedSessionLengthInMinutes: Swift.Int?
        /// The streaming images that users can select from when launching a streaming session with this launch profile.
        /// This member is required.
        public var streamingImageIds: [Swift.String]?

        public init (
            clipboardMode: NimbleClientTypes.StreamingClipboardMode? = nil,
            ec2InstanceTypes: [NimbleClientTypes.StreamingInstanceType]? = nil,
            maxSessionLengthInMinutes: Swift.Int? = nil,
            maxStoppedSessionLengthInMinutes: Swift.Int? = nil,
            streamingImageIds: [Swift.String]? = nil
        )
        {
            self.clipboardMode = clipboardMode
            self.ec2InstanceTypes = ec2InstanceTypes
            self.maxSessionLengthInMinutes = maxSessionLengthInMinutes
            self.maxStoppedSessionLengthInMinutes = maxStoppedSessionLengthInMinutes
            self.streamingImageIds = streamingImageIds
        }
    }

}

extension NimbleClientTypes.StreamConfigurationCreate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clipboardMode
        case ec2InstanceTypes
        case maxSessionLengthInMinutes
        case maxStoppedSessionLengthInMinutes
        case streamingImageIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clipboardMode = clipboardMode {
            try encodeContainer.encode(clipboardMode.rawValue, forKey: .clipboardMode)
        }
        if let ec2InstanceTypes = ec2InstanceTypes {
            var ec2InstanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceTypes)
            for streaminginstancetypelist0 in ec2InstanceTypes {
                try ec2InstanceTypesContainer.encode(streaminginstancetypelist0.rawValue)
            }
        }
        if let maxSessionLengthInMinutes = maxSessionLengthInMinutes {
            try encodeContainer.encode(maxSessionLengthInMinutes, forKey: .maxSessionLengthInMinutes)
        }
        if let maxStoppedSessionLengthInMinutes = maxStoppedSessionLengthInMinutes {
            try encodeContainer.encode(maxStoppedSessionLengthInMinutes, forKey: .maxStoppedSessionLengthInMinutes)
        }
        if let streamingImageIds = streamingImageIds {
            var streamingImageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .streamingImageIds)
            for streamingimageidlist0 in streamingImageIds {
                try streamingImageIdsContainer.encode(streamingimageidlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clipboardModeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingClipboardMode.self, forKey: .clipboardMode)
        clipboardMode = clipboardModeDecoded
        let ec2InstanceTypesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StreamingInstanceType?].self, forKey: .ec2InstanceTypes)
        var ec2InstanceTypesDecoded0:[NimbleClientTypes.StreamingInstanceType]? = nil
        if let ec2InstanceTypesContainer = ec2InstanceTypesContainer {
            ec2InstanceTypesDecoded0 = [NimbleClientTypes.StreamingInstanceType]()
            for string0 in ec2InstanceTypesContainer {
                if let string0 = string0 {
                    ec2InstanceTypesDecoded0?.append(string0)
                }
            }
        }
        ec2InstanceTypes = ec2InstanceTypesDecoded0
        let maxSessionLengthInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSessionLengthInMinutes)
        maxSessionLengthInMinutes = maxSessionLengthInMinutesDecoded
        let streamingImageIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .streamingImageIds)
        var streamingImageIdsDecoded0:[Swift.String]? = nil
        if let streamingImageIdsContainer = streamingImageIdsContainer {
            streamingImageIdsDecoded0 = [Swift.String]()
            for string0 in streamingImageIdsContainer {
                if let string0 = string0 {
                    streamingImageIdsDecoded0?.append(string0)
                }
            }
        }
        streamingImageIds = streamingImageIdsDecoded0
        let maxStoppedSessionLengthInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxStoppedSessionLengthInMinutes)
        maxStoppedSessionLengthInMinutes = maxStoppedSessionLengthInMinutesDecoded
    }
}

extension NimbleClientTypes {
    /// Configuration for streaming workstations created using this launch profile.
    public struct StreamConfigurationCreate: Swift.Equatable {
        /// Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.
        /// This member is required.
        public var clipboardMode: NimbleClientTypes.StreamingClipboardMode?
        /// The EC2 instance types that users can select from when launching a streaming session with this launch profile.
        /// This member is required.
        public var ec2InstanceTypes: [NimbleClientTypes.StreamingInstanceType]?
        /// The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.
        public var maxSessionLengthInMinutes: Swift.Int?
        /// The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.
        public var maxStoppedSessionLengthInMinutes: Swift.Int?
        /// The streaming images that users can select from when launching a streaming session with this launch profile.
        /// This member is required.
        public var streamingImageIds: [Swift.String]?

        public init (
            clipboardMode: NimbleClientTypes.StreamingClipboardMode? = nil,
            ec2InstanceTypes: [NimbleClientTypes.StreamingInstanceType]? = nil,
            maxSessionLengthInMinutes: Swift.Int? = nil,
            maxStoppedSessionLengthInMinutes: Swift.Int? = nil,
            streamingImageIds: [Swift.String]? = nil
        )
        {
            self.clipboardMode = clipboardMode
            self.ec2InstanceTypes = ec2InstanceTypes
            self.maxSessionLengthInMinutes = maxSessionLengthInMinutes
            self.maxStoppedSessionLengthInMinutes = maxStoppedSessionLengthInMinutes
            self.streamingImageIds = streamingImageIds
        }
    }

}

extension NimbleClientTypes {
    ///
    public enum StreamingClipboardMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingClipboardMode] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingClipboardMode(rawValue: rawValue) ?? StreamingClipboardMode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.StreamingImage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case ec2ImageId
        case encryptionConfiguration
        case eulaIds
        case name
        case owner
        case platform
        case state
        case statusCode
        case statusMessage
        case streamingImageId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2ImageId = ec2ImageId {
            try encodeContainer.encode(ec2ImageId, forKey: .ec2ImageId)
        }
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let eulaIds = eulaIds {
            var eulaIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eulaIds)
            for eulaidlist0 in eulaIds {
                try eulaIdsContainer.encode(eulaidlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let streamingImageId = streamingImageId {
            try encodeContainer.encode(streamingImageId, forKey: .streamingImageId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2ImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2ImageId)
        ec2ImageId = ec2ImageIdDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImageEncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let eulaIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eulaIds)
        var eulaIdsDecoded0:[Swift.String]? = nil
        if let eulaIdsContainer = eulaIdsContainer {
            eulaIdsDecoded0 = [Swift.String]()
            for string0 in eulaIdsContainer {
                if let string0 = string0 {
                    eulaIdsDecoded0?.append(string0)
                }
            }
        }
        eulaIds = eulaIdsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImageState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImageStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let streamingImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingImageId)
        streamingImageId = streamingImageIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NimbleClientTypes.StreamingImage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingImage(arn: \(Swift.String(describing: arn)), ec2ImageId: \(Swift.String(describing: ec2ImageId)), encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), eulaIds: \(Swift.String(describing: eulaIds)), owner: \(Swift.String(describing: owner)), platform: \(Swift.String(describing: platform)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), streamingImageId: \(Swift.String(describing: streamingImageId)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// Represents a streaming image resource. Streaming images are used by studio users to select which operating system and software they want to use in a Nimble Studio streaming session. Amazon provides a number of streaming images that include popular 3rd-party software. You can create your own streaming images using an Amazon Elastic Compute Cloud (Amazon EC2) machine image that you create for this purpose. You can also include software that your users require.
    public struct StreamingImage: Swift.Equatable {
        /// The ARN of the resource.
        public var arn: Swift.String?
        /// A human-readable description of the streaming image.
        public var description: Swift.String?
        /// The ID of an EC2 machine image with which to create the streaming image.
        public var ec2ImageId: Swift.String?
        /// The encryption configuration.
        public var encryptionConfiguration: NimbleClientTypes.StreamingImageEncryptionConfiguration?
        /// The list of EULAs that must be accepted before a Streaming Session can be started using this streaming image.
        public var eulaIds: [Swift.String]?
        /// A friendly name for a streaming image resource.
        public var name: Swift.String?
        /// The owner of the streaming image, either the studioId that contains the streaming image, or 'amazon' for images that are provided by Amazon Nimble Studio.
        public var owner: Swift.String?
        /// The platform of the streaming image, either WINDOWS or LINUX.
        public var platform: Swift.String?
        /// The current state.
        public var state: NimbleClientTypes.StreamingImageState?
        /// The status code.
        public var statusCode: NimbleClientTypes.StreamingImageStatusCode?
        /// The status message for the streaming image.
        public var statusMessage: Swift.String?
        /// The ID of the streaming image.
        public var streamingImageId: Swift.String?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            ec2ImageId: Swift.String? = nil,
            encryptionConfiguration: NimbleClientTypes.StreamingImageEncryptionConfiguration? = nil,
            eulaIds: [Swift.String]? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            platform: Swift.String? = nil,
            state: NimbleClientTypes.StreamingImageState? = nil,
            statusCode: NimbleClientTypes.StreamingImageStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            streamingImageId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.ec2ImageId = ec2ImageId
            self.encryptionConfiguration = encryptionConfiguration
            self.eulaIds = eulaIds
            self.name = name
            self.owner = owner
            self.platform = platform
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.streamingImageId = streamingImageId
            self.tags = tags
        }
    }

}

extension NimbleClientTypes.StreamingImageEncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyArn
        case keyType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyArn = keyArn {
            try encodeContainer.encode(keyArn, forKey: .keyArn)
        }
        if let keyType = keyType {
            try encodeContainer.encode(keyType.rawValue, forKey: .keyType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImageEncryptionConfigurationKeyType.self, forKey: .keyType)
        keyType = keyTypeDecoded
    }
}

extension NimbleClientTypes {
    /// Specifies how a streaming image is encrypted.
    public struct StreamingImageEncryptionConfiguration: Swift.Equatable {
        /// The ARN for a KMS key that is used to encrypt studio data.
        public var keyArn: Swift.String?
        /// The type of KMS key that is used to encrypt studio data.
        /// This member is required.
        public var keyType: NimbleClientTypes.StreamingImageEncryptionConfigurationKeyType?

        public init (
            keyArn: Swift.String? = nil,
            keyType: NimbleClientTypes.StreamingImageEncryptionConfigurationKeyType? = nil
        )
        {
            self.keyArn = keyArn
            self.keyType = keyType
        }
    }

}

extension NimbleClientTypes {
    ///
    public enum StreamingImageEncryptionConfigurationKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customerManagedKey
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingImageEncryptionConfigurationKeyType] {
            return [
                .customerManagedKey,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customerManagedKey: return "CUSTOMER_MANAGED_KEY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingImageEncryptionConfigurationKeyType(rawValue: rawValue) ?? StreamingImageEncryptionConfigurationKeyType.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    ///
    public enum StreamingImageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingImageState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingImageState(rawValue: rawValue) ?? StreamingImageState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    /// The status code.
    public enum StreamingImageStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalError
        case streamingImageCreateInProgress
        case streamingImageDeleted
        case streamingImageDeleteInProgress
        case streamingImageReady
        case streamingImageUpdateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingImageStatusCode] {
            return [
                .internalError,
                .streamingImageCreateInProgress,
                .streamingImageDeleted,
                .streamingImageDeleteInProgress,
                .streamingImageReady,
                .streamingImageUpdateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "INTERNAL_ERROR"
            case .streamingImageCreateInProgress: return "STREAMING_IMAGE_CREATE_IN_PROGRESS"
            case .streamingImageDeleted: return "STREAMING_IMAGE_DELETED"
            case .streamingImageDeleteInProgress: return "STREAMING_IMAGE_DELETE_IN_PROGRESS"
            case .streamingImageReady: return "STREAMING_IMAGE_READY"
            case .streamingImageUpdateInProgress: return "STREAMING_IMAGE_UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingImageStatusCode(rawValue: rawValue) ?? StreamingImageStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    ///
    public enum StreamingInstanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case g4dn12xlarge
        case g4dn16xlarge
        case g4dn2xlarge
        case g4dn4xlarge
        case g4dn8xlarge
        case g4dnXlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingInstanceType] {
            return [
                .g4dn12xlarge,
                .g4dn16xlarge,
                .g4dn2xlarge,
                .g4dn4xlarge,
                .g4dn8xlarge,
                .g4dnXlarge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .g4dn12xlarge: return "g4dn.12xlarge"
            case .g4dn16xlarge: return "g4dn.16xlarge"
            case .g4dn2xlarge: return "g4dn.2xlarge"
            case .g4dn4xlarge: return "g4dn.4xlarge"
            case .g4dn8xlarge: return "g4dn.8xlarge"
            case .g4dnXlarge: return "g4dn.xlarge"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingInstanceType(rawValue: rawValue) ?? StreamingInstanceType.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.StreamingSession: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case createdBy
        case ec2InstanceType
        case launchProfileId
        case ownedBy
        case sessionId
        case startedAt
        case startedBy
        case state
        case statusCode
        case statusMessage
        case stopAt
        case stoppedAt
        case stoppedBy
        case streamingImageId
        case tags
        case terminateAt
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let ec2InstanceType = ec2InstanceType {
            try encodeContainer.encode(ec2InstanceType, forKey: .ec2InstanceType)
        }
        if let launchProfileId = launchProfileId {
            try encodeContainer.encode(launchProfileId, forKey: .launchProfileId)
        }
        if let ownedBy = ownedBy {
            try encodeContainer.encode(ownedBy, forKey: .ownedBy)
        }
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
        if let startedBy = startedBy {
            try encodeContainer.encode(startedBy, forKey: .startedBy)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let stopAt = stopAt {
            try encodeContainer.encode(stopAt.timeIntervalSince1970, forKey: .stopAt)
        }
        if let stoppedAt = stoppedAt {
            try encodeContainer.encode(stoppedAt.timeIntervalSince1970, forKey: .stoppedAt)
        }
        if let stoppedBy = stoppedBy {
            try encodeContainer.encode(stoppedBy, forKey: .stoppedBy)
        }
        if let streamingImageId = streamingImageId {
            try encodeContainer.encode(streamingImageId, forKey: .streamingImageId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let terminateAt = terminateAt {
            try encodeContainer.encode(terminateAt.timeIntervalSince1970, forKey: .terminateAt)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let updatedBy = updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let ec2InstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceType)
        ec2InstanceType = ec2InstanceTypeDecoded
        let launchProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileId)
        launchProfileId = launchProfileIdDecoded
        let ownedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownedBy)
        ownedBy = ownedByDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let streamingImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingImageId)
        streamingImageId = streamingImageIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let terminateAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .terminateAt)
        terminateAt = terminateAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let stoppedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stoppedAt)
        stoppedAt = stoppedAtDecoded
        let stoppedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stoppedBy)
        stoppedBy = stoppedByDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let startedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startedBy)
        startedBy = startedByDecoded
        let stopAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stopAt)
        stopAt = stopAtDecoded
    }
}

extension NimbleClientTypes {
    /// A streaming session is a virtual workstation created using a particular launch profile.
    public struct StreamingSession: Swift.Equatable {
        /// The ARN of the resource.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The user ID of the user that created the streaming session.
        public var createdBy: Swift.String?
        /// The EC2 Instance type used for the streaming session.
        public var ec2InstanceType: Swift.String?
        /// The ID of the launch profile used to control access from the streaming session.
        public var launchProfileId: Swift.String?
        /// The user ID of the user that owns the streaming session.
        public var ownedBy: Swift.String?
        /// The session ID.
        public var sessionId: Swift.String?
        /// The time the session entered START_IN_PROGRESS state.
        public var startedAt: ClientRuntime.Date?
        /// The user ID of the user that started the streaming session.
        public var startedBy: Swift.String?
        /// The current state.
        public var state: NimbleClientTypes.StreamingSessionState?
        /// The status code.
        public var statusCode: NimbleClientTypes.StreamingSessionStatusCode?
        /// The status message for the streaming session.
        public var statusMessage: Swift.String?
        /// The time the streaming session will automatically be stopped if the user doesn’t stop the session themselves.
        public var stopAt: ClientRuntime.Date?
        /// The time the session entered STOP_IN_PROGRESS state.
        public var stoppedAt: ClientRuntime.Date?
        /// The user ID of the user that stopped the streaming session.
        public var stoppedBy: Swift.String?
        /// The ID of the streaming image.
        public var streamingImageId: Swift.String?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The time the streaming session will automatically terminate if not terminated by the user.
        public var terminateAt: ClientRuntime.Date?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user ID of the user that most recently updated the resource.
        public var updatedBy: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            ec2InstanceType: Swift.String? = nil,
            launchProfileId: Swift.String? = nil,
            ownedBy: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            startedBy: Swift.String? = nil,
            state: NimbleClientTypes.StreamingSessionState? = nil,
            statusCode: NimbleClientTypes.StreamingSessionStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            stopAt: ClientRuntime.Date? = nil,
            stoppedAt: ClientRuntime.Date? = nil,
            stoppedBy: Swift.String? = nil,
            streamingImageId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            terminateAt: ClientRuntime.Date? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.ec2InstanceType = ec2InstanceType
            self.launchProfileId = launchProfileId
            self.ownedBy = ownedBy
            self.sessionId = sessionId
            self.startedAt = startedAt
            self.startedBy = startedBy
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.stopAt = stopAt
            self.stoppedAt = stoppedAt
            self.stoppedBy = stoppedBy
            self.streamingImageId = streamingImageId
            self.tags = tags
            self.terminateAt = terminateAt
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension NimbleClientTypes {
    /// The streaming session state.
    public enum StreamingSessionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case startFailed
        case startInProgress
        case stopped
        case stopFailed
        case stopInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingSessionState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .startFailed,
                .startInProgress,
                .stopped,
                .stopFailed,
                .stopInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .startFailed: return "START_FAILED"
            case .startInProgress: return "START_IN_PROGRESS"
            case .stopped: return "STOPPED"
            case .stopFailed: return "STOP_FAILED"
            case .stopInProgress: return "STOP_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingSessionState(rawValue: rawValue) ?? StreamingSessionState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    ///
    public enum StreamingSessionStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activeDirectoryDomainJoinError
        case decryptStreamingImageError
        case initializationScriptError
        case insufficientCapacity
        case internalError
        case networkConnectionError
        case networkInterfaceError
        case streamingSessionCreateInProgress
        case streamingSessionDeleted
        case streamingSessionDeleteInProgress
        case streamingSessionReady
        case streamingSessionStarted
        case streamingSessionStartInProgress
        case streamingSessionStopped
        case streamingSessionStopInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingSessionStatusCode] {
            return [
                .activeDirectoryDomainJoinError,
                .decryptStreamingImageError,
                .initializationScriptError,
                .insufficientCapacity,
                .internalError,
                .networkConnectionError,
                .networkInterfaceError,
                .streamingSessionCreateInProgress,
                .streamingSessionDeleted,
                .streamingSessionDeleteInProgress,
                .streamingSessionReady,
                .streamingSessionStarted,
                .streamingSessionStartInProgress,
                .streamingSessionStopped,
                .streamingSessionStopInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activeDirectoryDomainJoinError: return "ACTIVE_DIRECTORY_DOMAIN_JOIN_ERROR"
            case .decryptStreamingImageError: return "DECRYPT_STREAMING_IMAGE_ERROR"
            case .initializationScriptError: return "INITIALIZATION_SCRIPT_ERROR"
            case .insufficientCapacity: return "INSUFFICIENT_CAPACITY"
            case .internalError: return "INTERNAL_ERROR"
            case .networkConnectionError: return "NETWORK_CONNECTION_ERROR"
            case .networkInterfaceError: return "NETWORK_INTERFACE_ERROR"
            case .streamingSessionCreateInProgress: return "STREAMING_SESSION_CREATE_IN_PROGRESS"
            case .streamingSessionDeleted: return "STREAMING_SESSION_DELETED"
            case .streamingSessionDeleteInProgress: return "STREAMING_SESSION_DELETE_IN_PROGRESS"
            case .streamingSessionReady: return "STREAMING_SESSION_READY"
            case .streamingSessionStarted: return "STREAMING_SESSION_STARTED"
            case .streamingSessionStartInProgress: return "STREAMING_SESSION_START_IN_PROGRESS"
            case .streamingSessionStopped: return "STREAMING_SESSION_STOPPED"
            case .streamingSessionStopInProgress: return "STREAMING_SESSION_STOP_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingSessionStatusCode(rawValue: rawValue) ?? StreamingSessionStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.StreamingSessionStream: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case expiresAt
        case ownedBy
        case state
        case statusCode
        case streamId
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let expiresAt = expiresAt {
            try encodeContainer.encode(expiresAt.timeIntervalSince1970, forKey: .expiresAt)
        }
        if let ownedBy = ownedBy {
            try encodeContainer.encode(ownedBy, forKey: .ownedBy)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let streamId = streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let expiresAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expiresAt)
        expiresAt = expiresAtDecoded
        let ownedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownedBy)
        ownedBy = ownedByDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionStreamState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionStreamStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension NimbleClientTypes.StreamingSessionStream: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingSessionStream(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), expiresAt: \(Swift.String(describing: expiresAt)), ownedBy: \(Swift.String(describing: ownedBy)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), streamId: \(Swift.String(describing: streamId)), url: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// A stream is an active connection to a streaming session, enabling a studio user to control the streaming session using a compatible client. Streaming session streams are compatible with the NICE DCV web client, included in the Nimble Studio portal, or the NICE DCV desktop client.
    public struct StreamingSessionStream: Swift.Equatable {
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The user ID of the user that created the streaming session stream.
        public var createdBy: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource expires.
        public var expiresAt: ClientRuntime.Date?
        /// The user ID of the user that owns the streaming session.
        public var ownedBy: Swift.String?
        /// The current state.
        public var state: NimbleClientTypes.StreamingSessionStreamState?
        /// The streaming session stream status code.
        public var statusCode: NimbleClientTypes.StreamingSessionStreamStatusCode?
        /// The stream ID.
        public var streamId: Swift.String?
        /// The URL to connect to this stream using the DCV client.
        public var url: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            expiresAt: ClientRuntime.Date? = nil,
            ownedBy: Swift.String? = nil,
            state: NimbleClientTypes.StreamingSessionStreamState? = nil,
            statusCode: NimbleClientTypes.StreamingSessionStreamStatusCode? = nil,
            streamId: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.expiresAt = expiresAt
            self.ownedBy = ownedBy
            self.state = state
            self.statusCode = statusCode
            self.streamId = streamId
            self.url = url
        }
    }

}

extension NimbleClientTypes {
    ///
    public enum StreamingSessionStreamState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingSessionStreamState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingSessionStreamState(rawValue: rawValue) ?? StreamingSessionStreamState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    ///
    public enum StreamingSessionStreamStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalError
        case networkConnectionError
        case streamCreateInProgress
        case streamDeleted
        case streamDeleteInProgress
        case streamReady
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingSessionStreamStatusCode] {
            return [
                .internalError,
                .networkConnectionError,
                .streamCreateInProgress,
                .streamDeleted,
                .streamDeleteInProgress,
                .streamReady,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "INTERNAL_ERROR"
            case .networkConnectionError: return "NETWORK_CONNECTION_ERROR"
            case .streamCreateInProgress: return "STREAM_CREATE_IN_PROGRESS"
            case .streamDeleted: return "STREAM_DELETED"
            case .streamDeleteInProgress: return "STREAM_DELETE_IN_PROGRESS"
            case .streamReady: return "STREAM_READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingSessionStreamStatusCode(rawValue: rawValue) ?? StreamingSessionStreamStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.Studio: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminRoleArn
        case arn
        case createdAt
        case displayName
        case homeRegion
        case ssoClientId
        case state
        case statusCode
        case statusMessage
        case studioEncryptionConfiguration
        case studioId
        case studioName
        case studioUrl
        case tags
        case updatedAt
        case userRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminRoleArn = adminRoleArn {
            try encodeContainer.encode(adminRoleArn, forKey: .adminRoleArn)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let ssoClientId = ssoClientId {
            try encodeContainer.encode(ssoClientId, forKey: .ssoClientId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let studioEncryptionConfiguration = studioEncryptionConfiguration {
            try encodeContainer.encode(studioEncryptionConfiguration, forKey: .studioEncryptionConfiguration)
        }
        if let studioId = studioId {
            try encodeContainer.encode(studioId, forKey: .studioId)
        }
        if let studioName = studioName {
            try encodeContainer.encode(studioName, forKey: .studioName)
        }
        if let studioUrl = studioUrl {
            try encodeContainer.encode(studioUrl, forKey: .studioUrl)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let userRoleArn = userRoleArn {
            try encodeContainer.encode(userRoleArn, forKey: .userRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminRoleArn)
        adminRoleArn = adminRoleArnDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let ssoClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssoClientId)
        ssoClientId = ssoClientIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let studioEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioEncryptionConfiguration.self, forKey: .studioEncryptionConfiguration)
        studioEncryptionConfiguration = studioEncryptionConfigurationDecoded
        let studioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioId)
        studioId = studioIdDecoded
        let studioNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioName)
        studioName = studioNameDecoded
        let studioUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioUrl)
        studioUrl = studioUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let userRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userRoleArn)
        userRoleArn = userRoleArnDecoded
    }
}

extension NimbleClientTypes.Studio: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Studio(adminRoleArn: \(Swift.String(describing: adminRoleArn)), arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), homeRegion: \(Swift.String(describing: homeRegion)), ssoClientId: \(Swift.String(describing: ssoClientId)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), studioEncryptionConfiguration: \(Swift.String(describing: studioEncryptionConfiguration)), studioId: \(Swift.String(describing: studioId)), studioName: \(Swift.String(describing: studioName)), studioUrl: \(Swift.String(describing: studioUrl)), tags: \(Swift.String(describing: tags)), updatedAt: \(Swift.String(describing: updatedAt)), userRoleArn: \(Swift.String(describing: userRoleArn)), displayName: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// Represents a studio resource. A studio is the core resource used with Nimble Studio. You must create a studio first, before any other resource type can be created. All other resources you create and manage in Nimble Studio are contained within a studio. When creating a studio, you must provides two IAM roles for use with the Nimble Studio portal. These roles are assumed by your users when they log in to the Nimble Studio portal via Amazon Web Services SSO and your identity source. The user role must have the AmazonNimbleStudio-StudioUser managed policy attached for the portal to function properly. The admin role must have the AmazonNimbleStudio-StudioAdmin managed policy attached for the portal to function properly. Your studio roles must trust the identity.nimble.amazonaws.com service principal to function properly.
    public struct Studio: Swift.Equatable {
        /// The IAM role that studio admins assume when logging in to the Nimble Studio portal.
        public var adminRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// A friendly name for the studio.
        public var displayName: Swift.String?
        /// The Amazon Web Services Region where the studio resource is located.
        public var homeRegion: Swift.String?
        /// The Amazon Web Services SSO application client ID used to integrate with Amazon Web Services SSO to enable Amazon Web Services SSO users to log in to Nimble Studio portal.
        public var ssoClientId: Swift.String?
        /// The current state of the studio resource.
        public var state: NimbleClientTypes.StudioState?
        /// Status codes that provide additional detail on the studio state.
        public var statusCode: NimbleClientTypes.StudioStatusCode?
        /// Additional detail on the studio state.
        public var statusMessage: Swift.String?
        /// Configuration of the encryption method that is used for the studio.
        public var studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration?
        /// The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.
        public var studioId: Swift.String?
        /// The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.
        public var studioName: Swift.String?
        /// The address of the web page for the studio.
        public var studioUrl: Swift.String?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The IAM role that studio users assume when logging in to the Nimble Studio portal.
        public var userRoleArn: Swift.String?

        public init (
            adminRoleArn: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            homeRegion: Swift.String? = nil,
            ssoClientId: Swift.String? = nil,
            state: NimbleClientTypes.StudioState? = nil,
            statusCode: NimbleClientTypes.StudioStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration? = nil,
            studioId: Swift.String? = nil,
            studioName: Swift.String? = nil,
            studioUrl: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            userRoleArn: Swift.String? = nil
        )
        {
            self.adminRoleArn = adminRoleArn
            self.arn = arn
            self.createdAt = createdAt
            self.displayName = displayName
            self.homeRegion = homeRegion
            self.ssoClientId = ssoClientId
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.studioEncryptionConfiguration = studioEncryptionConfiguration
            self.studioId = studioId
            self.studioName = studioName
            self.studioUrl = studioUrl
            self.tags = tags
            self.updatedAt = updatedAt
            self.userRoleArn = userRoleArn
        }
    }

}

extension NimbleClientTypes.StudioComponent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case configuration
        case createdAt
        case createdBy
        case description
        case ec2SecurityGroupIds
        case initializationScripts
        case name
        case scriptParameters
        case state
        case statusCode
        case statusMessage
        case studioComponentId
        case subtype
        case tags
        case type
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SecurityGroupIds = ec2SecurityGroupIds {
            var ec2SecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SecurityGroupIds)
            for studiocomponentsecuritygroupidlist0 in ec2SecurityGroupIds {
                try ec2SecurityGroupIdsContainer.encode(studiocomponentsecuritygroupidlist0)
            }
        }
        if let initializationScripts = initializationScripts {
            var initializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .initializationScripts)
            for studiocomponentinitializationscriptlist0 in initializationScripts {
                try initializationScriptsContainer.encode(studiocomponentinitializationscriptlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scriptParameters = scriptParameters {
            var scriptParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scriptParameters)
            for studiocomponentscriptparameterkeyvaluelist0 in scriptParameters {
                try scriptParametersContainer.encode(studiocomponentscriptparameterkeyvaluelist0)
            }
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let studioComponentId = studioComponentId {
            try encodeContainer.encode(studioComponentId, forKey: .studioComponentId)
        }
        if let subtype = subtype {
            try encodeContainer.encode(subtype.rawValue, forKey: .subtype)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let updatedBy = updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SecurityGroupIds)
        var ec2SecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let ec2SecurityGroupIdsContainer = ec2SecurityGroupIdsContainer {
            ec2SecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in ec2SecurityGroupIdsContainer {
                if let string0 = string0 {
                    ec2SecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SecurityGroupIds = ec2SecurityGroupIdsDecoded0
        let initializationScriptsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioComponentInitializationScript?].self, forKey: .initializationScripts)
        var initializationScriptsDecoded0:[NimbleClientTypes.StudioComponentInitializationScript]? = nil
        if let initializationScriptsContainer = initializationScriptsContainer {
            initializationScriptsDecoded0 = [NimbleClientTypes.StudioComponentInitializationScript]()
            for structure0 in initializationScriptsContainer {
                if let structure0 = structure0 {
                    initializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        initializationScripts = initializationScriptsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let scriptParametersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.ScriptParameterKeyValue?].self, forKey: .scriptParameters)
        var scriptParametersDecoded0:[NimbleClientTypes.ScriptParameterKeyValue]? = nil
        if let scriptParametersContainer = scriptParametersContainer {
            scriptParametersDecoded0 = [NimbleClientTypes.ScriptParameterKeyValue]()
            for structure0 in scriptParametersContainer {
                if let structure0 = structure0 {
                    scriptParametersDecoded0?.append(structure0)
                }
            }
        }
        scriptParameters = scriptParametersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let studioComponentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentId)
        studioComponentId = studioComponentIdDecoded
        let subtypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentSubtype.self, forKey: .subtype)
        subtype = subtypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentType.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension NimbleClientTypes {
    /// A studio component represents a network resource to be used by a studio's users and workflows. A typical studio contains studio components for each of the following: render farm, Active Directory, licensing, and file system. Access to a studio component is managed by specifying security groups for the resource, as well as its endpoint. A studio component also has a set of initialization scripts that are returned by GetLaunchProfileInitialization. These initialization scripts run on streaming sessions when they start. They provide users with flexibility in controlling how the studio resources are configured on a streaming session.
    public struct StudioComponent: Swift.Equatable {
        /// The ARN of the resource.
        public var arn: Swift.String?
        /// The configuration of the studio component, based on component type.
        public var configuration: NimbleClientTypes.StudioComponentConfiguration?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The user ID of the user that created the studio component.
        public var createdBy: Swift.String?
        /// A human-readable description for the studio component resource.
        public var description: Swift.String?
        /// The EC2 security groups that control access to the studio component.
        public var ec2SecurityGroupIds: [Swift.String]?
        /// Initialization scripts for studio components.
        public var initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]?
        /// A friendly name for the studio component resource.
        public var name: Swift.String?
        /// Parameters for the studio component scripts.
        public var scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]?
        /// The current state.
        public var state: NimbleClientTypes.StudioComponentState?
        /// The status code.
        public var statusCode: NimbleClientTypes.StudioComponentStatusCode?
        /// The status message for the studio component.
        public var statusMessage: Swift.String?
        /// The unique identifier for a studio component resource.
        public var studioComponentId: Swift.String?
        /// The specific subtype of a studio component.
        public var subtype: NimbleClientTypes.StudioComponentSubtype?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the studio component.
        public var type: NimbleClientTypes.StudioComponentType?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user ID of the user that most recently updated the resource.
        public var updatedBy: Swift.String?

        public init (
            arn: Swift.String? = nil,
            configuration: NimbleClientTypes.StudioComponentConfiguration? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            ec2SecurityGroupIds: [Swift.String]? = nil,
            initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]? = nil,
            name: Swift.String? = nil,
            scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]? = nil,
            state: NimbleClientTypes.StudioComponentState? = nil,
            statusCode: NimbleClientTypes.StudioComponentStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            studioComponentId: Swift.String? = nil,
            subtype: NimbleClientTypes.StudioComponentSubtype? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: NimbleClientTypes.StudioComponentType? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.arn = arn
            self.configuration = configuration
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.initializationScripts = initializationScripts
            self.name = name
            self.scriptParameters = scriptParameters
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.studioComponentId = studioComponentId
            self.subtype = subtype
            self.tags = tags
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension NimbleClientTypes.StudioComponentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activedirectoryconfiguration = "activeDirectoryConfiguration"
        case computefarmconfiguration = "computeFarmConfiguration"
        case licenseserviceconfiguration = "licenseServiceConfiguration"
        case sdkUnknown
        case sharedfilesystemconfiguration = "sharedFileSystemConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .activedirectoryconfiguration(activedirectoryconfiguration):
                try container.encode(activedirectoryconfiguration, forKey: .activedirectoryconfiguration)
            case let .computefarmconfiguration(computefarmconfiguration):
                try container.encode(computefarmconfiguration, forKey: .computefarmconfiguration)
            case let .licenseserviceconfiguration(licenseserviceconfiguration):
                try container.encode(licenseserviceconfiguration, forKey: .licenseserviceconfiguration)
            case let .sharedfilesystemconfiguration(sharedfilesystemconfiguration):
                try container.encode(sharedfilesystemconfiguration, forKey: .sharedfilesystemconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let activedirectoryconfigurationDecoded = try values.decodeIfPresent(NimbleClientTypes.ActiveDirectoryConfiguration.self, forKey: .activedirectoryconfiguration)
        if let activedirectoryconfiguration = activedirectoryconfigurationDecoded {
            self = .activedirectoryconfiguration(activedirectoryconfiguration)
            return
        }
        let computefarmconfigurationDecoded = try values.decodeIfPresent(NimbleClientTypes.ComputeFarmConfiguration.self, forKey: .computefarmconfiguration)
        if let computefarmconfiguration = computefarmconfigurationDecoded {
            self = .computefarmconfiguration(computefarmconfiguration)
            return
        }
        let licenseserviceconfigurationDecoded = try values.decodeIfPresent(NimbleClientTypes.LicenseServiceConfiguration.self, forKey: .licenseserviceconfiguration)
        if let licenseserviceconfiguration = licenseserviceconfigurationDecoded {
            self = .licenseserviceconfiguration(licenseserviceconfiguration)
            return
        }
        let sharedfilesystemconfigurationDecoded = try values.decodeIfPresent(NimbleClientTypes.SharedFileSystemConfiguration.self, forKey: .sharedfilesystemconfiguration)
        if let sharedfilesystemconfiguration = sharedfilesystemconfigurationDecoded {
            self = .sharedfilesystemconfiguration(sharedfilesystemconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension NimbleClientTypes {
    /// The configuration of the studio component, based on component type.
    public enum StudioComponentConfiguration: Swift.Equatable {
        /// The configuration for a Microsoft Active Directory (Microsoft AD) studio resource.
        case activedirectoryconfiguration(NimbleClientTypes.ActiveDirectoryConfiguration)
        /// The configuration for a render farm that is associated with a studio resource.
        case computefarmconfiguration(NimbleClientTypes.ComputeFarmConfiguration)
        /// The configuration for a license service that is associated with a studio resource.
        case licenseserviceconfiguration(NimbleClientTypes.LicenseServiceConfiguration)
        /// The configuration for a shared file storage system that is associated with a studio resource.
        case sharedfilesystemconfiguration(NimbleClientTypes.SharedFileSystemConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension NimbleClientTypes.StudioComponentInitializationScript: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfileProtocolVersion
        case platform
        case runContext
        case script
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchProfileProtocolVersion = launchProfileProtocolVersion {
            try encodeContainer.encode(launchProfileProtocolVersion, forKey: .launchProfileProtocolVersion)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let runContext = runContext {
            try encodeContainer.encode(runContext.rawValue, forKey: .runContext)
        }
        if let script = script {
            try encodeContainer.encode(script, forKey: .script)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileProtocolVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileProtocolVersion)
        launchProfileProtocolVersion = launchProfileProtocolVersionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfilePlatform.self, forKey: .platform)
        platform = platformDecoded
        let runContextDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentInitializationScriptRunContext.self, forKey: .runContext)
        runContext = runContextDecoded
        let scriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .script)
        script = scriptDecoded
    }
}

extension NimbleClientTypes {
    /// Initialization scripts for studio components.
    public struct StudioComponentInitializationScript: Swift.Equatable {
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public var launchProfileProtocolVersion: Swift.String?
        /// The platform of the initialization script, either WINDOWS or LINUX.
        public var platform: NimbleClientTypes.LaunchProfilePlatform?
        /// The method to use when running the initialization script.
        public var runContext: NimbleClientTypes.StudioComponentInitializationScriptRunContext?
        /// The initialization script.
        public var script: Swift.String?

        public init (
            launchProfileProtocolVersion: Swift.String? = nil,
            platform: NimbleClientTypes.LaunchProfilePlatform? = nil,
            runContext: NimbleClientTypes.StudioComponentInitializationScriptRunContext? = nil,
            script: Swift.String? = nil
        )
        {
            self.launchProfileProtocolVersion = launchProfileProtocolVersion
            self.platform = platform
            self.runContext = runContext
            self.script = script
        }
    }

}

extension NimbleClientTypes {
    ///
    public enum StudioComponentInitializationScriptRunContext: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case systemInitialization
        case userInitialization
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentInitializationScriptRunContext] {
            return [
                .systemInitialization,
                .userInitialization,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .systemInitialization: return "SYSTEM_INITIALIZATION"
            case .userInitialization: return "USER_INITIALIZATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioComponentInitializationScriptRunContext(rawValue: rawValue) ?? StudioComponentInitializationScriptRunContext.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    /// The current state of the studio component resource. While a studio component is being created, modified, or deleted, its state will equal "CREATE_IN_PROGRESS", "UPDATE_IN_PROGRESS", or "DELETE_IN_PROGRESS" These are called 'transition states'. No modifications may be made to the studio component while it is in a transition state. If creation of the resource fails, the state will change to `CREATE_FAILED`. The resource StatusCode and StatusMessage will provide more information of why creation failed. The resource in this state will automatically be deleted from your account after a period of time. If updating the resource fails, the state will change to `UPDATE_FAILED`. The resource StatusCode and StatusMessage will provide more information of why the update failed. The resource will be returned to the state it was in when the update request was invoked. If deleting the resource fails, the state will change to `DELETE_FAILED`. The resource StatusCode and StatusMessage will provide more information of why the update failed. The resource will be returned to the state it was in when the update request was invoked. After the resource is deleted successfully, it will change to the "DELETED" state. The resource will no longer count against service quotas and cannot be used or acted upon any futher. It will be removed from your account after a period of time.
    public enum StudioComponentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioComponentState(rawValue: rawValue) ?? StudioComponentState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    /// The current status of the studio component resource. When the resource is in the 'READY' state, the status code signals what the last mutation made to the resource was. When the resource is in a CREATE_FAILED/UPDATE_FAILED/DELETE_FAILED state, the status code signals what went wrong and why the mutation failed.
    public enum StudioComponentStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activeDirectoryAlreadyExists
        case encryptionKeyAccessDenied
        case encryptionKeyNotFound
        case internalError
        case studioComponentCreated
        case studioComponentCreateInProgress
        case studioComponentDeleted
        case studioComponentDeleteInProgress
        case studioComponentUpdated
        case studioComponentUpdateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentStatusCode] {
            return [
                .activeDirectoryAlreadyExists,
                .encryptionKeyAccessDenied,
                .encryptionKeyNotFound,
                .internalError,
                .studioComponentCreated,
                .studioComponentCreateInProgress,
                .studioComponentDeleted,
                .studioComponentDeleteInProgress,
                .studioComponentUpdated,
                .studioComponentUpdateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activeDirectoryAlreadyExists: return "ACTIVE_DIRECTORY_ALREADY_EXISTS"
            case .encryptionKeyAccessDenied: return "ENCRYPTION_KEY_ACCESS_DENIED"
            case .encryptionKeyNotFound: return "ENCRYPTION_KEY_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .studioComponentCreated: return "STUDIO_COMPONENT_CREATED"
            case .studioComponentCreateInProgress: return "STUDIO_COMPONENT_CREATE_IN_PROGRESS"
            case .studioComponentDeleted: return "STUDIO_COMPONENT_DELETED"
            case .studioComponentDeleteInProgress: return "STUDIO_COMPONENT_DELETE_IN_PROGRESS"
            case .studioComponentUpdated: return "STUDIO_COMPONENT_UPDATED"
            case .studioComponentUpdateInProgress: return "STUDIO_COMPONENT_UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioComponentStatusCode(rawValue: rawValue) ?? StudioComponentStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    ///
    public enum StudioComponentSubtype: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonFsxForLustre
        case amazonFsxForWindows
        case awsManagedMicrosoftAd
        case custom
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentSubtype] {
            return [
                .amazonFsxForLustre,
                .amazonFsxForWindows,
                .awsManagedMicrosoftAd,
                .custom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonFsxForLustre: return "AMAZON_FSX_FOR_LUSTRE"
            case .amazonFsxForWindows: return "AMAZON_FSX_FOR_WINDOWS"
            case .awsManagedMicrosoftAd: return "AWS_MANAGED_MICROSOFT_AD"
            case .custom: return "CUSTOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioComponentSubtype(rawValue: rawValue) ?? StudioComponentSubtype.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.StudioComponentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case name
        case studioComponentId
        case subtype
        case type
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let studioComponentId = studioComponentId {
            try encodeContainer.encode(studioComponentId, forKey: .studioComponentId)
        }
        if let subtype = subtype {
            try encodeContainer.encode(subtype.rawValue, forKey: .subtype)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let updatedBy = updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let studioComponentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentId)
        studioComponentId = studioComponentIdDecoded
        let subtypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentSubtype.self, forKey: .subtype)
        subtype = subtypeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentType.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension NimbleClientTypes {
    ///
    public struct StudioComponentSummary: Swift.Equatable {
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The user ID of the user that created the studio component.
        public var createdBy: Swift.String?
        /// The description.
        public var description: Swift.String?
        /// The name for the studio component.
        public var name: Swift.String?
        /// The unique identifier for a studio component resource.
        public var studioComponentId: Swift.String?
        /// The specific subtype of a studio component.
        public var subtype: NimbleClientTypes.StudioComponentSubtype?
        /// The type of the studio component.
        public var type: NimbleClientTypes.StudioComponentType?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user ID of the user that most recently updated the resource.
        public var updatedBy: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            studioComponentId: Swift.String? = nil,
            subtype: NimbleClientTypes.StudioComponentSubtype? = nil,
            type: NimbleClientTypes.StudioComponentType? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.name = name
            self.studioComponentId = studioComponentId
            self.subtype = subtype
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension NimbleClientTypes {
    ///
    public enum StudioComponentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activeDirectory
        case computeFarm
        case custom
        case licenseService
        case sharedFileSystem
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentType] {
            return [
                .activeDirectory,
                .computeFarm,
                .custom,
                .licenseService,
                .sharedFileSystem,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activeDirectory: return "ACTIVE_DIRECTORY"
            case .computeFarm: return "COMPUTE_FARM"
            case .custom: return "CUSTOM"
            case .licenseService: return "LICENSE_SERVICE"
            case .sharedFileSystem: return "SHARED_FILE_SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioComponentType(rawValue: rawValue) ?? StudioComponentType.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.StudioEncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyArn
        case keyType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyArn = keyArn {
            try encodeContainer.encode(keyArn, forKey: .keyArn)
        }
        if let keyType = keyType {
            try encodeContainer.encode(keyType.rawValue, forKey: .keyType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioEncryptionConfigurationKeyType.self, forKey: .keyType)
        keyType = keyTypeDecoded
    }
}

extension NimbleClientTypes {
    /// Configuration of the encryption method that is used for the studio.
    public struct StudioEncryptionConfiguration: Swift.Equatable {
        /// The ARN for a KMS key that is used to encrypt studio data.
        public var keyArn: Swift.String?
        /// The type of KMS key that is used to encrypt studio data.
        /// This member is required.
        public var keyType: NimbleClientTypes.StudioEncryptionConfigurationKeyType?

        public init (
            keyArn: Swift.String? = nil,
            keyType: NimbleClientTypes.StudioEncryptionConfigurationKeyType? = nil
        )
        {
            self.keyArn = keyArn
            self.keyType = keyType
        }
    }

}

extension NimbleClientTypes {
    /// The type of KMS key that is used to encrypt studio data.
    public enum StudioEncryptionConfigurationKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsOwnedKey
        case customerManagedKey
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioEncryptionConfigurationKeyType] {
            return [
                .awsOwnedKey,
                .customerManagedKey,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsOwnedKey: return "AWS_OWNED_KEY"
            case .customerManagedKey: return "CUSTOMER_MANAGED_KEY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioEncryptionConfigurationKeyType(rawValue: rawValue) ?? StudioEncryptionConfigurationKeyType.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.StudioMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case persona
        case principalId
        case sid
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let persona = persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let sid = sid {
            try encodeContainer.encode(sid, forKey: .sid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let personaDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioPersona.self, forKey: .persona)
        persona = personaDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let sidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sid)
        sid = sidDecoded
    }
}

extension NimbleClientTypes {
    /// A studio member is an association of a user from your studio identity source to elevated permissions that they are granted in the studio. When you add a user to your studio using the Nimble Studio console, they are given access to the studio's AWS SSO application and are given access to log in to the Nimble Studio portal. These users have the permissions provided by the studio's user IAM role and do not appear in the studio membership collection. Only studio admins appear in studio membership. When you add a user to studio membership with the persona ADMIN, upon logging in to the Nimble Studio portal, they are granted permissions specified by the Studio's Admin IAM role.
    public struct StudioMembership: Swift.Equatable {
        /// The ID of the identity store.
        public var identityStoreId: Swift.String?
        /// The persona.
        public var persona: NimbleClientTypes.StudioPersona?
        /// The principal ID.
        public var principalId: Swift.String?
        /// The Active Directory Security Identifier for this user, if available.
        public var sid: Swift.String?

        public init (
            identityStoreId: Swift.String? = nil,
            persona: NimbleClientTypes.StudioPersona? = nil,
            principalId: Swift.String? = nil,
            sid: Swift.String? = nil
        )
        {
            self.identityStoreId = identityStoreId
            self.persona = persona
            self.principalId = principalId
            self.sid = sid
        }
    }

}

extension NimbleClientTypes {
    ///
    public enum StudioPersona: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case administrator
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioPersona] {
            return [
                .administrator,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .administrator: return "ADMINISTRATOR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioPersona(rawValue: rawValue) ?? StudioPersona.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    ///
    public enum StudioState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioState(rawValue: rawValue) ?? StudioState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    /// The status code.
    public enum StudioStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsSsoAccessDenied
        case awsSsoConfigurationRepaired
        case awsSsoConfigurationRepairInProgress
        case awsSsoNotEnabled
        case encryptionKeyAccessDenied
        case encryptionKeyNotFound
        case internalError
        case roleCouldNotBeAssumed
        case roleNotOwnedByStudioOwner
        case studioCreated
        case studioCreateInProgress
        case studioDeleted
        case studioDeleteInProgress
        case studioUpdated
        case studioUpdateInProgress
        case studioWithLaunchProfilesNotDeleted
        case studioWithStreamingImagesNotDeleted
        case studioWithStudioComponentsNotDeleted
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioStatusCode] {
            return [
                .awsSsoAccessDenied,
                .awsSsoConfigurationRepaired,
                .awsSsoConfigurationRepairInProgress,
                .awsSsoNotEnabled,
                .encryptionKeyAccessDenied,
                .encryptionKeyNotFound,
                .internalError,
                .roleCouldNotBeAssumed,
                .roleNotOwnedByStudioOwner,
                .studioCreated,
                .studioCreateInProgress,
                .studioDeleted,
                .studioDeleteInProgress,
                .studioUpdated,
                .studioUpdateInProgress,
                .studioWithLaunchProfilesNotDeleted,
                .studioWithStreamingImagesNotDeleted,
                .studioWithStudioComponentsNotDeleted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsSsoAccessDenied: return "AWS_SSO_ACCESS_DENIED"
            case .awsSsoConfigurationRepaired: return "AWS_SSO_CONFIGURATION_REPAIRED"
            case .awsSsoConfigurationRepairInProgress: return "AWS_SSO_CONFIGURATION_REPAIR_IN_PROGRESS"
            case .awsSsoNotEnabled: return "AWS_SSO_NOT_ENABLED"
            case .encryptionKeyAccessDenied: return "ENCRYPTION_KEY_ACCESS_DENIED"
            case .encryptionKeyNotFound: return "ENCRYPTION_KEY_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .roleCouldNotBeAssumed: return "ROLE_COULD_NOT_BE_ASSUMED"
            case .roleNotOwnedByStudioOwner: return "ROLE_NOT_OWNED_BY_STUDIO_OWNER"
            case .studioCreated: return "STUDIO_CREATED"
            case .studioCreateInProgress: return "STUDIO_CREATE_IN_PROGRESS"
            case .studioDeleted: return "STUDIO_DELETED"
            case .studioDeleteInProgress: return "STUDIO_DELETE_IN_PROGRESS"
            case .studioUpdated: return "STUDIO_UPDATED"
            case .studioUpdateInProgress: return "STUDIO_UPDATE_IN_PROGRESS"
            case .studioWithLaunchProfilesNotDeleted: return "STUDIO_WITH_LAUNCH_PROFILES_NOT_DELETED"
            case .studioWithStreamingImagesNotDeleted: return "STUDIO_WITH_STREAMING_IMAGES_NOT_DELETED"
            case .studioWithStudioComponentsNotDeleted: return "STUDIO_WITH_STUDIO_COMPONENTS_NOT_DELETED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioStatusCode(rawValue: rawValue) ?? StudioStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/2020-08-01/tags/\(resourceArn.urlPercentEncoding())"
    }
}

///
public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource you want to add tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A collection of labels, in the form of key:value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request throughput limit was exceeded.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A more specific error code.
    public var code: Swift.String?
    /// The exception context.
    public var context: [Swift.String:Swift.String]?
    /// A human-readable description of the error.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let context: [Swift.String:Swift.String]?
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case context
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/2020-08-01/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// Identifies the Amazon Resource Name(ARN) key from which you are removing tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tag keys. Specify only the tag keys, not the tag values.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateLaunchProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case launchProfileProtocolVersions
        case name
        case streamConfiguration
        case studioComponentIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let launchProfileProtocolVersions = launchProfileProtocolVersions {
            var launchProfileProtocolVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchProfileProtocolVersions)
            for launchprofileprotocolversionlist0 in launchProfileProtocolVersions {
                try launchProfileProtocolVersionsContainer.encode(launchprofileprotocolversionlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let streamConfiguration = streamConfiguration {
            try encodeContainer.encode(streamConfiguration, forKey: .streamConfiguration)
        }
        if let studioComponentIds = studioComponentIds {
            var studioComponentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .studioComponentIds)
            for launchprofilestudiocomponentidlist0 in studioComponentIds {
                try studioComponentIdsContainer.encode(launchprofilestudiocomponentidlist0)
            }
        }
    }
}

extension UpdateLaunchProfileInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateLaunchProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())"
    }
}

///
public struct UpdateLaunchProfileInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The Launch Profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
    public var launchProfileProtocolVersions: [Swift.String]?
    /// The name for the launch profile.
    public var name: Swift.String?
    /// A configuration for a streaming session.
    public var streamConfiguration: NimbleClientTypes.StreamConfigurationCreate?
    /// Unique identifiers for a collection of studio components that can be used with this launch profile.
    public var studioComponentIds: [Swift.String]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        launchProfileProtocolVersions: [Swift.String]? = nil,
        name: Swift.String? = nil,
        streamConfiguration: NimbleClientTypes.StreamConfigurationCreate? = nil,
        studioComponentIds: [Swift.String]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.launchProfileId = launchProfileId
        self.launchProfileProtocolVersions = launchProfileProtocolVersions
        self.name = name
        self.streamConfiguration = streamConfiguration
        self.studioComponentIds = studioComponentIds
        self.studioId = studioId
    }
}

struct UpdateLaunchProfileInputBody: Swift.Equatable {
    let description: Swift.String?
    let launchProfileProtocolVersions: [Swift.String]?
    let name: Swift.String?
    let streamConfiguration: NimbleClientTypes.StreamConfigurationCreate?
    let studioComponentIds: [Swift.String]?
}

extension UpdateLaunchProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case launchProfileProtocolVersions
        case name
        case streamConfiguration
        case studioComponentIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let launchProfileProtocolVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .launchProfileProtocolVersions)
        var launchProfileProtocolVersionsDecoded0:[Swift.String]? = nil
        if let launchProfileProtocolVersionsContainer = launchProfileProtocolVersionsContainer {
            launchProfileProtocolVersionsDecoded0 = [Swift.String]()
            for string0 in launchProfileProtocolVersionsContainer {
                if let string0 = string0 {
                    launchProfileProtocolVersionsDecoded0?.append(string0)
                }
            }
        }
        launchProfileProtocolVersions = launchProfileProtocolVersionsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let streamConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamConfigurationCreate.self, forKey: .streamConfiguration)
        streamConfiguration = streamConfigurationDecoded
        let studioComponentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .studioComponentIds)
        var studioComponentIdsDecoded0:[Swift.String]? = nil
        if let studioComponentIdsContainer = studioComponentIdsContainer {
            studioComponentIdsDecoded0 = [Swift.String]()
            for string0 in studioComponentIdsContainer {
                if let string0 = string0 {
                    studioComponentIdsDecoded0?.append(string0)
                }
            }
        }
        studioComponentIds = studioComponentIdsDecoded0
    }
}

extension UpdateLaunchProfileMemberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case persona
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let persona = persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
    }
}

extension UpdateLaunchProfileMemberInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateLaunchProfileMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        guard let principalId = principalId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
    }
}

///
public struct UpdateLaunchProfileMemberInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The Launch Profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The persona.
    /// This member is required.
    public var persona: NimbleClientTypes.LaunchProfilePersona?
    /// The principal ID. This currently supports a Amazon Web Services SSO UserId.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        persona: NimbleClientTypes.LaunchProfilePersona? = nil,
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.launchProfileId = launchProfileId
        self.persona = persona
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct UpdateLaunchProfileMemberInputBody: Swift.Equatable {
    let persona: NimbleClientTypes.LaunchProfilePersona?
}

extension UpdateLaunchProfileMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case persona
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let personaDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfilePersona.self, forKey: .persona)
        persona = personaDecoded
    }
}

extension UpdateLaunchProfileMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLaunchProfileMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLaunchProfileMemberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLaunchProfileMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateLaunchProfileMemberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.member = output.member
        } else {
            self.member = nil
        }
    }
}

public struct UpdateLaunchProfileMemberOutputResponse: Swift.Equatable {
    /// The updated member.
    public var member: NimbleClientTypes.LaunchProfileMembership?

    public init (
        member: NimbleClientTypes.LaunchProfileMembership? = nil
    )
    {
        self.member = member
    }
}

struct UpdateLaunchProfileMemberOutputResponseBody: Swift.Equatable {
    let member: NimbleClientTypes.LaunchProfileMembership?
}

extension UpdateLaunchProfileMemberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileMembership.self, forKey: .member)
        member = memberDecoded
    }
}

extension UpdateLaunchProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLaunchProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLaunchProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLaunchProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateLaunchProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
        } else {
            self.launchProfile = nil
        }
    }
}

///
public struct UpdateLaunchProfileOutputResponse: Swift.Equatable {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?

    public init (
        launchProfile: NimbleClientTypes.LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

struct UpdateLaunchProfileOutputResponseBody: Swift.Equatable {
    let launchProfile: NimbleClientTypes.LaunchProfile?
}

extension UpdateLaunchProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfile
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
    }
}

extension UpdateStreamingImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStreamingImageInput(clientToken: \(Swift.String(describing: clientToken)), streamingImageId: \(Swift.String(describing: streamingImageId)), studioId: \(Swift.String(describing: studioId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateStreamingImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateStreamingImageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateStreamingImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let streamingImageId = streamingImageId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images/\(streamingImageId.urlPercentEncoding())"
    }
}

///
public struct UpdateStreamingImageInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The name for the streaming image.
    public var name: Swift.String?
    /// The streaming image ID.
    /// This member is required.
    public var streamingImageId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        streamingImageId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.streamingImageId = streamingImageId
        self.studioId = studioId
    }
}

struct UpdateStreamingImageInputBody: Swift.Equatable {
    let description: Swift.String?
    let name: Swift.String?
}

extension UpdateStreamingImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateStreamingImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStreamingImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStreamingImageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStreamingImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateStreamingImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingImage = output.streamingImage
        } else {
            self.streamingImage = nil
        }
    }
}

///
public struct UpdateStreamingImageOutputResponse: Swift.Equatable {
    ///
    public var streamingImage: NimbleClientTypes.StreamingImage?

    public init (
        streamingImage: NimbleClientTypes.StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

struct UpdateStreamingImageOutputResponseBody: Swift.Equatable {
    let streamingImage: NimbleClientTypes.StreamingImage?
}

extension UpdateStreamingImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingImage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingImageDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImage.self, forKey: .streamingImage)
        streamingImage = streamingImageDecoded
    }
}

extension UpdateStudioComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case description
        case ec2SecurityGroupIds
        case initializationScripts
        case name
        case scriptParameters
        case subtype
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SecurityGroupIds = ec2SecurityGroupIds {
            var ec2SecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SecurityGroupIds)
            for studiocomponentsecuritygroupidlist0 in ec2SecurityGroupIds {
                try ec2SecurityGroupIdsContainer.encode(studiocomponentsecuritygroupidlist0)
            }
        }
        if let initializationScripts = initializationScripts {
            var initializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .initializationScripts)
            for studiocomponentinitializationscriptlist0 in initializationScripts {
                try initializationScriptsContainer.encode(studiocomponentinitializationscriptlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scriptParameters = scriptParameters {
            var scriptParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scriptParameters)
            for studiocomponentscriptparameterkeyvaluelist0 in scriptParameters {
                try scriptParametersContainer.encode(studiocomponentscriptparameterkeyvaluelist0)
            }
        }
        if let subtype = subtype {
            try encodeContainer.encode(subtype.rawValue, forKey: .subtype)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateStudioComponentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateStudioComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let studioComponentId = studioComponentId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components/\(studioComponentId.urlPercentEncoding())"
    }
}

///
public struct UpdateStudioComponentInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The configuration of the studio component, based on component type.
    public var configuration: NimbleClientTypes.StudioComponentConfiguration?
    /// The description.
    public var description: Swift.String?
    /// The EC2 security groups that control access to the studio component.
    public var ec2SecurityGroupIds: [Swift.String]?
    /// Initialization scripts for studio components.
    public var initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]?
    /// The name for the studio component.
    public var name: Swift.String?
    /// Parameters for the studio component scripts.
    public var scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]?
    /// The studio component ID.
    /// This member is required.
    public var studioComponentId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// The specific subtype of a studio component.
    public var subtype: NimbleClientTypes.StudioComponentSubtype?
    /// The type of the studio component.
    public var type: NimbleClientTypes.StudioComponentType?

    public init (
        clientToken: Swift.String? = nil,
        configuration: NimbleClientTypes.StudioComponentConfiguration? = nil,
        description: Swift.String? = nil,
        ec2SecurityGroupIds: [Swift.String]? = nil,
        initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]? = nil,
        name: Swift.String? = nil,
        scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]? = nil,
        studioComponentId: Swift.String? = nil,
        studioId: Swift.String? = nil,
        subtype: NimbleClientTypes.StudioComponentSubtype? = nil,
        type: NimbleClientTypes.StudioComponentType? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.ec2SecurityGroupIds = ec2SecurityGroupIds
        self.initializationScripts = initializationScripts
        self.name = name
        self.scriptParameters = scriptParameters
        self.studioComponentId = studioComponentId
        self.studioId = studioId
        self.subtype = subtype
        self.type = type
    }
}

struct UpdateStudioComponentInputBody: Swift.Equatable {
    let configuration: NimbleClientTypes.StudioComponentConfiguration?
    let description: Swift.String?
    let ec2SecurityGroupIds: [Swift.String]?
    let initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]?
    let name: Swift.String?
    let scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]?
    let subtype: NimbleClientTypes.StudioComponentSubtype?
    let type: NimbleClientTypes.StudioComponentType?
}

extension UpdateStudioComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case description
        case ec2SecurityGroupIds
        case initializationScripts
        case name
        case scriptParameters
        case subtype
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SecurityGroupIds)
        var ec2SecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let ec2SecurityGroupIdsContainer = ec2SecurityGroupIdsContainer {
            ec2SecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in ec2SecurityGroupIdsContainer {
                if let string0 = string0 {
                    ec2SecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SecurityGroupIds = ec2SecurityGroupIdsDecoded0
        let initializationScriptsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioComponentInitializationScript?].self, forKey: .initializationScripts)
        var initializationScriptsDecoded0:[NimbleClientTypes.StudioComponentInitializationScript]? = nil
        if let initializationScriptsContainer = initializationScriptsContainer {
            initializationScriptsDecoded0 = [NimbleClientTypes.StudioComponentInitializationScript]()
            for structure0 in initializationScriptsContainer {
                if let structure0 = structure0 {
                    initializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        initializationScripts = initializationScriptsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let scriptParametersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.ScriptParameterKeyValue?].self, forKey: .scriptParameters)
        var scriptParametersDecoded0:[NimbleClientTypes.ScriptParameterKeyValue]? = nil
        if let scriptParametersContainer = scriptParametersContainer {
            scriptParametersDecoded0 = [NimbleClientTypes.ScriptParameterKeyValue]()
            for structure0 in scriptParametersContainer {
                if let structure0 = structure0 {
                    scriptParametersDecoded0?.append(structure0)
                }
            }
        }
        scriptParameters = scriptParametersDecoded0
        let subtypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentSubtype.self, forKey: .subtype)
        subtype = subtypeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentType.self, forKey: .type)
        type = typeDecoded
    }
}

extension UpdateStudioComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStudioComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStudioComponentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStudioComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateStudioComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studioComponent = output.studioComponent
        } else {
            self.studioComponent = nil
        }
    }
}

///
public struct UpdateStudioComponentOutputResponse: Swift.Equatable {
    /// Information about the studio component.
    public var studioComponent: NimbleClientTypes.StudioComponent?

    public init (
        studioComponent: NimbleClientTypes.StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

struct UpdateStudioComponentOutputResponseBody: Swift.Equatable {
    let studioComponent: NimbleClientTypes.StudioComponent?
}

extension UpdateStudioComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studioComponent
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioComponentDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponent.self, forKey: .studioComponent)
        studioComponent = studioComponentDecoded
    }
}

extension UpdateStudioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStudioInput(adminRoleArn: \(Swift.String(describing: adminRoleArn)), clientToken: \(Swift.String(describing: clientToken)), studioId: \(Swift.String(describing: studioId)), userRoleArn: \(Swift.String(describing: userRoleArn)), displayName: \"CONTENT_REDACTED\")"}
}

extension UpdateStudioInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminRoleArn
        case displayName
        case userRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminRoleArn = adminRoleArn {
            try encodeContainer.encode(adminRoleArn, forKey: .adminRoleArn)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let userRoleArn = userRoleArn {
            try encodeContainer.encode(userRoleArn, forKey: .userRoleArn)
        }
    }
}

extension UpdateStudioInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateStudioInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())"
    }
}

///
public struct UpdateStudioInput: Swift.Equatable {
    /// The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.
    public var adminRoleArn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the AWS SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// A friendly name for the studio.
    public var displayName: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.
    public var userRoleArn: Swift.String?

    public init (
        adminRoleArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        studioId: Swift.String? = nil,
        userRoleArn: Swift.String? = nil
    )
    {
        self.adminRoleArn = adminRoleArn
        self.clientToken = clientToken
        self.displayName = displayName
        self.studioId = studioId
        self.userRoleArn = userRoleArn
    }
}

struct UpdateStudioInputBody: Swift.Equatable {
    let adminRoleArn: Swift.String?
    let displayName: Swift.String?
    let userRoleArn: Swift.String?
}

extension UpdateStudioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminRoleArn
        case displayName
        case userRoleArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminRoleArn)
        adminRoleArn = adminRoleArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let userRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userRoleArn)
        userRoleArn = userRoleArnDecoded
    }
}

extension UpdateStudioOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStudioOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStudioOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStudioOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateStudioOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

///
public struct UpdateStudioOutputResponse: Swift.Equatable {
    /// Information about a studio.
    /// This member is required.
    public var studio: NimbleClientTypes.Studio?

    public init (
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct UpdateStudioOutputResponseBody: Swift.Equatable {
    let studio: NimbleClientTypes.Studio?
}

extension UpdateStudioOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studio
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One of the parameters in the request is invalid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A more specific error code.
    public var code: Swift.String?
    /// The exception context.
    public var context: [Swift.String:Swift.String]?
    /// A human-readable description of the error.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let context: [Swift.String:Swift.String]?
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case context
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
