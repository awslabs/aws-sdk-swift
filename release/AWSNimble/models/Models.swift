// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptEulasInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptEulasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptEulasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptEulasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptEulasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptEulasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptEulasOutputError>
}

extension AcceptEulasInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptEulasInput(clientToken: \(Swift.String(describing: clientToken)), eulaIds: \(Swift.String(describing: eulaIds)), studioId: \(Swift.String(describing: studioId)))"}
}

extension AcceptEulasInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eulaIds = "eulaIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eulaIds = eulaIds {
            var eulaIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eulaIds)
            for eulaidlist0 in eulaIds {
                try eulaIdsContainer.encode(eulaidlist0)
            }
        }
    }
}

public struct AcceptEulasInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptEulasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptEulasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptEulasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptEulasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptEulasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptEulasOutputError>
}

public struct AcceptEulasInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptEulasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptEulasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptEulasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptEulasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptEulasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptEulasOutputError>
}

public struct AcceptEulasInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptEulasInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AcceptEulasInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptEulasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/eula-acceptances"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AcceptEulasInput
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptEulasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptEulasOutputError>
}

/// A collection of EULA acceptances.
public struct AcceptEulasInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The EULA ID.
    public var eulaIds: [Swift.String]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        eulaIds: [Swift.String]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.eulaIds = eulaIds
        self.studioId = studioId
    }
}

struct AcceptEulasInputBody: Swift.Equatable {
    public let eulaIds: [Swift.String]?
}

extension AcceptEulasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eulaIds = "eulaIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulaIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eulaIds)
        var eulaIdsDecoded0:[Swift.String]? = nil
        if let eulaIdsContainer = eulaIdsContainer {
            eulaIdsDecoded0 = [Swift.String]()
            for string0 in eulaIdsContainer {
                if let string0 = string0 {
                    eulaIdsDecoded0?.append(string0)
                }
            }
        }
        eulaIds = eulaIdsDecoded0
    }
}

extension AcceptEulasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptEulasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptEulasOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptEulasOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptEulasOutputResponse(eulaAcceptances: \(Swift.String(describing: eulaAcceptances)))"}
}

extension AcceptEulasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AcceptEulasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eulaAcceptances = output.eulaAcceptances
        } else {
            self.eulaAcceptances = nil
        }
    }
}

public struct AcceptEulasOutputResponse: Swift.Equatable {
    /// A collection of EULA acceptances.
    public var eulaAcceptances: [NimbleClientTypes.EulaAcceptance]?

    public init (
        eulaAcceptances: [NimbleClientTypes.EulaAcceptance]? = nil
    )
    {
        self.eulaAcceptances = eulaAcceptances
    }
}

struct AcceptEulasOutputResponseBody: Swift.Equatable {
    public let eulaAcceptances: [NimbleClientTypes.EulaAcceptance]?
}

extension AcceptEulasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eulaAcceptances = "eulaAcceptances"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulaAcceptancesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.EulaAcceptance?].self, forKey: .eulaAcceptances)
        var eulaAcceptancesDecoded0:[NimbleClientTypes.EulaAcceptance]? = nil
        if let eulaAcceptancesContainer = eulaAcceptancesContainer {
            eulaAcceptancesDecoded0 = [NimbleClientTypes.EulaAcceptance]()
            for structure0 in eulaAcceptancesContainer {
                if let structure0 = structure0 {
                    eulaAcceptancesDecoded0?.append(structure0)
                }
            }
        }
        eulaAcceptances = eulaAcceptancesDecoded0
    }
}

extension AccessDeniedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessDeniedException(code: \(Swift.String(describing: code)), context: \(Swift.String(describing: context)), message: \(Swift.String(describing: message)))"}
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A more specific error code.
    public var code: Swift.String?
    /// The exception context.
    public var context: [Swift.String:Swift.String]?
    /// A human-readable description of the error.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let context: [Swift.String:Swift.String]?
    public let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case context = "context"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in contextContainer {
                if let __string0 = __string0 {
                    contextDecoded0?[key0] = __string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NimbleClientTypes.ActiveDirectoryComputerAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension NimbleClientTypes.ActiveDirectoryComputerAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActiveDirectoryComputerAttribute(name: \(Swift.String(describing: name)), value: \(Swift.String(describing: value)))"}
}

extension NimbleClientTypes {
    /// An LDAP attribute of an Active Directory computer account, in the form of a name:value pair.
    public struct ActiveDirectoryComputerAttribute: Swift.Equatable {
        /// The name for the LDAP attribute.
        public var name: Swift.String?
        /// The value for the LDAP attribute.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension NimbleClientTypes.ActiveDirectoryConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computerAttributes = "computerAttributes"
        case directoryId = "directoryId"
        case organizationalUnitDistinguishedName = "organizationalUnitDistinguishedName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computerAttributes = computerAttributes {
            var computerAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .computerAttributes)
            for activedirectorycomputerattributelist0 in computerAttributes {
                try computerAttributesContainer.encode(activedirectorycomputerattributelist0)
            }
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let organizationalUnitDistinguishedName = organizationalUnitDistinguishedName {
            try encodeContainer.encode(organizationalUnitDistinguishedName, forKey: .organizationalUnitDistinguishedName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computerAttributesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.ActiveDirectoryComputerAttribute?].self, forKey: .computerAttributes)
        var computerAttributesDecoded0:[NimbleClientTypes.ActiveDirectoryComputerAttribute]? = nil
        if let computerAttributesContainer = computerAttributesContainer {
            computerAttributesDecoded0 = [NimbleClientTypes.ActiveDirectoryComputerAttribute]()
            for structure0 in computerAttributesContainer {
                if let structure0 = structure0 {
                    computerAttributesDecoded0?.append(structure0)
                }
            }
        }
        computerAttributes = computerAttributesDecoded0
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let organizationalUnitDistinguishedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnitDistinguishedName)
        organizationalUnitDistinguishedName = organizationalUnitDistinguishedNameDecoded
    }
}

extension NimbleClientTypes.ActiveDirectoryConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActiveDirectoryConfiguration(computerAttributes: \(Swift.String(describing: computerAttributes)), directoryId: \(Swift.String(describing: directoryId)), organizationalUnitDistinguishedName: \(Swift.String(describing: organizationalUnitDistinguishedName)))"}
}

extension NimbleClientTypes {
    /// The configuration for a Microsoft Active Directory (Microsoft AD) studio resource.
    public struct ActiveDirectoryConfiguration: Swift.Equatable {
        /// A collection of custom attributes for an Active Directory computer.
        public var computerAttributes: [NimbleClientTypes.ActiveDirectoryComputerAttribute]?
        /// The directory ID of the Directory Service for Microsoft Active Directory to access using this studio component.
        public var directoryId: Swift.String?
        /// The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.
        public var organizationalUnitDistinguishedName: Swift.String?

        public init (
            computerAttributes: [NimbleClientTypes.ActiveDirectoryComputerAttribute]? = nil,
            directoryId: Swift.String? = nil,
            organizationalUnitDistinguishedName: Swift.String? = nil
        )
        {
            self.computerAttributes = computerAttributes
            self.directoryId = directoryId
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
        }
    }

}

extension NimbleClientTypes.ComputeFarmConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDirectoryUser = "activeDirectoryUser"
        case endpoint = "endpoint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDirectoryUser = activeDirectoryUser {
            try encodeContainer.encode(activeDirectoryUser, forKey: .activeDirectoryUser)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDirectoryUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activeDirectoryUser)
        activeDirectoryUser = activeDirectoryUserDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension NimbleClientTypes.ComputeFarmConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComputeFarmConfiguration(activeDirectoryUser: \(Swift.String(describing: activeDirectoryUser)), endpoint: \(Swift.String(describing: endpoint)))"}
}

extension NimbleClientTypes {
    /// The configuration for a render farm that is associated with a studio resource.
    public struct ComputeFarmConfiguration: Swift.Equatable {
        /// The name of an Active Directory user that is used on ComputeFarm worker instances.
        public var activeDirectoryUser: Swift.String?
        /// The endpoint of the ComputeFarm that is accessed by the studio component resource.
        public var endpoint: Swift.String?

        public init (
            activeDirectoryUser: Swift.String? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.activeDirectoryUser = activeDirectoryUser
            self.endpoint = endpoint
        }
    }

}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(code: \(Swift.String(describing: code)), context: \(Swift.String(describing: context)), message: \(Swift.String(describing: message)))"}
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A more specific error code.
    public var code: Swift.String?
    /// The exception context.
    public var context: [Swift.String:Swift.String]?
    /// A human-readable description of the error.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let context: [Swift.String:Swift.String]?
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case context = "context"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in contextContainer {
                if let __string0 = __string0 {
                    contextDecoded0?[key0] = __string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateLaunchProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLaunchProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLaunchProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLaunchProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLaunchProfileOutputError>
}

extension CreateLaunchProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLaunchProfileInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), ec2SubnetIds: \(Swift.String(describing: ec2SubnetIds)), launchProfileProtocolVersions: \(Swift.String(describing: launchProfileProtocolVersions)), name: \(Swift.String(describing: name)), streamConfiguration: \(Swift.String(describing: streamConfiguration)), studioComponentIds: \(Swift.String(describing: studioComponentIds)), studioId: \(Swift.String(describing: studioId)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateLaunchProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case ec2SubnetIds = "ec2SubnetIds"
        case launchProfileProtocolVersions = "launchProfileProtocolVersions"
        case name = "name"
        case streamConfiguration = "streamConfiguration"
        case studioComponentIds = "studioComponentIds"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SubnetIds = ec2SubnetIds {
            var ec2SubnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SubnetIds)
            for ec2subnetidlist0 in ec2SubnetIds {
                try ec2SubnetIdsContainer.encode(ec2subnetidlist0)
            }
        }
        if let launchProfileProtocolVersions = launchProfileProtocolVersions {
            var launchProfileProtocolVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchProfileProtocolVersions)
            for launchprofileprotocolversionlist0 in launchProfileProtocolVersions {
                try launchProfileProtocolVersionsContainer.encode(launchprofileprotocolversionlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let streamConfiguration = streamConfiguration {
            try encodeContainer.encode(streamConfiguration, forKey: .streamConfiguration)
        }
        if let studioComponentIds = studioComponentIds {
            var studioComponentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .studioComponentIds)
            for launchprofilestudiocomponentidlist0 in studioComponentIds {
                try studioComponentIdsContainer.encode(launchprofilestudiocomponentidlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateLaunchProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLaunchProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLaunchProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLaunchProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLaunchProfileOutputError>
}

public struct CreateLaunchProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLaunchProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateLaunchProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateLaunchProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLaunchProfileOutputError>
}

public struct CreateLaunchProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateLaunchProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateLaunchProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateLaunchProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateLaunchProfileOutputError>
}

/// A collection of launch profiles.
public struct CreateLaunchProfileInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// This member is required.
    public var ec2SubnetIds: [Swift.String]?
    /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
    /// This member is required.
    public var launchProfileProtocolVersions: [Swift.String]?
    /// The name for the launch profile.
    /// This member is required.
    public var name: Swift.String?
    /// A configuration for a streaming session.
    /// This member is required.
    public var streamConfiguration: NimbleClientTypes.StreamConfigurationCreate?
    /// Unique identifiers for a collection of studio components that can be used with this launch profile.
    /// This member is required.
    public var studioComponentIds: [Swift.String]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// A collection of labels, in the form of key:value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        ec2SubnetIds: [Swift.String]? = nil,
        launchProfileProtocolVersions: [Swift.String]? = nil,
        name: Swift.String? = nil,
        streamConfiguration: NimbleClientTypes.StreamConfigurationCreate? = nil,
        studioComponentIds: [Swift.String]? = nil,
        studioId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.ec2SubnetIds = ec2SubnetIds
        self.launchProfileProtocolVersions = launchProfileProtocolVersions
        self.name = name
        self.streamConfiguration = streamConfiguration
        self.studioComponentIds = studioComponentIds
        self.studioId = studioId
        self.tags = tags
    }
}

struct CreateLaunchProfileInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let ec2SubnetIds: [Swift.String]?
    public let launchProfileProtocolVersions: [Swift.String]?
    public let name: Swift.String?
    public let streamConfiguration: NimbleClientTypes.StreamConfigurationCreate?
    public let studioComponentIds: [Swift.String]?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateLaunchProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case ec2SubnetIds = "ec2SubnetIds"
        case launchProfileProtocolVersions = "launchProfileProtocolVersions"
        case name = "name"
        case streamConfiguration = "streamConfiguration"
        case studioComponentIds = "studioComponentIds"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SubnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SubnetIds)
        var ec2SubnetIdsDecoded0:[Swift.String]? = nil
        if let ec2SubnetIdsContainer = ec2SubnetIdsContainer {
            ec2SubnetIdsDecoded0 = [Swift.String]()
            for string0 in ec2SubnetIdsContainer {
                if let string0 = string0 {
                    ec2SubnetIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SubnetIds = ec2SubnetIdsDecoded0
        let launchProfileProtocolVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .launchProfileProtocolVersions)
        var launchProfileProtocolVersionsDecoded0:[Swift.String]? = nil
        if let launchProfileProtocolVersionsContainer = launchProfileProtocolVersionsContainer {
            launchProfileProtocolVersionsDecoded0 = [Swift.String]()
            for string0 in launchProfileProtocolVersionsContainer {
                if let string0 = string0 {
                    launchProfileProtocolVersionsDecoded0?.append(string0)
                }
            }
        }
        launchProfileProtocolVersions = launchProfileProtocolVersionsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let streamConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamConfigurationCreate.self, forKey: .streamConfiguration)
        streamConfiguration = streamConfigurationDecoded
        let studioComponentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .studioComponentIds)
        var studioComponentIdsDecoded0:[Swift.String]? = nil
        if let studioComponentIdsContainer = studioComponentIdsContainer {
            studioComponentIdsDecoded0 = [Swift.String]()
            for string0 in studioComponentIdsContainer {
                if let string0 = string0 {
                    studioComponentIdsDecoded0?.append(string0)
                }
            }
        }
        studioComponentIds = studioComponentIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLaunchProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLaunchProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLaunchProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLaunchProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLaunchProfileOutputResponse(launchProfile: \(Swift.String(describing: launchProfile)))"}
}

extension CreateLaunchProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLaunchProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
        } else {
            self.launchProfile = nil
        }
    }
}

public struct CreateLaunchProfileOutputResponse: Swift.Equatable {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?

    public init (
        launchProfile: NimbleClientTypes.LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

struct CreateLaunchProfileOutputResponseBody: Swift.Equatable {
    public let launchProfile: NimbleClientTypes.LaunchProfile?
}

extension CreateLaunchProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfile = "launchProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
    }
}

public struct CreateStreamingImageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingImageOutputError>
}

extension CreateStreamingImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingImageInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), ec2ImageId: \(Swift.String(describing: ec2ImageId)), name: \(Swift.String(describing: name)), studioId: \(Swift.String(describing: studioId)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateStreamingImageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case ec2ImageId = "ec2ImageId"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2ImageId = ec2ImageId {
            try encodeContainer.encode(ec2ImageId, forKey: .ec2ImageId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateStreamingImageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingImageOutputError>
}

public struct CreateStreamingImageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingImageOutputError>
}

public struct CreateStreamingImageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingImageInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateStreamingImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateStreamingImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingImageOutputError>
}

/// A collection of streaming images.
public struct CreateStreamingImageInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// A human-readable description of the streaming image.
    public var description: Swift.String?
    /// The ID of an EC2 machine image with which to create this streaming image.
    /// This member is required.
    public var ec2ImageId: Swift.String?
    /// A friendly name for a streaming image resource.
    /// This member is required.
    public var name: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// A collection of labels, in the form of key:value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        ec2ImageId: Swift.String? = nil,
        name: Swift.String? = nil,
        studioId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.ec2ImageId = ec2ImageId
        self.name = name
        self.studioId = studioId
        self.tags = tags
    }
}

struct CreateStreamingImageInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let ec2ImageId: Swift.String?
    public let name: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateStreamingImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case ec2ImageId = "ec2ImageId"
        case name = "name"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2ImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2ImageId)
        ec2ImageId = ec2ImageIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStreamingImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamingImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingImageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingImageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingImageOutputResponse(streamingImage: \(Swift.String(describing: streamingImage)))"}
}

extension CreateStreamingImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStreamingImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingImage = output.streamingImage
        } else {
            self.streamingImage = nil
        }
    }
}

public struct CreateStreamingImageOutputResponse: Swift.Equatable {
    public var streamingImage: NimbleClientTypes.StreamingImage?

    public init (
        streamingImage: NimbleClientTypes.StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

struct CreateStreamingImageOutputResponseBody: Swift.Equatable {
    public let streamingImage: NimbleClientTypes.StreamingImage?
}

extension CreateStreamingImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingImage = "streamingImage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingImageDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImage.self, forKey: .streamingImage)
        streamingImage = streamingImageDecoded
    }
}

public struct CreateStreamingSessionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingSessionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingSessionOutputError>
}

extension CreateStreamingSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingSessionInput(clientToken: \(Swift.String(describing: clientToken)), ec2InstanceType: \(Swift.String(describing: ec2InstanceType)), launchProfileId: \(Swift.String(describing: launchProfileId)), ownedBy: \(Swift.String(describing: ownedBy)), streamingImageId: \(Swift.String(describing: streamingImageId)), studioId: \(Swift.String(describing: studioId)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateStreamingSessionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2InstanceType = "ec2InstanceType"
        case launchProfileId = "launchProfileId"
        case ownedBy = "ownedBy"
        case streamingImageId = "streamingImageId"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2InstanceType = ec2InstanceType {
            try encodeContainer.encode(ec2InstanceType.rawValue, forKey: .ec2InstanceType)
        }
        if let launchProfileId = launchProfileId {
            try encodeContainer.encode(launchProfileId, forKey: .launchProfileId)
        }
        if let ownedBy = ownedBy {
            try encodeContainer.encode(ownedBy, forKey: .ownedBy)
        }
        if let streamingImageId = streamingImageId {
            try encodeContainer.encode(streamingImageId, forKey: .streamingImageId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateStreamingSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingSessionOutputError>
}

public struct CreateStreamingSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingSessionOutputError>
}

public struct CreateStreamingSessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingSessionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateStreamingSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateStreamingSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingSessionOutputError>
}

/// A collection of streaming sessions.
public struct CreateStreamingSessionInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The EC2 Instance type used for the streaming session.
    public var ec2InstanceType: NimbleClientTypes.StreamingInstanceType?
    /// The launch profile ID.
    public var launchProfileId: Swift.String?
    /// The user ID of the user that owns the streaming session.
    public var ownedBy: Swift.String?
    /// The ID of the streaming image.
    public var streamingImageId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// A collection of labels, in the form of key:value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        ec2InstanceType: NimbleClientTypes.StreamingInstanceType? = nil,
        launchProfileId: Swift.String? = nil,
        ownedBy: Swift.String? = nil,
        streamingImageId: Swift.String? = nil,
        studioId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.ec2InstanceType = ec2InstanceType
        self.launchProfileId = launchProfileId
        self.ownedBy = ownedBy
        self.streamingImageId = streamingImageId
        self.studioId = studioId
        self.tags = tags
    }
}

struct CreateStreamingSessionInputBody: Swift.Equatable {
    public let ec2InstanceType: NimbleClientTypes.StreamingInstanceType?
    public let launchProfileId: Swift.String?
    public let ownedBy: Swift.String?
    public let streamingImageId: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateStreamingSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2InstanceType = "ec2InstanceType"
        case launchProfileId = "launchProfileId"
        case ownedBy = "ownedBy"
        case streamingImageId = "streamingImageId"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2InstanceTypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingInstanceType.self, forKey: .ec2InstanceType)
        ec2InstanceType = ec2InstanceTypeDecoded
        let launchProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileId)
        launchProfileId = launchProfileIdDecoded
        let ownedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownedBy)
        ownedBy = ownedByDecoded
        let streamingImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingImageId)
        streamingImageId = streamingImageIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStreamingSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamingSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingSessionOutputResponse(session: \(Swift.String(describing: session)))"}
}

extension CreateStreamingSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStreamingSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct CreateStreamingSessionOutputResponse: Swift.Equatable {
    /// The session.
    public var session: NimbleClientTypes.StreamingSession?

    public init (
        session: NimbleClientTypes.StreamingSession? = nil
    )
    {
        self.session = session
    }
}

struct CreateStreamingSessionOutputResponseBody: Swift.Equatable {
    public let session: NimbleClientTypes.StreamingSession?
}

extension CreateStreamingSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session = "session"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSession.self, forKey: .session)
        session = sessionDecoded
    }
}

public struct CreateStreamingSessionStreamInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingSessionStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingSessionStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingSessionStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingSessionStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingSessionStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingSessionStreamOutputError>
}

extension CreateStreamingSessionStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingSessionStreamInput(clientToken: \(Swift.String(describing: clientToken)), expirationInSeconds: \(Swift.String(describing: expirationInSeconds)), sessionId: \(Swift.String(describing: sessionId)), studioId: \(Swift.String(describing: studioId)))"}
}

extension CreateStreamingSessionStreamInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expirationInSeconds = "expirationInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expirationInSeconds = expirationInSeconds {
            try encodeContainer.encode(expirationInSeconds, forKey: .expirationInSeconds)
        }
    }
}

public struct CreateStreamingSessionStreamInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingSessionStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingSessionStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingSessionStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingSessionStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingSessionStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingSessionStreamOutputError>
}

public struct CreateStreamingSessionStreamInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingSessionStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStreamingSessionStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingSessionStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStreamingSessionStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingSessionStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingSessionStreamOutputError>
}

public struct CreateStreamingSessionStreamInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStreamingSessionStreamInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateStreamingSessionStreamInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStreamingSessionStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let sessionId = input.sessionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sessionId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())/streams"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateStreamingSessionStreamInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStreamingSessionStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStreamingSessionStreamOutputError>
}

/// A list collection streams.
public struct CreateStreamingSessionStreamInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The expiration time in seconds.
    public var expirationInSeconds: Swift.Int?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        expirationInSeconds: Swift.Int? = nil,
        sessionId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.expirationInSeconds = expirationInSeconds
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

struct CreateStreamingSessionStreamInputBody: Swift.Equatable {
    public let expirationInSeconds: Swift.Int?
}

extension CreateStreamingSessionStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expirationInSeconds = "expirationInSeconds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expirationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expirationInSeconds)
        expirationInSeconds = expirationInSecondsDecoded
    }
}

extension CreateStreamingSessionStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamingSessionStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingSessionStreamOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingSessionStreamOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingSessionStreamOutputResponse(stream: \(Swift.String(describing: stream)))"}
}

extension CreateStreamingSessionStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStreamingSessionStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stream = output.stream
        } else {
            self.stream = nil
        }
    }
}

public struct CreateStreamingSessionStreamOutputResponse: Swift.Equatable {
    /// The stream.
    public var stream: NimbleClientTypes.StreamingSessionStream?

    public init (
        stream: NimbleClientTypes.StreamingSessionStream? = nil
    )
    {
        self.stream = stream
    }
}

struct CreateStreamingSessionStreamOutputResponseBody: Swift.Equatable {
    public let stream: NimbleClientTypes.StreamingSessionStream?
}

extension CreateStreamingSessionStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stream = "stream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionStream.self, forKey: .stream)
        stream = streamDecoded
    }
}

public struct CreateStudioComponentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStudioComponentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStudioComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStudioComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStudioComponentOutputError>
}

extension CreateStudioComponentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStudioComponentInput(clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), description: \(Swift.String(describing: description)), ec2SecurityGroupIds: \(Swift.String(describing: ec2SecurityGroupIds)), initializationScripts: \(Swift.String(describing: initializationScripts)), name: \(Swift.String(describing: name)), scriptParameters: \(Swift.String(describing: scriptParameters)), studioId: \(Swift.String(describing: studioId)), subtype: \(Swift.String(describing: subtype)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)))"}
}

extension CreateStudioComponentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "configuration"
        case description = "description"
        case ec2SecurityGroupIds = "ec2SecurityGroupIds"
        case initializationScripts = "initializationScripts"
        case name = "name"
        case scriptParameters = "scriptParameters"
        case subtype = "subtype"
        case tags = "tags"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SecurityGroupIds = ec2SecurityGroupIds {
            var ec2SecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SecurityGroupIds)
            for studiocomponentsecuritygroupidlist0 in ec2SecurityGroupIds {
                try ec2SecurityGroupIdsContainer.encode(studiocomponentsecuritygroupidlist0)
            }
        }
        if let initializationScripts = initializationScripts {
            var initializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .initializationScripts)
            for studiocomponentinitializationscriptlist0 in initializationScripts {
                try initializationScriptsContainer.encode(studiocomponentinitializationscriptlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scriptParameters = scriptParameters {
            var scriptParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scriptParameters)
            for studiocomponentscriptparameterkeyvaluelist0 in scriptParameters {
                try scriptParametersContainer.encode(studiocomponentscriptparameterkeyvaluelist0)
            }
        }
        if let subtype = subtype {
            try encodeContainer.encode(subtype.rawValue, forKey: .subtype)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateStudioComponentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStudioComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStudioComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStudioComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStudioComponentOutputError>
}

public struct CreateStudioComponentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStudioComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStudioComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStudioComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStudioComponentOutputError>
}

public struct CreateStudioComponentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStudioComponentInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateStudioComponentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateStudioComponentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStudioComponentOutputError>
}

/// The studio components.
public struct CreateStudioComponentInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The configuration of the studio component, based on component type.
    public var configuration: NimbleClientTypes.StudioComponentConfiguration?
    /// The description.
    public var description: Swift.String?
    /// The EC2 security groups that control access to the studio component.
    public var ec2SecurityGroupIds: [Swift.String]?
    /// Initialization scripts for studio components.
    public var initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]?
    /// The name for the studio component.
    /// This member is required.
    public var name: Swift.String?
    /// Parameters for the studio component scripts.
    public var scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// The specific subtype of a studio component.
    public var subtype: NimbleClientTypes.StudioComponentSubtype?
    /// A collection of labels, in the form of key:value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the studio component.
    /// This member is required.
    public var type: NimbleClientTypes.StudioComponentType?

    public init (
        clientToken: Swift.String? = nil,
        configuration: NimbleClientTypes.StudioComponentConfiguration? = nil,
        description: Swift.String? = nil,
        ec2SecurityGroupIds: [Swift.String]? = nil,
        initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]? = nil,
        name: Swift.String? = nil,
        scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]? = nil,
        studioId: Swift.String? = nil,
        subtype: NimbleClientTypes.StudioComponentSubtype? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: NimbleClientTypes.StudioComponentType? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.ec2SecurityGroupIds = ec2SecurityGroupIds
        self.initializationScripts = initializationScripts
        self.name = name
        self.scriptParameters = scriptParameters
        self.studioId = studioId
        self.subtype = subtype
        self.tags = tags
        self.type = type
    }
}

struct CreateStudioComponentInputBody: Swift.Equatable {
    public let configuration: NimbleClientTypes.StudioComponentConfiguration?
    public let description: Swift.String?
    public let ec2SecurityGroupIds: [Swift.String]?
    public let initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]?
    public let name: Swift.String?
    public let scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]?
    public let subtype: NimbleClientTypes.StudioComponentSubtype?
    public let tags: [Swift.String:Swift.String]?
    public let type: NimbleClientTypes.StudioComponentType?
}

extension CreateStudioComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "configuration"
        case description = "description"
        case ec2SecurityGroupIds = "ec2SecurityGroupIds"
        case initializationScripts = "initializationScripts"
        case name = "name"
        case scriptParameters = "scriptParameters"
        case subtype = "subtype"
        case tags = "tags"
        case type = "type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SecurityGroupIds)
        var ec2SecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let ec2SecurityGroupIdsContainer = ec2SecurityGroupIdsContainer {
            ec2SecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in ec2SecurityGroupIdsContainer {
                if let string0 = string0 {
                    ec2SecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SecurityGroupIds = ec2SecurityGroupIdsDecoded0
        let initializationScriptsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioComponentInitializationScript?].self, forKey: .initializationScripts)
        var initializationScriptsDecoded0:[NimbleClientTypes.StudioComponentInitializationScript]? = nil
        if let initializationScriptsContainer = initializationScriptsContainer {
            initializationScriptsDecoded0 = [NimbleClientTypes.StudioComponentInitializationScript]()
            for structure0 in initializationScriptsContainer {
                if let structure0 = structure0 {
                    initializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        initializationScripts = initializationScriptsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let scriptParametersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.ScriptParameterKeyValue?].self, forKey: .scriptParameters)
        var scriptParametersDecoded0:[NimbleClientTypes.ScriptParameterKeyValue]? = nil
        if let scriptParametersContainer = scriptParametersContainer {
            scriptParametersDecoded0 = [NimbleClientTypes.ScriptParameterKeyValue]()
            for structure0 in scriptParametersContainer {
                if let structure0 = structure0 {
                    scriptParametersDecoded0?.append(structure0)
                }
            }
        }
        scriptParameters = scriptParametersDecoded0
        let subtypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentSubtype.self, forKey: .subtype)
        subtype = subtypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateStudioComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStudioComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStudioComponentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStudioComponentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStudioComponentOutputResponse(studioComponent: \(Swift.String(describing: studioComponent)))"}
}

extension CreateStudioComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStudioComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studioComponent = output.studioComponent
        } else {
            self.studioComponent = nil
        }
    }
}

public struct CreateStudioComponentOutputResponse: Swift.Equatable {
    /// Information about the studio component.
    public var studioComponent: NimbleClientTypes.StudioComponent?

    public init (
        studioComponent: NimbleClientTypes.StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

struct CreateStudioComponentOutputResponseBody: Swift.Equatable {
    public let studioComponent: NimbleClientTypes.StudioComponent?
}

extension CreateStudioComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studioComponent = "studioComponent"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioComponentDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponent.self, forKey: .studioComponent)
        studioComponent = studioComponentDecoded
    }
}

public struct CreateStudioInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStudioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStudioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStudioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStudioOutputError>
}

extension CreateStudioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStudioInput(adminRoleArn: \(Swift.String(describing: adminRoleArn)), clientToken: \(Swift.String(describing: clientToken)), displayName: \(Swift.String(describing: displayName)), studioEncryptionConfiguration: \(Swift.String(describing: studioEncryptionConfiguration)), studioName: \(Swift.String(describing: studioName)), tags: \(Swift.String(describing: tags)), userRoleArn: \(Swift.String(describing: userRoleArn)))"}
}

extension CreateStudioInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminRoleArn = "adminRoleArn"
        case displayName = "displayName"
        case studioEncryptionConfiguration = "studioEncryptionConfiguration"
        case studioName = "studioName"
        case tags = "tags"
        case userRoleArn = "userRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminRoleArn = adminRoleArn {
            try encodeContainer.encode(adminRoleArn, forKey: .adminRoleArn)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let studioEncryptionConfiguration = studioEncryptionConfiguration {
            try encodeContainer.encode(studioEncryptionConfiguration, forKey: .studioEncryptionConfiguration)
        }
        if let studioName = studioName {
            try encodeContainer.encode(studioName, forKey: .studioName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let userRoleArn = userRoleArn {
            try encodeContainer.encode(userRoleArn, forKey: .userRoleArn)
        }
    }
}

public struct CreateStudioInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStudioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStudioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStudioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStudioOutputError>
}

public struct CreateStudioInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStudioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateStudioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateStudioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStudioOutputError>
}

public struct CreateStudioInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateStudioInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateStudioInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateStudioInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateStudioOutputError>
}

/// A collection of studio resources.
public struct CreateStudioInput: Swift.Equatable {
    /// The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.
    /// This member is required.
    public var adminRoleArn: Swift.String?
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// A friendly name for the studio.
    /// This member is required.
    public var displayName: Swift.String?
    /// The studio encryption configuration.
    public var studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration?
    /// The studio name that is used in the URL of the Nimble Studio portal when accessed by Nimble Studio users.
    /// This member is required.
    public var studioName: Swift.String?
    /// A collection of labels, in the form of key:value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.
    /// This member is required.
    public var userRoleArn: Swift.String?

    public init (
        adminRoleArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration? = nil,
        studioName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userRoleArn: Swift.String? = nil
    )
    {
        self.adminRoleArn = adminRoleArn
        self.clientToken = clientToken
        self.displayName = displayName
        self.studioEncryptionConfiguration = studioEncryptionConfiguration
        self.studioName = studioName
        self.tags = tags
        self.userRoleArn = userRoleArn
    }
}

struct CreateStudioInputBody: Swift.Equatable {
    public let adminRoleArn: Swift.String?
    public let displayName: Swift.String?
    public let studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration?
    public let studioName: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let userRoleArn: Swift.String?
}

extension CreateStudioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminRoleArn = "adminRoleArn"
        case displayName = "displayName"
        case studioEncryptionConfiguration = "studioEncryptionConfiguration"
        case studioName = "studioName"
        case tags = "tags"
        case userRoleArn = "userRoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminRoleArn)
        adminRoleArn = adminRoleArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let studioEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioEncryptionConfiguration.self, forKey: .studioEncryptionConfiguration)
        studioEncryptionConfiguration = studioEncryptionConfigurationDecoded
        let studioNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioName)
        studioName = studioNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let userRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userRoleArn)
        userRoleArn = userRoleArnDecoded
    }
}

extension CreateStudioOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStudioOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStudioOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStudioOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStudioOutputResponse(studio: \(Swift.String(describing: studio)))"}
}

extension CreateStudioOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStudioOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

public struct CreateStudioOutputResponse: Swift.Equatable {
    /// Information about a studio.
    public var studio: NimbleClientTypes.Studio?

    public init (
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct CreateStudioOutputResponseBody: Swift.Equatable {
    public let studio: NimbleClientTypes.Studio?
}

extension CreateStudioOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studio = "studio"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

extension DeleteLaunchProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLaunchProfileInput(clientToken: \(Swift.String(describing: clientToken)), launchProfileId: \(Swift.String(describing: launchProfileId)), studioId: \(Swift.String(describing: studioId)))"}
}

extension DeleteLaunchProfileInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteLaunchProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLaunchProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLaunchProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLaunchProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLaunchProfileOutputError>
}

public struct DeleteLaunchProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLaunchProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLaunchProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLaunchProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLaunchProfileOutputError>
}

public struct DeleteLaunchProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLaunchProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteLaunchProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let launchProfileId = input.launchProfileId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("launchProfileId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLaunchProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLaunchProfileOutputError>
}

public struct DeleteLaunchProfileInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The launch profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.launchProfileId = launchProfileId
        self.studioId = studioId
    }
}

struct DeleteLaunchProfileInputBody: Swift.Equatable {
}

extension DeleteLaunchProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLaunchProfileMemberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLaunchProfileMemberInput(clientToken: \(Swift.String(describing: clientToken)), launchProfileId: \(Swift.String(describing: launchProfileId)), principalId: \(Swift.String(describing: principalId)), studioId: \(Swift.String(describing: studioId)))"}
}

extension DeleteLaunchProfileMemberInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteLaunchProfileMemberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLaunchProfileMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLaunchProfileMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLaunchProfileMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLaunchProfileMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLaunchProfileMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLaunchProfileMemberOutputError>
}

public struct DeleteLaunchProfileMemberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLaunchProfileMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLaunchProfileMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLaunchProfileMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLaunchProfileMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLaunchProfileMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLaunchProfileMemberOutputError>
}

public struct DeleteLaunchProfileMemberInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLaunchProfileMemberInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteLaunchProfileMemberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLaunchProfileMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let launchProfileId = input.launchProfileId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("launchProfileId is nil and needs a value for the path of this operation"))))
        }
        guard let principalId = input.principalId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("principalId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteLaunchProfileMemberInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLaunchProfileMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLaunchProfileMemberOutputError>
}

public struct DeleteLaunchProfileMemberInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The launch profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The principal ID.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.launchProfileId = launchProfileId
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct DeleteLaunchProfileMemberInputBody: Swift.Equatable {
}

extension DeleteLaunchProfileMemberInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLaunchProfileMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLaunchProfileMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLaunchProfileMemberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLaunchProfileMemberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLaunchProfileMemberOutputResponse()"}
}

extension DeleteLaunchProfileMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLaunchProfileMemberOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteLaunchProfileMemberOutputResponseBody: Swift.Equatable {
}

extension DeleteLaunchProfileMemberOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLaunchProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLaunchProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLaunchProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLaunchProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLaunchProfileOutputResponse(launchProfile: \(Swift.String(describing: launchProfile)))"}
}

extension DeleteLaunchProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteLaunchProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
        } else {
            self.launchProfile = nil
        }
    }
}

public struct DeleteLaunchProfileOutputResponse: Swift.Equatable {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?

    public init (
        launchProfile: NimbleClientTypes.LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

struct DeleteLaunchProfileOutputResponseBody: Swift.Equatable {
    public let launchProfile: NimbleClientTypes.LaunchProfile?
}

extension DeleteLaunchProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfile = "launchProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
    }
}

extension DeleteStreamingImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStreamingImageInput(clientToken: \(Swift.String(describing: clientToken)), streamingImageId: \(Swift.String(describing: streamingImageId)), studioId: \(Swift.String(describing: studioId)))"}
}

extension DeleteStreamingImageInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteStreamingImageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamingImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStreamingImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStreamingImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamingImageOutputError>
}

public struct DeleteStreamingImageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamingImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStreamingImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStreamingImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamingImageOutputError>
}

public struct DeleteStreamingImageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamingImageInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteStreamingImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let streamingImageId = input.streamingImageId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("streamingImageId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images/\(streamingImageId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteStreamingImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamingImageOutputError>
}

public struct DeleteStreamingImageInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The streaming image ID.
    /// This member is required.
    public var streamingImageId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        streamingImageId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.streamingImageId = streamingImageId
        self.studioId = studioId
    }
}

struct DeleteStreamingImageInputBody: Swift.Equatable {
}

extension DeleteStreamingImageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStreamingImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStreamingImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStreamingImageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamingImageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStreamingImageOutputResponse(streamingImage: \(Swift.String(describing: streamingImage)))"}
}

extension DeleteStreamingImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteStreamingImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingImage = output.streamingImage
        } else {
            self.streamingImage = nil
        }
    }
}

public struct DeleteStreamingImageOutputResponse: Swift.Equatable {
    /// The streaming image.
    public var streamingImage: NimbleClientTypes.StreamingImage?

    public init (
        streamingImage: NimbleClientTypes.StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

struct DeleteStreamingImageOutputResponseBody: Swift.Equatable {
    public let streamingImage: NimbleClientTypes.StreamingImage?
}

extension DeleteStreamingImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingImage = "streamingImage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingImageDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImage.self, forKey: .streamingImage)
        streamingImage = streamingImageDecoded
    }
}

extension DeleteStreamingSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStreamingSessionInput(clientToken: \(Swift.String(describing: clientToken)), sessionId: \(Swift.String(describing: sessionId)), studioId: \(Swift.String(describing: studioId)))"}
}

extension DeleteStreamingSessionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteStreamingSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamingSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStreamingSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamingSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStreamingSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamingSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamingSessionOutputError>
}

public struct DeleteStreamingSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamingSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStreamingSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamingSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStreamingSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamingSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamingSessionOutputError>
}

public struct DeleteStreamingSessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStreamingSessionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteStreamingSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStreamingSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let sessionId = input.sessionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sessionId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteStreamingSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStreamingSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStreamingSessionOutputError>
}

public struct DeleteStreamingSessionInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

struct DeleteStreamingSessionInputBody: Swift.Equatable {
}

extension DeleteStreamingSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStreamingSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStreamingSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStreamingSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamingSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStreamingSessionOutputResponse(session: \(Swift.String(describing: session)))"}
}

extension DeleteStreamingSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteStreamingSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct DeleteStreamingSessionOutputResponse: Swift.Equatable {
    /// The session.
    public var session: NimbleClientTypes.StreamingSession?

    public init (
        session: NimbleClientTypes.StreamingSession? = nil
    )
    {
        self.session = session
    }
}

struct DeleteStreamingSessionOutputResponseBody: Swift.Equatable {
    public let session: NimbleClientTypes.StreamingSession?
}

extension DeleteStreamingSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session = "session"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSession.self, forKey: .session)
        session = sessionDecoded
    }
}

extension DeleteStudioComponentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStudioComponentInput(clientToken: \(Swift.String(describing: clientToken)), studioComponentId: \(Swift.String(describing: studioComponentId)), studioId: \(Swift.String(describing: studioId)))"}
}

extension DeleteStudioComponentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteStudioComponentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStudioComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStudioComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStudioComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStudioComponentOutputError>
}

public struct DeleteStudioComponentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStudioComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStudioComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStudioComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStudioComponentOutputError>
}

public struct DeleteStudioComponentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStudioComponentInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteStudioComponentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let studioComponentId = input.studioComponentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioComponentId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components/\(studioComponentId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteStudioComponentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStudioComponentOutputError>
}

public struct DeleteStudioComponentInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The studio component ID.
    /// This member is required.
    public var studioComponentId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        studioComponentId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.studioComponentId = studioComponentId
        self.studioId = studioId
    }
}

struct DeleteStudioComponentInputBody: Swift.Equatable {
}

extension DeleteStudioComponentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStudioComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStudioComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStudioComponentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStudioComponentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStudioComponentOutputResponse(studioComponent: \(Swift.String(describing: studioComponent)))"}
}

extension DeleteStudioComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteStudioComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studioComponent = output.studioComponent
        } else {
            self.studioComponent = nil
        }
    }
}

public struct DeleteStudioComponentOutputResponse: Swift.Equatable {
    /// Information about the studio component.
    public var studioComponent: NimbleClientTypes.StudioComponent?

    public init (
        studioComponent: NimbleClientTypes.StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

struct DeleteStudioComponentOutputResponseBody: Swift.Equatable {
    public let studioComponent: NimbleClientTypes.StudioComponent?
}

extension DeleteStudioComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studioComponent = "studioComponent"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioComponentDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponent.self, forKey: .studioComponent)
        studioComponent = studioComponentDecoded
    }
}

extension DeleteStudioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStudioInput(clientToken: \(Swift.String(describing: clientToken)), studioId: \(Swift.String(describing: studioId)))"}
}

extension DeleteStudioInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteStudioInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStudioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStudioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStudioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStudioOutputError>
}

public struct DeleteStudioInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStudioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStudioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStudioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStudioOutputError>
}

public struct DeleteStudioInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStudioInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteStudioInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteStudioInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStudioOutputError>
}

public struct DeleteStudioInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.studioId = studioId
    }
}

struct DeleteStudioInputBody: Swift.Equatable {
}

extension DeleteStudioInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStudioMemberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStudioMemberInput(clientToken: \(Swift.String(describing: clientToken)), principalId: \(Swift.String(describing: principalId)), studioId: \(Swift.String(describing: studioId)))"}
}

extension DeleteStudioMemberInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteStudioMemberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStudioMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStudioMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStudioMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStudioMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStudioMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStudioMemberOutputError>
}

public struct DeleteStudioMemberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStudioMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteStudioMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStudioMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteStudioMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStudioMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStudioMemberOutputError>
}

public struct DeleteStudioMemberInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteStudioMemberInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteStudioMemberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteStudioMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let principalId = input.principalId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("principalId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteStudioMemberInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteStudioMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteStudioMemberOutputError>
}

public struct DeleteStudioMemberInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The principal ID.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct DeleteStudioMemberInputBody: Swift.Equatable {
}

extension DeleteStudioMemberInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStudioMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStudioMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStudioMemberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStudioMemberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStudioMemberOutputResponse()"}
}

extension DeleteStudioMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStudioMemberOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteStudioMemberOutputResponseBody: Swift.Equatable {
}

extension DeleteStudioMemberOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStudioOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStudioOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStudioOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStudioOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteStudioOutputResponse(studio: \(Swift.String(describing: studio)))"}
}

extension DeleteStudioOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteStudioOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

public struct DeleteStudioOutputResponse: Swift.Equatable {
    /// Information about a studio.
    public var studio: NimbleClientTypes.Studio?

    public init (
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct DeleteStudioOutputResponseBody: Swift.Equatable {
    public let studio: NimbleClientTypes.Studio?
}

extension DeleteStudioOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studio = "studio"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

extension NimbleClientTypes.Eula: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "content"
        case createdAt = "createdAt"
        case eulaId = "eulaId"
        case name = "name"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let eulaId = eulaId {
            try encodeContainer.encode(eulaId, forKey: .eulaId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let eulaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eulaId)
        eulaId = eulaIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension NimbleClientTypes.Eula: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Eula(content: \(Swift.String(describing: content)), createdAt: \(Swift.String(describing: createdAt)), eulaId: \(Swift.String(describing: eulaId)), name: \(Swift.String(describing: name)), updatedAt: \(Swift.String(describing: updatedAt)))"}
}

extension NimbleClientTypes {
    /// Represents a EULA resource.
    public struct Eula: Swift.Equatable {
        /// The EULA content.
        public var content: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The EULA ID.
        public var eulaId: Swift.String?
        /// The name for the EULA.
        public var name: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        public var updatedAt: ClientRuntime.Date?

        public init (
            content: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            eulaId: Swift.String? = nil,
            name: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.content = content
            self.createdAt = createdAt
            self.eulaId = eulaId
            self.name = name
            self.updatedAt = updatedAt
        }
    }

}

extension NimbleClientTypes.EulaAcceptance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptedAt = "acceptedAt"
        case acceptedBy = "acceptedBy"
        case accepteeId = "accepteeId"
        case eulaAcceptanceId = "eulaAcceptanceId"
        case eulaId = "eulaId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptedAt = acceptedAt {
            try encodeContainer.encode(acceptedAt.timeIntervalSince1970, forKey: .acceptedAt)
        }
        if let acceptedBy = acceptedBy {
            try encodeContainer.encode(acceptedBy, forKey: .acceptedBy)
        }
        if let accepteeId = accepteeId {
            try encodeContainer.encode(accepteeId, forKey: .accepteeId)
        }
        if let eulaAcceptanceId = eulaAcceptanceId {
            try encodeContainer.encode(eulaAcceptanceId, forKey: .eulaAcceptanceId)
        }
        if let eulaId = eulaId {
            try encodeContainer.encode(eulaId, forKey: .eulaId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .acceptedAt)
        acceptedAt = acceptedAtDecoded
        let acceptedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptedBy)
        acceptedBy = acceptedByDecoded
        let accepteeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accepteeId)
        accepteeId = accepteeIdDecoded
        let eulaAcceptanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eulaAcceptanceId)
        eulaAcceptanceId = eulaAcceptanceIdDecoded
        let eulaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eulaId)
        eulaId = eulaIdDecoded
    }
}

extension NimbleClientTypes.EulaAcceptance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EulaAcceptance(acceptedAt: \(Swift.String(describing: acceptedAt)), acceptedBy: \(Swift.String(describing: acceptedBy)), accepteeId: \(Swift.String(describing: accepteeId)), eulaAcceptanceId: \(Swift.String(describing: eulaAcceptanceId)), eulaId: \(Swift.String(describing: eulaId)))"}
}

extension NimbleClientTypes {
    public struct EulaAcceptance: Swift.Equatable {
        /// The Unix epoch timestamp in seconds for when the EULA was accepted.
        public var acceptedAt: ClientRuntime.Date?
        /// The ID of the person who accepted the EULA.
        public var acceptedBy: Swift.String?
        /// The ID of the acceptee.
        public var accepteeId: Swift.String?
        /// The EULA acceptance ID.
        public var eulaAcceptanceId: Swift.String?
        /// The EULA ID.
        public var eulaId: Swift.String?

        public init (
            acceptedAt: ClientRuntime.Date? = nil,
            acceptedBy: Swift.String? = nil,
            accepteeId: Swift.String? = nil,
            eulaAcceptanceId: Swift.String? = nil,
            eulaId: Swift.String? = nil
        )
        {
            self.acceptedAt = acceptedAt
            self.acceptedBy = acceptedBy
            self.accepteeId = accepteeId
            self.eulaAcceptanceId = eulaAcceptanceId
            self.eulaId = eulaId
        }
    }

}

extension GetEulaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEulaInput(eulaId: \(Swift.String(describing: eulaId)))"}
}

extension GetEulaInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetEulaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEulaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEulaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEulaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEulaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEulaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEulaOutputError>
}

public struct GetEulaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEulaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetEulaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEulaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetEulaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetEulaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEulaOutputError>
}

public struct GetEulaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetEulaInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetEulaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetEulaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let eulaId = input.eulaId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("eulaId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/eulas/\(eulaId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetEulaInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetEulaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetEulaOutputError>
}

public struct GetEulaInput: Swift.Equatable {
    /// The EULA ID.
    /// This member is required.
    public var eulaId: Swift.String?

    public init (
        eulaId: Swift.String? = nil
    )
    {
        self.eulaId = eulaId
    }
}

struct GetEulaInputBody: Swift.Equatable {
}

extension GetEulaInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEulaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEulaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEulaOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEulaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEulaOutputResponse(eula: \(Swift.String(describing: eula)))"}
}

extension GetEulaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEulaOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eula = output.eula
        } else {
            self.eula = nil
        }
    }
}

public struct GetEulaOutputResponse: Swift.Equatable {
    /// The EULA.
    public var eula: NimbleClientTypes.Eula?

    public init (
        eula: NimbleClientTypes.Eula? = nil
    )
    {
        self.eula = eula
    }
}

struct GetEulaOutputResponseBody: Swift.Equatable {
    public let eula: NimbleClientTypes.Eula?
}

extension GetEulaOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eula = "eula"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulaDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.Eula.self, forKey: .eula)
        eula = eulaDecoded
    }
}

extension GetLaunchProfileDetailsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLaunchProfileDetailsInput(launchProfileId: \(Swift.String(describing: launchProfileId)), studioId: \(Swift.String(describing: studioId)))"}
}

extension GetLaunchProfileDetailsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetLaunchProfileDetailsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLaunchProfileDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLaunchProfileDetailsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLaunchProfileDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLaunchProfileDetailsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLaunchProfileDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLaunchProfileDetailsOutputError>
}

public struct GetLaunchProfileDetailsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLaunchProfileDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLaunchProfileDetailsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLaunchProfileDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLaunchProfileDetailsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLaunchProfileDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLaunchProfileDetailsOutputError>
}

public struct GetLaunchProfileDetailsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLaunchProfileDetailsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetLaunchProfileDetailsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLaunchProfileDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let launchProfileId = input.launchProfileId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("launchProfileId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/details"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLaunchProfileDetailsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLaunchProfileDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLaunchProfileDetailsOutputError>
}

public struct GetLaunchProfileDetailsInput: Swift.Equatable {
    /// The launch profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        launchProfileId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.studioId = studioId
    }
}

struct GetLaunchProfileDetailsInputBody: Swift.Equatable {
}

extension GetLaunchProfileDetailsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLaunchProfileDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLaunchProfileDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLaunchProfileDetailsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLaunchProfileDetailsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLaunchProfileDetailsOutputResponse(launchProfile: \(Swift.String(describing: launchProfile)), streamingImages: \(Swift.String(describing: streamingImages)), studioComponentSummaries: \(Swift.String(describing: studioComponentSummaries)))"}
}

extension GetLaunchProfileDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLaunchProfileDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
            self.streamingImages = output.streamingImages
            self.studioComponentSummaries = output.studioComponentSummaries
        } else {
            self.launchProfile = nil
            self.streamingImages = nil
            self.studioComponentSummaries = nil
        }
    }
}

public struct GetLaunchProfileDetailsOutputResponse: Swift.Equatable {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?
    /// A collection of streaming images.
    public var streamingImages: [NimbleClientTypes.StreamingImage]?
    /// A collection of studio component summaries.
    public var studioComponentSummaries: [NimbleClientTypes.StudioComponentSummary]?

    public init (
        launchProfile: NimbleClientTypes.LaunchProfile? = nil,
        streamingImages: [NimbleClientTypes.StreamingImage]? = nil,
        studioComponentSummaries: [NimbleClientTypes.StudioComponentSummary]? = nil
    )
    {
        self.launchProfile = launchProfile
        self.streamingImages = streamingImages
        self.studioComponentSummaries = studioComponentSummaries
    }
}

struct GetLaunchProfileDetailsOutputResponseBody: Swift.Equatable {
    public let launchProfile: NimbleClientTypes.LaunchProfile?
    public let streamingImages: [NimbleClientTypes.StreamingImage]?
    public let studioComponentSummaries: [NimbleClientTypes.StudioComponentSummary]?
}

extension GetLaunchProfileDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfile = "launchProfile"
        case streamingImages = "streamingImages"
        case studioComponentSummaries = "studioComponentSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
        let streamingImagesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StreamingImage?].self, forKey: .streamingImages)
        var streamingImagesDecoded0:[NimbleClientTypes.StreamingImage]? = nil
        if let streamingImagesContainer = streamingImagesContainer {
            streamingImagesDecoded0 = [NimbleClientTypes.StreamingImage]()
            for structure0 in streamingImagesContainer {
                if let structure0 = structure0 {
                    streamingImagesDecoded0?.append(structure0)
                }
            }
        }
        streamingImages = streamingImagesDecoded0
        let studioComponentSummariesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioComponentSummary?].self, forKey: .studioComponentSummaries)
        var studioComponentSummariesDecoded0:[NimbleClientTypes.StudioComponentSummary]? = nil
        if let studioComponentSummariesContainer = studioComponentSummariesContainer {
            studioComponentSummariesDecoded0 = [NimbleClientTypes.StudioComponentSummary]()
            for structure0 in studioComponentSummariesContainer {
                if let structure0 = structure0 {
                    studioComponentSummariesDecoded0?.append(structure0)
                }
            }
        }
        studioComponentSummaries = studioComponentSummariesDecoded0
    }
}

extension GetLaunchProfileInitializationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLaunchProfileInitializationInput(launchProfileId: \(Swift.String(describing: launchProfileId)), launchProfileProtocolVersions: \(Swift.String(describing: launchProfileProtocolVersions)), launchPurpose: \(Swift.String(describing: launchPurpose)), platform: \(Swift.String(describing: platform)), studioId: \(Swift.String(describing: studioId)))"}
}

extension GetLaunchProfileInitializationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetLaunchProfileInitializationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLaunchProfileInitializationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLaunchProfileInitializationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLaunchProfileInitializationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLaunchProfileInitializationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLaunchProfileInitializationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLaunchProfileInitializationOutputError>
}

public struct GetLaunchProfileInitializationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLaunchProfileInitializationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLaunchProfileInitializationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLaunchProfileInitializationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let launchProfileProtocolVersions = input.operationInput.launchProfileProtocolVersions {
            launchProfileProtocolVersions.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "launchProfileProtocolVersions".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let launchPurpose = input.operationInput.launchPurpose {
            let launchPurposeQueryItem = ClientRuntime.URLQueryItem(name: "launchPurpose".urlPercentEncoding(), value: Swift.String(launchPurpose).urlPercentEncoding())
            input.builder.withQueryItem(launchPurposeQueryItem)
        }
        if let platform = input.operationInput.platform {
            let platformQueryItem = ClientRuntime.URLQueryItem(name: "platform".urlPercentEncoding(), value: Swift.String(platform).urlPercentEncoding())
            input.builder.withQueryItem(platformQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLaunchProfileInitializationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLaunchProfileInitializationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLaunchProfileInitializationOutputError>
}

public struct GetLaunchProfileInitializationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLaunchProfileInitializationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetLaunchProfileInitializationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLaunchProfileInitializationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let launchProfileId = input.launchProfileId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("launchProfileId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/init"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLaunchProfileInitializationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLaunchProfileInitializationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLaunchProfileInitializationOutputError>
}

public struct GetLaunchProfileInitializationInput: Swift.Equatable {
    /// The launch profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// A collection of launch profile protocol versions.
    /// This member is required.
    public var launchProfileProtocolVersions: [Swift.String]?
    /// The launch purpose.
    /// This member is required.
    public var launchPurpose: Swift.String?
    /// The platform.
    /// This member is required.
    public var platform: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        launchProfileId: Swift.String? = nil,
        launchProfileProtocolVersions: [Swift.String]? = nil,
        launchPurpose: Swift.String? = nil,
        platform: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.launchProfileProtocolVersions = launchProfileProtocolVersions
        self.launchPurpose = launchPurpose
        self.platform = platform
        self.studioId = studioId
    }
}

struct GetLaunchProfileInitializationInputBody: Swift.Equatable {
}

extension GetLaunchProfileInitializationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLaunchProfileInitializationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLaunchProfileInitializationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLaunchProfileInitializationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLaunchProfileInitializationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLaunchProfileInitializationOutputResponse(launchProfileInitialization: \(Swift.String(describing: launchProfileInitialization)))"}
}

extension GetLaunchProfileInitializationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLaunchProfileInitializationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfileInitialization = output.launchProfileInitialization
        } else {
            self.launchProfileInitialization = nil
        }
    }
}

public struct GetLaunchProfileInitializationOutputResponse: Swift.Equatable {
    /// The launch profile initialization.
    public var launchProfileInitialization: NimbleClientTypes.LaunchProfileInitialization?

    public init (
        launchProfileInitialization: NimbleClientTypes.LaunchProfileInitialization? = nil
    )
    {
        self.launchProfileInitialization = launchProfileInitialization
    }
}

struct GetLaunchProfileInitializationOutputResponseBody: Swift.Equatable {
    public let launchProfileInitialization: NimbleClientTypes.LaunchProfileInitialization?
}

extension GetLaunchProfileInitializationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfileInitialization = "launchProfileInitialization"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileInitializationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileInitialization.self, forKey: .launchProfileInitialization)
        launchProfileInitialization = launchProfileInitializationDecoded
    }
}

extension GetLaunchProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLaunchProfileInput(launchProfileId: \(Swift.String(describing: launchProfileId)), studioId: \(Swift.String(describing: studioId)))"}
}

extension GetLaunchProfileInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetLaunchProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLaunchProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLaunchProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLaunchProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLaunchProfileOutputError>
}

public struct GetLaunchProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLaunchProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLaunchProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLaunchProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLaunchProfileOutputError>
}

public struct GetLaunchProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLaunchProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetLaunchProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let launchProfileId = input.launchProfileId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("launchProfileId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLaunchProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLaunchProfileOutputError>
}

public struct GetLaunchProfileInput: Swift.Equatable {
    /// The launch profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        launchProfileId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.studioId = studioId
    }
}

struct GetLaunchProfileInputBody: Swift.Equatable {
}

extension GetLaunchProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLaunchProfileMemberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLaunchProfileMemberInput(launchProfileId: \(Swift.String(describing: launchProfileId)), principalId: \(Swift.String(describing: principalId)), studioId: \(Swift.String(describing: studioId)))"}
}

extension GetLaunchProfileMemberInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetLaunchProfileMemberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLaunchProfileMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLaunchProfileMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLaunchProfileMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLaunchProfileMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLaunchProfileMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLaunchProfileMemberOutputError>
}

public struct GetLaunchProfileMemberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLaunchProfileMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLaunchProfileMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLaunchProfileMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLaunchProfileMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLaunchProfileMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLaunchProfileMemberOutputError>
}

public struct GetLaunchProfileMemberInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLaunchProfileMemberInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetLaunchProfileMemberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLaunchProfileMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let launchProfileId = input.launchProfileId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("launchProfileId is nil and needs a value for the path of this operation"))))
        }
        guard let principalId = input.principalId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("principalId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetLaunchProfileMemberInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetLaunchProfileMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLaunchProfileMemberOutputError>
}

public struct GetLaunchProfileMemberInput: Swift.Equatable {
    /// The launch profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The principal ID.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        launchProfileId: Swift.String? = nil,
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct GetLaunchProfileMemberInputBody: Swift.Equatable {
}

extension GetLaunchProfileMemberInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLaunchProfileMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLaunchProfileMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLaunchProfileMemberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLaunchProfileMemberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLaunchProfileMemberOutputResponse(member: \(Swift.String(describing: member)))"}
}

extension GetLaunchProfileMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLaunchProfileMemberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.member = output.member
        } else {
            self.member = nil
        }
    }
}

public struct GetLaunchProfileMemberOutputResponse: Swift.Equatable {
    /// The member.
    public var member: NimbleClientTypes.LaunchProfileMembership?

    public init (
        member: NimbleClientTypes.LaunchProfileMembership? = nil
    )
    {
        self.member = member
    }
}

struct GetLaunchProfileMemberOutputResponseBody: Swift.Equatable {
    public let member: NimbleClientTypes.LaunchProfileMembership?
}

extension GetLaunchProfileMemberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member = "member"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileMembership.self, forKey: .member)
        member = memberDecoded
    }
}

extension GetLaunchProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLaunchProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLaunchProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLaunchProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLaunchProfileOutputResponse(launchProfile: \(Swift.String(describing: launchProfile)))"}
}

extension GetLaunchProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLaunchProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
        } else {
            self.launchProfile = nil
        }
    }
}

public struct GetLaunchProfileOutputResponse: Swift.Equatable {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?

    public init (
        launchProfile: NimbleClientTypes.LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

struct GetLaunchProfileOutputResponseBody: Swift.Equatable {
    public let launchProfile: NimbleClientTypes.LaunchProfile?
}

extension GetLaunchProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfile = "launchProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
    }
}

extension GetStreamingImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamingImageInput(streamingImageId: \(Swift.String(describing: streamingImageId)), studioId: \(Swift.String(describing: studioId)))"}
}

extension GetStreamingImageInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetStreamingImageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamingImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamingImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingImageOutputError>
}

public struct GetStreamingImageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamingImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamingImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingImageOutputError>
}

public struct GetStreamingImageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingImageInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetStreamingImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let streamingImageId = input.streamingImageId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("streamingImageId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images/\(streamingImageId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetStreamingImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingImageOutputError>
}

public struct GetStreamingImageInput: Swift.Equatable {
    /// The streaming image ID.
    /// This member is required.
    public var streamingImageId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        streamingImageId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.streamingImageId = streamingImageId
        self.studioId = studioId
    }
}

struct GetStreamingImageInputBody: Swift.Equatable {
}

extension GetStreamingImageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStreamingImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStreamingImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamingImageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamingImageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamingImageOutputResponse(streamingImage: \(Swift.String(describing: streamingImage)))"}
}

extension GetStreamingImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStreamingImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingImage = output.streamingImage
        } else {
            self.streamingImage = nil
        }
    }
}

public struct GetStreamingImageOutputResponse: Swift.Equatable {
    /// The streaming image.
    public var streamingImage: NimbleClientTypes.StreamingImage?

    public init (
        streamingImage: NimbleClientTypes.StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

struct GetStreamingImageOutputResponseBody: Swift.Equatable {
    public let streamingImage: NimbleClientTypes.StreamingImage?
}

extension GetStreamingImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingImage = "streamingImage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingImageDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImage.self, forKey: .streamingImage)
        streamingImage = streamingImageDecoded
    }
}

extension GetStreamingSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamingSessionInput(sessionId: \(Swift.String(describing: sessionId)), studioId: \(Swift.String(describing: studioId)))"}
}

extension GetStreamingSessionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetStreamingSessionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingSessionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamingSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamingSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingSessionOutputError>
}

public struct GetStreamingSessionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingSessionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamingSessionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamingSessionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingSessionOutputError>
}

public struct GetStreamingSessionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingSessionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetStreamingSessionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingSessionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let sessionId = input.sessionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sessionId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetStreamingSessionInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingSessionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingSessionOutputError>
}

public struct GetStreamingSessionInput: Swift.Equatable {
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        sessionId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

struct GetStreamingSessionInputBody: Swift.Equatable {
}

extension GetStreamingSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStreamingSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStreamingSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamingSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamingSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamingSessionOutputResponse(session: \(Swift.String(describing: session)))"}
}

extension GetStreamingSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStreamingSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct GetStreamingSessionOutputResponse: Swift.Equatable {
    /// The session.
    public var session: NimbleClientTypes.StreamingSession?

    public init (
        session: NimbleClientTypes.StreamingSession? = nil
    )
    {
        self.session = session
    }
}

struct GetStreamingSessionOutputResponseBody: Swift.Equatable {
    public let session: NimbleClientTypes.StreamingSession?
}

extension GetStreamingSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session = "session"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSession.self, forKey: .session)
        session = sessionDecoded
    }
}

extension GetStreamingSessionStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamingSessionStreamInput(sessionId: \(Swift.String(describing: sessionId)), streamId: \(Swift.String(describing: streamId)), studioId: \(Swift.String(describing: studioId)))"}
}

extension GetStreamingSessionStreamInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetStreamingSessionStreamInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingSessionStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamingSessionStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingSessionStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamingSessionStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingSessionStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingSessionStreamOutputError>
}

public struct GetStreamingSessionStreamInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingSessionStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStreamingSessionStreamInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingSessionStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStreamingSessionStreamInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingSessionStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingSessionStreamOutputError>
}

public struct GetStreamingSessionStreamInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStreamingSessionStreamInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetStreamingSessionStreamInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStreamingSessionStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let sessionId = input.sessionId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("sessionId is nil and needs a value for the path of this operation"))))
        }
        guard let streamId = input.streamId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("streamId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())/streams/\(streamId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetStreamingSessionStreamInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetStreamingSessionStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStreamingSessionStreamOutputError>
}

public struct GetStreamingSessionStreamInput: Swift.Equatable {
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The stream ID.
    /// This member is required.
    public var streamId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        sessionId: Swift.String? = nil,
        streamId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
        self.streamId = streamId
        self.studioId = studioId
    }
}

struct GetStreamingSessionStreamInputBody: Swift.Equatable {
}

extension GetStreamingSessionStreamInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStreamingSessionStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStreamingSessionStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamingSessionStreamOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamingSessionStreamOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamingSessionStreamOutputResponse(stream: \(Swift.String(describing: stream)))"}
}

extension GetStreamingSessionStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStreamingSessionStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stream = output.stream
        } else {
            self.stream = nil
        }
    }
}

public struct GetStreamingSessionStreamOutputResponse: Swift.Equatable {
    /// The stream.
    public var stream: NimbleClientTypes.StreamingSessionStream?

    public init (
        stream: NimbleClientTypes.StreamingSessionStream? = nil
    )
    {
        self.stream = stream
    }
}

struct GetStreamingSessionStreamOutputResponseBody: Swift.Equatable {
    public let stream: NimbleClientTypes.StreamingSessionStream?
}

extension GetStreamingSessionStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stream = "stream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionStream.self, forKey: .stream)
        stream = streamDecoded
    }
}

extension GetStudioComponentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStudioComponentInput(studioComponentId: \(Swift.String(describing: studioComponentId)), studioId: \(Swift.String(describing: studioId)))"}
}

extension GetStudioComponentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetStudioComponentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStudioComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStudioComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStudioComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStudioComponentOutputError>
}

public struct GetStudioComponentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStudioComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStudioComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStudioComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStudioComponentOutputError>
}

public struct GetStudioComponentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStudioComponentInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetStudioComponentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let studioComponentId = input.studioComponentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioComponentId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components/\(studioComponentId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetStudioComponentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStudioComponentOutputError>
}

public struct GetStudioComponentInput: Swift.Equatable {
    /// The studio component ID.
    /// This member is required.
    public var studioComponentId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        studioComponentId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.studioComponentId = studioComponentId
        self.studioId = studioId
    }
}

struct GetStudioComponentInputBody: Swift.Equatable {
}

extension GetStudioComponentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStudioComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStudioComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStudioComponentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStudioComponentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStudioComponentOutputResponse(studioComponent: \(Swift.String(describing: studioComponent)))"}
}

extension GetStudioComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStudioComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studioComponent = output.studioComponent
        } else {
            self.studioComponent = nil
        }
    }
}

public struct GetStudioComponentOutputResponse: Swift.Equatable {
    /// Information about the studio component.
    public var studioComponent: NimbleClientTypes.StudioComponent?

    public init (
        studioComponent: NimbleClientTypes.StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

struct GetStudioComponentOutputResponseBody: Swift.Equatable {
    public let studioComponent: NimbleClientTypes.StudioComponent?
}

extension GetStudioComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studioComponent = "studioComponent"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioComponentDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponent.self, forKey: .studioComponent)
        studioComponent = studioComponentDecoded
    }
}

extension GetStudioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStudioInput(studioId: \(Swift.String(describing: studioId)))"}
}

extension GetStudioInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetStudioInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStudioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStudioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStudioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStudioOutputError>
}

public struct GetStudioInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStudioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStudioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStudioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStudioOutputError>
}

public struct GetStudioInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStudioInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetStudioInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetStudioInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStudioOutputError>
}

public struct GetStudioInput: Swift.Equatable {
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        studioId: Swift.String? = nil
    )
    {
        self.studioId = studioId
    }
}

struct GetStudioInputBody: Swift.Equatable {
}

extension GetStudioInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStudioMemberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStudioMemberInput(principalId: \(Swift.String(describing: principalId)), studioId: \(Swift.String(describing: studioId)))"}
}

extension GetStudioMemberInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetStudioMemberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStudioMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStudioMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStudioMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStudioMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStudioMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStudioMemberOutputError>
}

public struct GetStudioMemberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStudioMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetStudioMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStudioMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetStudioMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetStudioMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStudioMemberOutputError>
}

public struct GetStudioMemberInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetStudioMemberInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetStudioMemberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetStudioMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let principalId = input.principalId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("principalId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetStudioMemberInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetStudioMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetStudioMemberOutputError>
}

public struct GetStudioMemberInput: Swift.Equatable {
    /// The principal ID.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct GetStudioMemberInputBody: Swift.Equatable {
}

extension GetStudioMemberInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStudioMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStudioMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStudioMemberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStudioMemberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStudioMemberOutputResponse(member: \(Swift.String(describing: member)))"}
}

extension GetStudioMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStudioMemberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.member = output.member
        } else {
            self.member = nil
        }
    }
}

public struct GetStudioMemberOutputResponse: Swift.Equatable {
    /// The member.
    public var member: NimbleClientTypes.StudioMembership?

    public init (
        member: NimbleClientTypes.StudioMembership? = nil
    )
    {
        self.member = member
    }
}

struct GetStudioMemberOutputResponseBody: Swift.Equatable {
    public let member: NimbleClientTypes.StudioMembership?
}

extension GetStudioMemberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member = "member"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioMembership.self, forKey: .member)
        member = memberDecoded
    }
}

extension GetStudioOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStudioOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStudioOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStudioOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStudioOutputResponse(studio: \(Swift.String(describing: studio)))"}
}

extension GetStudioOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStudioOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

public struct GetStudioOutputResponse: Swift.Equatable {
    /// Information about a studio.
    public var studio: NimbleClientTypes.Studio?

    public init (
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct GetStudioOutputResponseBody: Swift.Equatable {
    public let studio: NimbleClientTypes.Studio?
}

extension GetStudioOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studio = "studio"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

extension InternalServerErrorException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalServerErrorException(code: \(Swift.String(describing: code)), context: \(Swift.String(describing: context)), message: \(Swift.String(describing: message)))"}
}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// A more specific error code.
    public var code: Swift.String?
    /// The exception context.
    public var context: [Swift.String:Swift.String]?
    /// A human-readable description of the error.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let context: [Swift.String:Swift.String]?
    public let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case context = "context"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in contextContainer {
                if let __string0 = __string0 {
                    contextDecoded0?[key0] = __string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NimbleClientTypes.LaunchProfile: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case createdBy = "createdBy"
        case description = "description"
        case ec2SubnetIds = "ec2SubnetIds"
        case launchProfileId = "launchProfileId"
        case launchProfileProtocolVersions = "launchProfileProtocolVersions"
        case name = "name"
        case state = "state"
        case statusCode = "statusCode"
        case statusMessage = "statusMessage"
        case streamConfiguration = "streamConfiguration"
        case studioComponentIds = "studioComponentIds"
        case tags = "tags"
        case updatedAt = "updatedAt"
        case updatedBy = "updatedBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SubnetIds = ec2SubnetIds {
            var ec2SubnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SubnetIds)
            for ec2subnetidlist0 in ec2SubnetIds {
                try ec2SubnetIdsContainer.encode(ec2subnetidlist0)
            }
        }
        if let launchProfileId = launchProfileId {
            try encodeContainer.encode(launchProfileId, forKey: .launchProfileId)
        }
        if let launchProfileProtocolVersions = launchProfileProtocolVersions {
            var launchProfileProtocolVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchProfileProtocolVersions)
            for launchprofileprotocolversionlist0 in launchProfileProtocolVersions {
                try launchProfileProtocolVersionsContainer.encode(launchprofileprotocolversionlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let streamConfiguration = streamConfiguration {
            try encodeContainer.encode(streamConfiguration, forKey: .streamConfiguration)
        }
        if let studioComponentIds = studioComponentIds {
            var studioComponentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .studioComponentIds)
            for launchprofilestudiocomponentidlist0 in studioComponentIds {
                try studioComponentIdsContainer.encode(launchprofilestudiocomponentidlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let updatedBy = updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SubnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SubnetIds)
        var ec2SubnetIdsDecoded0:[Swift.String]? = nil
        if let ec2SubnetIdsContainer = ec2SubnetIdsContainer {
            ec2SubnetIdsDecoded0 = [Swift.String]()
            for string0 in ec2SubnetIdsContainer {
                if let string0 = string0 {
                    ec2SubnetIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SubnetIds = ec2SubnetIdsDecoded0
        let launchProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileId)
        launchProfileId = launchProfileIdDecoded
        let launchProfileProtocolVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .launchProfileProtocolVersions)
        var launchProfileProtocolVersionsDecoded0:[Swift.String]? = nil
        if let launchProfileProtocolVersionsContainer = launchProfileProtocolVersionsContainer {
            launchProfileProtocolVersionsDecoded0 = [Swift.String]()
            for string0 in launchProfileProtocolVersionsContainer {
                if let string0 = string0 {
                    launchProfileProtocolVersionsDecoded0?.append(string0)
                }
            }
        }
        launchProfileProtocolVersions = launchProfileProtocolVersionsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let streamConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamConfiguration.self, forKey: .streamConfiguration)
        streamConfiguration = streamConfigurationDecoded
        let studioComponentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .studioComponentIds)
        var studioComponentIdsDecoded0:[Swift.String]? = nil
        if let studioComponentIdsContainer = studioComponentIdsContainer {
            studioComponentIdsDecoded0 = [Swift.String]()
            for string0 in studioComponentIdsContainer {
                if let string0 = string0 {
                    studioComponentIdsDecoded0?.append(string0)
                }
            }
        }
        studioComponentIds = studioComponentIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension NimbleClientTypes.LaunchProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchProfile(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), description: \(Swift.String(describing: description)), ec2SubnetIds: \(Swift.String(describing: ec2SubnetIds)), launchProfileId: \(Swift.String(describing: launchProfileId)), launchProfileProtocolVersions: \(Swift.String(describing: launchProfileProtocolVersions)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), streamConfiguration: \(Swift.String(describing: streamConfiguration)), studioComponentIds: \(Swift.String(describing: studioComponentIds)), tags: \(Swift.String(describing: tags)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)))"}
}

extension NimbleClientTypes {
    public struct LaunchProfile: Swift.Equatable {
        /// The ARN of the resource.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The user ID of the user that created the launch profile.
        public var createdBy: Swift.String?
        /// A human-readable description of the launch profile.
        public var description: Swift.String?
        /// Unique identifiers for a collection of EC2 subnets.
        public var ec2SubnetIds: [Swift.String]?
        /// The launch profile ID.
        public var launchProfileId: Swift.String?
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public var launchProfileProtocolVersions: [Swift.String]?
        /// A friendly name for the launch profile.
        public var name: Swift.String?
        /// The current state.
        public var state: NimbleClientTypes.LaunchProfileState?
        /// The status code.
        public var statusCode: NimbleClientTypes.LaunchProfileStatusCode?
        /// The status message for the launch profile.
        public var statusMessage: Swift.String?
        /// A configuration for a streaming session.
        public var streamConfiguration: NimbleClientTypes.StreamConfiguration?
        /// Unique identifiers for a collection of studio components that can be used with this launch profile.
        public var studioComponentIds: [Swift.String]?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user ID of the user that most recently updated the resource.
        public var updatedBy: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            ec2SubnetIds: [Swift.String]? = nil,
            launchProfileId: Swift.String? = nil,
            launchProfileProtocolVersions: [Swift.String]? = nil,
            name: Swift.String? = nil,
            state: NimbleClientTypes.LaunchProfileState? = nil,
            statusCode: NimbleClientTypes.LaunchProfileStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            streamConfiguration: NimbleClientTypes.StreamConfiguration? = nil,
            studioComponentIds: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.ec2SubnetIds = ec2SubnetIds
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.name = name
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.streamConfiguration = streamConfiguration
            self.studioComponentIds = studioComponentIds
            self.tags = tags
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension NimbleClientTypes.LaunchProfileInitialization: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDirectory = "activeDirectory"
        case ec2SecurityGroupIds = "ec2SecurityGroupIds"
        case launchProfileId = "launchProfileId"
        case launchProfileProtocolVersion = "launchProfileProtocolVersion"
        case launchPurpose = "launchPurpose"
        case name = "name"
        case platform = "platform"
        case systemInitializationScripts = "systemInitializationScripts"
        case userInitializationScripts = "userInitializationScripts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDirectory = activeDirectory {
            try encodeContainer.encode(activeDirectory, forKey: .activeDirectory)
        }
        if let ec2SecurityGroupIds = ec2SecurityGroupIds {
            var ec2SecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SecurityGroupIds)
            for launchprofilesecuritygroupidlist0 in ec2SecurityGroupIds {
                try ec2SecurityGroupIdsContainer.encode(launchprofilesecuritygroupidlist0)
            }
        }
        if let launchProfileId = launchProfileId {
            try encodeContainer.encode(launchProfileId, forKey: .launchProfileId)
        }
        if let launchProfileProtocolVersion = launchProfileProtocolVersion {
            try encodeContainer.encode(launchProfileProtocolVersion, forKey: .launchProfileProtocolVersion)
        }
        if let launchPurpose = launchPurpose {
            try encodeContainer.encode(launchPurpose, forKey: .launchPurpose)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let systemInitializationScripts = systemInitializationScripts {
            var systemInitializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .systemInitializationScripts)
            for launchprofileinitializationscriptlist0 in systemInitializationScripts {
                try systemInitializationScriptsContainer.encode(launchprofileinitializationscriptlist0)
            }
        }
        if let userInitializationScripts = userInitializationScripts {
            var userInitializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userInitializationScripts)
            for launchprofileinitializationscriptlist0 in userInitializationScripts {
                try userInitializationScriptsContainer.encode(launchprofileinitializationscriptlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDirectoryDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileInitializationActiveDirectory.self, forKey: .activeDirectory)
        activeDirectory = activeDirectoryDecoded
        let ec2SecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SecurityGroupIds)
        var ec2SecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let ec2SecurityGroupIdsContainer = ec2SecurityGroupIdsContainer {
            ec2SecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in ec2SecurityGroupIdsContainer {
                if let string0 = string0 {
                    ec2SecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SecurityGroupIds = ec2SecurityGroupIdsDecoded0
        let launchProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileId)
        launchProfileId = launchProfileIdDecoded
        let launchProfileProtocolVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileProtocolVersion)
        launchProfileProtocolVersion = launchProfileProtocolVersionDecoded
        let launchPurposeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchPurpose)
        launchPurpose = launchPurposeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let platformDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfilePlatform.self, forKey: .platform)
        platform = platformDecoded
        let systemInitializationScriptsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.LaunchProfileInitializationScript?].self, forKey: .systemInitializationScripts)
        var systemInitializationScriptsDecoded0:[NimbleClientTypes.LaunchProfileInitializationScript]? = nil
        if let systemInitializationScriptsContainer = systemInitializationScriptsContainer {
            systemInitializationScriptsDecoded0 = [NimbleClientTypes.LaunchProfileInitializationScript]()
            for structure0 in systemInitializationScriptsContainer {
                if let structure0 = structure0 {
                    systemInitializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        systemInitializationScripts = systemInitializationScriptsDecoded0
        let userInitializationScriptsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.LaunchProfileInitializationScript?].self, forKey: .userInitializationScripts)
        var userInitializationScriptsDecoded0:[NimbleClientTypes.LaunchProfileInitializationScript]? = nil
        if let userInitializationScriptsContainer = userInitializationScriptsContainer {
            userInitializationScriptsDecoded0 = [NimbleClientTypes.LaunchProfileInitializationScript]()
            for structure0 in userInitializationScriptsContainer {
                if let structure0 = structure0 {
                    userInitializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        userInitializationScripts = userInitializationScriptsDecoded0
    }
}

extension NimbleClientTypes.LaunchProfileInitialization: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchProfileInitialization(activeDirectory: \(Swift.String(describing: activeDirectory)), ec2SecurityGroupIds: \(Swift.String(describing: ec2SecurityGroupIds)), launchProfileId: \(Swift.String(describing: launchProfileId)), launchProfileProtocolVersion: \(Swift.String(describing: launchProfileProtocolVersion)), launchPurpose: \(Swift.String(describing: launchPurpose)), name: \(Swift.String(describing: name)), platform: \(Swift.String(describing: platform)), systemInitializationScripts: \(Swift.String(describing: systemInitializationScripts)), userInitializationScripts: \(Swift.String(describing: userInitializationScripts)))"}
}

extension NimbleClientTypes {
    public struct LaunchProfileInitialization: Swift.Equatable {
        /// A LaunchProfileInitializationActiveDirectory resource.
        public var activeDirectory: NimbleClientTypes.LaunchProfileInitializationActiveDirectory?
        /// The EC2 security groups that control access to the studio component.
        public var ec2SecurityGroupIds: [Swift.String]?
        /// The launch profile ID.
        public var launchProfileId: Swift.String?
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public var launchProfileProtocolVersion: Swift.String?
        /// The launch purpose.
        public var launchPurpose: Swift.String?
        /// The name for the launch profile.
        public var name: Swift.String?
        /// The platform of the launch platform, either WINDOWS or LINUX.
        public var platform: NimbleClientTypes.LaunchProfilePlatform?
        /// The system initializtion scripts.
        public var systemInitializationScripts: [NimbleClientTypes.LaunchProfileInitializationScript]?
        /// The user initializtion scripts.
        public var userInitializationScripts: [NimbleClientTypes.LaunchProfileInitializationScript]?

        public init (
            activeDirectory: NimbleClientTypes.LaunchProfileInitializationActiveDirectory? = nil,
            ec2SecurityGroupIds: [Swift.String]? = nil,
            launchProfileId: Swift.String? = nil,
            launchProfileProtocolVersion: Swift.String? = nil,
            launchPurpose: Swift.String? = nil,
            name: Swift.String? = nil,
            platform: NimbleClientTypes.LaunchProfilePlatform? = nil,
            systemInitializationScripts: [NimbleClientTypes.LaunchProfileInitializationScript]? = nil,
            userInitializationScripts: [NimbleClientTypes.LaunchProfileInitializationScript]? = nil
        )
        {
            self.activeDirectory = activeDirectory
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersion = launchProfileProtocolVersion
            self.launchPurpose = launchPurpose
            self.name = name
            self.platform = platform
            self.systemInitializationScripts = systemInitializationScripts
            self.userInitializationScripts = userInitializationScripts
        }
    }

}

extension NimbleClientTypes.LaunchProfileInitializationActiveDirectory: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computerAttributes = "computerAttributes"
        case directoryId = "directoryId"
        case directoryName = "directoryName"
        case dnsIpAddresses = "dnsIpAddresses"
        case organizationalUnitDistinguishedName = "organizationalUnitDistinguishedName"
        case studioComponentId = "studioComponentId"
        case studioComponentName = "studioComponentName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computerAttributes = computerAttributes {
            var computerAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .computerAttributes)
            for activedirectorycomputerattributelist0 in computerAttributes {
                try computerAttributesContainer.encode(activedirectorycomputerattributelist0)
            }
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let dnsIpAddresses = dnsIpAddresses {
            var dnsIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIpAddresses)
            for activedirectorydnsipaddresslist0 in dnsIpAddresses {
                try dnsIpAddressesContainer.encode(activedirectorydnsipaddresslist0)
            }
        }
        if let organizationalUnitDistinguishedName = organizationalUnitDistinguishedName {
            try encodeContainer.encode(organizationalUnitDistinguishedName, forKey: .organizationalUnitDistinguishedName)
        }
        if let studioComponentId = studioComponentId {
            try encodeContainer.encode(studioComponentId, forKey: .studioComponentId)
        }
        if let studioComponentName = studioComponentName {
            try encodeContainer.encode(studioComponentName, forKey: .studioComponentName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computerAttributesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.ActiveDirectoryComputerAttribute?].self, forKey: .computerAttributes)
        var computerAttributesDecoded0:[NimbleClientTypes.ActiveDirectoryComputerAttribute]? = nil
        if let computerAttributesContainer = computerAttributesContainer {
            computerAttributesDecoded0 = [NimbleClientTypes.ActiveDirectoryComputerAttribute]()
            for structure0 in computerAttributesContainer {
                if let structure0 = structure0 {
                    computerAttributesDecoded0?.append(structure0)
                }
            }
        }
        computerAttributes = computerAttributesDecoded0
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let dnsIpAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dnsIpAddresses)
        var dnsIpAddressesDecoded0:[Swift.String]? = nil
        if let dnsIpAddressesContainer = dnsIpAddressesContainer {
            dnsIpAddressesDecoded0 = [Swift.String]()
            for string0 in dnsIpAddressesContainer {
                if let string0 = string0 {
                    dnsIpAddressesDecoded0?.append(string0)
                }
            }
        }
        dnsIpAddresses = dnsIpAddressesDecoded0
        let organizationalUnitDistinguishedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnitDistinguishedName)
        organizationalUnitDistinguishedName = organizationalUnitDistinguishedNameDecoded
        let studioComponentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentId)
        studioComponentId = studioComponentIdDecoded
        let studioComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentName)
        studioComponentName = studioComponentNameDecoded
    }
}

extension NimbleClientTypes.LaunchProfileInitializationActiveDirectory: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchProfileInitializationActiveDirectory(computerAttributes: \(Swift.String(describing: computerAttributes)), directoryId: \(Swift.String(describing: directoryId)), directoryName: \(Swift.String(describing: directoryName)), dnsIpAddresses: \(Swift.String(describing: dnsIpAddresses)), organizationalUnitDistinguishedName: \(Swift.String(describing: organizationalUnitDistinguishedName)), studioComponentId: \(Swift.String(describing: studioComponentId)), studioComponentName: \(Swift.String(describing: studioComponentName)))"}
}

extension NimbleClientTypes {
    public struct LaunchProfileInitializationActiveDirectory: Swift.Equatable {
        /// A collection of custom attributes for an Active Directory computer.
        public var computerAttributes: [NimbleClientTypes.ActiveDirectoryComputerAttribute]?
        /// The directory ID of the Directory Service for Microsoft Active Directory to access using this launch profile.
        public var directoryId: Swift.String?
        /// The directory name.
        public var directoryName: Swift.String?
        /// The DNS IP address.
        public var dnsIpAddresses: [Swift.String]?
        /// The name for the organizational unit distinguished name.
        public var organizationalUnitDistinguishedName: Swift.String?
        /// The unique identifier for a studio component resource.
        public var studioComponentId: Swift.String?
        /// The name for the studio component.
        public var studioComponentName: Swift.String?

        public init (
            computerAttributes: [NimbleClientTypes.ActiveDirectoryComputerAttribute]? = nil,
            directoryId: Swift.String? = nil,
            directoryName: Swift.String? = nil,
            dnsIpAddresses: [Swift.String]? = nil,
            organizationalUnitDistinguishedName: Swift.String? = nil,
            studioComponentId: Swift.String? = nil,
            studioComponentName: Swift.String? = nil
        )
        {
            self.computerAttributes = computerAttributes
            self.directoryId = directoryId
            self.directoryName = directoryName
            self.dnsIpAddresses = dnsIpAddresses
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
            self.studioComponentId = studioComponentId
            self.studioComponentName = studioComponentName
        }
    }

}

extension NimbleClientTypes.LaunchProfileInitializationScript: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case script = "script"
        case studioComponentId = "studioComponentId"
        case studioComponentName = "studioComponentName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let script = script {
            try encodeContainer.encode(script, forKey: .script)
        }
        if let studioComponentId = studioComponentId {
            try encodeContainer.encode(studioComponentId, forKey: .studioComponentId)
        }
        if let studioComponentName = studioComponentName {
            try encodeContainer.encode(studioComponentName, forKey: .studioComponentName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .script)
        script = scriptDecoded
        let studioComponentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentId)
        studioComponentId = studioComponentIdDecoded
        let studioComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentName)
        studioComponentName = studioComponentNameDecoded
    }
}

extension NimbleClientTypes.LaunchProfileInitializationScript: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchProfileInitializationScript(script: \(Swift.String(describing: script)), studioComponentId: \(Swift.String(describing: studioComponentId)), studioComponentName: \(Swift.String(describing: studioComponentName)))"}
}

extension NimbleClientTypes {
    public struct LaunchProfileInitializationScript: Swift.Equatable {
        /// The initialization script.
        public var script: Swift.String?
        /// The unique identifier for a studio component resource.
        public var studioComponentId: Swift.String?
        /// The name for the studio component.
        public var studioComponentName: Swift.String?

        public init (
            script: Swift.String? = nil,
            studioComponentId: Swift.String? = nil,
            studioComponentName: Swift.String? = nil
        )
        {
            self.script = script
            self.studioComponentId = studioComponentId
            self.studioComponentName = studioComponentName
        }
    }

}

extension NimbleClientTypes.LaunchProfileMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "identityStoreId"
        case persona = "persona"
        case principalId = "principalId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let persona = persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let personaDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfilePersona.self, forKey: .persona)
        persona = personaDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension NimbleClientTypes.LaunchProfileMembership: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchProfileMembership(identityStoreId: \(Swift.String(describing: identityStoreId)), persona: \(Swift.String(describing: persona)), principalId: \(Swift.String(describing: principalId)))"}
}

extension NimbleClientTypes {
    public struct LaunchProfileMembership: Swift.Equatable {
        /// The ID of the identity store.
        public var identityStoreId: Swift.String?
        /// The persona.
        public var persona: NimbleClientTypes.LaunchProfilePersona?
        /// The principal ID.
        public var principalId: Swift.String?

        public init (
            identityStoreId: Swift.String? = nil,
            persona: NimbleClientTypes.LaunchProfilePersona? = nil,
            principalId: Swift.String? = nil
        )
        {
            self.identityStoreId = identityStoreId
            self.persona = persona
            self.principalId = principalId
        }
    }

}

extension NimbleClientTypes {
    public enum LaunchProfilePersona: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfilePersona] {
            return [
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchProfilePersona(rawValue: rawValue) ?? LaunchProfilePersona.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum LaunchProfilePlatform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfilePlatform] {
            return [
                .linux,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchProfilePlatform(rawValue: rawValue) ?? LaunchProfilePlatform.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum LaunchProfileState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfileState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchProfileState(rawValue: rawValue) ?? LaunchProfileState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum LaunchProfileStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case encryptionKeyAccessDenied
        case encryptionKeyNotFound
        case internalError
        case invalidSubnetsProvided
        case launchProfileCreated
        case launchProfileCreateInProgress
        case launchProfileDeleted
        case launchProfileDeleteInProgress
        case launchProfileUpdated
        case launchProfileUpdateInProgress
        case launchProfileWithStreamSessionsNotDeleted
        case streamingImageNotFound
        case streamingImageNotReady
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfileStatusCode] {
            return [
                .encryptionKeyAccessDenied,
                .encryptionKeyNotFound,
                .internalError,
                .invalidSubnetsProvided,
                .launchProfileCreated,
                .launchProfileCreateInProgress,
                .launchProfileDeleted,
                .launchProfileDeleteInProgress,
                .launchProfileUpdated,
                .launchProfileUpdateInProgress,
                .launchProfileWithStreamSessionsNotDeleted,
                .streamingImageNotFound,
                .streamingImageNotReady,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .encryptionKeyAccessDenied: return "ENCRYPTION_KEY_ACCESS_DENIED"
            case .encryptionKeyNotFound: return "ENCRYPTION_KEY_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidSubnetsProvided: return "INVALID_SUBNETS_PROVIDED"
            case .launchProfileCreated: return "LAUNCH_PROFILE_CREATED"
            case .launchProfileCreateInProgress: return "LAUNCH_PROFILE_CREATE_IN_PROGRESS"
            case .launchProfileDeleted: return "LAUNCH_PROFILE_DELETED"
            case .launchProfileDeleteInProgress: return "LAUNCH_PROFILE_DELETE_IN_PROGRESS"
            case .launchProfileUpdated: return "LAUNCH_PROFILE_UPDATED"
            case .launchProfileUpdateInProgress: return "LAUNCH_PROFILE_UPDATE_IN_PROGRESS"
            case .launchProfileWithStreamSessionsNotDeleted: return "LAUNCH_PROFILE_WITH_STREAM_SESSIONS_NOT_DELETED"
            case .streamingImageNotFound: return "STREAMING_IMAGE_NOT_FOUND"
            case .streamingImageNotReady: return "STREAMING_IMAGE_NOT_READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchProfileStatusCode(rawValue: rawValue) ?? LaunchProfileStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.LicenseServiceConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "endpoint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension NimbleClientTypes.LicenseServiceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LicenseServiceConfiguration(endpoint: \(Swift.String(describing: endpoint)))"}
}

extension NimbleClientTypes {
    /// The configuration for a license service that is associated with a studio resource.
    public struct LicenseServiceConfiguration: Swift.Equatable {
        /// The endpoint of the license service that is accessed by the studio component resource.
        public var endpoint: Swift.String?

        public init (
            endpoint: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
        }
    }

}

extension ListEulaAcceptancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEulaAcceptancesInput(eulaIds: \(Swift.String(describing: eulaIds)), nextToken: \(Swift.String(describing: nextToken)), studioId: \(Swift.String(describing: studioId)))"}
}

extension ListEulaAcceptancesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListEulaAcceptancesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEulaAcceptancesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEulaAcceptancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEulaAcceptancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEulaAcceptancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEulaAcceptancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEulaAcceptancesOutputError>
}

public struct ListEulaAcceptancesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEulaAcceptancesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEulaAcceptancesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEulaAcceptancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let eulaIds = input.operationInput.eulaIds {
            eulaIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "eulaIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEulaAcceptancesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEulaAcceptancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEulaAcceptancesOutputError>
}

public struct ListEulaAcceptancesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEulaAcceptancesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListEulaAcceptancesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEulaAcceptancesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/eula-acceptances"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEulaAcceptancesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEulaAcceptancesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEulaAcceptancesOutputError>
}

public struct ListEulaAcceptancesInput: Swift.Equatable {
    /// A collection of EULA IDs.
    public var eulaIds: [Swift.String]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        eulaIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.eulaIds = eulaIds
        self.nextToken = nextToken
        self.studioId = studioId
    }
}

struct ListEulaAcceptancesInputBody: Swift.Equatable {
}

extension ListEulaAcceptancesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListEulaAcceptancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEulaAcceptancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEulaAcceptancesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEulaAcceptancesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEulaAcceptancesOutputResponse(eulaAcceptances: \(Swift.String(describing: eulaAcceptances)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEulaAcceptancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEulaAcceptancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eulaAcceptances = output.eulaAcceptances
            self.nextToken = output.nextToken
        } else {
            self.eulaAcceptances = nil
            self.nextToken = nil
        }
    }
}

public struct ListEulaAcceptancesOutputResponse: Swift.Equatable {
    /// A collection of EULA acceptances.
    public var eulaAcceptances: [NimbleClientTypes.EulaAcceptance]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        eulaAcceptances: [NimbleClientTypes.EulaAcceptance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eulaAcceptances = eulaAcceptances
        self.nextToken = nextToken
    }
}

struct ListEulaAcceptancesOutputResponseBody: Swift.Equatable {
    public let eulaAcceptances: [NimbleClientTypes.EulaAcceptance]?
    public let nextToken: Swift.String?
}

extension ListEulaAcceptancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eulaAcceptances = "eulaAcceptances"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulaAcceptancesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.EulaAcceptance?].self, forKey: .eulaAcceptances)
        var eulaAcceptancesDecoded0:[NimbleClientTypes.EulaAcceptance]? = nil
        if let eulaAcceptancesContainer = eulaAcceptancesContainer {
            eulaAcceptancesDecoded0 = [NimbleClientTypes.EulaAcceptance]()
            for structure0 in eulaAcceptancesContainer {
                if let structure0 = structure0 {
                    eulaAcceptancesDecoded0?.append(structure0)
                }
            }
        }
        eulaAcceptances = eulaAcceptancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEulasInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEulasInput(eulaIds: \(Swift.String(describing: eulaIds)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEulasInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListEulasInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEulasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEulasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEulasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEulasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEulasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEulasOutputError>
}

public struct ListEulasInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEulasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListEulasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEulasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let eulaIds = input.operationInput.eulaIds {
            eulaIds.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "eulaIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListEulasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListEulasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEulasOutputError>
}

public struct ListEulasInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListEulasInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListEulasInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListEulasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/eulas"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListEulasInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListEulasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListEulasOutputError>
}

public struct ListEulasInput: Swift.Equatable {
    /// A collection of EULA IDs.
    public var eulaIds: [Swift.String]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        eulaIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eulaIds = eulaIds
        self.nextToken = nextToken
    }
}

struct ListEulasInputBody: Swift.Equatable {
}

extension ListEulasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListEulasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEulasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEulasOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEulasOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEulasOutputResponse(eulas: \(Swift.String(describing: eulas)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListEulasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEulasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eulas = output.eulas
            self.nextToken = output.nextToken
        } else {
            self.eulas = nil
            self.nextToken = nil
        }
    }
}

public struct ListEulasOutputResponse: Swift.Equatable {
    /// A collection of EULA resources.
    public var eulas: [NimbleClientTypes.Eula]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        eulas: [NimbleClientTypes.Eula]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eulas = eulas
        self.nextToken = nextToken
    }
}

struct ListEulasOutputResponseBody: Swift.Equatable {
    public let eulas: [NimbleClientTypes.Eula]?
    public let nextToken: Swift.String?
}

extension ListEulasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eulas = "eulas"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulasContainer = try containerValues.decodeIfPresent([NimbleClientTypes.Eula?].self, forKey: .eulas)
        var eulasDecoded0:[NimbleClientTypes.Eula]? = nil
        if let eulasContainer = eulasContainer {
            eulasDecoded0 = [NimbleClientTypes.Eula]()
            for structure0 in eulasContainer {
                if let structure0 = structure0 {
                    eulasDecoded0?.append(structure0)
                }
            }
        }
        eulas = eulasDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLaunchProfileMembersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLaunchProfileMembersInput(launchProfileId: \(Swift.String(describing: launchProfileId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), studioId: \(Swift.String(describing: studioId)))"}
}

extension ListLaunchProfileMembersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListLaunchProfileMembersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLaunchProfileMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLaunchProfileMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLaunchProfileMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLaunchProfileMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLaunchProfileMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLaunchProfileMembersOutputError>
}

public struct ListLaunchProfileMembersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLaunchProfileMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLaunchProfileMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLaunchProfileMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLaunchProfileMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLaunchProfileMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLaunchProfileMembersOutputError>
}

public struct ListLaunchProfileMembersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLaunchProfileMembersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListLaunchProfileMembersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLaunchProfileMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let launchProfileId = input.launchProfileId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("launchProfileId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLaunchProfileMembersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLaunchProfileMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLaunchProfileMembersOutputError>
}

public struct ListLaunchProfileMembersInput: Swift.Equatable {
    /// The launch profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        launchProfileId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.studioId = studioId
    }
}

struct ListLaunchProfileMembersInputBody: Swift.Equatable {
}

extension ListLaunchProfileMembersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLaunchProfileMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLaunchProfileMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLaunchProfileMembersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLaunchProfileMembersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLaunchProfileMembersOutputResponse(members: \(Swift.String(describing: members)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLaunchProfileMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLaunchProfileMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListLaunchProfileMembersOutputResponse: Swift.Equatable {
    /// A list of members.
    public var members: [NimbleClientTypes.LaunchProfileMembership]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        members: [NimbleClientTypes.LaunchProfileMembership]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListLaunchProfileMembersOutputResponseBody: Swift.Equatable {
    public let members: [NimbleClientTypes.LaunchProfileMembership]?
    public let nextToken: Swift.String?
}

extension ListLaunchProfileMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members = "members"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.LaunchProfileMembership?].self, forKey: .members)
        var membersDecoded0:[NimbleClientTypes.LaunchProfileMembership]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [NimbleClientTypes.LaunchProfileMembership]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLaunchProfilesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLaunchProfilesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), principalId: \(Swift.String(describing: principalId)), states: \(Swift.String(describing: states)), studioId: \(Swift.String(describing: studioId)))"}
}

extension ListLaunchProfilesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListLaunchProfilesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLaunchProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLaunchProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLaunchProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLaunchProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLaunchProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLaunchProfilesOutputError>
}

public struct ListLaunchProfilesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLaunchProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLaunchProfilesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLaunchProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let principalId = input.operationInput.principalId {
            let principalIdQueryItem = ClientRuntime.URLQueryItem(name: "principalId".urlPercentEncoding(), value: Swift.String(principalId).urlPercentEncoding())
            input.builder.withQueryItem(principalIdQueryItem)
        }
        if let states = input.operationInput.states {
            states.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLaunchProfilesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLaunchProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLaunchProfilesOutputError>
}

public struct ListLaunchProfilesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLaunchProfilesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListLaunchProfilesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLaunchProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLaunchProfilesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLaunchProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLaunchProfilesOutputError>
}

public struct ListLaunchProfilesInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The principal ID.
    public var principalId: Swift.String?
    /// A list of states.
    public var states: [Swift.String]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        states: [Swift.String]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalId = principalId
        self.states = states
        self.studioId = studioId
    }
}

struct ListLaunchProfilesInputBody: Swift.Equatable {
}

extension ListLaunchProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListLaunchProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLaunchProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLaunchProfilesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLaunchProfilesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLaunchProfilesOutputResponse(launchProfiles: \(Swift.String(describing: launchProfiles)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListLaunchProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLaunchProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfiles = output.launchProfiles
            self.nextToken = output.nextToken
        } else {
            self.launchProfiles = nil
            self.nextToken = nil
        }
    }
}

public struct ListLaunchProfilesOutputResponse: Swift.Equatable {
    /// A collection of launch profiles.
    public var launchProfiles: [NimbleClientTypes.LaunchProfile]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        launchProfiles: [NimbleClientTypes.LaunchProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.launchProfiles = launchProfiles
        self.nextToken = nextToken
    }
}

struct ListLaunchProfilesOutputResponseBody: Swift.Equatable {
    public let launchProfiles: [NimbleClientTypes.LaunchProfile]?
    public let nextToken: Swift.String?
}

extension ListLaunchProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfiles = "launchProfiles"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfilesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.LaunchProfile?].self, forKey: .launchProfiles)
        var launchProfilesDecoded0:[NimbleClientTypes.LaunchProfile]? = nil
        if let launchProfilesContainer = launchProfilesContainer {
            launchProfilesDecoded0 = [NimbleClientTypes.LaunchProfile]()
            for structure0 in launchProfilesContainer {
                if let structure0 = structure0 {
                    launchProfilesDecoded0?.append(structure0)
                }
            }
        }
        launchProfiles = launchProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStreamingImagesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStreamingImagesInput(nextToken: \(Swift.String(describing: nextToken)), owner: \(Swift.String(describing: owner)), studioId: \(Swift.String(describing: studioId)))"}
}

extension ListStreamingImagesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListStreamingImagesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamingImagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamingImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamingImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamingImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamingImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamingImagesOutputError>
}

public struct ListStreamingImagesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamingImagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamingImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamingImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let owner = input.operationInput.owner {
            let ownerQueryItem = ClientRuntime.URLQueryItem(name: "owner".urlPercentEncoding(), value: Swift.String(owner).urlPercentEncoding())
            input.builder.withQueryItem(ownerQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamingImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamingImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamingImagesOutputError>
}

public struct ListStreamingImagesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamingImagesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListStreamingImagesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamingImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListStreamingImagesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamingImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamingImagesOutputError>
}

public struct ListStreamingImagesInput: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The owner.
    public var owner: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        owner: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.owner = owner
        self.studioId = studioId
    }
}

struct ListStreamingImagesInputBody: Swift.Equatable {
}

extension ListStreamingImagesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListStreamingImagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamingImagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamingImagesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamingImagesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStreamingImagesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), streamingImages: \(Swift.String(describing: streamingImages)))"}
}

extension ListStreamingImagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStreamingImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.streamingImages = output.streamingImages
        } else {
            self.nextToken = nil
            self.streamingImages = nil
        }
    }
}

public struct ListStreamingImagesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A collection of streaming images.
    public var streamingImages: [NimbleClientTypes.StreamingImage]?

    public init (
        nextToken: Swift.String? = nil,
        streamingImages: [NimbleClientTypes.StreamingImage]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamingImages = streamingImages
    }
}

struct ListStreamingImagesOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let streamingImages: [NimbleClientTypes.StreamingImage]?
}

extension ListStreamingImagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case streamingImages = "streamingImages"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let streamingImagesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StreamingImage?].self, forKey: .streamingImages)
        var streamingImagesDecoded0:[NimbleClientTypes.StreamingImage]? = nil
        if let streamingImagesContainer = streamingImagesContainer {
            streamingImagesDecoded0 = [NimbleClientTypes.StreamingImage]()
            for structure0 in streamingImagesContainer {
                if let structure0 = structure0 {
                    streamingImagesDecoded0?.append(structure0)
                }
            }
        }
        streamingImages = streamingImagesDecoded0
    }
}

extension ListStreamingSessionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStreamingSessionsInput(createdBy: \(Swift.String(describing: createdBy)), nextToken: \(Swift.String(describing: nextToken)), ownedBy: \(Swift.String(describing: ownedBy)), sessionIds: \(Swift.String(describing: sessionIds)), studioId: \(Swift.String(describing: studioId)))"}
}

extension ListStreamingSessionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListStreamingSessionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamingSessionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamingSessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamingSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamingSessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamingSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamingSessionsOutputError>
}

public struct ListStreamingSessionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamingSessionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStreamingSessionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamingSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let createdBy = input.operationInput.createdBy {
            let createdByQueryItem = ClientRuntime.URLQueryItem(name: "createdBy".urlPercentEncoding(), value: Swift.String(createdBy).urlPercentEncoding())
            input.builder.withQueryItem(createdByQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let ownedBy = input.operationInput.ownedBy {
            let ownedByQueryItem = ClientRuntime.URLQueryItem(name: "ownedBy".urlPercentEncoding(), value: Swift.String(ownedBy).urlPercentEncoding())
            input.builder.withQueryItem(ownedByQueryItem)
        }
        if let sessionIds = input.operationInput.sessionIds {
            let sessionIdsQueryItem = ClientRuntime.URLQueryItem(name: "sessionIds".urlPercentEncoding(), value: Swift.String(sessionIds).urlPercentEncoding())
            input.builder.withQueryItem(sessionIdsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStreamingSessionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamingSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamingSessionsOutputError>
}

public struct ListStreamingSessionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStreamingSessionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListStreamingSessionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStreamingSessionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListStreamingSessionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListStreamingSessionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStreamingSessionsOutputError>
}

public struct ListStreamingSessionsInput: Swift.Equatable {
    /// The user ID of the user that created the streaming session.
    public var createdBy: Swift.String?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The user ID of the user that owns the streaming session.
    public var ownedBy: Swift.String?
    /// A collection of session IDs.
    public var sessionIds: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        createdBy: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        ownedBy: Swift.String? = nil,
        sessionIds: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.createdBy = createdBy
        self.nextToken = nextToken
        self.ownedBy = ownedBy
        self.sessionIds = sessionIds
        self.studioId = studioId
    }
}

struct ListStreamingSessionsInputBody: Swift.Equatable {
}

extension ListStreamingSessionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListStreamingSessionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamingSessionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamingSessionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamingSessionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStreamingSessionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), sessions: \(Swift.String(describing: sessions)))"}
}

extension ListStreamingSessionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStreamingSessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sessions = output.sessions
        } else {
            self.nextToken = nil
            self.sessions = nil
        }
    }
}

public struct ListStreamingSessionsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A collection of streaming sessions.
    public var sessions: [NimbleClientTypes.StreamingSession]?

    public init (
        nextToken: Swift.String? = nil,
        sessions: [NimbleClientTypes.StreamingSession]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

struct ListStreamingSessionsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let sessions: [NimbleClientTypes.StreamingSession]?
}

extension ListStreamingSessionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case sessions = "sessions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sessionsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StreamingSession?].self, forKey: .sessions)
        var sessionsDecoded0:[NimbleClientTypes.StreamingSession]? = nil
        if let sessionsContainer = sessionsContainer {
            sessionsDecoded0 = [NimbleClientTypes.StreamingSession]()
            for structure0 in sessionsContainer {
                if let structure0 = structure0 {
                    sessionsDecoded0?.append(structure0)
                }
            }
        }
        sessions = sessionsDecoded0
    }
}

extension ListStudioComponentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStudioComponentsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), states: \(Swift.String(describing: states)), studioId: \(Swift.String(describing: studioId)), types: \(Swift.String(describing: types)))"}
}

extension ListStudioComponentsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListStudioComponentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStudioComponentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStudioComponentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStudioComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStudioComponentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStudioComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStudioComponentsOutputError>
}

public struct ListStudioComponentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStudioComponentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStudioComponentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStudioComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let types = input.operationInput.types {
            types.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "types".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let states = input.operationInput.states {
            states.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStudioComponentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStudioComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStudioComponentsOutputError>
}

public struct ListStudioComponentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStudioComponentsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListStudioComponentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStudioComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListStudioComponentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListStudioComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStudioComponentsOutputError>
}

public struct ListStudioComponentsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of states.
    public var states: [Swift.String]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// The types.
    public var types: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        states: [Swift.String]? = nil,
        studioId: Swift.String? = nil,
        types: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.states = states
        self.studioId = studioId
        self.types = types
    }
}

struct ListStudioComponentsInputBody: Swift.Equatable {
}

extension ListStudioComponentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListStudioComponentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStudioComponentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStudioComponentsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStudioComponentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStudioComponentsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), studioComponents: \(Swift.String(describing: studioComponents)))"}
}

extension ListStudioComponentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStudioComponentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.studioComponents = output.studioComponents
        } else {
            self.nextToken = nil
            self.studioComponents = nil
        }
    }
}

public struct ListStudioComponentsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A collection of studio components.
    public var studioComponents: [NimbleClientTypes.StudioComponent]?

    public init (
        nextToken: Swift.String? = nil,
        studioComponents: [NimbleClientTypes.StudioComponent]? = nil
    )
    {
        self.nextToken = nextToken
        self.studioComponents = studioComponents
    }
}

struct ListStudioComponentsOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let studioComponents: [NimbleClientTypes.StudioComponent]?
}

extension ListStudioComponentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case studioComponents = "studioComponents"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let studioComponentsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioComponent?].self, forKey: .studioComponents)
        var studioComponentsDecoded0:[NimbleClientTypes.StudioComponent]? = nil
        if let studioComponentsContainer = studioComponentsContainer {
            studioComponentsDecoded0 = [NimbleClientTypes.StudioComponent]()
            for structure0 in studioComponentsContainer {
                if let structure0 = structure0 {
                    studioComponentsDecoded0?.append(structure0)
                }
            }
        }
        studioComponents = studioComponentsDecoded0
    }
}

extension ListStudioMembersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStudioMembersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), studioId: \(Swift.String(describing: studioId)))"}
}

extension ListStudioMembersInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListStudioMembersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStudioMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStudioMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStudioMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStudioMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStudioMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStudioMembersOutputError>
}

public struct ListStudioMembersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStudioMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStudioMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStudioMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStudioMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStudioMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStudioMembersOutputError>
}

public struct ListStudioMembersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStudioMembersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListStudioMembersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStudioMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/membership"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListStudioMembersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListStudioMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStudioMembersOutputError>
}

public struct ListStudioMembersInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.studioId = studioId
    }
}

struct ListStudioMembersInputBody: Swift.Equatable {
}

extension ListStudioMembersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListStudioMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStudioMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStudioMembersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStudioMembersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStudioMembersOutputResponse(members: \(Swift.String(describing: members)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListStudioMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStudioMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListStudioMembersOutputResponse: Swift.Equatable {
    /// A list of members.
    public var members: [NimbleClientTypes.StudioMembership]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        members: [NimbleClientTypes.StudioMembership]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListStudioMembersOutputResponseBody: Swift.Equatable {
    public let members: [NimbleClientTypes.StudioMembership]?
    public let nextToken: Swift.String?
}

extension ListStudioMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members = "members"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioMembership?].self, forKey: .members)
        var membersDecoded0:[NimbleClientTypes.StudioMembership]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [NimbleClientTypes.StudioMembership]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStudiosInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStudiosInput(nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListStudiosInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListStudiosInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStudiosInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStudiosInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStudiosOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStudiosInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStudiosOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStudiosOutputError>
}

public struct ListStudiosInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStudiosInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStudiosInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStudiosOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStudiosInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStudiosOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStudiosOutputError>
}

public struct ListStudiosInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStudiosInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListStudiosInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStudiosOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListStudiosInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListStudiosOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStudiosOutputError>
}

public struct ListStudiosInput: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListStudiosInputBody: Swift.Equatable {
}

extension ListStudiosInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListStudiosOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStudiosOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStudiosOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStudiosOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStudiosOutputResponse(nextToken: \(Swift.String(describing: nextToken)), studios: \(Swift.String(describing: studios)))"}
}

extension ListStudiosOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStudiosOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.studios = output.studios
        } else {
            self.nextToken = nil
            self.studios = nil
        }
    }
}

public struct ListStudiosOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A collection of studios.
    public var studios: [NimbleClientTypes.Studio]?

    public init (
        nextToken: Swift.String? = nil,
        studios: [NimbleClientTypes.Studio]? = nil
    )
    {
        self.nextToken = nextToken
        self.studios = studios
    }
}

struct ListStudiosOutputResponseBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let studios: [NimbleClientTypes.Studio]?
}

extension ListStudiosOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case studios = "studios"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let studiosContainer = try containerValues.decodeIfPresent([NimbleClientTypes.Studio?].self, forKey: .studios)
        var studiosDecoded0:[NimbleClientTypes.Studio]? = nil
        if let studiosContainer = studiosContainer {
            studiosDecoded0 = [NimbleClientTypes.Studio]()
            for structure0 in studiosContainer {
                if let structure0 = structure0 {
                    studiosDecoded0?.append(structure0)
                }
            }
        }
        studios = studiosDecoded0
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the target resource for tagging operations.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A collection of labels, in the form of key:value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NimbleClientTypes.NewLaunchProfileMember: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case persona = "persona"
        case principalId = "principalId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let persona = persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let personaDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfilePersona.self, forKey: .persona)
        persona = personaDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension NimbleClientTypes.NewLaunchProfileMember: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NewLaunchProfileMember(persona: \(Swift.String(describing: persona)), principalId: \(Swift.String(describing: principalId)))"}
}

extension NimbleClientTypes {
    public struct NewLaunchProfileMember: Swift.Equatable {
        /// The persona.
        /// This member is required.
        public var persona: NimbleClientTypes.LaunchProfilePersona?
        /// The principal ID.
        /// This member is required.
        public var principalId: Swift.String?

        public init (
            persona: NimbleClientTypes.LaunchProfilePersona? = nil,
            principalId: Swift.String? = nil
        )
        {
            self.persona = persona
            self.principalId = principalId
        }
    }

}

extension NimbleClientTypes.NewStudioMember: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case persona = "persona"
        case principalId = "principalId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let persona = persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let personaDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioPersona.self, forKey: .persona)
        persona = personaDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension NimbleClientTypes.NewStudioMember: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NewStudioMember(persona: \(Swift.String(describing: persona)), principalId: \(Swift.String(describing: principalId)))"}
}

extension NimbleClientTypes {
    public struct NewStudioMember: Swift.Equatable {
        /// The persona.
        /// This member is required.
        public var persona: NimbleClientTypes.StudioPersona?
        /// The principal ID.
        /// This member is required.
        public var principalId: Swift.String?

        public init (
            persona: NimbleClientTypes.StudioPersona? = nil,
            principalId: Swift.String? = nil
        )
        {
            self.persona = persona
            self.principalId = principalId
        }
    }

}

public struct PutLaunchProfileMembersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLaunchProfileMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLaunchProfileMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLaunchProfileMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLaunchProfileMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLaunchProfileMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLaunchProfileMembersOutputError>
}

extension PutLaunchProfileMembersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutLaunchProfileMembersInput(clientToken: \(Swift.String(describing: clientToken)), identityStoreId: \(Swift.String(describing: identityStoreId)), launchProfileId: \(Swift.String(describing: launchProfileId)), members: \(Swift.String(describing: members)), studioId: \(Swift.String(describing: studioId)))"}
}

extension PutLaunchProfileMembersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "identityStoreId"
        case members = "members"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for newlaunchprofilememberlist0 in members {
                try membersContainer.encode(newlaunchprofilememberlist0)
            }
        }
    }
}

public struct PutLaunchProfileMembersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLaunchProfileMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLaunchProfileMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLaunchProfileMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLaunchProfileMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLaunchProfileMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLaunchProfileMembersOutputError>
}

public struct PutLaunchProfileMembersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLaunchProfileMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLaunchProfileMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLaunchProfileMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLaunchProfileMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLaunchProfileMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLaunchProfileMembersOutputError>
}

public struct PutLaunchProfileMembersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLaunchProfileMembersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: PutLaunchProfileMembersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLaunchProfileMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let launchProfileId = input.launchProfileId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("launchProfileId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutLaunchProfileMembersInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutLaunchProfileMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLaunchProfileMembersOutputError>
}

/// Information about a launch profile membership.
public struct PutLaunchProfileMembersInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The ID of the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The launch profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// A list of members.
    /// This member is required.
    public var members: [NimbleClientTypes.NewLaunchProfileMember]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        members: [NimbleClientTypes.NewLaunchProfileMember]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.identityStoreId = identityStoreId
        self.launchProfileId = launchProfileId
        self.members = members
        self.studioId = studioId
    }
}

struct PutLaunchProfileMembersInputBody: Swift.Equatable {
    public let identityStoreId: Swift.String?
    public let members: [NimbleClientTypes.NewLaunchProfileMember]?
}

extension PutLaunchProfileMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "identityStoreId"
        case members = "members"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.NewLaunchProfileMember?].self, forKey: .members)
        var membersDecoded0:[NimbleClientTypes.NewLaunchProfileMember]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [NimbleClientTypes.NewLaunchProfileMember]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
    }
}

extension PutLaunchProfileMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLaunchProfileMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLaunchProfileMembersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLaunchProfileMembersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutLaunchProfileMembersOutputResponse()"}
}

extension PutLaunchProfileMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutLaunchProfileMembersOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutLaunchProfileMembersOutputResponseBody: Swift.Equatable {
}

extension PutLaunchProfileMembersOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutStudioMembersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutStudioMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutStudioMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutStudioMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutStudioMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutStudioMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutStudioMembersOutputError>
}

extension PutStudioMembersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutStudioMembersInput(clientToken: \(Swift.String(describing: clientToken)), identityStoreId: \(Swift.String(describing: identityStoreId)), members: \(Swift.String(describing: members)), studioId: \(Swift.String(describing: studioId)))"}
}

extension PutStudioMembersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "identityStoreId"
        case members = "members"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for newstudiomemberlist0 in members {
                try membersContainer.encode(newstudiomemberlist0)
            }
        }
    }
}

public struct PutStudioMembersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutStudioMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutStudioMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutStudioMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutStudioMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutStudioMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutStudioMembersOutputError>
}

public struct PutStudioMembersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutStudioMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutStudioMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutStudioMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutStudioMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutStudioMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutStudioMembersOutputError>
}

public struct PutStudioMembersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutStudioMembersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: PutStudioMembersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutStudioMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/membership"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutStudioMembersInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutStudioMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutStudioMembersOutputError>
}

/// A launch profile membership collection.
public struct PutStudioMembersInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The ID of the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// A list of members.
    /// This member is required.
    public var members: [NimbleClientTypes.NewStudioMember]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        members: [NimbleClientTypes.NewStudioMember]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.identityStoreId = identityStoreId
        self.members = members
        self.studioId = studioId
    }
}

struct PutStudioMembersInputBody: Swift.Equatable {
    public let identityStoreId: Swift.String?
    public let members: [NimbleClientTypes.NewStudioMember]?
}

extension PutStudioMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "identityStoreId"
        case members = "members"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.NewStudioMember?].self, forKey: .members)
        var membersDecoded0:[NimbleClientTypes.NewStudioMember]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [NimbleClientTypes.NewStudioMember]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
    }
}

extension PutStudioMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutStudioMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutStudioMembersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutStudioMembersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutStudioMembersOutputResponse()"}
}

extension PutStudioMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutStudioMembersOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutStudioMembersOutputResponseBody: Swift.Equatable {
}

extension PutStudioMembersOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(code: \(Swift.String(describing: code)), context: \(Swift.String(describing: context)), message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A more specific error code.
    public var code: Swift.String?
    /// The exception context.
    public var context: [Swift.String:Swift.String]?
    /// A human-readable description of the error.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let context: [Swift.String:Swift.String]?
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case context = "context"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in contextContainer {
                if let __string0 = __string0 {
                    contextDecoded0?[key0] = __string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NimbleClientTypes.ScriptParameterKeyValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension NimbleClientTypes.ScriptParameterKeyValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScriptParameterKeyValue(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension NimbleClientTypes {
    /// A parameter for a studio component script, in the form of a key:value pair.
    public struct ScriptParameterKeyValue: Swift.Equatable {
        /// A script parameter key.
        public var key: Swift.String?
        /// A script parameter value.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(code: \(Swift.String(describing: code)), context: \(Swift.String(describing: context)), message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A more specific error code.
    public var code: Swift.String?
    /// The exception context.
    public var context: [Swift.String:Swift.String]?
    /// A human-readable description of the error.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let context: [Swift.String:Swift.String]?
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case context = "context"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in contextContainer {
                if let __string0 = __string0 {
                    contextDecoded0?[key0] = __string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NimbleClientTypes.SharedFileSystemConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "endpoint"
        case fileSystemId = "fileSystemId"
        case linuxMountPoint = "linuxMountPoint"
        case shareName = "shareName"
        case windowsMountDrive = "windowsMountDrive"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let fileSystemId = fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let linuxMountPoint = linuxMountPoint {
            try encodeContainer.encode(linuxMountPoint, forKey: .linuxMountPoint)
        }
        if let shareName = shareName {
            try encodeContainer.encode(shareName, forKey: .shareName)
        }
        if let windowsMountDrive = windowsMountDrive {
            try encodeContainer.encode(windowsMountDrive, forKey: .windowsMountDrive)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let linuxMountPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linuxMountPoint)
        linuxMountPoint = linuxMountPointDecoded
        let shareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareName)
        shareName = shareNameDecoded
        let windowsMountDriveDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowsMountDrive)
        windowsMountDrive = windowsMountDriveDecoded
    }
}

extension NimbleClientTypes.SharedFileSystemConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SharedFileSystemConfiguration(endpoint: \(Swift.String(describing: endpoint)), fileSystemId: \(Swift.String(describing: fileSystemId)), linuxMountPoint: \(Swift.String(describing: linuxMountPoint)), shareName: \(Swift.String(describing: shareName)), windowsMountDrive: \(Swift.String(describing: windowsMountDrive)))"}
}

extension NimbleClientTypes {
    /// The configuration for a shared file storage system that is associated with a studio resource.
    public struct SharedFileSystemConfiguration: Swift.Equatable {
        /// The endpoint of the shared file system that is accessed by the studio component resource.
        public var endpoint: Swift.String?
        /// The unique identifier for a file system.
        public var fileSystemId: Swift.String?
        /// The mount location for a shared file system on a Linux virtual workstation.
        public var linuxMountPoint: Swift.String?
        /// The name of the file share.
        public var shareName: Swift.String?
        /// The mount location for a shared file system on a Windows virtual workstation.
        public var windowsMountDrive: Swift.String?

        public init (
            endpoint: Swift.String? = nil,
            fileSystemId: Swift.String? = nil,
            linuxMountPoint: Swift.String? = nil,
            shareName: Swift.String? = nil,
            windowsMountDrive: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
            self.fileSystemId = fileSystemId
            self.linuxMountPoint = linuxMountPoint
            self.shareName = shareName
            self.windowsMountDrive = windowsMountDrive
        }
    }

}

extension StartStudioSSOConfigurationRepairInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartStudioSSOConfigurationRepairInput(clientToken: \(Swift.String(describing: clientToken)), studioId: \(Swift.String(describing: studioId)))"}
}

extension StartStudioSSOConfigurationRepairInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct StartStudioSSOConfigurationRepairInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartStudioSSOConfigurationRepairInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartStudioSSOConfigurationRepairInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartStudioSSOConfigurationRepairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartStudioSSOConfigurationRepairInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartStudioSSOConfigurationRepairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartStudioSSOConfigurationRepairOutputError>
}

public struct StartStudioSSOConfigurationRepairInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartStudioSSOConfigurationRepairInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartStudioSSOConfigurationRepairInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartStudioSSOConfigurationRepairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartStudioSSOConfigurationRepairInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartStudioSSOConfigurationRepairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartStudioSSOConfigurationRepairOutputError>
}

public struct StartStudioSSOConfigurationRepairInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartStudioSSOConfigurationRepairInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: StartStudioSSOConfigurationRepairInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartStudioSSOConfigurationRepairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/sso-configuration"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartStudioSSOConfigurationRepairInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartStudioSSOConfigurationRepairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartStudioSSOConfigurationRepairOutputError>
}

public struct StartStudioSSOConfigurationRepairInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.studioId = studioId
    }
}

struct StartStudioSSOConfigurationRepairInputBody: Swift.Equatable {
}

extension StartStudioSSOConfigurationRepairInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StartStudioSSOConfigurationRepairOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartStudioSSOConfigurationRepairOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartStudioSSOConfigurationRepairOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartStudioSSOConfigurationRepairOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartStudioSSOConfigurationRepairOutputResponse(studio: \(Swift.String(describing: studio)))"}
}

extension StartStudioSSOConfigurationRepairOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartStudioSSOConfigurationRepairOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

public struct StartStudioSSOConfigurationRepairOutputResponse: Swift.Equatable {
    /// Information about a studio.
    public var studio: NimbleClientTypes.Studio?

    public init (
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct StartStudioSSOConfigurationRepairOutputResponseBody: Swift.Equatable {
    public let studio: NimbleClientTypes.Studio?
}

extension StartStudioSSOConfigurationRepairOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studio = "studio"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

extension NimbleClientTypes.StreamConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clipboardMode = "clipboardMode"
        case ec2InstanceTypes = "ec2InstanceTypes"
        case maxSessionLengthInMinutes = "maxSessionLengthInMinutes"
        case streamingImageIds = "streamingImageIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clipboardMode = clipboardMode {
            try encodeContainer.encode(clipboardMode.rawValue, forKey: .clipboardMode)
        }
        if let ec2InstanceTypes = ec2InstanceTypes {
            var ec2InstanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceTypes)
            for streaminginstancetypelist0 in ec2InstanceTypes {
                try ec2InstanceTypesContainer.encode(streaminginstancetypelist0.rawValue)
            }
        }
        if let maxSessionLengthInMinutes = maxSessionLengthInMinutes {
            try encodeContainer.encode(maxSessionLengthInMinutes, forKey: .maxSessionLengthInMinutes)
        }
        if let streamingImageIds = streamingImageIds {
            var streamingImageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .streamingImageIds)
            for streamingimageidlist0 in streamingImageIds {
                try streamingImageIdsContainer.encode(streamingimageidlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clipboardModeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingClipboardMode.self, forKey: .clipboardMode)
        clipboardMode = clipboardModeDecoded
        let ec2InstanceTypesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StreamingInstanceType?].self, forKey: .ec2InstanceTypes)
        var ec2InstanceTypesDecoded0:[NimbleClientTypes.StreamingInstanceType]? = nil
        if let ec2InstanceTypesContainer = ec2InstanceTypesContainer {
            ec2InstanceTypesDecoded0 = [NimbleClientTypes.StreamingInstanceType]()
            for string0 in ec2InstanceTypesContainer {
                if let string0 = string0 {
                    ec2InstanceTypesDecoded0?.append(string0)
                }
            }
        }
        ec2InstanceTypes = ec2InstanceTypesDecoded0
        let maxSessionLengthInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSessionLengthInMinutes)
        maxSessionLengthInMinutes = maxSessionLengthInMinutesDecoded
        let streamingImageIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .streamingImageIds)
        var streamingImageIdsDecoded0:[Swift.String]? = nil
        if let streamingImageIdsContainer = streamingImageIdsContainer {
            streamingImageIdsDecoded0 = [Swift.String]()
            for string0 in streamingImageIdsContainer {
                if let string0 = string0 {
                    streamingImageIdsDecoded0?.append(string0)
                }
            }
        }
        streamingImageIds = streamingImageIdsDecoded0
    }
}

extension NimbleClientTypes.StreamConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamConfiguration(clipboardMode: \(Swift.String(describing: clipboardMode)), ec2InstanceTypes: \(Swift.String(describing: ec2InstanceTypes)), maxSessionLengthInMinutes: \(Swift.String(describing: maxSessionLengthInMinutes)), streamingImageIds: \(Swift.String(describing: streamingImageIds)))"}
}

extension NimbleClientTypes {
    /// A configuration for a streaming session.
    public struct StreamConfiguration: Swift.Equatable {
        /// Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.
        public var clipboardMode: NimbleClientTypes.StreamingClipboardMode?
        /// The EC2 instance types that users can select from when launching a streaming session with this launch profile.
        public var ec2InstanceTypes: [NimbleClientTypes.StreamingInstanceType]?
        /// The length of time, in minutes, that a streaming session can run. After this point, Nimble Studio automatically terminates the session.
        public var maxSessionLengthInMinutes: Swift.Int?
        /// The streaming images that users can select from when launching a streaming session with this launch profile.
        public var streamingImageIds: [Swift.String]?

        public init (
            clipboardMode: NimbleClientTypes.StreamingClipboardMode? = nil,
            ec2InstanceTypes: [NimbleClientTypes.StreamingInstanceType]? = nil,
            maxSessionLengthInMinutes: Swift.Int? = nil,
            streamingImageIds: [Swift.String]? = nil
        )
        {
            self.clipboardMode = clipboardMode
            self.ec2InstanceTypes = ec2InstanceTypes
            self.maxSessionLengthInMinutes = maxSessionLengthInMinutes
            self.streamingImageIds = streamingImageIds
        }
    }

}

extension NimbleClientTypes.StreamConfigurationCreate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clipboardMode = "clipboardMode"
        case ec2InstanceTypes = "ec2InstanceTypes"
        case maxSessionLengthInMinutes = "maxSessionLengthInMinutes"
        case streamingImageIds = "streamingImageIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clipboardMode = clipboardMode {
            try encodeContainer.encode(clipboardMode.rawValue, forKey: .clipboardMode)
        }
        if let ec2InstanceTypes = ec2InstanceTypes {
            var ec2InstanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceTypes)
            for streaminginstancetypelist0 in ec2InstanceTypes {
                try ec2InstanceTypesContainer.encode(streaminginstancetypelist0.rawValue)
            }
        }
        if let maxSessionLengthInMinutes = maxSessionLengthInMinutes {
            try encodeContainer.encode(maxSessionLengthInMinutes, forKey: .maxSessionLengthInMinutes)
        }
        if let streamingImageIds = streamingImageIds {
            var streamingImageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .streamingImageIds)
            for streamingimageidlist0 in streamingImageIds {
                try streamingImageIdsContainer.encode(streamingimageidlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clipboardModeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingClipboardMode.self, forKey: .clipboardMode)
        clipboardMode = clipboardModeDecoded
        let ec2InstanceTypesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StreamingInstanceType?].self, forKey: .ec2InstanceTypes)
        var ec2InstanceTypesDecoded0:[NimbleClientTypes.StreamingInstanceType]? = nil
        if let ec2InstanceTypesContainer = ec2InstanceTypesContainer {
            ec2InstanceTypesDecoded0 = [NimbleClientTypes.StreamingInstanceType]()
            for string0 in ec2InstanceTypesContainer {
                if let string0 = string0 {
                    ec2InstanceTypesDecoded0?.append(string0)
                }
            }
        }
        ec2InstanceTypes = ec2InstanceTypesDecoded0
        let maxSessionLengthInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSessionLengthInMinutes)
        maxSessionLengthInMinutes = maxSessionLengthInMinutesDecoded
        let streamingImageIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .streamingImageIds)
        var streamingImageIdsDecoded0:[Swift.String]? = nil
        if let streamingImageIdsContainer = streamingImageIdsContainer {
            streamingImageIdsDecoded0 = [Swift.String]()
            for string0 in streamingImageIdsContainer {
                if let string0 = string0 {
                    streamingImageIdsDecoded0?.append(string0)
                }
            }
        }
        streamingImageIds = streamingImageIdsDecoded0
    }
}

extension NimbleClientTypes.StreamConfigurationCreate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamConfigurationCreate(clipboardMode: \(Swift.String(describing: clipboardMode)), ec2InstanceTypes: \(Swift.String(describing: ec2InstanceTypes)), maxSessionLengthInMinutes: \(Swift.String(describing: maxSessionLengthInMinutes)), streamingImageIds: \(Swift.String(describing: streamingImageIds)))"}
}

extension NimbleClientTypes {
    public struct StreamConfigurationCreate: Swift.Equatable {
        /// Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.
        /// This member is required.
        public var clipboardMode: NimbleClientTypes.StreamingClipboardMode?
        /// The EC2 instance types that users can select from when launching a streaming session with this launch profile.
        /// This member is required.
        public var ec2InstanceTypes: [NimbleClientTypes.StreamingInstanceType]?
        /// The length of time, in minutes, that a streaming session can run. After this point, Nimble Studio automatically terminates the session.
        public var maxSessionLengthInMinutes: Swift.Int?
        /// The streaming images that users can select from when launching a streaming session with this launch profile.
        /// This member is required.
        public var streamingImageIds: [Swift.String]?

        public init (
            clipboardMode: NimbleClientTypes.StreamingClipboardMode? = nil,
            ec2InstanceTypes: [NimbleClientTypes.StreamingInstanceType]? = nil,
            maxSessionLengthInMinutes: Swift.Int? = nil,
            streamingImageIds: [Swift.String]? = nil
        )
        {
            self.clipboardMode = clipboardMode
            self.ec2InstanceTypes = ec2InstanceTypes
            self.maxSessionLengthInMinutes = maxSessionLengthInMinutes
            self.streamingImageIds = streamingImageIds
        }
    }

}

extension NimbleClientTypes {
    public enum StreamingClipboardMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingClipboardMode] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingClipboardMode(rawValue: rawValue) ?? StreamingClipboardMode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.StreamingImage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case description = "description"
        case ec2ImageId = "ec2ImageId"
        case encryptionConfiguration = "encryptionConfiguration"
        case eulaIds = "eulaIds"
        case name = "name"
        case owner = "owner"
        case platform = "platform"
        case state = "state"
        case statusCode = "statusCode"
        case statusMessage = "statusMessage"
        case streamingImageId = "streamingImageId"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2ImageId = ec2ImageId {
            try encodeContainer.encode(ec2ImageId, forKey: .ec2ImageId)
        }
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let eulaIds = eulaIds {
            var eulaIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eulaIds)
            for eulaidlist0 in eulaIds {
                try eulaIdsContainer.encode(eulaidlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let streamingImageId = streamingImageId {
            try encodeContainer.encode(streamingImageId, forKey: .streamingImageId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2ImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2ImageId)
        ec2ImageId = ec2ImageIdDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImageEncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let eulaIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eulaIds)
        var eulaIdsDecoded0:[Swift.String]? = nil
        if let eulaIdsContainer = eulaIdsContainer {
            eulaIdsDecoded0 = [Swift.String]()
            for string0 in eulaIdsContainer {
                if let string0 = string0 {
                    eulaIdsDecoded0?.append(string0)
                }
            }
        }
        eulaIds = eulaIdsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImageState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImageStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let streamingImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingImageId)
        streamingImageId = streamingImageIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NimbleClientTypes.StreamingImage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingImage(arn: \(Swift.String(describing: arn)), description: \(Swift.String(describing: description)), ec2ImageId: \(Swift.String(describing: ec2ImageId)), encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), eulaIds: \(Swift.String(describing: eulaIds)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), platform: \(Swift.String(describing: platform)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), streamingImageId: \(Swift.String(describing: streamingImageId)), tags: \(Swift.String(describing: tags)))"}
}

extension NimbleClientTypes {
    public struct StreamingImage: Swift.Equatable {
        /// The ARN of the resource.
        public var arn: Swift.String?
        /// A human-readable description of the streaming image.
        public var description: Swift.String?
        /// The ID of an EC2 machine image with which to create the streaming image.
        public var ec2ImageId: Swift.String?
        /// The encryption configuration.
        public var encryptionConfiguration: NimbleClientTypes.StreamingImageEncryptionConfiguration?
        /// The list of EULAs that must be accepted before a Streaming Session can be started using this streaming image.
        public var eulaIds: [Swift.String]?
        /// A friendly name for a streaming image resource.
        public var name: Swift.String?
        /// The owner of the streaming image, either the studioId that contains the streaming image, or 'amazon' for images that are provided by Amazon Nimble Studio.
        public var owner: Swift.String?
        /// The platform of the streaming image, either WINDOWS or LINUX.
        public var platform: Swift.String?
        /// The current state.
        public var state: NimbleClientTypes.StreamingImageState?
        /// The status code.
        public var statusCode: NimbleClientTypes.StreamingImageStatusCode?
        /// The status message for the streaming image.
        public var statusMessage: Swift.String?
        /// The ID of the streaming image.
        public var streamingImageId: Swift.String?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            ec2ImageId: Swift.String? = nil,
            encryptionConfiguration: NimbleClientTypes.StreamingImageEncryptionConfiguration? = nil,
            eulaIds: [Swift.String]? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            platform: Swift.String? = nil,
            state: NimbleClientTypes.StreamingImageState? = nil,
            statusCode: NimbleClientTypes.StreamingImageStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            streamingImageId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.ec2ImageId = ec2ImageId
            self.encryptionConfiguration = encryptionConfiguration
            self.eulaIds = eulaIds
            self.name = name
            self.owner = owner
            self.platform = platform
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.streamingImageId = streamingImageId
            self.tags = tags
        }
    }

}

extension NimbleClientTypes.StreamingImageEncryptionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyArn = "keyArn"
        case keyType = "keyType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyArn = keyArn {
            try encodeContainer.encode(keyArn, forKey: .keyArn)
        }
        if let keyType = keyType {
            try encodeContainer.encode(keyType.rawValue, forKey: .keyType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImageEncryptionConfigurationKeyType.self, forKey: .keyType)
        keyType = keyTypeDecoded
    }
}

extension NimbleClientTypes.StreamingImageEncryptionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingImageEncryptionConfiguration(keyArn: \(Swift.String(describing: keyArn)), keyType: \(Swift.String(describing: keyType)))"}
}

extension NimbleClientTypes {
    public struct StreamingImageEncryptionConfiguration: Swift.Equatable {
        /// The ARN for a KMS key that is used to encrypt studio data.
        public var keyArn: Swift.String?
        /// The type of KMS key that is used to encrypt studio data.
        /// This member is required.
        public var keyType: NimbleClientTypes.StreamingImageEncryptionConfigurationKeyType?

        public init (
            keyArn: Swift.String? = nil,
            keyType: NimbleClientTypes.StreamingImageEncryptionConfigurationKeyType? = nil
        )
        {
            self.keyArn = keyArn
            self.keyType = keyType
        }
    }

}

extension NimbleClientTypes {
    ///
    public enum StreamingImageEncryptionConfigurationKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customerManagedKey
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingImageEncryptionConfigurationKeyType] {
            return [
                .customerManagedKey,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customerManagedKey: return "CUSTOMER_MANAGED_KEY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingImageEncryptionConfigurationKeyType(rawValue: rawValue) ?? StreamingImageEncryptionConfigurationKeyType.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum StreamingImageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingImageState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingImageState(rawValue: rawValue) ?? StreamingImageState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    /// The status code.
    public enum StreamingImageStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalError
        case streamingImageCreateInProgress
        case streamingImageDeleted
        case streamingImageDeleteInProgress
        case streamingImageReady
        case streamingImageUpdateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingImageStatusCode] {
            return [
                .internalError,
                .streamingImageCreateInProgress,
                .streamingImageDeleted,
                .streamingImageDeleteInProgress,
                .streamingImageReady,
                .streamingImageUpdateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "INTERNAL_ERROR"
            case .streamingImageCreateInProgress: return "STREAMING_IMAGE_CREATE_IN_PROGRESS"
            case .streamingImageDeleted: return "STREAMING_IMAGE_DELETED"
            case .streamingImageDeleteInProgress: return "STREAMING_IMAGE_DELETE_IN_PROGRESS"
            case .streamingImageReady: return "STREAMING_IMAGE_READY"
            case .streamingImageUpdateInProgress: return "STREAMING_IMAGE_UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingImageStatusCode(rawValue: rawValue) ?? StreamingImageStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum StreamingInstanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case g4dn12xlarge
        case g4dn16xlarge
        case g4dn2xlarge
        case g4dn4xlarge
        case g4dn8xlarge
        case g4dnXlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingInstanceType] {
            return [
                .g4dn12xlarge,
                .g4dn16xlarge,
                .g4dn2xlarge,
                .g4dn4xlarge,
                .g4dn8xlarge,
                .g4dnXlarge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .g4dn12xlarge: return "g4dn.12xlarge"
            case .g4dn16xlarge: return "g4dn.16xlarge"
            case .g4dn2xlarge: return "g4dn.2xlarge"
            case .g4dn4xlarge: return "g4dn.4xlarge"
            case .g4dn8xlarge: return "g4dn.8xlarge"
            case .g4dnXlarge: return "g4dn.xlarge"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingInstanceType(rawValue: rawValue) ?? StreamingInstanceType.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.StreamingSession: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case createdBy = "createdBy"
        case ec2InstanceType = "ec2InstanceType"
        case launchProfileId = "launchProfileId"
        case ownedBy = "ownedBy"
        case sessionId = "sessionId"
        case state = "state"
        case statusCode = "statusCode"
        case statusMessage = "statusMessage"
        case streamingImageId = "streamingImageId"
        case tags = "tags"
        case terminateAt = "terminateAt"
        case updatedAt = "updatedAt"
        case updatedBy = "updatedBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let ec2InstanceType = ec2InstanceType {
            try encodeContainer.encode(ec2InstanceType, forKey: .ec2InstanceType)
        }
        if let launchProfileId = launchProfileId {
            try encodeContainer.encode(launchProfileId, forKey: .launchProfileId)
        }
        if let ownedBy = ownedBy {
            try encodeContainer.encode(ownedBy, forKey: .ownedBy)
        }
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let streamingImageId = streamingImageId {
            try encodeContainer.encode(streamingImageId, forKey: .streamingImageId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let terminateAt = terminateAt {
            try encodeContainer.encode(terminateAt.timeIntervalSince1970, forKey: .terminateAt)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let updatedBy = updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let ec2InstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceType)
        ec2InstanceType = ec2InstanceTypeDecoded
        let launchProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileId)
        launchProfileId = launchProfileIdDecoded
        let ownedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownedBy)
        ownedBy = ownedByDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let streamingImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingImageId)
        streamingImageId = streamingImageIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let terminateAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .terminateAt)
        terminateAt = terminateAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension NimbleClientTypes.StreamingSession: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingSession(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), ec2InstanceType: \(Swift.String(describing: ec2InstanceType)), launchProfileId: \(Swift.String(describing: launchProfileId)), ownedBy: \(Swift.String(describing: ownedBy)), sessionId: \(Swift.String(describing: sessionId)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), streamingImageId: \(Swift.String(describing: streamingImageId)), tags: \(Swift.String(describing: tags)), terminateAt: \(Swift.String(describing: terminateAt)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)))"}
}

extension NimbleClientTypes {
    public struct StreamingSession: Swift.Equatable {
        /// The ARN of the resource.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The user ID of the user that created the streaming session.
        public var createdBy: Swift.String?
        /// The EC2 Instance type used for the streaming session.
        public var ec2InstanceType: Swift.String?
        /// The ID of the launch profile used to control access from the streaming session.
        public var launchProfileId: Swift.String?
        /// The user ID of the user that owns the streaming session.
        public var ownedBy: Swift.String?
        /// The session ID.
        public var sessionId: Swift.String?
        /// The current state.
        public var state: NimbleClientTypes.StreamingSessionState?
        /// The status code.
        public var statusCode: NimbleClientTypes.StreamingSessionStatusCode?
        /// The status message for the streaming session.
        public var statusMessage: Swift.String?
        /// The ID of the streaming image.
        public var streamingImageId: Swift.String?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The time the streaming session will automatically terminate if not terminated by the user.
        public var terminateAt: ClientRuntime.Date?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user ID of the user that most recently updated the resource.
        public var updatedBy: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            ec2InstanceType: Swift.String? = nil,
            launchProfileId: Swift.String? = nil,
            ownedBy: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            state: NimbleClientTypes.StreamingSessionState? = nil,
            statusCode: NimbleClientTypes.StreamingSessionStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            streamingImageId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            terminateAt: ClientRuntime.Date? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.ec2InstanceType = ec2InstanceType
            self.launchProfileId = launchProfileId
            self.ownedBy = ownedBy
            self.sessionId = sessionId
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.streamingImageId = streamingImageId
            self.tags = tags
            self.terminateAt = terminateAt
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension NimbleClientTypes {
    /// The streaming session state.
    public enum StreamingSessionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingSessionState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingSessionState(rawValue: rawValue) ?? StreamingSessionState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum StreamingSessionStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activeDirectoryDomainJoinError
        case decryptStreamingImageError
        case initializationScriptError
        case insufficientCapacity
        case internalError
        case networkConnectionError
        case networkInterfaceError
        case streamingSessionCreateInProgress
        case streamingSessionDeleted
        case streamingSessionDeleteInProgress
        case streamingSessionReady
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingSessionStatusCode] {
            return [
                .activeDirectoryDomainJoinError,
                .decryptStreamingImageError,
                .initializationScriptError,
                .insufficientCapacity,
                .internalError,
                .networkConnectionError,
                .networkInterfaceError,
                .streamingSessionCreateInProgress,
                .streamingSessionDeleted,
                .streamingSessionDeleteInProgress,
                .streamingSessionReady,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activeDirectoryDomainJoinError: return "ACTIVE_DIRECTORY_DOMAIN_JOIN_ERROR"
            case .decryptStreamingImageError: return "DECRYPT_STREAMING_IMAGE_ERROR"
            case .initializationScriptError: return "INITIALIZATION_SCRIPT_ERROR"
            case .insufficientCapacity: return "INSUFFICIENT_CAPACITY"
            case .internalError: return "INTERNAL_ERROR"
            case .networkConnectionError: return "NETWORK_CONNECTION_ERROR"
            case .networkInterfaceError: return "NETWORK_INTERFACE_ERROR"
            case .streamingSessionCreateInProgress: return "STREAMING_SESSION_CREATE_IN_PROGRESS"
            case .streamingSessionDeleted: return "STREAMING_SESSION_DELETED"
            case .streamingSessionDeleteInProgress: return "STREAMING_SESSION_DELETE_IN_PROGRESS"
            case .streamingSessionReady: return "STREAMING_SESSION_READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingSessionStatusCode(rawValue: rawValue) ?? StreamingSessionStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.StreamingSessionStream: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "createdAt"
        case createdBy = "createdBy"
        case expiresAt = "expiresAt"
        case ownedBy = "ownedBy"
        case state = "state"
        case statusCode = "statusCode"
        case streamId = "streamId"
        case url = "url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let expiresAt = expiresAt {
            try encodeContainer.encode(expiresAt.timeIntervalSince1970, forKey: .expiresAt)
        }
        if let ownedBy = ownedBy {
            try encodeContainer.encode(ownedBy, forKey: .ownedBy)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let streamId = streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let expiresAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expiresAt)
        expiresAt = expiresAtDecoded
        let ownedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownedBy)
        ownedBy = ownedByDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionStreamState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionStreamStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension NimbleClientTypes.StreamingSessionStream: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingSessionStream(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), expiresAt: \(Swift.String(describing: expiresAt)), ownedBy: \(Swift.String(describing: ownedBy)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), streamId: \(Swift.String(describing: streamId)), url: \(Swift.String(describing: url)))"}
}

extension NimbleClientTypes {
    public struct StreamingSessionStream: Swift.Equatable {
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The user ID of the user that created the streaming session stream.
        public var createdBy: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource expires.
        public var expiresAt: ClientRuntime.Date?
        /// The user ID of the user that owns the streaming session.
        public var ownedBy: Swift.String?
        /// The current state.
        public var state: NimbleClientTypes.StreamingSessionStreamState?
        /// The streaming session stream status code.
        public var statusCode: NimbleClientTypes.StreamingSessionStreamStatusCode?
        /// The stream ID.
        public var streamId: Swift.String?
        /// The URL to connect to this stream using the DCV client.
        public var url: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            expiresAt: ClientRuntime.Date? = nil,
            ownedBy: Swift.String? = nil,
            state: NimbleClientTypes.StreamingSessionStreamState? = nil,
            statusCode: NimbleClientTypes.StreamingSessionStreamStatusCode? = nil,
            streamId: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.expiresAt = expiresAt
            self.ownedBy = ownedBy
            self.state = state
            self.statusCode = statusCode
            self.streamId = streamId
            self.url = url
        }
    }

}

extension NimbleClientTypes {
    public enum StreamingSessionStreamState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingSessionStreamState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingSessionStreamState(rawValue: rawValue) ?? StreamingSessionStreamState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum StreamingSessionStreamStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalError
        case networkConnectionError
        case streamCreateInProgress
        case streamDeleted
        case streamDeleteInProgress
        case streamReady
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingSessionStreamStatusCode] {
            return [
                .internalError,
                .networkConnectionError,
                .streamCreateInProgress,
                .streamDeleted,
                .streamDeleteInProgress,
                .streamReady,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "INTERNAL_ERROR"
            case .networkConnectionError: return "NETWORK_CONNECTION_ERROR"
            case .streamCreateInProgress: return "STREAM_CREATE_IN_PROGRESS"
            case .streamDeleted: return "STREAM_DELETED"
            case .streamDeleteInProgress: return "STREAM_DELETE_IN_PROGRESS"
            case .streamReady: return "STREAM_READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingSessionStreamStatusCode(rawValue: rawValue) ?? StreamingSessionStreamStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.Studio: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminRoleArn = "adminRoleArn"
        case arn = "arn"
        case createdAt = "createdAt"
        case displayName = "displayName"
        case homeRegion = "homeRegion"
        case ssoClientId = "ssoClientId"
        case state = "state"
        case statusCode = "statusCode"
        case statusMessage = "statusMessage"
        case studioEncryptionConfiguration = "studioEncryptionConfiguration"
        case studioId = "studioId"
        case studioName = "studioName"
        case studioUrl = "studioUrl"
        case tags = "tags"
        case updatedAt = "updatedAt"
        case userRoleArn = "userRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminRoleArn = adminRoleArn {
            try encodeContainer.encode(adminRoleArn, forKey: .adminRoleArn)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let ssoClientId = ssoClientId {
            try encodeContainer.encode(ssoClientId, forKey: .ssoClientId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let studioEncryptionConfiguration = studioEncryptionConfiguration {
            try encodeContainer.encode(studioEncryptionConfiguration, forKey: .studioEncryptionConfiguration)
        }
        if let studioId = studioId {
            try encodeContainer.encode(studioId, forKey: .studioId)
        }
        if let studioName = studioName {
            try encodeContainer.encode(studioName, forKey: .studioName)
        }
        if let studioUrl = studioUrl {
            try encodeContainer.encode(studioUrl, forKey: .studioUrl)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let userRoleArn = userRoleArn {
            try encodeContainer.encode(userRoleArn, forKey: .userRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminRoleArn)
        adminRoleArn = adminRoleArnDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let ssoClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssoClientId)
        ssoClientId = ssoClientIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let studioEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioEncryptionConfiguration.self, forKey: .studioEncryptionConfiguration)
        studioEncryptionConfiguration = studioEncryptionConfigurationDecoded
        let studioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioId)
        studioId = studioIdDecoded
        let studioNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioName)
        studioName = studioNameDecoded
        let studioUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioUrl)
        studioUrl = studioUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let userRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userRoleArn)
        userRoleArn = userRoleArnDecoded
    }
}

extension NimbleClientTypes.Studio: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Studio(adminRoleArn: \(Swift.String(describing: adminRoleArn)), arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), displayName: \(Swift.String(describing: displayName)), homeRegion: \(Swift.String(describing: homeRegion)), ssoClientId: \(Swift.String(describing: ssoClientId)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), studioEncryptionConfiguration: \(Swift.String(describing: studioEncryptionConfiguration)), studioId: \(Swift.String(describing: studioId)), studioName: \(Swift.String(describing: studioName)), studioUrl: \(Swift.String(describing: studioUrl)), tags: \(Swift.String(describing: tags)), updatedAt: \(Swift.String(describing: updatedAt)), userRoleArn: \(Swift.String(describing: userRoleArn)))"}
}

extension NimbleClientTypes {
    public struct Studio: Swift.Equatable {
        /// The IAM role that studio admins assume when logging in to the Nimble Studio portal.
        public var adminRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public var arn: Swift.String?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// A friendly name for the studio.
        public var displayName: Swift.String?
        /// The Amazon Web Services Region where the studio resource is located.
        public var homeRegion: Swift.String?
        /// The Amazon Web Services SSO application client ID used to integrate with Amazon Web Services SSO to enable Amazon Web Services SSO users to log in to Nimble portal.
        public var ssoClientId: Swift.String?
        /// The current state of the studio resource.
        public var state: NimbleClientTypes.StudioState?
        /// Status codes that provide additional detail on the studio state.
        public var statusCode: NimbleClientTypes.StudioStatusCode?
        /// Additional detail on the studio state.
        public var statusMessage: Swift.String?
        /// Configuration of the encryption method that is used for the studio.
        public var studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration?
        /// The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.
        public var studioId: Swift.String?
        /// The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.
        public var studioName: Swift.String?
        /// The address of the web page for the studio.
        public var studioUrl: Swift.String?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The IAM role that studio users assume when logging in to the Nimble Studio portal.
        public var userRoleArn: Swift.String?

        public init (
            adminRoleArn: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            homeRegion: Swift.String? = nil,
            ssoClientId: Swift.String? = nil,
            state: NimbleClientTypes.StudioState? = nil,
            statusCode: NimbleClientTypes.StudioStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration? = nil,
            studioId: Swift.String? = nil,
            studioName: Swift.String? = nil,
            studioUrl: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            userRoleArn: Swift.String? = nil
        )
        {
            self.adminRoleArn = adminRoleArn
            self.arn = arn
            self.createdAt = createdAt
            self.displayName = displayName
            self.homeRegion = homeRegion
            self.ssoClientId = ssoClientId
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.studioEncryptionConfiguration = studioEncryptionConfiguration
            self.studioId = studioId
            self.studioName = studioName
            self.studioUrl = studioUrl
            self.tags = tags
            self.updatedAt = updatedAt
            self.userRoleArn = userRoleArn
        }
    }

}

extension NimbleClientTypes.StudioComponent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case configuration = "configuration"
        case createdAt = "createdAt"
        case createdBy = "createdBy"
        case description = "description"
        case ec2SecurityGroupIds = "ec2SecurityGroupIds"
        case initializationScripts = "initializationScripts"
        case name = "name"
        case scriptParameters = "scriptParameters"
        case state = "state"
        case statusCode = "statusCode"
        case statusMessage = "statusMessage"
        case studioComponentId = "studioComponentId"
        case subtype = "subtype"
        case tags = "tags"
        case type = "type"
        case updatedAt = "updatedAt"
        case updatedBy = "updatedBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SecurityGroupIds = ec2SecurityGroupIds {
            var ec2SecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SecurityGroupIds)
            for studiocomponentsecuritygroupidlist0 in ec2SecurityGroupIds {
                try ec2SecurityGroupIdsContainer.encode(studiocomponentsecuritygroupidlist0)
            }
        }
        if let initializationScripts = initializationScripts {
            var initializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .initializationScripts)
            for studiocomponentinitializationscriptlist0 in initializationScripts {
                try initializationScriptsContainer.encode(studiocomponentinitializationscriptlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scriptParameters = scriptParameters {
            var scriptParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scriptParameters)
            for studiocomponentscriptparameterkeyvaluelist0 in scriptParameters {
                try scriptParametersContainer.encode(studiocomponentscriptparameterkeyvaluelist0)
            }
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let studioComponentId = studioComponentId {
            try encodeContainer.encode(studioComponentId, forKey: .studioComponentId)
        }
        if let subtype = subtype {
            try encodeContainer.encode(subtype.rawValue, forKey: .subtype)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let updatedBy = updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SecurityGroupIds)
        var ec2SecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let ec2SecurityGroupIdsContainer = ec2SecurityGroupIdsContainer {
            ec2SecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in ec2SecurityGroupIdsContainer {
                if let string0 = string0 {
                    ec2SecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SecurityGroupIds = ec2SecurityGroupIdsDecoded0
        let initializationScriptsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioComponentInitializationScript?].self, forKey: .initializationScripts)
        var initializationScriptsDecoded0:[NimbleClientTypes.StudioComponentInitializationScript]? = nil
        if let initializationScriptsContainer = initializationScriptsContainer {
            initializationScriptsDecoded0 = [NimbleClientTypes.StudioComponentInitializationScript]()
            for structure0 in initializationScriptsContainer {
                if let structure0 = structure0 {
                    initializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        initializationScripts = initializationScriptsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let scriptParametersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.ScriptParameterKeyValue?].self, forKey: .scriptParameters)
        var scriptParametersDecoded0:[NimbleClientTypes.ScriptParameterKeyValue]? = nil
        if let scriptParametersContainer = scriptParametersContainer {
            scriptParametersDecoded0 = [NimbleClientTypes.ScriptParameterKeyValue]()
            for structure0 in scriptParametersContainer {
                if let structure0 = structure0 {
                    scriptParametersDecoded0?.append(structure0)
                }
            }
        }
        scriptParameters = scriptParametersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let studioComponentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentId)
        studioComponentId = studioComponentIdDecoded
        let subtypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentSubtype.self, forKey: .subtype)
        subtype = subtypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentType.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension NimbleClientTypes.StudioComponent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StudioComponent(arn: \(Swift.String(describing: arn)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), description: \(Swift.String(describing: description)), ec2SecurityGroupIds: \(Swift.String(describing: ec2SecurityGroupIds)), initializationScripts: \(Swift.String(describing: initializationScripts)), name: \(Swift.String(describing: name)), scriptParameters: \(Swift.String(describing: scriptParameters)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), studioComponentId: \(Swift.String(describing: studioComponentId)), subtype: \(Swift.String(describing: subtype)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)))"}
}

extension NimbleClientTypes {
    /// A network that is used by a studios users and workflows, including render farm, Active Directory, licensing, and file system.
    public struct StudioComponent: Swift.Equatable {
        /// The ARN of the resource.
        public var arn: Swift.String?
        /// The configuration of the studio component, based on component type.
        public var configuration: NimbleClientTypes.StudioComponentConfiguration?
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The user ID of the user that created the studio component.
        public var createdBy: Swift.String?
        /// A human-readable description for the studio component resource.
        public var description: Swift.String?
        /// The EC2 security groups that control access to the studio component.
        public var ec2SecurityGroupIds: [Swift.String]?
        /// Initialization scripts for studio components.
        public var initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]?
        /// A friendly name for the studio component resource.
        public var name: Swift.String?
        /// Parameters for the studio component scripts.
        public var scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]?
        /// The current state.
        public var state: NimbleClientTypes.StudioComponentState?
        /// The status code.
        public var statusCode: NimbleClientTypes.StudioComponentStatusCode?
        /// The status message for the studio component.
        public var statusMessage: Swift.String?
        /// The unique identifier for a studio component resource.
        public var studioComponentId: Swift.String?
        /// The specific subtype of a studio component.
        public var subtype: NimbleClientTypes.StudioComponentSubtype?
        /// A collection of labels, in the form of key:value pairs, that apply to this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the studio component.
        public var type: NimbleClientTypes.StudioComponentType?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user ID of the user that most recently updated the resource.
        public var updatedBy: Swift.String?

        public init (
            arn: Swift.String? = nil,
            configuration: NimbleClientTypes.StudioComponentConfiguration? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            ec2SecurityGroupIds: [Swift.String]? = nil,
            initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]? = nil,
            name: Swift.String? = nil,
            scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]? = nil,
            state: NimbleClientTypes.StudioComponentState? = nil,
            statusCode: NimbleClientTypes.StudioComponentStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            studioComponentId: Swift.String? = nil,
            subtype: NimbleClientTypes.StudioComponentSubtype? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: NimbleClientTypes.StudioComponentType? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.arn = arn
            self.configuration = configuration
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.initializationScripts = initializationScripts
            self.name = name
            self.scriptParameters = scriptParameters
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.studioComponentId = studioComponentId
            self.subtype = subtype
            self.tags = tags
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension NimbleClientTypes.StudioComponentConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDirectoryConfiguration = "activeDirectoryConfiguration"
        case computeFarmConfiguration = "computeFarmConfiguration"
        case licenseServiceConfiguration = "licenseServiceConfiguration"
        case sharedFileSystemConfiguration = "sharedFileSystemConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDirectoryConfiguration = activeDirectoryConfiguration {
            try encodeContainer.encode(activeDirectoryConfiguration, forKey: .activeDirectoryConfiguration)
        }
        if let computeFarmConfiguration = computeFarmConfiguration {
            try encodeContainer.encode(computeFarmConfiguration, forKey: .computeFarmConfiguration)
        }
        if let licenseServiceConfiguration = licenseServiceConfiguration {
            try encodeContainer.encode(licenseServiceConfiguration, forKey: .licenseServiceConfiguration)
        }
        if let sharedFileSystemConfiguration = sharedFileSystemConfiguration {
            try encodeContainer.encode(sharedFileSystemConfiguration, forKey: .sharedFileSystemConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDirectoryConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.ActiveDirectoryConfiguration.self, forKey: .activeDirectoryConfiguration)
        activeDirectoryConfiguration = activeDirectoryConfigurationDecoded
        let computeFarmConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.ComputeFarmConfiguration.self, forKey: .computeFarmConfiguration)
        computeFarmConfiguration = computeFarmConfigurationDecoded
        let licenseServiceConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LicenseServiceConfiguration.self, forKey: .licenseServiceConfiguration)
        licenseServiceConfiguration = licenseServiceConfigurationDecoded
        let sharedFileSystemConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.SharedFileSystemConfiguration.self, forKey: .sharedFileSystemConfiguration)
        sharedFileSystemConfiguration = sharedFileSystemConfigurationDecoded
    }
}

extension NimbleClientTypes.StudioComponentConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StudioComponentConfiguration(activeDirectoryConfiguration: \(Swift.String(describing: activeDirectoryConfiguration)), computeFarmConfiguration: \(Swift.String(describing: computeFarmConfiguration)), licenseServiceConfiguration: \(Swift.String(describing: licenseServiceConfiguration)), sharedFileSystemConfiguration: \(Swift.String(describing: sharedFileSystemConfiguration)))"}
}

extension NimbleClientTypes {
    /// The configuration of the studio component, based on component type.
    public struct StudioComponentConfiguration: Swift.Equatable {
        /// The configuration for a Microsoft Active Directory (Microsoft AD) studio resource.
        public var activeDirectoryConfiguration: NimbleClientTypes.ActiveDirectoryConfiguration?
        /// The configuration for a render farm that is associated with a studio resource.
        public var computeFarmConfiguration: NimbleClientTypes.ComputeFarmConfiguration?
        /// The configuration for a license service that is associated with a studio resource.
        public var licenseServiceConfiguration: NimbleClientTypes.LicenseServiceConfiguration?
        /// The configuration for a shared file storage system that is associated with a studio resource.
        public var sharedFileSystemConfiguration: NimbleClientTypes.SharedFileSystemConfiguration?

        public init (
            activeDirectoryConfiguration: NimbleClientTypes.ActiveDirectoryConfiguration? = nil,
            computeFarmConfiguration: NimbleClientTypes.ComputeFarmConfiguration? = nil,
            licenseServiceConfiguration: NimbleClientTypes.LicenseServiceConfiguration? = nil,
            sharedFileSystemConfiguration: NimbleClientTypes.SharedFileSystemConfiguration? = nil
        )
        {
            self.activeDirectoryConfiguration = activeDirectoryConfiguration
            self.computeFarmConfiguration = computeFarmConfiguration
            self.licenseServiceConfiguration = licenseServiceConfiguration
            self.sharedFileSystemConfiguration = sharedFileSystemConfiguration
        }
    }

}

extension NimbleClientTypes.StudioComponentInitializationScript: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfileProtocolVersion = "launchProfileProtocolVersion"
        case platform = "platform"
        case runContext = "runContext"
        case script = "script"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchProfileProtocolVersion = launchProfileProtocolVersion {
            try encodeContainer.encode(launchProfileProtocolVersion, forKey: .launchProfileProtocolVersion)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let runContext = runContext {
            try encodeContainer.encode(runContext.rawValue, forKey: .runContext)
        }
        if let script = script {
            try encodeContainer.encode(script, forKey: .script)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileProtocolVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileProtocolVersion)
        launchProfileProtocolVersion = launchProfileProtocolVersionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfilePlatform.self, forKey: .platform)
        platform = platformDecoded
        let runContextDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentInitializationScriptRunContext.self, forKey: .runContext)
        runContext = runContextDecoded
        let scriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .script)
        script = scriptDecoded
    }
}

extension NimbleClientTypes.StudioComponentInitializationScript: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StudioComponentInitializationScript(launchProfileProtocolVersion: \(Swift.String(describing: launchProfileProtocolVersion)), platform: \(Swift.String(describing: platform)), runContext: \(Swift.String(describing: runContext)), script: \(Swift.String(describing: script)))"}
}

extension NimbleClientTypes {
    /// Initialization scripts for studio components.
    public struct StudioComponentInitializationScript: Swift.Equatable {
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public var launchProfileProtocolVersion: Swift.String?
        /// The platform of the initialization script, either WINDOWS or LINUX.
        public var platform: NimbleClientTypes.LaunchProfilePlatform?
        /// The method to use when running the initialization script.
        public var runContext: NimbleClientTypes.StudioComponentInitializationScriptRunContext?
        /// The initialization script.
        public var script: Swift.String?

        public init (
            launchProfileProtocolVersion: Swift.String? = nil,
            platform: NimbleClientTypes.LaunchProfilePlatform? = nil,
            runContext: NimbleClientTypes.StudioComponentInitializationScriptRunContext? = nil,
            script: Swift.String? = nil
        )
        {
            self.launchProfileProtocolVersion = launchProfileProtocolVersion
            self.platform = platform
            self.runContext = runContext
            self.script = script
        }
    }

}

extension NimbleClientTypes {
    public enum StudioComponentInitializationScriptRunContext: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case systemInitialization
        case userInitialization
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentInitializationScriptRunContext] {
            return [
                .systemInitialization,
                .userInitialization,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .systemInitialization: return "SYSTEM_INITIALIZATION"
            case .userInitialization: return "USER_INITIALIZATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioComponentInitializationScriptRunContext(rawValue: rawValue) ?? StudioComponentInitializationScriptRunContext.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    /// The current state of the studio component resource. While a studio component is being created, modified, or deleted, its state will equal "CREATE_IN_PROGRESS", "UPDATE_IN_PROGRESS", or "DELETE_IN_PROGRESS" These are called 'transition states'. No modifications may be made to the studio component while it is in a transition state. If creation of the resource fails, the state will change to `CREATE_FAILED`. The resource StatusCode and StatusMessage will provide more information of why creation failed. The resource in this state will automatically be deleted from your account after a period of time. If updating the resource fails, the state will change to `UPDATE_FAILED`. The resource StatusCode and StatusMessage will provide more information of why the update failed. The resource will be returned to the state it was in when the update request was invoked. If deleting the resource fails, the state will change to `DELETE_FAILED`. The resource StatusCode and StatusMessage will provide more information of why the update failed. The resource will be returned to the state it was in when the update request was invoked. After the resource is deleted successfully, it will change to the "DELETED" state. The resource will no longer count against service quotas and cannot be used or acted upon any futher. It will be removed from your account after a period of time.
    public enum StudioComponentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioComponentState(rawValue: rawValue) ?? StudioComponentState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    /// The current status of the studio component resource. When the resource is in the 'READY' state, the status code signals what the last mutation made to the resource was. When the resource is in a CREATE_FAILED/UPDATE_FAILED/DELETE_FAILED state, the status code signals what went wrong and why the mutation failed.
    public enum StudioComponentStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activeDirectoryAlreadyExists
        case encryptionKeyAccessDenied
        case encryptionKeyNotFound
        case internalError
        case studioComponentCreated
        case studioComponentCreateInProgress
        case studioComponentDeleted
        case studioComponentDeleteInProgress
        case studioComponentUpdated
        case studioComponentUpdateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentStatusCode] {
            return [
                .activeDirectoryAlreadyExists,
                .encryptionKeyAccessDenied,
                .encryptionKeyNotFound,
                .internalError,
                .studioComponentCreated,
                .studioComponentCreateInProgress,
                .studioComponentDeleted,
                .studioComponentDeleteInProgress,
                .studioComponentUpdated,
                .studioComponentUpdateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activeDirectoryAlreadyExists: return "ACTIVE_DIRECTORY_ALREADY_EXISTS"
            case .encryptionKeyAccessDenied: return "ENCRYPTION_KEY_ACCESS_DENIED"
            case .encryptionKeyNotFound: return "ENCRYPTION_KEY_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .studioComponentCreated: return "STUDIO_COMPONENT_CREATED"
            case .studioComponentCreateInProgress: return "STUDIO_COMPONENT_CREATE_IN_PROGRESS"
            case .studioComponentDeleted: return "STUDIO_COMPONENT_DELETED"
            case .studioComponentDeleteInProgress: return "STUDIO_COMPONENT_DELETE_IN_PROGRESS"
            case .studioComponentUpdated: return "STUDIO_COMPONENT_UPDATED"
            case .studioComponentUpdateInProgress: return "STUDIO_COMPONENT_UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioComponentStatusCode(rawValue: rawValue) ?? StudioComponentStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum StudioComponentSubtype: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonFsxForLustre
        case amazonFsxForWindows
        case awsManagedMicrosoftAd
        case custom
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentSubtype] {
            return [
                .amazonFsxForLustre,
                .amazonFsxForWindows,
                .awsManagedMicrosoftAd,
                .custom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonFsxForLustre: return "AMAZON_FSX_FOR_LUSTRE"
            case .amazonFsxForWindows: return "AMAZON_FSX_FOR_WINDOWS"
            case .awsManagedMicrosoftAd: return "AWS_MANAGED_MICROSOFT_AD"
            case .custom: return "CUSTOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioComponentSubtype(rawValue: rawValue) ?? StudioComponentSubtype.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.StudioComponentSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "createdAt"
        case createdBy = "createdBy"
        case description = "description"
        case name = "name"
        case studioComponentId = "studioComponentId"
        case subtype = "subtype"
        case type = "type"
        case updatedAt = "updatedAt"
        case updatedBy = "updatedBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let studioComponentId = studioComponentId {
            try encodeContainer.encode(studioComponentId, forKey: .studioComponentId)
        }
        if let subtype = subtype {
            try encodeContainer.encode(subtype.rawValue, forKey: .subtype)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let updatedBy = updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let studioComponentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentId)
        studioComponentId = studioComponentIdDecoded
        let subtypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentSubtype.self, forKey: .subtype)
        subtype = subtypeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentType.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension NimbleClientTypes.StudioComponentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StudioComponentSummary(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), studioComponentId: \(Swift.String(describing: studioComponentId)), subtype: \(Swift.String(describing: subtype)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)))"}
}

extension NimbleClientTypes {
    ///
    public struct StudioComponentSummary: Swift.Equatable {
        /// The Unix epoch timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The user ID of the user that created the studio component.
        public var createdBy: Swift.String?
        /// The description.
        public var description: Swift.String?
        /// The name for the studio component.
        public var name: Swift.String?
        /// The unique identifier for a studio component resource.
        public var studioComponentId: Swift.String?
        /// The specific subtype of a studio component.
        public var subtype: NimbleClientTypes.StudioComponentSubtype?
        /// The type of the studio component.
        public var type: NimbleClientTypes.StudioComponentType?
        /// The Unix epoch timestamp in seconds for when the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user ID of the user that most recently updated the resource.
        public var updatedBy: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            studioComponentId: Swift.String? = nil,
            subtype: NimbleClientTypes.StudioComponentSubtype? = nil,
            type: NimbleClientTypes.StudioComponentType? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.name = name
            self.studioComponentId = studioComponentId
            self.subtype = subtype
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension NimbleClientTypes {
    public enum StudioComponentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activeDirectory
        case computeFarm
        case custom
        case licenseService
        case sharedFileSystem
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentType] {
            return [
                .activeDirectory,
                .computeFarm,
                .custom,
                .licenseService,
                .sharedFileSystem,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activeDirectory: return "ACTIVE_DIRECTORY"
            case .computeFarm: return "COMPUTE_FARM"
            case .custom: return "CUSTOM"
            case .licenseService: return "LICENSE_SERVICE"
            case .sharedFileSystem: return "SHARED_FILE_SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioComponentType(rawValue: rawValue) ?? StudioComponentType.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.StudioEncryptionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyArn = "keyArn"
        case keyType = "keyType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyArn = keyArn {
            try encodeContainer.encode(keyArn, forKey: .keyArn)
        }
        if let keyType = keyType {
            try encodeContainer.encode(keyType.rawValue, forKey: .keyType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioEncryptionConfigurationKeyType.self, forKey: .keyType)
        keyType = keyTypeDecoded
    }
}

extension NimbleClientTypes.StudioEncryptionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StudioEncryptionConfiguration(keyArn: \(Swift.String(describing: keyArn)), keyType: \(Swift.String(describing: keyType)))"}
}

extension NimbleClientTypes {
    /// Configuration of the encryption method that is used for the studio.
    public struct StudioEncryptionConfiguration: Swift.Equatable {
        /// The ARN for a KMS key that is used to encrypt studio data.
        public var keyArn: Swift.String?
        /// The type of KMS key that is used to encrypt studio data.
        /// This member is required.
        public var keyType: NimbleClientTypes.StudioEncryptionConfigurationKeyType?

        public init (
            keyArn: Swift.String? = nil,
            keyType: NimbleClientTypes.StudioEncryptionConfigurationKeyType? = nil
        )
        {
            self.keyArn = keyArn
            self.keyType = keyType
        }
    }

}

extension NimbleClientTypes {
    /// The type of KMS key that is used to encrypt studio data.
    public enum StudioEncryptionConfigurationKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsOwnedKey
        case customerManagedKey
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioEncryptionConfigurationKeyType] {
            return [
                .awsOwnedKey,
                .customerManagedKey,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsOwnedKey: return "AWS_OWNED_KEY"
            case .customerManagedKey: return "CUSTOMER_MANAGED_KEY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioEncryptionConfigurationKeyType(rawValue: rawValue) ?? StudioEncryptionConfigurationKeyType.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.StudioMembership: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "identityStoreId"
        case persona = "persona"
        case principalId = "principalId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let persona = persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let personaDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioPersona.self, forKey: .persona)
        persona = personaDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension NimbleClientTypes.StudioMembership: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StudioMembership(identityStoreId: \(Swift.String(describing: identityStoreId)), persona: \(Swift.String(describing: persona)), principalId: \(Swift.String(describing: principalId)))"}
}

extension NimbleClientTypes {
    public struct StudioMembership: Swift.Equatable {
        /// The ID of the identity store.
        public var identityStoreId: Swift.String?
        /// The persona.
        public var persona: NimbleClientTypes.StudioPersona?
        /// The principal ID.
        public var principalId: Swift.String?

        public init (
            identityStoreId: Swift.String? = nil,
            persona: NimbleClientTypes.StudioPersona? = nil,
            principalId: Swift.String? = nil
        )
        {
            self.identityStoreId = identityStoreId
            self.persona = persona
            self.principalId = principalId
        }
    }

}

extension NimbleClientTypes {
    public enum StudioPersona: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case administrator
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioPersona] {
            return [
                .administrator,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .administrator: return "ADMINISTRATOR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioPersona(rawValue: rawValue) ?? StudioPersona.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum StudioState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioState(rawValue: rawValue) ?? StudioState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    /// The status code.
    public enum StudioStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsSsoAccessDenied
        case awsSsoConfigurationRepaired
        case awsSsoConfigurationRepairInProgress
        case awsSsoNotEnabled
        case encryptionKeyAccessDenied
        case encryptionKeyNotFound
        case internalError
        case roleCouldNotBeAssumed
        case roleNotOwnedByStudioOwner
        case studioCreated
        case studioCreateInProgress
        case studioDeleted
        case studioDeleteInProgress
        case studioUpdated
        case studioUpdateInProgress
        case studioWithLaunchProfilesNotDeleted
        case studioWithStreamingImagesNotDeleted
        case studioWithStudioComponentsNotDeleted
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioStatusCode] {
            return [
                .awsSsoAccessDenied,
                .awsSsoConfigurationRepaired,
                .awsSsoConfigurationRepairInProgress,
                .awsSsoNotEnabled,
                .encryptionKeyAccessDenied,
                .encryptionKeyNotFound,
                .internalError,
                .roleCouldNotBeAssumed,
                .roleNotOwnedByStudioOwner,
                .studioCreated,
                .studioCreateInProgress,
                .studioDeleted,
                .studioDeleteInProgress,
                .studioUpdated,
                .studioUpdateInProgress,
                .studioWithLaunchProfilesNotDeleted,
                .studioWithStreamingImagesNotDeleted,
                .studioWithStudioComponentsNotDeleted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsSsoAccessDenied: return "AWS_SSO_ACCESS_DENIED"
            case .awsSsoConfigurationRepaired: return "AWS_SSO_CONFIGURATION_REPAIRED"
            case .awsSsoConfigurationRepairInProgress: return "AWS_SSO_CONFIGURATION_REPAIR_IN_PROGRESS"
            case .awsSsoNotEnabled: return "AWS_SSO_NOT_ENABLED"
            case .encryptionKeyAccessDenied: return "ENCRYPTION_KEY_ACCESS_DENIED"
            case .encryptionKeyNotFound: return "ENCRYPTION_KEY_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .roleCouldNotBeAssumed: return "ROLE_COULD_NOT_BE_ASSUMED"
            case .roleNotOwnedByStudioOwner: return "ROLE_NOT_OWNED_BY_STUDIO_OWNER"
            case .studioCreated: return "STUDIO_CREATED"
            case .studioCreateInProgress: return "STUDIO_CREATE_IN_PROGRESS"
            case .studioDeleted: return "STUDIO_DELETED"
            case .studioDeleteInProgress: return "STUDIO_DELETE_IN_PROGRESS"
            case .studioUpdated: return "STUDIO_UPDATED"
            case .studioUpdateInProgress: return "STUDIO_UPDATE_IN_PROGRESS"
            case .studioWithLaunchProfilesNotDeleted: return "STUDIO_WITH_LAUNCH_PROFILES_NOT_DELETED"
            case .studioWithStreamingImagesNotDeleted: return "STUDIO_WITH_STREAMING_IMAGES_NOT_DELETED"
            case .studioWithStudioComponentsNotDeleted: return "STUDIO_WITH_STUDIO_COMPONENTS_NOT_DELETED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioStatusCode(rawValue: rawValue) ?? StudioStatusCode.sdkUnknown(rawValue)
        }
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

/// The ARN for the role that manages access.
public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the target resource for tagging operations.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A collection of labels, in the form of key:value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(code: \(Swift.String(describing: code)), context: \(Swift.String(describing: context)), message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A more specific error code.
    public var code: Swift.String?
    /// The exception context.
    public var context: [Swift.String:Swift.String]?
    /// A human-readable description of the error.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let context: [Swift.String:Swift.String]?
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case context = "context"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in contextContainer {
                if let __string0 = __string0 {
                    contextDecoded0?[key0] = __string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/tags/\(resourceArn.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the target resource for tagging operations.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of tag keys to delete.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateLaunchProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLaunchProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLaunchProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLaunchProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLaunchProfileOutputError>
}

extension UpdateLaunchProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLaunchProfileInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), launchProfileId: \(Swift.String(describing: launchProfileId)), launchProfileProtocolVersions: \(Swift.String(describing: launchProfileProtocolVersions)), name: \(Swift.String(describing: name)), streamConfiguration: \(Swift.String(describing: streamConfiguration)), studioComponentIds: \(Swift.String(describing: studioComponentIds)), studioId: \(Swift.String(describing: studioId)))"}
}

extension UpdateLaunchProfileInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case launchProfileProtocolVersions = "launchProfileProtocolVersions"
        case name = "name"
        case streamConfiguration = "streamConfiguration"
        case studioComponentIds = "studioComponentIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let launchProfileProtocolVersions = launchProfileProtocolVersions {
            var launchProfileProtocolVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchProfileProtocolVersions)
            for launchprofileprotocolversionlist0 in launchProfileProtocolVersions {
                try launchProfileProtocolVersionsContainer.encode(launchprofileprotocolversionlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let streamConfiguration = streamConfiguration {
            try encodeContainer.encode(streamConfiguration, forKey: .streamConfiguration)
        }
        if let studioComponentIds = studioComponentIds {
            var studioComponentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .studioComponentIds)
            for launchprofilestudiocomponentidlist0 in studioComponentIds {
                try studioComponentIdsContainer.encode(launchprofilestudiocomponentidlist0)
            }
        }
    }
}

public struct UpdateLaunchProfileInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLaunchProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLaunchProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLaunchProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLaunchProfileOutputError>
}

public struct UpdateLaunchProfileInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLaunchProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLaunchProfileInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLaunchProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLaunchProfileOutputError>
}

public struct UpdateLaunchProfileInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLaunchProfileInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateLaunchProfileInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLaunchProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let launchProfileId = input.launchProfileId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("launchProfileId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLaunchProfileInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLaunchProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLaunchProfileOutputError>
}

/// The launch profile ID.
public struct UpdateLaunchProfileInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The launch profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
    public var launchProfileProtocolVersions: [Swift.String]?
    /// The name for the launch profile.
    public var name: Swift.String?
    /// A configuration for a streaming session.
    public var streamConfiguration: NimbleClientTypes.StreamConfigurationCreate?
    /// Unique identifiers for a collection of studio components that can be used with this launch profile.
    public var studioComponentIds: [Swift.String]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        launchProfileProtocolVersions: [Swift.String]? = nil,
        name: Swift.String? = nil,
        streamConfiguration: NimbleClientTypes.StreamConfigurationCreate? = nil,
        studioComponentIds: [Swift.String]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.launchProfileId = launchProfileId
        self.launchProfileProtocolVersions = launchProfileProtocolVersions
        self.name = name
        self.streamConfiguration = streamConfiguration
        self.studioComponentIds = studioComponentIds
        self.studioId = studioId
    }
}

struct UpdateLaunchProfileInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let launchProfileProtocolVersions: [Swift.String]?
    public let name: Swift.String?
    public let streamConfiguration: NimbleClientTypes.StreamConfigurationCreate?
    public let studioComponentIds: [Swift.String]?
}

extension UpdateLaunchProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case launchProfileProtocolVersions = "launchProfileProtocolVersions"
        case name = "name"
        case streamConfiguration = "streamConfiguration"
        case studioComponentIds = "studioComponentIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let launchProfileProtocolVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .launchProfileProtocolVersions)
        var launchProfileProtocolVersionsDecoded0:[Swift.String]? = nil
        if let launchProfileProtocolVersionsContainer = launchProfileProtocolVersionsContainer {
            launchProfileProtocolVersionsDecoded0 = [Swift.String]()
            for string0 in launchProfileProtocolVersionsContainer {
                if let string0 = string0 {
                    launchProfileProtocolVersionsDecoded0?.append(string0)
                }
            }
        }
        launchProfileProtocolVersions = launchProfileProtocolVersionsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let streamConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamConfigurationCreate.self, forKey: .streamConfiguration)
        streamConfiguration = streamConfigurationDecoded
        let studioComponentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .studioComponentIds)
        var studioComponentIdsDecoded0:[Swift.String]? = nil
        if let studioComponentIdsContainer = studioComponentIdsContainer {
            studioComponentIdsDecoded0 = [Swift.String]()
            for string0 in studioComponentIdsContainer {
                if let string0 = string0 {
                    studioComponentIdsDecoded0?.append(string0)
                }
            }
        }
        studioComponentIds = studioComponentIdsDecoded0
    }
}

public struct UpdateLaunchProfileMemberInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLaunchProfileMemberInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLaunchProfileMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLaunchProfileMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLaunchProfileMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLaunchProfileMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLaunchProfileMemberOutputError>
}

extension UpdateLaunchProfileMemberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLaunchProfileMemberInput(clientToken: \(Swift.String(describing: clientToken)), launchProfileId: \(Swift.String(describing: launchProfileId)), persona: \(Swift.String(describing: persona)), principalId: \(Swift.String(describing: principalId)), studioId: \(Swift.String(describing: studioId)))"}
}

extension UpdateLaunchProfileMemberInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case persona = "persona"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let persona = persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
    }
}

public struct UpdateLaunchProfileMemberInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLaunchProfileMemberInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLaunchProfileMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLaunchProfileMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLaunchProfileMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLaunchProfileMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLaunchProfileMemberOutputError>
}

public struct UpdateLaunchProfileMemberInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLaunchProfileMemberInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateLaunchProfileMemberInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLaunchProfileMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateLaunchProfileMemberInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLaunchProfileMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLaunchProfileMemberOutputError>
}

public struct UpdateLaunchProfileMemberInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateLaunchProfileMemberInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateLaunchProfileMemberInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateLaunchProfileMemberOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let launchProfileId = input.launchProfileId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("launchProfileId is nil and needs a value for the path of this operation"))))
        }
        guard let principalId = input.principalId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("principalId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateLaunchProfileMemberInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateLaunchProfileMemberOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateLaunchProfileMemberOutputError>
}

/// The principal ID.
public struct UpdateLaunchProfileMemberInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The launch profile ID.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The persona.
    /// This member is required.
    public var persona: NimbleClientTypes.LaunchProfilePersona?
    /// The principal ID.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        persona: NimbleClientTypes.LaunchProfilePersona? = nil,
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.launchProfileId = launchProfileId
        self.persona = persona
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct UpdateLaunchProfileMemberInputBody: Swift.Equatable {
    public let persona: NimbleClientTypes.LaunchProfilePersona?
}

extension UpdateLaunchProfileMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case persona = "persona"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let personaDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfilePersona.self, forKey: .persona)
        persona = personaDecoded
    }
}

extension UpdateLaunchProfileMemberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLaunchProfileMemberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLaunchProfileMemberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLaunchProfileMemberOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLaunchProfileMemberOutputResponse(member: \(Swift.String(describing: member)))"}
}

extension UpdateLaunchProfileMemberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateLaunchProfileMemberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.member = output.member
        } else {
            self.member = nil
        }
    }
}

public struct UpdateLaunchProfileMemberOutputResponse: Swift.Equatable {
    /// The member.
    public var member: NimbleClientTypes.LaunchProfileMembership?

    public init (
        member: NimbleClientTypes.LaunchProfileMembership? = nil
    )
    {
        self.member = member
    }
}

struct UpdateLaunchProfileMemberOutputResponseBody: Swift.Equatable {
    public let member: NimbleClientTypes.LaunchProfileMembership?
}

extension UpdateLaunchProfileMemberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member = "member"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileMembership.self, forKey: .member)
        member = memberDecoded
    }
}

extension UpdateLaunchProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLaunchProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLaunchProfileOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLaunchProfileOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLaunchProfileOutputResponse(launchProfile: \(Swift.String(describing: launchProfile)))"}
}

extension UpdateLaunchProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateLaunchProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
        } else {
            self.launchProfile = nil
        }
    }
}

public struct UpdateLaunchProfileOutputResponse: Swift.Equatable {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?

    public init (
        launchProfile: NimbleClientTypes.LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

struct UpdateLaunchProfileOutputResponseBody: Swift.Equatable {
    public let launchProfile: NimbleClientTypes.LaunchProfile?
}

extension UpdateLaunchProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfile = "launchProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
    }
}

public struct UpdateStreamingImageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStreamingImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStreamingImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStreamingImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStreamingImageOutputError>
}

extension UpdateStreamingImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStreamingImageInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), streamingImageId: \(Swift.String(describing: streamingImageId)), studioId: \(Swift.String(describing: studioId)))"}
}

extension UpdateStreamingImageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateStreamingImageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStreamingImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStreamingImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStreamingImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStreamingImageOutputError>
}

public struct UpdateStreamingImageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStreamingImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStreamingImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStreamingImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStreamingImageOutputError>
}

public struct UpdateStreamingImageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStreamingImageInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateStreamingImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStreamingImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let streamingImageId = input.streamingImageId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("streamingImageId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images/\(streamingImageId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateStreamingImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStreamingImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStreamingImageOutputError>
}

/// The streaming image ID.
public struct UpdateStreamingImageInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The name for the streaming image.
    public var name: Swift.String?
    /// The streaming image ID.
    /// This member is required.
    public var streamingImageId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        streamingImageId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.streamingImageId = streamingImageId
        self.studioId = studioId
    }
}

struct UpdateStreamingImageInputBody: Swift.Equatable {
    public let description: Swift.String?
    public let name: Swift.String?
}

extension UpdateStreamingImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case name = "name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateStreamingImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStreamingImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStreamingImageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStreamingImageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStreamingImageOutputResponse(streamingImage: \(Swift.String(describing: streamingImage)))"}
}

extension UpdateStreamingImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateStreamingImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingImage = output.streamingImage
        } else {
            self.streamingImage = nil
        }
    }
}

public struct UpdateStreamingImageOutputResponse: Swift.Equatable {
    ///
    public var streamingImage: NimbleClientTypes.StreamingImage?

    public init (
        streamingImage: NimbleClientTypes.StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

struct UpdateStreamingImageOutputResponseBody: Swift.Equatable {
    public let streamingImage: NimbleClientTypes.StreamingImage?
}

extension UpdateStreamingImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingImage = "streamingImage"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingImageDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImage.self, forKey: .streamingImage)
        streamingImage = streamingImageDecoded
    }
}

public struct UpdateStudioComponentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStudioComponentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStudioComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStudioComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStudioComponentOutputError>
}

extension UpdateStudioComponentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStudioComponentInput(clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), description: \(Swift.String(describing: description)), ec2SecurityGroupIds: \(Swift.String(describing: ec2SecurityGroupIds)), initializationScripts: \(Swift.String(describing: initializationScripts)), name: \(Swift.String(describing: name)), scriptParameters: \(Swift.String(describing: scriptParameters)), studioComponentId: \(Swift.String(describing: studioComponentId)), studioId: \(Swift.String(describing: studioId)), subtype: \(Swift.String(describing: subtype)), type: \(Swift.String(describing: type)))"}
}

extension UpdateStudioComponentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "configuration"
        case description = "description"
        case ec2SecurityGroupIds = "ec2SecurityGroupIds"
        case initializationScripts = "initializationScripts"
        case name = "name"
        case scriptParameters = "scriptParameters"
        case subtype = "subtype"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SecurityGroupIds = ec2SecurityGroupIds {
            var ec2SecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SecurityGroupIds)
            for studiocomponentsecuritygroupidlist0 in ec2SecurityGroupIds {
                try ec2SecurityGroupIdsContainer.encode(studiocomponentsecuritygroupidlist0)
            }
        }
        if let initializationScripts = initializationScripts {
            var initializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .initializationScripts)
            for studiocomponentinitializationscriptlist0 in initializationScripts {
                try initializationScriptsContainer.encode(studiocomponentinitializationscriptlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scriptParameters = scriptParameters {
            var scriptParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scriptParameters)
            for studiocomponentscriptparameterkeyvaluelist0 in scriptParameters {
                try scriptParametersContainer.encode(studiocomponentscriptparameterkeyvaluelist0)
            }
        }
        if let subtype = subtype {
            try encodeContainer.encode(subtype.rawValue, forKey: .subtype)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct UpdateStudioComponentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStudioComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStudioComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStudioComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStudioComponentOutputError>
}

public struct UpdateStudioComponentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStudioComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStudioComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStudioComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStudioComponentOutputError>
}

public struct UpdateStudioComponentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStudioComponentInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateStudioComponentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStudioComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        guard let studioComponentId = input.studioComponentId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioComponentId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components/\(studioComponentId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateStudioComponentInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStudioComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStudioComponentOutputError>
}

/// The studio component ID.
public struct UpdateStudioComponentInput: Swift.Equatable {
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// The configuration of the studio component, based on component type.
    public var configuration: NimbleClientTypes.StudioComponentConfiguration?
    /// The description.
    public var description: Swift.String?
    /// The EC2 security groups that control access to the studio component.
    public var ec2SecurityGroupIds: [Swift.String]?
    /// Initialization scripts for studio components.
    public var initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]?
    /// The name for the studio component.
    public var name: Swift.String?
    /// Parameters for the studio component scripts.
    public var scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]?
    /// The studio component ID.
    /// This member is required.
    public var studioComponentId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// The specific subtype of a studio component.
    public var subtype: NimbleClientTypes.StudioComponentSubtype?
    /// The type of the studio component.
    public var type: NimbleClientTypes.StudioComponentType?

    public init (
        clientToken: Swift.String? = nil,
        configuration: NimbleClientTypes.StudioComponentConfiguration? = nil,
        description: Swift.String? = nil,
        ec2SecurityGroupIds: [Swift.String]? = nil,
        initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]? = nil,
        name: Swift.String? = nil,
        scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]? = nil,
        studioComponentId: Swift.String? = nil,
        studioId: Swift.String? = nil,
        subtype: NimbleClientTypes.StudioComponentSubtype? = nil,
        type: NimbleClientTypes.StudioComponentType? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.ec2SecurityGroupIds = ec2SecurityGroupIds
        self.initializationScripts = initializationScripts
        self.name = name
        self.scriptParameters = scriptParameters
        self.studioComponentId = studioComponentId
        self.studioId = studioId
        self.subtype = subtype
        self.type = type
    }
}

struct UpdateStudioComponentInputBody: Swift.Equatable {
    public let configuration: NimbleClientTypes.StudioComponentConfiguration?
    public let description: Swift.String?
    public let ec2SecurityGroupIds: [Swift.String]?
    public let initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]?
    public let name: Swift.String?
    public let scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]?
    public let subtype: NimbleClientTypes.StudioComponentSubtype?
    public let type: NimbleClientTypes.StudioComponentType?
}

extension UpdateStudioComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "configuration"
        case description = "description"
        case ec2SecurityGroupIds = "ec2SecurityGroupIds"
        case initializationScripts = "initializationScripts"
        case name = "name"
        case scriptParameters = "scriptParameters"
        case subtype = "subtype"
        case type = "type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SecurityGroupIds)
        var ec2SecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let ec2SecurityGroupIdsContainer = ec2SecurityGroupIdsContainer {
            ec2SecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in ec2SecurityGroupIdsContainer {
                if let string0 = string0 {
                    ec2SecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SecurityGroupIds = ec2SecurityGroupIdsDecoded0
        let initializationScriptsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioComponentInitializationScript?].self, forKey: .initializationScripts)
        var initializationScriptsDecoded0:[NimbleClientTypes.StudioComponentInitializationScript]? = nil
        if let initializationScriptsContainer = initializationScriptsContainer {
            initializationScriptsDecoded0 = [NimbleClientTypes.StudioComponentInitializationScript]()
            for structure0 in initializationScriptsContainer {
                if let structure0 = structure0 {
                    initializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        initializationScripts = initializationScriptsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let scriptParametersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.ScriptParameterKeyValue?].self, forKey: .scriptParameters)
        var scriptParametersDecoded0:[NimbleClientTypes.ScriptParameterKeyValue]? = nil
        if let scriptParametersContainer = scriptParametersContainer {
            scriptParametersDecoded0 = [NimbleClientTypes.ScriptParameterKeyValue]()
            for structure0 in scriptParametersContainer {
                if let structure0 = structure0 {
                    scriptParametersDecoded0?.append(structure0)
                }
            }
        }
        scriptParameters = scriptParametersDecoded0
        let subtypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentSubtype.self, forKey: .subtype)
        subtype = subtypeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentType.self, forKey: .type)
        type = typeDecoded
    }
}

extension UpdateStudioComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStudioComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStudioComponentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStudioComponentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStudioComponentOutputResponse(studioComponent: \(Swift.String(describing: studioComponent)))"}
}

extension UpdateStudioComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateStudioComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studioComponent = output.studioComponent
        } else {
            self.studioComponent = nil
        }
    }
}

public struct UpdateStudioComponentOutputResponse: Swift.Equatable {
    /// Information about the studio component.
    public var studioComponent: NimbleClientTypes.StudioComponent?

    public init (
        studioComponent: NimbleClientTypes.StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

struct UpdateStudioComponentOutputResponseBody: Swift.Equatable {
    public let studioComponent: NimbleClientTypes.StudioComponent?
}

extension UpdateStudioComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studioComponent = "studioComponent"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioComponentDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponent.self, forKey: .studioComponent)
        studioComponent = studioComponentDecoded
    }
}

public struct UpdateStudioInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStudioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStudioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStudioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStudioOutputError>
}

extension UpdateStudioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStudioInput(adminRoleArn: \(Swift.String(describing: adminRoleArn)), clientToken: \(Swift.String(describing: clientToken)), displayName: \(Swift.String(describing: displayName)), studioId: \(Swift.String(describing: studioId)), userRoleArn: \(Swift.String(describing: userRoleArn)))"}
}

extension UpdateStudioInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminRoleArn = "adminRoleArn"
        case displayName = "displayName"
        case userRoleArn = "userRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminRoleArn = adminRoleArn {
            try encodeContainer.encode(adminRoleArn, forKey: .adminRoleArn)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let userRoleArn = userRoleArn {
            try encodeContainer.encode(userRoleArn, forKey: .userRoleArn)
        }
    }
}

public struct UpdateStudioInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStudioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStudioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amz-Client-Token", value: Swift.String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStudioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStudioOutputError>
}

public struct UpdateStudioInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStudioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateStudioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateStudioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStudioOutputError>
}

public struct UpdateStudioInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateStudioInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateStudioInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateStudioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let studioId = input.studioId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("studioId is nil and needs a value for the path of this operation"))))
        }
        let hostCustomPath = URL(string: "http://\(context.getHost())")?.path
        var urlPath = "/2020-08-01/studios/\(studioId.urlPercentEncoding())"
        if let hostCustomPath = hostCustomPath, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateStudioInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateStudioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateStudioOutputError>
}

/// The studio ID.
public struct UpdateStudioInput: Swift.Equatable {
    /// The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.
    public var adminRoleArn: Swift.String?
    /// To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.
    public var clientToken: Swift.String?
    /// A friendly name for the studio.
    public var displayName: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.
    public var userRoleArn: Swift.String?

    public init (
        adminRoleArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        studioId: Swift.String? = nil,
        userRoleArn: Swift.String? = nil
    )
    {
        self.adminRoleArn = adminRoleArn
        self.clientToken = clientToken
        self.displayName = displayName
        self.studioId = studioId
        self.userRoleArn = userRoleArn
    }
}

struct UpdateStudioInputBody: Swift.Equatable {
    public let adminRoleArn: Swift.String?
    public let displayName: Swift.String?
    public let userRoleArn: Swift.String?
}

extension UpdateStudioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminRoleArn = "adminRoleArn"
        case displayName = "displayName"
        case userRoleArn = "userRoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminRoleArn)
        adminRoleArn = adminRoleArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let userRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userRoleArn)
        userRoleArn = userRoleArnDecoded
    }
}

extension UpdateStudioOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStudioOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStudioOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerErrorException(InternalServerErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStudioOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStudioOutputResponse(studio: \(Swift.String(describing: studio)))"}
}

extension UpdateStudioOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateStudioOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

public struct UpdateStudioOutputResponse: Swift.Equatable {
    /// Information about a studio.
    public var studio: NimbleClientTypes.Studio?

    public init (
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct UpdateStudioOutputResponseBody: Swift.Equatable {
    public let studio: NimbleClientTypes.Studio?
}

extension UpdateStudioOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studio = "studio"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(code: \(Swift.String(describing: code)), context: \(Swift.String(describing: context)), message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.context = output.context
            self.message = output.message
        } else {
            self.code = nil
            self.context = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A more specific error code.
    public var code: Swift.String?
    /// The exception context.
    public var context: [Swift.String:Swift.String]?
    /// A human-readable description of the error.
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.context = context
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let code: Swift.String?
    public let context: [Swift.String:Swift.String]?
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "code"
        case context = "context"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in contextContainer {
                if let __string0 = __string0 {
                    contextDecoded0?[key0] = __string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
