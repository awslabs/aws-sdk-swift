// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension Application: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension Application: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Application(description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

public struct Application: Equatable {
    /// <p>The description of the application.</p>
    public let description: String?
    /// <p>The application ID.</p>
    public let id: String?
    /// <p>The application name.</p>
    public let name: String?

    public init (
        description: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input fails to satisfy the constraints specified by an AWS service.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum BytesMeasure {
    case kilobytes
    case sdkUnknown(String)
}

extension BytesMeasure : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BytesMeasure] {
        return [
            .kilobytes,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .kilobytes: return "KILOBYTES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BytesMeasure(rawValue: rawValue) ?? BytesMeasure.sdkUnknown(rawValue)
    }
}

extension ConfigurationProfileSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case id = "Id"
        case locationUri = "LocationUri"
        case name = "Name"
        case validatorTypes = "ValidatorTypes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let locationUri = locationUri {
            try encodeContainer.encode(locationUri, forKey: .locationUri)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let validatorTypes = validatorTypes {
            var validatorTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validatorTypes)
            for validatortypelist0 in validatorTypes {
                try validatorTypesContainer.encode(validatortypelist0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let validatorTypesContainer = try containerValues.decodeIfPresent([ValidatorType?].self, forKey: .validatorTypes)
        var validatorTypesDecoded0:[ValidatorType]? = nil
        if let validatorTypesContainer = validatorTypesContainer {
            validatorTypesDecoded0 = [ValidatorType]()
            for string0 in validatorTypesContainer {
                if let string0 = string0 {
                    validatorTypesDecoded0?.append(string0)
                }
            }
        }
        validatorTypes = validatorTypesDecoded0
    }
}

extension ConfigurationProfileSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationProfileSummary(applicationId: \(String(describing: applicationId)), id: \(String(describing: id)), locationUri: \(String(describing: locationUri)), name: \(String(describing: name)), validatorTypes: \(String(describing: validatorTypes)))"}
}

/// <p>A summary of a configuration profile.</p>
public struct ConfigurationProfileSummary: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The ID of the configuration profile.</p>
    public let id: String?
    /// <p>The URI location of the configuration.</p>
    public let locationUri: String?
    /// <p>The name of the configuration profile.</p>
    public let name: String?
    /// <p>The types of validators in the configuration profile.</p>
    public let validatorTypes: [ValidatorType]?

    public init (
        applicationId: String? = nil,
        id: String? = nil,
        locationUri: String? = nil,
        name: String? = nil,
        validatorTypes: [ValidatorType]? = nil
    )
    {
        self.applicationId = applicationId
        self.id = id
        self.locationUri = locationUri
        self.name = name
        self.validatorTypes = validatorTypes
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request could not be processed because of conflict in the current state of the
///          resource.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateApplicationInputBodyMiddleware: Middleware {
    public let id: String = "CreateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

extension CreateApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationInput(description: \(String(describing: description)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInput: Equatable {
    /// <p>A description of the application.</p>
    public let description: String?
    /// <p>A name for the application.</p>
    public let name: String?
    /// <p>Metadata to assign to the application. Tags help organize and categorize your AppConfig
    ///          resources. Each tag consists of a key and an optional value, both of which you
    ///          define.</p>
    public let tags: [String:String]?

    public init (
        description: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let tags: [String:String]?
}

extension CreateApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationOutputResponse(description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

extension CreateApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.name = output.name
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct CreateApplicationOutputResponse: Equatable {
    /// <p>The description of the application.</p>
    public let description: String?
    /// <p>The application ID.</p>
    public let id: String?
    /// <p>The application name.</p>
    public let name: String?

    public init (
        description: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct CreateApplicationOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
}

extension CreateApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct CreateConfigurationProfileInputBodyMiddleware: Middleware {
    public let id: String = "CreateConfigurationProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationProfileInput>
    public typealias MOutput = OperationOutput<CreateConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationProfileOutputError>
}

extension CreateConfigurationProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationProfileInput(applicationId: \(String(describing: applicationId)), description: \(String(describing: description)), locationUri: \(String(describing: locationUri)), name: \(String(describing: name)), retrievalRoleArn: \(String(describing: retrievalRoleArn)), tags: \(String(describing: tags)), validators: \(String(describing: validators)))"}
}

extension CreateConfigurationProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case tags = "Tags"
        case validators = "Validators"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let locationUri = locationUri {
            try encodeContainer.encode(locationUri, forKey: .locationUri)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let retrievalRoleArn = retrievalRoleArn {
            try encodeContainer.encode(retrievalRoleArn, forKey: .retrievalRoleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let validators = validators {
            var validatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validators)
            for validatorlist0 in validators {
                try validatorsContainer.encode(validatorlist0)
            }
        }
    }
}

public struct CreateConfigurationProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConfigurationProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationProfileInput>
    public typealias MOutput = OperationOutput<CreateConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationProfileOutputError>
}

public struct CreateConfigurationProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConfigurationProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationProfileInput>
    public typealias MOutput = OperationOutput<CreateConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationProfileOutputError>
}

public struct CreateConfigurationProfileInput: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>A description of the configuration profile.</p>
    public let description: String?
    /// <p>A URI to locate the configuration. You can specify a Systems Manager (SSM) document, an SSM
    ///          Parameter Store parameter, or an Amazon S3 object. For an SSM document, specify either the
    ///          document name in the format <code>ssm-document://<Document_name></code> or the Amazon
    ///          Resource Name (ARN). For a parameter, specify either the parameter name in the format
    ///             <code>ssm-parameter://<Parameter_name></code> or the ARN. For an Amazon S3 object,
    ///          specify the URI in the following format: <code>s3://<bucket>/<objectKey>
    ///          </code>. Here is an example: s3://my-bucket/my-app/us-east-1/my-config.json</p>
    public let locationUri: String?
    /// <p>A name for the configuration profile.</p>
    public let name: String?
    /// <p>The ARN of an IAM role with permission to access the configuration at the specified
    ///          LocationUri.</p>
    public let retrievalRoleArn: String?
    /// <p>Metadata to assign to the configuration profile. Tags help organize and categorize your
    ///          AppConfig resources. Each tag consists of a key and an optional value, both of which you
    ///          define.</p>
    public let tags: [String:String]?
    /// <p>A list of methods for validating the configuration.</p>
    public let validators: [Validator]?

    public init (
        applicationId: String? = nil,
        description: String? = nil,
        locationUri: String? = nil,
        name: String? = nil,
        retrievalRoleArn: String? = nil,
        tags: [String:String]? = nil,
        validators: [Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.locationUri = locationUri
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.tags = tags
        self.validators = validators
    }
}

struct CreateConfigurationProfileInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let locationUri: String?
    public let retrievalRoleArn: String?
    public let validators: [Validator]?
    public let tags: [String:String]?
}

extension CreateConfigurationProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case tags = "Tags"
        case validators = "Validators"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([Validator?].self, forKey: .validators)
        var validatorsDecoded0:[Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConfigurationProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigurationProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationProfileOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationProfileOutputResponse(applicationId: \(String(describing: applicationId)), description: \(String(describing: description)), id: \(String(describing: id)), locationUri: \(String(describing: locationUri)), name: \(String(describing: name)), retrievalRoleArn: \(String(describing: retrievalRoleArn)), validators: \(String(describing: validators)))"}
}

extension CreateConfigurationProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConfigurationProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.locationUri = output.locationUri
            self.name = output.name
            self.retrievalRoleArn = output.retrievalRoleArn
            self.validators = output.validators
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.locationUri = nil
            self.name = nil
            self.retrievalRoleArn = nil
            self.validators = nil
        }
    }
}

public struct CreateConfigurationProfileOutputResponse: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The configuration profile description.</p>
    public let description: String?
    /// <p>The configuration profile ID.</p>
    public let id: String?
    /// <p>The URI location of the configuration.</p>
    public let locationUri: String?
    /// <p>The name of the configuration profile.</p>
    public let name: String?
    /// <p>The ARN of an IAM role with permission to access the configuration at the specified
    ///          LocationUri.</p>
    public let retrievalRoleArn: String?
    /// <p>A list of methods for validating the configuration.</p>
    public let validators: [Validator]?

    public init (
        applicationId: String? = nil,
        description: String? = nil,
        id: String? = nil,
        locationUri: String? = nil,
        name: String? = nil,
        retrievalRoleArn: String? = nil,
        validators: [Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.locationUri = locationUri
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.validators = validators
    }
}

struct CreateConfigurationProfileOutputResponseBody: Equatable {
    public let applicationId: String?
    public let id: String?
    public let name: String?
    public let description: String?
    public let locationUri: String?
    public let retrievalRoleArn: String?
    public let validators: [Validator]?
}

extension CreateConfigurationProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case validators = "Validators"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([Validator?].self, forKey: .validators)
        var validatorsDecoded0:[Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
    }
}

public struct CreateDeploymentStrategyInputBodyMiddleware: Middleware {
    public let id: String = "CreateDeploymentStrategyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentStrategyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentStrategyInput>
    public typealias MOutput = OperationOutput<CreateDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentStrategyOutputError>
}

extension CreateDeploymentStrategyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeploymentStrategyInput(deploymentDurationInMinutes: \(String(describing: deploymentDurationInMinutes)), description: \(String(describing: description)), finalBakeTimeInMinutes: \(String(describing: finalBakeTimeInMinutes)), growthFactor: \(String(describing: growthFactor)), growthType: \(String(describing: growthType)), name: \(String(describing: name)), replicateTo: \(String(describing: replicateTo)), tags: \(String(describing: tags)))"}
}

extension CreateDeploymentStrategyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case name = "Name"
        case replicateTo = "ReplicateTo"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deploymentDurationInMinutes != 0 {
            try encodeContainer.encode(deploymentDurationInMinutes, forKey: .deploymentDurationInMinutes)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if finalBakeTimeInMinutes != 0 {
            try encodeContainer.encode(finalBakeTimeInMinutes, forKey: .finalBakeTimeInMinutes)
        }
        if growthFactor != 0.0 {
            try encodeContainer.encode(growthFactor, forKey: .growthFactor)
        }
        if let growthType = growthType {
            try encodeContainer.encode(growthType.rawValue, forKey: .growthType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let replicateTo = replicateTo {
            try encodeContainer.encode(replicateTo.rawValue, forKey: .replicateTo)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDeploymentStrategyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDeploymentStrategyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentStrategyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentStrategyInput>
    public typealias MOutput = OperationOutput<CreateDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentStrategyOutputError>
}

public struct CreateDeploymentStrategyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDeploymentStrategyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeploymentStrategyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeploymentStrategyInput>
    public typealias MOutput = OperationOutput<CreateDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeploymentStrategyOutputError>
}

public struct CreateDeploymentStrategyInput: Equatable {
    /// <p>Total amount of time for a deployment to last.</p>
    public let deploymentDurationInMinutes: Int
    /// <p>A description of the deployment strategy.</p>
    public let description: String?
    /// <p>The amount of time AppConfig monitors for alarms before considering the deployment to be
    ///          complete and no longer eligible for automatic roll back.</p>
    public let finalBakeTimeInMinutes: Int
    /// <p>The percentage of targets to receive a deployed configuration during each
    ///          interval.</p>
    public let growthFactor: Float
    /// <p>The algorithm used to define how percentage grows over time. AWS AppConfig supports the
    ///          following growth types:</p>
    ///          <p>
    ///             <b>Linear</b>: For this type, AppConfig processes the
    ///          deployment by dividing the total number of targets by the value specified for <code>Step
    ///             percentage</code>. For example, a linear deployment that uses a <code>Step
    ///             percentage</code> of 10 deploys the configuration to 10 percent of the hosts. After
    ///          those deployments are complete, the system deploys the configuration to the next 10
    ///          percent. This continues until 100% of the targets have successfully received the
    ///          configuration.</p>
    ///
    ///          <p>
    ///             <b>Exponential</b>: For this type, AppConfig processes the
    ///          deployment exponentially using the following formula: <code>G*(2^N)</code>. In this
    ///          formula, <code>G</code> is the growth factor specified by the user and <code>N</code> is
    ///          the number of steps until the configuration is deployed to all targets. For example, if you
    ///          specify a growth factor of 2, then the system rolls out the configuration as
    ///          follows:</p>
    ///          <p>
    ///             <code>2*(2^0)</code>
    ///          </p>
    ///          <p>
    ///             <code>2*(2^1)</code>
    ///          </p>
    ///          <p>
    ///             <code>2*(2^2)</code>
    ///          </p>
    ///          <p>Expressed numerically, the deployment rolls out as follows: 2% of the targets, 4% of the
    ///          targets, 8% of the targets, and continues until the configuration has been deployed to all
    ///          targets.</p>
    public let growthType: GrowthType?
    /// <p>A name for the deployment strategy.</p>
    public let name: String?
    /// <p>Save the deployment strategy to a Systems Manager (SSM) document.</p>
    public let replicateTo: ReplicateTo?
    /// <p>Metadata to assign to the deployment strategy. Tags help organize and categorize your
    ///          AppConfig resources. Each tag consists of a key and an optional value, both of which you
    ///          define.</p>
    public let tags: [String:String]?

    public init (
        deploymentDurationInMinutes: Int = 0,
        description: String? = nil,
        finalBakeTimeInMinutes: Int = 0,
        growthFactor: Float = 0.0,
        growthType: GrowthType? = nil,
        name: String? = nil,
        replicateTo: ReplicateTo? = nil,
        tags: [String:String]? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.name = name
        self.replicateTo = replicateTo
        self.tags = tags
    }
}

struct CreateDeploymentStrategyInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let deploymentDurationInMinutes: Int
    public let finalBakeTimeInMinutes: Int
    public let growthFactor: Float
    public let growthType: GrowthType?
    public let replicateTo: ReplicateTo?
    public let tags: [String:String]?
}

extension CreateDeploymentStrategyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case name = "Name"
        case replicateTo = "ReplicateTo"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let growthFactorDecoded = try containerValues.decode(Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeploymentStrategyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeploymentStrategyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeploymentStrategyOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeploymentStrategyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeploymentStrategyOutputResponse(deploymentDurationInMinutes: \(String(describing: deploymentDurationInMinutes)), description: \(String(describing: description)), finalBakeTimeInMinutes: \(String(describing: finalBakeTimeInMinutes)), growthFactor: \(String(describing: growthFactor)), growthType: \(String(describing: growthType)), id: \(String(describing: id)), name: \(String(describing: name)), replicateTo: \(String(describing: replicateTo)))"}
}

extension CreateDeploymentStrategyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDeploymentStrategyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.description = output.description
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.id = output.id
            self.name = output.name
            self.replicateTo = output.replicateTo
        } else {
            self.deploymentDurationInMinutes = 0
            self.description = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = 0.0
            self.growthType = nil
            self.id = nil
            self.name = nil
            self.replicateTo = nil
        }
    }
}

public struct CreateDeploymentStrategyOutputResponse: Equatable {
    /// <p>Total amount of time the deployment lasted.</p>
    public let deploymentDurationInMinutes: Int
    /// <p>The description of the deployment strategy.</p>
    public let description: String?
    /// <p>The amount of time AppConfig monitored for alarms before considering the deployment to be
    ///          complete and no longer eligible for automatic roll back.</p>
    public let finalBakeTimeInMinutes: Int
    /// <p>The percentage of targets that received a deployed configuration during each
    ///          interval.</p>
    public let growthFactor: Float
    /// <p>The algorithm used to define how percentage grew over time.</p>
    public let growthType: GrowthType?
    /// <p>The deployment strategy ID.</p>
    public let id: String?
    /// <p>The name of the deployment strategy.</p>
    public let name: String?
    /// <p>Save the deployment strategy to a Systems Manager (SSM) document.</p>
    public let replicateTo: ReplicateTo?

    public init (
        deploymentDurationInMinutes: Int = 0,
        description: String? = nil,
        finalBakeTimeInMinutes: Int = 0,
        growthFactor: Float = 0.0,
        growthType: GrowthType? = nil,
        id: String? = nil,
        name: String? = nil,
        replicateTo: ReplicateTo? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.id = id
        self.name = name
        self.replicateTo = replicateTo
    }
}

struct CreateDeploymentStrategyOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
    public let deploymentDurationInMinutes: Int
    public let growthType: GrowthType?
    public let growthFactor: Float
    public let finalBakeTimeInMinutes: Int
    public let replicateTo: ReplicateTo?
}

extension CreateDeploymentStrategyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case id = "Id"
        case name = "Name"
        case replicateTo = "ReplicateTo"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
    }
}

public struct CreateEnvironmentInputBodyMiddleware: Middleware {
    public let id: String = "CreateEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEnvironmentOutputError>
}

extension CreateEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEnvironmentInput(applicationId: \(String(describing: applicationId)), description: \(String(describing: description)), monitors: \(String(describing: monitors)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateEnvironmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case monitors = "Monitors"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let monitors = monitors {
            var monitorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitors)
            for monitorlist0 in monitors {
                try monitorsContainer.encode(monitorlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEnvironmentOutputError>
}

public struct CreateEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEnvironmentOutputError>
}

public struct CreateEnvironmentInput: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>A description of the environment.</p>
    public let description: String?
    /// <p>Amazon CloudWatch alarms to monitor during the deployment process.</p>
    public let monitors: [Monitor]?
    /// <p>A name for the environment.</p>
    public let name: String?
    /// <p>Metadata to assign to the environment. Tags help organize and categorize your AppConfig
    ///          resources. Each tag consists of a key and an optional value, both of which you
    ///          define.</p>
    public let tags: [String:String]?

    public init (
        applicationId: String? = nil,
        description: String? = nil,
        monitors: [Monitor]? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.monitors = monitors
        self.name = name
        self.tags = tags
    }
}

struct CreateEnvironmentInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let monitors: [Monitor]?
    public let tags: [String:String]?
}

extension CreateEnvironmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case monitors = "Monitors"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEnvironmentOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEnvironmentOutputResponse(applicationId: \(String(describing: applicationId)), description: \(String(describing: description)), id: \(String(describing: id)), monitors: \(String(describing: monitors)), name: \(String(describing: name)), state: \(String(describing: state)))"}
}

extension CreateEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.monitors = output.monitors
            self.name = output.name
            self.state = output.state
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.monitors = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct CreateEnvironmentOutputResponse: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The description of the environment.</p>
    public let description: String?
    /// <p>The environment ID.</p>
    public let id: String?
    /// <p>Amazon CloudWatch alarms monitored during the deployment.</p>
    public let monitors: [Monitor]?
    /// <p>The name of the environment.</p>
    public let name: String?
    /// <p>The state of the environment. An environment can be in one of the following states:
    ///             <code>READY_FOR_DEPLOYMENT</code>, <code>DEPLOYING</code>, <code>ROLLING_BACK</code>, or
    ///             <code>ROLLED_BACK</code>
    ///          </p>
    public let state: EnvironmentState?

    public init (
        applicationId: String? = nil,
        description: String? = nil,
        id: String? = nil,
        monitors: [Monitor]? = nil,
        name: String? = nil,
        state: EnvironmentState? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.monitors = monitors
        self.name = name
        self.state = state
    }
}

struct CreateEnvironmentOutputResponseBody: Equatable {
    public let applicationId: String?
    public let id: String?
    public let name: String?
    public let description: String?
    public let state: EnvironmentState?
    public let monitors: [Monitor]?
}

extension CreateEnvironmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case monitors = "Monitors"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

public struct CreateHostedConfigurationVersionInputBodyMiddleware: Middleware {
    public let id: String = "CreateHostedConfigurationVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHostedConfigurationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let content = input.operationInput.content {
            let contentdata = content
            let contentbody = HttpBody.data(contentdata)
            input.builder.withBody(contentbody)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHostedConfigurationVersionInput>
    public typealias MOutput = OperationOutput<CreateHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHostedConfigurationVersionOutputError>
}

extension CreateHostedConfigurationVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHostedConfigurationVersionInput(applicationId: \(String(describing: applicationId)), configurationProfileId: \(String(describing: configurationProfileId)), content: \(String(describing: content)), contentType: \(String(describing: contentType)), description: \(String(describing: description)), latestVersionNumber: \(String(describing: latestVersionNumber)))"}
}

extension CreateHostedConfigurationVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content.base64EncodedString(), forKey: .content)
        }
    }
}

public struct CreateHostedConfigurationVersionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateHostedConfigurationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHostedConfigurationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentType = input.operationInput.contentType {
            input.builder.withHeader(name: "Content-Type", value: String(contentType))
        }
        if let description = input.operationInput.description {
            input.builder.withHeader(name: "Description", value: String(description))
        }
        if input.operationInput.latestVersionNumber != 0 {
            input.builder.withHeader(name: "Latest-Version-Number", value: String(input.operationInput.latestVersionNumber))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHostedConfigurationVersionInput>
    public typealias MOutput = OperationOutput<CreateHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHostedConfigurationVersionOutputError>
}

public struct CreateHostedConfigurationVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateHostedConfigurationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateHostedConfigurationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateHostedConfigurationVersionInput>
    public typealias MOutput = OperationOutput<CreateHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateHostedConfigurationVersionOutputError>
}

public struct CreateHostedConfigurationVersionInput: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The configuration profile ID.</p>
    public let configurationProfileId: String?
    /// <p>The content of the configuration or the configuration data.</p>
    public let content: Data?
    /// <p>A standard MIME type describing the format of the configuration content. For more
    ///          information, see <a href="https://docs.aws.amazon.com/https:/www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">Content-Type</a>.</p>
    public let contentType: String?
    /// <p>A description of the configuration.</p>
    public let description: String?
    /// <p>An optional locking token used to prevent race conditions from overwriting configuration
    ///          updates when creating a new version. To ensure your data is not overwritten when creating
    ///          multiple hosted configuration versions in rapid succession, specify the version of the
    ///          latest hosted configuration version.</p>
    public let latestVersionNumber: Int

    public init (
        applicationId: String? = nil,
        configurationProfileId: String? = nil,
        content: Data? = nil,
        contentType: String? = nil,
        description: String? = nil,
        latestVersionNumber: Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.content = content
        self.contentType = contentType
        self.description = description
        self.latestVersionNumber = latestVersionNumber
    }
}

struct CreateHostedConfigurationVersionInputBody: Equatable {
    public let content: Data?
}

extension CreateHostedConfigurationVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .content)
        content = contentDecoded
    }
}

extension CreateHostedConfigurationVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHostedConfigurationVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHostedConfigurationVersionOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case payloadTooLargeException(PayloadTooLargeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHostedConfigurationVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateHostedConfigurationVersionOutputResponse(applicationId: \(String(describing: applicationId)), configurationProfileId: \(String(describing: configurationProfileId)), content: \(String(describing: content)), contentType: \(String(describing: contentType)), description: \(String(describing: description)), versionNumber: \(String(describing: versionNumber)))"}
}

extension CreateHostedConfigurationVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let applicationIdHeaderValue = httpResponse.headers.value(for: "Application-Id") {
            self.applicationId = applicationIdHeaderValue
        } else {
            self.applicationId = nil
        }
        if let configurationProfileIdHeaderValue = httpResponse.headers.value(for: "Configuration-Profile-Id") {
            self.configurationProfileId = configurationProfileIdHeaderValue
        } else {
            self.configurationProfileId = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let descriptionHeaderValue = httpResponse.headers.value(for: "Description") {
            self.description = descriptionHeaderValue
        } else {
            self.description = nil
        }
        if let versionNumberHeaderValue = httpResponse.headers.value(for: "Version-Number") {
            self.versionNumber = Int(versionNumberHeaderValue) ?? 0
        } else {
            self.versionNumber = 0
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.content = data
        } else {
            self.content = nil
        }
    }
}

public struct CreateHostedConfigurationVersionOutputResponse: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The configuration profile ID.</p>
    public let configurationProfileId: String?
    /// <p>The content of the configuration or the configuration data.</p>
    public let content: Data?
    /// <p>A standard MIME type describing the format of the configuration content. For more
    ///          information, see <a href="https://docs.aws.amazon.com/https:/www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">Content-Type</a>.</p>
    public let contentType: String?
    /// <p>A description of the configuration.</p>
    public let description: String?
    /// <p>The configuration version.</p>
    public let versionNumber: Int

    public init (
        applicationId: String? = nil,
        configurationProfileId: String? = nil,
        content: Data? = nil,
        contentType: String? = nil,
        description: String? = nil,
        versionNumber: Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.content = content
        self.contentType = contentType
        self.description = description
        self.versionNumber = versionNumber
    }
}

struct CreateHostedConfigurationVersionOutputResponseBody: Equatable {
    public let content: Data?
}

extension CreateHostedConfigurationVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .content)
        content = contentDecoded
    }
}

extension DeleteApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationInput(applicationId: \(String(describing: applicationId)))"}
}

extension DeleteApplicationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInput: Equatable {
    /// <p>The ID of the application to delete.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteApplicationInputBody: Equatable {
}

extension DeleteApplicationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationOutputResponse()"}
}

extension DeleteApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationOutputResponse: Equatable {

    public init() {}
}

struct DeleteApplicationOutputResponseBody: Equatable {
}

extension DeleteApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteConfigurationProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationProfileInput(applicationId: \(String(describing: applicationId)), configurationProfileId: \(String(describing: configurationProfileId)))"}
}

extension DeleteConfigurationProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteConfigurationProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConfigurationProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationProfileInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationProfileOutputError>
}

public struct DeleteConfigurationProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConfigurationProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationProfileInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationProfileOutputError>
}

public struct DeleteConfigurationProfileInput: Equatable {
    /// <p>The application ID that includes the configuration profile you want to delete.</p>
    public let applicationId: String?
    /// <p>The ID of the configuration profile you want to delete.</p>
    public let configurationProfileId: String?

    public init (
        applicationId: String? = nil,
        configurationProfileId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
    }
}

struct DeleteConfigurationProfileInputBody: Equatable {
}

extension DeleteConfigurationProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteConfigurationProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationProfileOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationProfileOutputResponse()"}
}

extension DeleteConfigurationProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConfigurationProfileOutputResponse: Equatable {

    public init() {}
}

struct DeleteConfigurationProfileOutputResponseBody: Equatable {
}

extension DeleteConfigurationProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDeploymentStrategyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDeploymentStrategyInput(deploymentStrategyId: \(String(describing: deploymentStrategyId)))"}
}

extension DeleteDeploymentStrategyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDeploymentStrategyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDeploymentStrategyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeploymentStrategyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeploymentStrategyInput>
    public typealias MOutput = OperationOutput<DeleteDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeploymentStrategyOutputError>
}

public struct DeleteDeploymentStrategyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDeploymentStrategyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeploymentStrategyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeploymentStrategyInput>
    public typealias MOutput = OperationOutput<DeleteDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeploymentStrategyOutputError>
}

public struct DeleteDeploymentStrategyInput: Equatable {
    /// <p>The ID of the deployment strategy you want to delete.</p>
    public let deploymentStrategyId: String?

    public init (
        deploymentStrategyId: String? = nil
    )
    {
        self.deploymentStrategyId = deploymentStrategyId
    }
}

struct DeleteDeploymentStrategyInputBody: Equatable {
}

extension DeleteDeploymentStrategyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDeploymentStrategyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeploymentStrategyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeploymentStrategyOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeploymentStrategyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDeploymentStrategyOutputResponse()"}
}

extension DeleteDeploymentStrategyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeploymentStrategyOutputResponse: Equatable {

    public init() {}
}

struct DeleteDeploymentStrategyOutputResponseBody: Equatable {
}

extension DeleteDeploymentStrategyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEnvironmentInput(applicationId: \(String(describing: applicationId)), environmentId: \(String(describing: environmentId)))"}
}

extension DeleteEnvironmentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEnvironmentInput>
    public typealias MOutput = OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEnvironmentInput>
    public typealias MOutput = OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInput: Equatable {
    /// <p>The application ID that includes the environment you want to delete.</p>
    public let applicationId: String?
    /// <p>The ID of the environment you want to delete.</p>
    public let environmentId: String?

    public init (
        applicationId: String? = nil,
        environmentId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.environmentId = environmentId
    }
}

struct DeleteEnvironmentInputBody: Equatable {
}

extension DeleteEnvironmentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEnvironmentOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEnvironmentOutputResponse()"}
}

extension DeleteEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEnvironmentOutputResponse: Equatable {

    public init() {}
}

struct DeleteEnvironmentOutputResponseBody: Equatable {
}

extension DeleteEnvironmentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteHostedConfigurationVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteHostedConfigurationVersionInput(applicationId: \(String(describing: applicationId)), configurationProfileId: \(String(describing: configurationProfileId)), versionNumber: \(String(describing: versionNumber)))"}
}

extension DeleteHostedConfigurationVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteHostedConfigurationVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteHostedConfigurationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHostedConfigurationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHostedConfigurationVersionInput>
    public typealias MOutput = OperationOutput<DeleteHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHostedConfigurationVersionOutputError>
}

public struct DeleteHostedConfigurationVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteHostedConfigurationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteHostedConfigurationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteHostedConfigurationVersionInput>
    public typealias MOutput = OperationOutput<DeleteHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteHostedConfigurationVersionOutputError>
}

public struct DeleteHostedConfigurationVersionInput: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The configuration profile ID.</p>
    public let configurationProfileId: String?
    /// <p>The versions number to delete.</p>
    public let versionNumber: Int

    public init (
        applicationId: String? = nil,
        configurationProfileId: String? = nil,
        versionNumber: Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.versionNumber = versionNumber
    }
}

struct DeleteHostedConfigurationVersionInputBody: Equatable {
}

extension DeleteHostedConfigurationVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteHostedConfigurationVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHostedConfigurationVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHostedConfigurationVersionOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHostedConfigurationVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteHostedConfigurationVersionOutputResponse()"}
}

extension DeleteHostedConfigurationVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteHostedConfigurationVersionOutputResponse: Equatable {

    public init() {}
}

struct DeleteHostedConfigurationVersionOutputResponseBody: Equatable {
}

extension DeleteHostedConfigurationVersionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeploymentEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case eventType = "EventType"
        case occurredAt = "OccurredAt"
        case triggeredBy = "TriggeredBy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let occurredAt = occurredAt {
            try encodeContainer.encode(occurredAt.timeIntervalSince1970, forKey: .occurredAt)
        }
        if let triggeredBy = triggeredBy {
            try encodeContainer.encode(triggeredBy.rawValue, forKey: .triggeredBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeDecoded = try containerValues.decodeIfPresent(DeploymentEventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let triggeredByDecoded = try containerValues.decodeIfPresent(TriggeredBy.self, forKey: .triggeredBy)
        triggeredBy = triggeredByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let occurredAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .occurredAt)
        occurredAt = occurredAtDecoded
    }
}

extension DeploymentEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeploymentEvent(description: \(String(describing: description)), eventType: \(String(describing: eventType)), occurredAt: \(String(describing: occurredAt)), triggeredBy: \(String(describing: triggeredBy)))"}
}

/// <p>An object that describes a deployment event.</p>
public struct DeploymentEvent: Equatable {
    /// <p>A description of the deployment event. Descriptions include, but are not limited to, the
    ///          user account or the CloudWatch alarm ARN that initiated a rollback, the percentage of hosts
    ///          that received the deployment, or in the case of an internal error, a recommendation to
    ///          attempt a new deployment.</p>
    public let description: String?
    /// <p>The type of deployment event. Deployment event types include the start, stop, or
    ///          completion of a deployment; a percentage update; the start or stop of a bake period; the
    ///          start or completion of a rollback.</p>
    public let eventType: DeploymentEventType?
    /// <p>The date and time the event occurred.</p>
    public let occurredAt: Date?
    /// <p>The entity that triggered the deployment event. Events can be triggered by a user, AWS
    ///          AppConfig, an Amazon CloudWatch alarm, or an internal error.</p>
    public let triggeredBy: TriggeredBy?

    public init (
        description: String? = nil,
        eventType: DeploymentEventType? = nil,
        occurredAt: Date? = nil,
        triggeredBy: TriggeredBy? = nil
    )
    {
        self.description = description
        self.eventType = eventType
        self.occurredAt = occurredAt
        self.triggeredBy = triggeredBy
    }
}

public enum DeploymentEventType {
    case bakeTimeStarted
    case deploymentCompleted
    case deploymentStarted
    case percentageUpdated
    case rollbackCompleted
    case rollbackStarted
    case sdkUnknown(String)
}

extension DeploymentEventType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeploymentEventType] {
        return [
            .bakeTimeStarted,
            .deploymentCompleted,
            .deploymentStarted,
            .percentageUpdated,
            .rollbackCompleted,
            .rollbackStarted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bakeTimeStarted: return "BAKE_TIME_STARTED"
        case .deploymentCompleted: return "DEPLOYMENT_COMPLETED"
        case .deploymentStarted: return "DEPLOYMENT_STARTED"
        case .percentageUpdated: return "PERCENTAGE_UPDATED"
        case .rollbackCompleted: return "ROLLBACK_COMPLETED"
        case .rollbackStarted: return "ROLLBACK_STARTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeploymentEventType(rawValue: rawValue) ?? DeploymentEventType.sdkUnknown(rawValue)
    }
}

public enum DeploymentState {
    case baking
    case complete
    case deploying
    case rolledBack
    case rollingBack
    case validating
    case sdkUnknown(String)
}

extension DeploymentState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeploymentState] {
        return [
            .baking,
            .complete,
            .deploying,
            .rolledBack,
            .rollingBack,
            .validating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .baking: return "BAKING"
        case .complete: return "COMPLETE"
        case .deploying: return "DEPLOYING"
        case .rolledBack: return "ROLLED_BACK"
        case .rollingBack: return "ROLLING_BACK"
        case .validating: return "VALIDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeploymentState(rawValue: rawValue) ?? DeploymentState.sdkUnknown(rawValue)
    }
}

extension DeploymentStrategy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case id = "Id"
        case name = "Name"
        case replicateTo = "ReplicateTo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deploymentDurationInMinutes != 0 {
            try encodeContainer.encode(deploymentDurationInMinutes, forKey: .deploymentDurationInMinutes)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if finalBakeTimeInMinutes != 0 {
            try encodeContainer.encode(finalBakeTimeInMinutes, forKey: .finalBakeTimeInMinutes)
        }
        if growthFactor != 0.0 {
            try encodeContainer.encode(growthFactor, forKey: .growthFactor)
        }
        if let growthType = growthType {
            try encodeContainer.encode(growthType.rawValue, forKey: .growthType)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let replicateTo = replicateTo {
            try encodeContainer.encode(replicateTo.rawValue, forKey: .replicateTo)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
    }
}

extension DeploymentStrategy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeploymentStrategy(deploymentDurationInMinutes: \(String(describing: deploymentDurationInMinutes)), description: \(String(describing: description)), finalBakeTimeInMinutes: \(String(describing: finalBakeTimeInMinutes)), growthFactor: \(String(describing: growthFactor)), growthType: \(String(describing: growthType)), id: \(String(describing: id)), name: \(String(describing: name)), replicateTo: \(String(describing: replicateTo)))"}
}

public struct DeploymentStrategy: Equatable {
    /// <p>Total amount of time the deployment lasted.</p>
    public let deploymentDurationInMinutes: Int
    /// <p>The description of the deployment strategy.</p>
    public let description: String?
    /// <p>The amount of time AppConfig monitored for alarms before considering the deployment to be
    ///          complete and no longer eligible for automatic roll back.</p>
    public let finalBakeTimeInMinutes: Int
    /// <p>The percentage of targets that received a deployed configuration during each
    ///          interval.</p>
    public let growthFactor: Float
    /// <p>The algorithm used to define how percentage grew over time.</p>
    public let growthType: GrowthType?
    /// <p>The deployment strategy ID.</p>
    public let id: String?
    /// <p>The name of the deployment strategy.</p>
    public let name: String?
    /// <p>Save the deployment strategy to a Systems Manager (SSM) document.</p>
    public let replicateTo: ReplicateTo?

    public init (
        deploymentDurationInMinutes: Int = 0,
        description: String? = nil,
        finalBakeTimeInMinutes: Int = 0,
        growthFactor: Float = 0.0,
        growthType: GrowthType? = nil,
        id: String? = nil,
        name: String? = nil,
        replicateTo: ReplicateTo? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.id = id
        self.name = name
        self.replicateTo = replicateTo
    }
}

extension DeploymentSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case completedAt = "CompletedAt"
        case configurationName = "ConfigurationName"
        case configurationVersion = "ConfigurationVersion"
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case deploymentNumber = "DeploymentNumber"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case percentageComplete = "PercentageComplete"
        case startedAt = "StartedAt"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completedAt = completedAt {
            try encodeContainer.encode(completedAt.timeIntervalSince1970, forKey: .completedAt)
        }
        if let configurationName = configurationName {
            try encodeContainer.encode(configurationName, forKey: .configurationName)
        }
        if let configurationVersion = configurationVersion {
            try encodeContainer.encode(configurationVersion, forKey: .configurationVersion)
        }
        if deploymentDurationInMinutes != 0 {
            try encodeContainer.encode(deploymentDurationInMinutes, forKey: .deploymentDurationInMinutes)
        }
        if deploymentNumber != 0 {
            try encodeContainer.encode(deploymentNumber, forKey: .deploymentNumber)
        }
        if finalBakeTimeInMinutes != 0 {
            try encodeContainer.encode(finalBakeTimeInMinutes, forKey: .finalBakeTimeInMinutes)
        }
        if growthFactor != 0.0 {
            try encodeContainer.encode(growthFactor, forKey: .growthFactor)
        }
        if let growthType = growthType {
            try encodeContainer.encode(growthType.rawValue, forKey: .growthType)
        }
        if percentageComplete != 0.0 {
            try encodeContainer.encode(percentageComplete, forKey: .percentageComplete)
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentNumberDecoded = try containerValues.decode(Int.self, forKey: .deploymentNumber)
        deploymentNumber = deploymentNumberDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DeploymentState.self, forKey: .state)
        state = stateDecoded
        let percentageCompleteDecoded = try containerValues.decode(Float.self, forKey: .percentageComplete)
        percentageComplete = percentageCompleteDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
    }
}

extension DeploymentSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeploymentSummary(completedAt: \(String(describing: completedAt)), configurationName: \(String(describing: configurationName)), configurationVersion: \(String(describing: configurationVersion)), deploymentDurationInMinutes: \(String(describing: deploymentDurationInMinutes)), deploymentNumber: \(String(describing: deploymentNumber)), finalBakeTimeInMinutes: \(String(describing: finalBakeTimeInMinutes)), growthFactor: \(String(describing: growthFactor)), growthType: \(String(describing: growthType)), percentageComplete: \(String(describing: percentageComplete)), startedAt: \(String(describing: startedAt)), state: \(String(describing: state)))"}
}

/// <p>Information about the deployment.</p>
public struct DeploymentSummary: Equatable {
    /// <p>Time the deployment completed.</p>
    public let completedAt: Date?
    /// <p>The name of the configuration.</p>
    public let configurationName: String?
    /// <p>The version of the configuration.</p>
    public let configurationVersion: String?
    /// <p>Total amount of time the deployment lasted.</p>
    public let deploymentDurationInMinutes: Int
    /// <p>The sequence number of the deployment.</p>
    public let deploymentNumber: Int
    /// <p>The amount of time AppConfig monitors for alarms before considering the deployment to be
    ///          complete and no longer eligible for automatic roll back.</p>
    public let finalBakeTimeInMinutes: Int
    /// <p>The percentage of targets to receive a deployed configuration during each
    ///          interval.</p>
    public let growthFactor: Float
    /// <p>The algorithm used to define how percentage grows over time.</p>
    public let growthType: GrowthType?
    /// <p>The percentage of targets for which the deployment is available.</p>
    public let percentageComplete: Float
    /// <p>Time the deployment started.</p>
    public let startedAt: Date?
    /// <p>The state of the deployment.</p>
    public let state: DeploymentState?

    public init (
        completedAt: Date? = nil,
        configurationName: String? = nil,
        configurationVersion: String? = nil,
        deploymentDurationInMinutes: Int = 0,
        deploymentNumber: Int = 0,
        finalBakeTimeInMinutes: Int = 0,
        growthFactor: Float = 0.0,
        growthType: GrowthType? = nil,
        percentageComplete: Float = 0.0,
        startedAt: Date? = nil,
        state: DeploymentState? = nil
    )
    {
        self.completedAt = completedAt
        self.configurationName = configurationName
        self.configurationVersion = configurationVersion
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.deploymentNumber = deploymentNumber
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.percentageComplete = percentageComplete
        self.startedAt = startedAt
        self.state = state
    }
}

extension Environment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case monitors = "Monitors"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let monitors = monitors {
            var monitorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitors)
            for monitorlist0 in monitors {
                try monitorsContainer.encode(monitorlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

extension Environment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Environment(applicationId: \(String(describing: applicationId)), description: \(String(describing: description)), id: \(String(describing: id)), monitors: \(String(describing: monitors)), name: \(String(describing: name)), state: \(String(describing: state)))"}
}

public struct Environment: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The description of the environment.</p>
    public let description: String?
    /// <p>The environment ID.</p>
    public let id: String?
    /// <p>Amazon CloudWatch alarms monitored during the deployment.</p>
    public let monitors: [Monitor]?
    /// <p>The name of the environment.</p>
    public let name: String?
    /// <p>The state of the environment. An environment can be in one of the following states:
    ///             <code>READY_FOR_DEPLOYMENT</code>, <code>DEPLOYING</code>, <code>ROLLING_BACK</code>, or
    ///             <code>ROLLED_BACK</code>
    ///          </p>
    public let state: EnvironmentState?

    public init (
        applicationId: String? = nil,
        description: String? = nil,
        id: String? = nil,
        monitors: [Monitor]? = nil,
        name: String? = nil,
        state: EnvironmentState? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.monitors = monitors
        self.name = name
        self.state = state
    }
}

public enum EnvironmentState {
    case deploying
    case readyForDeployment
    case rolledBack
    case rollingBack
    case sdkUnknown(String)
}

extension EnvironmentState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EnvironmentState] {
        return [
            .deploying,
            .readyForDeployment,
            .rolledBack,
            .rollingBack,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deploying: return "DEPLOYING"
        case .readyForDeployment: return "READY_FOR_DEPLOYMENT"
        case .rolledBack: return "ROLLED_BACK"
        case .rollingBack: return "ROLLING_BACK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EnvironmentState(rawValue: rawValue) ?? EnvironmentState.sdkUnknown(rawValue)
    }
}

extension GetApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApplicationInput(applicationId: \(String(describing: applicationId)))"}
}

extension GetApplicationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "GetApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApplicationInput>
    public typealias MOutput = OperationOutput<GetApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApplicationOutputError>
}

public struct GetApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApplicationInput>
    public typealias MOutput = OperationOutput<GetApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApplicationOutputError>
}

public struct GetApplicationInput: Equatable {
    /// <p>The ID of the application you want to get.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetApplicationInputBody: Equatable {
}

extension GetApplicationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApplicationOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApplicationOutputResponse(description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

extension GetApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.name = output.name
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct GetApplicationOutputResponse: Equatable {
    /// <p>The description of the application.</p>
    public let description: String?
    /// <p>The application ID.</p>
    public let id: String?
    /// <p>The application name.</p>
    public let name: String?

    public init (
        description: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct GetApplicationOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
}

extension GetApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GetConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConfigurationInput(application: \(String(describing: application)), clientConfigurationVersion: \(String(describing: clientConfigurationVersion)), clientId: \(String(describing: clientId)), configuration: \(String(describing: configuration)), environment: \(String(describing: environment)))"}
}

extension GetConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigurationInput>
    public typealias MOutput = OperationOutput<GetConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigurationOutputError>
}

public struct GetConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientId = input.operationInput.clientId {
            let clientIdQueryItem = URLQueryItem(name: "client_id".urlPercentEncoding(), value: String(clientId).urlPercentEncoding())
            input.builder.withQueryItem(clientIdQueryItem)
        }
        if let clientConfigurationVersion = input.operationInput.clientConfigurationVersion {
            let clientConfigurationVersionQueryItem = URLQueryItem(name: "client_configuration_version".urlPercentEncoding(), value: String(clientConfigurationVersion).urlPercentEncoding())
            input.builder.withQueryItem(clientConfigurationVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigurationInput>
    public typealias MOutput = OperationOutput<GetConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigurationOutputError>
}

public struct GetConfigurationInput: Equatable {
    /// <p>The application to get. Specify either the application name or the application
    ///          ID.</p>
    public let application: String?
    /// <p>The configuration version returned in the most recent <code>GetConfiguration</code>
    ///          response.</p>
    ///          <important>
    ///             <p>AWS AppConfig uses the value of the <code>ClientConfigurationVersion</code> parameter
    ///             to identify the configuration version on your clients. If you dont send
    ///                <code>ClientConfigurationVersion</code> with each call to
    ///                <code>GetConfiguration</code>, your clients receive the current configuration. You
    ///             are charged each time your clients receive a configuration.</p>
    ///             <p>To avoid excess charges, we recommend that you include the
    ///                <code>ClientConfigurationVersion</code> value with every call to
    ///                <code>GetConfiguration</code>. This value must be saved on your client. Subsequent
    ///             calls to <code>GetConfiguration</code> must pass this value by using the
    ///                <code>ClientConfigurationVersion</code> parameter. </p>
    ///          </important>
    ///          <p>For more information about working with configurations, see <a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/appconfig-retrieving-the-configuration.html">Retrieving the Configuration</a> in the
    ///          <i>AWS AppConfig User Guide</i>.</p>
    public let clientConfigurationVersion: String?
    /// <p>A unique ID to identify the client for the configuration. This ID enables AppConfig to
    ///          deploy the configuration in intervals, as defined in the deployment strategy.</p>
    public let clientId: String?
    /// <p>The configuration to get. Specify either the configuration name or the configuration
    ///          ID.</p>
    public let configuration: String?
    /// <p>The environment to get. Specify either the environment name or the environment
    ///          ID.</p>
    public let environment: String?

    public init (
        application: String? = nil,
        clientConfigurationVersion: String? = nil,
        clientId: String? = nil,
        configuration: String? = nil,
        environment: String? = nil
    )
    {
        self.application = application
        self.clientConfigurationVersion = clientConfigurationVersion
        self.clientId = clientId
        self.configuration = configuration
        self.environment = environment
    }
}

struct GetConfigurationInputBody: Equatable {
}

extension GetConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigurationOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConfigurationOutputResponse(configurationVersion: \(String(describing: configurationVersion)), content: \(String(describing: content)), contentType: \(String(describing: contentType)))"}
}

extension GetConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let configurationVersionHeaderValue = httpResponse.headers.value(for: "Configuration-Version") {
            self.configurationVersion = configurationVersionHeaderValue
        } else {
            self.configurationVersion = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.content = data
        } else {
            self.content = nil
        }
    }
}

public struct GetConfigurationOutputResponse: Equatable {
    /// <p>The configuration version.</p>
    public let configurationVersion: String?
    /// <p>The content of the configuration or the configuration data.</p>
    public let content: Data?
    /// <p>A standard MIME type describing the format of the configuration content. For more
    ///          information, see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">Content-Type</a>.</p>
    public let contentType: String?

    public init (
        configurationVersion: String? = nil,
        content: Data? = nil,
        contentType: String? = nil
    )
    {
        self.configurationVersion = configurationVersion
        self.content = content
        self.contentType = contentType
    }
}

struct GetConfigurationOutputResponseBody: Equatable {
    public let content: Data?
}

extension GetConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .content)
        content = contentDecoded
    }
}

extension GetConfigurationProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConfigurationProfileInput(applicationId: \(String(describing: applicationId)), configurationProfileId: \(String(describing: configurationProfileId)))"}
}

extension GetConfigurationProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetConfigurationProfileInputHeadersMiddleware: Middleware {
    public let id: String = "GetConfigurationProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigurationProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigurationProfileInput>
    public typealias MOutput = OperationOutput<GetConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigurationProfileOutputError>
}

public struct GetConfigurationProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConfigurationProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigurationProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigurationProfileInput>
    public typealias MOutput = OperationOutput<GetConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigurationProfileOutputError>
}

public struct GetConfigurationProfileInput: Equatable {
    /// <p>The ID of the application that includes the configuration profile you want to
    ///          get.</p>
    public let applicationId: String?
    /// <p>The ID of the configuration profile you want to get.</p>
    public let configurationProfileId: String?

    public init (
        applicationId: String? = nil,
        configurationProfileId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
    }
}

struct GetConfigurationProfileInputBody: Equatable {
}

extension GetConfigurationProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetConfigurationProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigurationProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigurationProfileOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigurationProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConfigurationProfileOutputResponse(applicationId: \(String(describing: applicationId)), description: \(String(describing: description)), id: \(String(describing: id)), locationUri: \(String(describing: locationUri)), name: \(String(describing: name)), retrievalRoleArn: \(String(describing: retrievalRoleArn)), validators: \(String(describing: validators)))"}
}

extension GetConfigurationProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetConfigurationProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.locationUri = output.locationUri
            self.name = output.name
            self.retrievalRoleArn = output.retrievalRoleArn
            self.validators = output.validators
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.locationUri = nil
            self.name = nil
            self.retrievalRoleArn = nil
            self.validators = nil
        }
    }
}

public struct GetConfigurationProfileOutputResponse: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The configuration profile description.</p>
    public let description: String?
    /// <p>The configuration profile ID.</p>
    public let id: String?
    /// <p>The URI location of the configuration.</p>
    public let locationUri: String?
    /// <p>The name of the configuration profile.</p>
    public let name: String?
    /// <p>The ARN of an IAM role with permission to access the configuration at the specified
    ///          LocationUri.</p>
    public let retrievalRoleArn: String?
    /// <p>A list of methods for validating the configuration.</p>
    public let validators: [Validator]?

    public init (
        applicationId: String? = nil,
        description: String? = nil,
        id: String? = nil,
        locationUri: String? = nil,
        name: String? = nil,
        retrievalRoleArn: String? = nil,
        validators: [Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.locationUri = locationUri
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.validators = validators
    }
}

struct GetConfigurationProfileOutputResponseBody: Equatable {
    public let applicationId: String?
    public let id: String?
    public let name: String?
    public let description: String?
    public let locationUri: String?
    public let retrievalRoleArn: String?
    public let validators: [Validator]?
}

extension GetConfigurationProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case validators = "Validators"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([Validator?].self, forKey: .validators)
        var validatorsDecoded0:[Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
    }
}

extension GetDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeploymentInput(applicationId: \(String(describing: applicationId)), deploymentNumber: \(String(describing: deploymentNumber)), environmentId: \(String(describing: environmentId)))"}
}

extension GetDeploymentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeploymentInput>
    public typealias MOutput = OperationOutput<GetDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeploymentOutputError>
}

public struct GetDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeploymentInput>
    public typealias MOutput = OperationOutput<GetDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeploymentOutputError>
}

public struct GetDeploymentInput: Equatable {
    /// <p>The ID of the application that includes the deployment you want to get. </p>
    public let applicationId: String?
    /// <p>The sequence number of the deployment.</p>
    public let deploymentNumber: Int
    /// <p>The ID of the environment that includes the deployment you want to get. </p>
    public let environmentId: String?

    public init (
        applicationId: String? = nil,
        deploymentNumber: Int = 0,
        environmentId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.deploymentNumber = deploymentNumber
        self.environmentId = environmentId
    }
}

struct GetDeploymentInputBody: Equatable {
}

extension GetDeploymentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeploymentOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeploymentOutputResponse(applicationId: \(String(describing: applicationId)), completedAt: \(String(describing: completedAt)), configurationLocationUri: \(String(describing: configurationLocationUri)), configurationName: \(String(describing: configurationName)), configurationProfileId: \(String(describing: configurationProfileId)), configurationVersion: \(String(describing: configurationVersion)), deploymentDurationInMinutes: \(String(describing: deploymentDurationInMinutes)), deploymentNumber: \(String(describing: deploymentNumber)), deploymentStrategyId: \(String(describing: deploymentStrategyId)), description: \(String(describing: description)), environmentId: \(String(describing: environmentId)), eventLog: \(String(describing: eventLog)), finalBakeTimeInMinutes: \(String(describing: finalBakeTimeInMinutes)), growthFactor: \(String(describing: growthFactor)), growthType: \(String(describing: growthType)), percentageComplete: \(String(describing: percentageComplete)), startedAt: \(String(describing: startedAt)), state: \(String(describing: state)))"}
}

extension GetDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.completedAt = output.completedAt
            self.configurationLocationUri = output.configurationLocationUri
            self.configurationName = output.configurationName
            self.configurationProfileId = output.configurationProfileId
            self.configurationVersion = output.configurationVersion
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.deploymentNumber = output.deploymentNumber
            self.deploymentStrategyId = output.deploymentStrategyId
            self.description = output.description
            self.environmentId = output.environmentId
            self.eventLog = output.eventLog
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.percentageComplete = output.percentageComplete
            self.startedAt = output.startedAt
            self.state = output.state
        } else {
            self.applicationId = nil
            self.completedAt = nil
            self.configurationLocationUri = nil
            self.configurationName = nil
            self.configurationProfileId = nil
            self.configurationVersion = nil
            self.deploymentDurationInMinutes = 0
            self.deploymentNumber = 0
            self.deploymentStrategyId = nil
            self.description = nil
            self.environmentId = nil
            self.eventLog = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = 0.0
            self.growthType = nil
            self.percentageComplete = 0.0
            self.startedAt = nil
            self.state = nil
        }
    }
}

public struct GetDeploymentOutputResponse: Equatable {
    /// <p>The ID of the application that was deployed.</p>
    public let applicationId: String?
    /// <p>The time the deployment completed. </p>
    public let completedAt: Date?
    /// <p>Information about the source location of the configuration.</p>
    public let configurationLocationUri: String?
    /// <p>The name of the configuration.</p>
    public let configurationName: String?
    /// <p>The ID of the configuration profile that was deployed.</p>
    public let configurationProfileId: String?
    /// <p>The configuration version that was deployed.</p>
    public let configurationVersion: String?
    /// <p>Total amount of time the deployment lasted.</p>
    public let deploymentDurationInMinutes: Int
    /// <p>The sequence number of the deployment.</p>
    public let deploymentNumber: Int
    /// <p>The ID of the deployment strategy that was deployed.</p>
    public let deploymentStrategyId: String?
    /// <p>The description of the deployment.</p>
    public let description: String?
    /// <p>The ID of the environment that was deployed.</p>
    public let environmentId: String?
    /// <p>A list containing all events related to a deployment. The most recent events are
    ///          displayed first.</p>
    public let eventLog: [DeploymentEvent]?
    /// <p>The amount of time AppConfig monitored for alarms before considering the deployment to be
    ///          complete and no longer eligible for automatic roll back.</p>
    public let finalBakeTimeInMinutes: Int
    /// <p>The percentage of targets to receive a deployed configuration during each
    ///          interval.</p>
    public let growthFactor: Float
    /// <p>The algorithm used to define how percentage grew over time.</p>
    public let growthType: GrowthType?
    /// <p>The percentage of targets for which the deployment is available.</p>
    public let percentageComplete: Float
    /// <p>The time the deployment started.</p>
    public let startedAt: Date?
    /// <p>The state of the deployment.</p>
    public let state: DeploymentState?

    public init (
        applicationId: String? = nil,
        completedAt: Date? = nil,
        configurationLocationUri: String? = nil,
        configurationName: String? = nil,
        configurationProfileId: String? = nil,
        configurationVersion: String? = nil,
        deploymentDurationInMinutes: Int = 0,
        deploymentNumber: Int = 0,
        deploymentStrategyId: String? = nil,
        description: String? = nil,
        environmentId: String? = nil,
        eventLog: [DeploymentEvent]? = nil,
        finalBakeTimeInMinutes: Int = 0,
        growthFactor: Float = 0.0,
        growthType: GrowthType? = nil,
        percentageComplete: Float = 0.0,
        startedAt: Date? = nil,
        state: DeploymentState? = nil
    )
    {
        self.applicationId = applicationId
        self.completedAt = completedAt
        self.configurationLocationUri = configurationLocationUri
        self.configurationName = configurationName
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.deploymentNumber = deploymentNumber
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.environmentId = environmentId
        self.eventLog = eventLog
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.percentageComplete = percentageComplete
        self.startedAt = startedAt
        self.state = state
    }
}

struct GetDeploymentOutputResponseBody: Equatable {
    public let applicationId: String?
    public let environmentId: String?
    public let deploymentStrategyId: String?
    public let configurationProfileId: String?
    public let deploymentNumber: Int
    public let configurationName: String?
    public let configurationLocationUri: String?
    public let configurationVersion: String?
    public let description: String?
    public let deploymentDurationInMinutes: Int
    public let growthType: GrowthType?
    public let growthFactor: Float
    public let finalBakeTimeInMinutes: Int
    public let state: DeploymentState?
    public let eventLog: [DeploymentEvent]?
    public let percentageComplete: Float
    public let startedAt: Date?
    public let completedAt: Date?
}

extension GetDeploymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case completedAt = "CompletedAt"
        case configurationLocationUri = "ConfigurationLocationUri"
        case configurationName = "ConfigurationName"
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case deploymentNumber = "DeploymentNumber"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case environmentId = "EnvironmentId"
        case eventLog = "EventLog"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case percentageComplete = "PercentageComplete"
        case startedAt = "StartedAt"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let deploymentStrategyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentStrategyId)
        deploymentStrategyId = deploymentStrategyIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let deploymentNumberDecoded = try containerValues.decode(Int.self, forKey: .deploymentNumber)
        deploymentNumber = deploymentNumberDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let configurationLocationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationLocationUri)
        configurationLocationUri = configurationLocationUriDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DeploymentState.self, forKey: .state)
        state = stateDecoded
        let eventLogContainer = try containerValues.decodeIfPresent([DeploymentEvent?].self, forKey: .eventLog)
        var eventLogDecoded0:[DeploymentEvent]? = nil
        if let eventLogContainer = eventLogContainer {
            eventLogDecoded0 = [DeploymentEvent]()
            for structure0 in eventLogContainer {
                if let structure0 = structure0 {
                    eventLogDecoded0?.append(structure0)
                }
            }
        }
        eventLog = eventLogDecoded0
        let percentageCompleteDecoded = try containerValues.decode(Float.self, forKey: .percentageComplete)
        percentageComplete = percentageCompleteDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
    }
}

extension GetDeploymentStrategyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeploymentStrategyInput(deploymentStrategyId: \(String(describing: deploymentStrategyId)))"}
}

extension GetDeploymentStrategyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDeploymentStrategyInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeploymentStrategyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeploymentStrategyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeploymentStrategyInput>
    public typealias MOutput = OperationOutput<GetDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeploymentStrategyOutputError>
}

public struct GetDeploymentStrategyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeploymentStrategyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeploymentStrategyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeploymentStrategyInput>
    public typealias MOutput = OperationOutput<GetDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeploymentStrategyOutputError>
}

public struct GetDeploymentStrategyInput: Equatable {
    /// <p>The ID of the deployment strategy to get.</p>
    public let deploymentStrategyId: String?

    public init (
        deploymentStrategyId: String? = nil
    )
    {
        self.deploymentStrategyId = deploymentStrategyId
    }
}

struct GetDeploymentStrategyInputBody: Equatable {
}

extension GetDeploymentStrategyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDeploymentStrategyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeploymentStrategyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeploymentStrategyOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeploymentStrategyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeploymentStrategyOutputResponse(deploymentDurationInMinutes: \(String(describing: deploymentDurationInMinutes)), description: \(String(describing: description)), finalBakeTimeInMinutes: \(String(describing: finalBakeTimeInMinutes)), growthFactor: \(String(describing: growthFactor)), growthType: \(String(describing: growthType)), id: \(String(describing: id)), name: \(String(describing: name)), replicateTo: \(String(describing: replicateTo)))"}
}

extension GetDeploymentStrategyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeploymentStrategyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.description = output.description
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.id = output.id
            self.name = output.name
            self.replicateTo = output.replicateTo
        } else {
            self.deploymentDurationInMinutes = 0
            self.description = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = 0.0
            self.growthType = nil
            self.id = nil
            self.name = nil
            self.replicateTo = nil
        }
    }
}

public struct GetDeploymentStrategyOutputResponse: Equatable {
    /// <p>Total amount of time the deployment lasted.</p>
    public let deploymentDurationInMinutes: Int
    /// <p>The description of the deployment strategy.</p>
    public let description: String?
    /// <p>The amount of time AppConfig monitored for alarms before considering the deployment to be
    ///          complete and no longer eligible for automatic roll back.</p>
    public let finalBakeTimeInMinutes: Int
    /// <p>The percentage of targets that received a deployed configuration during each
    ///          interval.</p>
    public let growthFactor: Float
    /// <p>The algorithm used to define how percentage grew over time.</p>
    public let growthType: GrowthType?
    /// <p>The deployment strategy ID.</p>
    public let id: String?
    /// <p>The name of the deployment strategy.</p>
    public let name: String?
    /// <p>Save the deployment strategy to a Systems Manager (SSM) document.</p>
    public let replicateTo: ReplicateTo?

    public init (
        deploymentDurationInMinutes: Int = 0,
        description: String? = nil,
        finalBakeTimeInMinutes: Int = 0,
        growthFactor: Float = 0.0,
        growthType: GrowthType? = nil,
        id: String? = nil,
        name: String? = nil,
        replicateTo: ReplicateTo? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.id = id
        self.name = name
        self.replicateTo = replicateTo
    }
}

struct GetDeploymentStrategyOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
    public let deploymentDurationInMinutes: Int
    public let growthType: GrowthType?
    public let growthFactor: Float
    public let finalBakeTimeInMinutes: Int
    public let replicateTo: ReplicateTo?
}

extension GetDeploymentStrategyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case id = "Id"
        case name = "Name"
        case replicateTo = "ReplicateTo"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
    }
}

extension GetEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEnvironmentInput(applicationId: \(String(describing: applicationId)), environmentId: \(String(describing: environmentId)))"}
}

extension GetEnvironmentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "GetEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEnvironmentInput>
    public typealias MOutput = OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEnvironmentOutputError>
}

public struct GetEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEnvironmentInput>
    public typealias MOutput = OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEnvironmentOutputError>
}

public struct GetEnvironmentInput: Equatable {
    /// <p>The ID of the application that includes the environment you want to get.</p>
    public let applicationId: String?
    /// <p>The ID of the environment you wnat to get.</p>
    public let environmentId: String?

    public init (
        applicationId: String? = nil,
        environmentId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.environmentId = environmentId
    }
}

struct GetEnvironmentInputBody: Equatable {
}

extension GetEnvironmentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEnvironmentOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEnvironmentOutputResponse(applicationId: \(String(describing: applicationId)), description: \(String(describing: description)), id: \(String(describing: id)), monitors: \(String(describing: monitors)), name: \(String(describing: name)), state: \(String(describing: state)))"}
}

extension GetEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.monitors = output.monitors
            self.name = output.name
            self.state = output.state
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.monitors = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct GetEnvironmentOutputResponse: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The description of the environment.</p>
    public let description: String?
    /// <p>The environment ID.</p>
    public let id: String?
    /// <p>Amazon CloudWatch alarms monitored during the deployment.</p>
    public let monitors: [Monitor]?
    /// <p>The name of the environment.</p>
    public let name: String?
    /// <p>The state of the environment. An environment can be in one of the following states:
    ///             <code>READY_FOR_DEPLOYMENT</code>, <code>DEPLOYING</code>, <code>ROLLING_BACK</code>, or
    ///             <code>ROLLED_BACK</code>
    ///          </p>
    public let state: EnvironmentState?

    public init (
        applicationId: String? = nil,
        description: String? = nil,
        id: String? = nil,
        monitors: [Monitor]? = nil,
        name: String? = nil,
        state: EnvironmentState? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.monitors = monitors
        self.name = name
        self.state = state
    }
}

struct GetEnvironmentOutputResponseBody: Equatable {
    public let applicationId: String?
    public let id: String?
    public let name: String?
    public let description: String?
    public let state: EnvironmentState?
    public let monitors: [Monitor]?
}

extension GetEnvironmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case monitors = "Monitors"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

extension GetHostedConfigurationVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetHostedConfigurationVersionInput(applicationId: \(String(describing: applicationId)), configurationProfileId: \(String(describing: configurationProfileId)), versionNumber: \(String(describing: versionNumber)))"}
}

extension GetHostedConfigurationVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetHostedConfigurationVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetHostedConfigurationVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetHostedConfigurationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetHostedConfigurationVersionInput>
    public typealias MOutput = OperationOutput<GetHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetHostedConfigurationVersionOutputError>
}

public struct GetHostedConfigurationVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetHostedConfigurationVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetHostedConfigurationVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetHostedConfigurationVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetHostedConfigurationVersionInput>
    public typealias MOutput = OperationOutput<GetHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetHostedConfigurationVersionOutputError>
}

public struct GetHostedConfigurationVersionInput: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The configuration profile ID.</p>
    public let configurationProfileId: String?
    /// <p>The version.</p>
    public let versionNumber: Int

    public init (
        applicationId: String? = nil,
        configurationProfileId: String? = nil,
        versionNumber: Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.versionNumber = versionNumber
    }
}

struct GetHostedConfigurationVersionInputBody: Equatable {
}

extension GetHostedConfigurationVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetHostedConfigurationVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetHostedConfigurationVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetHostedConfigurationVersionOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetHostedConfigurationVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetHostedConfigurationVersionOutputResponse(applicationId: \(String(describing: applicationId)), configurationProfileId: \(String(describing: configurationProfileId)), content: \(String(describing: content)), contentType: \(String(describing: contentType)), description: \(String(describing: description)), versionNumber: \(String(describing: versionNumber)))"}
}

extension GetHostedConfigurationVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let applicationIdHeaderValue = httpResponse.headers.value(for: "Application-Id") {
            self.applicationId = applicationIdHeaderValue
        } else {
            self.applicationId = nil
        }
        if let configurationProfileIdHeaderValue = httpResponse.headers.value(for: "Configuration-Profile-Id") {
            self.configurationProfileId = configurationProfileIdHeaderValue
        } else {
            self.configurationProfileId = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let descriptionHeaderValue = httpResponse.headers.value(for: "Description") {
            self.description = descriptionHeaderValue
        } else {
            self.description = nil
        }
        if let versionNumberHeaderValue = httpResponse.headers.value(for: "Version-Number") {
            self.versionNumber = Int(versionNumberHeaderValue) ?? 0
        } else {
            self.versionNumber = 0
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.content = data
        } else {
            self.content = nil
        }
    }
}

public struct GetHostedConfigurationVersionOutputResponse: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The configuration profile ID.</p>
    public let configurationProfileId: String?
    /// <p>The content of the configuration or the configuration data.</p>
    public let content: Data?
    /// <p>A standard MIME type describing the format of the configuration content. For more
    ///          information, see <a href="https://docs.aws.amazon.com/https:/www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">Content-Type</a>.</p>
    public let contentType: String?
    /// <p>A description of the configuration.</p>
    public let description: String?
    /// <p>The configuration version.</p>
    public let versionNumber: Int

    public init (
        applicationId: String? = nil,
        configurationProfileId: String? = nil,
        content: Data? = nil,
        contentType: String? = nil,
        description: String? = nil,
        versionNumber: Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.content = content
        self.contentType = contentType
        self.description = description
        self.versionNumber = versionNumber
    }
}

struct GetHostedConfigurationVersionOutputResponseBody: Equatable {
    public let content: Data?
}

extension GetHostedConfigurationVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .content)
        content = contentDecoded
    }
}

public enum GrowthType {
    case exponential
    case linear
    case sdkUnknown(String)
}

extension GrowthType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GrowthType] {
        return [
            .exponential,
            .linear,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .exponential: return "EXPONENTIAL"
        case .linear: return "LINEAR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GrowthType(rawValue: rawValue) ?? GrowthType.sdkUnknown(rawValue)
    }
}

extension HostedConfigurationVersionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case configurationProfileId = "ConfigurationProfileId"
        case contentType = "ContentType"
        case description = "Description"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let configurationProfileId = configurationProfileId {
            try encodeContainer.encode(configurationProfileId, forKey: .configurationProfileId)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if versionNumber != 0 {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let versionNumberDecoded = try containerValues.decode(Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension HostedConfigurationVersionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HostedConfigurationVersionSummary(applicationId: \(String(describing: applicationId)), configurationProfileId: \(String(describing: configurationProfileId)), contentType: \(String(describing: contentType)), description: \(String(describing: description)), versionNumber: \(String(describing: versionNumber)))"}
}

/// <p>Information about the configuration.</p>
public struct HostedConfigurationVersionSummary: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The configuration profile ID.</p>
    public let configurationProfileId: String?
    /// <p>A standard MIME type describing the format of the configuration content. For more
    ///          information, see <a href="https://docs.aws.amazon.com/https:/www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17">Content-Type</a>.</p>
    public let contentType: String?
    /// <p>A description of the configuration.</p>
    public let description: String?
    /// <p>The configuration version.</p>
    public let versionNumber: Int

    public init (
        applicationId: String? = nil,
        configurationProfileId: String? = nil,
        contentType: String? = nil,
        description: String? = nil,
        versionNumber: Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.contentType = contentType
        self.description = description
        self.versionNumber = versionNumber
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was an internal failure in the AppConfig service.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListApplicationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next_token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "max_results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInput: Equatable {
    /// <p>The maximum number of items to return for this call. The call also returns a token that
    ///          you can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Equatable {
}

extension ListApplicationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListApplicationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutputResponse: Equatable {
    /// <p>The elements from this collection.</p>
    public let items: [Application]?
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///          results.</p>
    public let nextToken: String?

    public init (
        items: [Application]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputResponseBody: Equatable {
    public let items: [Application]?
    public let nextToken: String?
}

extension ListApplicationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Application?].self, forKey: .items)
        var itemsDecoded0:[Application]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Application]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConfigurationProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationProfilesInput(applicationId: \(String(describing: applicationId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConfigurationProfilesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListConfigurationProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "ListConfigurationProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationProfilesInput>
    public typealias MOutput = OperationOutput<ListConfigurationProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationProfilesOutputError>
}

public struct ListConfigurationProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConfigurationProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next_token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "max_results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationProfilesInput>
    public typealias MOutput = OperationOutput<ListConfigurationProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationProfilesOutputError>
}

public struct ListConfigurationProfilesInput: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The maximum number of items to return for this call. The call also returns a token that
    ///          you can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results.</p>
    public let nextToken: String?

    public init (
        applicationId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationProfilesInputBody: Equatable {
}

extension ListConfigurationProfilesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListConfigurationProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationProfilesOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationProfilesOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConfigurationProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConfigurationProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfigurationProfilesOutputResponse: Equatable {
    /// <p>The elements from this collection.</p>
    public let items: [ConfigurationProfileSummary]?
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///          results.</p>
    public let nextToken: String?

    public init (
        items: [ConfigurationProfileSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListConfigurationProfilesOutputResponseBody: Equatable {
    public let items: [ConfigurationProfileSummary]?
    public let nextToken: String?
}

extension ListConfigurationProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ConfigurationProfileSummary?].self, forKey: .items)
        var itemsDecoded0:[ConfigurationProfileSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ConfigurationProfileSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeploymentStrategiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeploymentStrategiesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeploymentStrategiesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDeploymentStrategiesInputHeadersMiddleware: Middleware {
    public let id: String = "ListDeploymentStrategiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeploymentStrategiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeploymentStrategiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeploymentStrategiesInput>
    public typealias MOutput = OperationOutput<ListDeploymentStrategiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeploymentStrategiesOutputError>
}

public struct ListDeploymentStrategiesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDeploymentStrategiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeploymentStrategiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeploymentStrategiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next_token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "max_results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeploymentStrategiesInput>
    public typealias MOutput = OperationOutput<ListDeploymentStrategiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeploymentStrategiesOutputError>
}

public struct ListDeploymentStrategiesInput: Equatable {
    /// <p>The maximum number of items to return for this call. The call also returns a token that
    ///          you can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeploymentStrategiesInputBody: Equatable {
}

extension ListDeploymentStrategiesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDeploymentStrategiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeploymentStrategiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeploymentStrategiesOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeploymentStrategiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeploymentStrategiesOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeploymentStrategiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDeploymentStrategiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentStrategiesOutputResponse: Equatable {
    /// <p>The elements from this collection.</p>
    public let items: [DeploymentStrategy]?
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///          results.</p>
    public let nextToken: String?

    public init (
        items: [DeploymentStrategy]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDeploymentStrategiesOutputResponseBody: Equatable {
    public let items: [DeploymentStrategy]?
    public let nextToken: String?
}

extension ListDeploymentStrategiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DeploymentStrategy?].self, forKey: .items)
        var itemsDecoded0:[DeploymentStrategy]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DeploymentStrategy]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeploymentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeploymentsInput(applicationId: \(String(describing: applicationId)), environmentId: \(String(describing: environmentId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeploymentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDeploymentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDeploymentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeploymentsInput>
    public typealias MOutput = OperationOutput<ListDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeploymentsOutputError>
}

public struct ListDeploymentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDeploymentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeploymentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeploymentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next_token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "max_results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeploymentsInput>
    public typealias MOutput = OperationOutput<ListDeploymentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeploymentsOutputError>
}

public struct ListDeploymentsInput: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The environment ID.</p>
    public let environmentId: String?
    /// <p>The maximum number of items to return for this call. The call also returns a token that
    ///          you can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results.</p>
    public let nextToken: String?

    public init (
        applicationId: String? = nil,
        environmentId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.applicationId = applicationId
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeploymentsInputBody: Equatable {
}

extension ListDeploymentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDeploymentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeploymentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeploymentsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeploymentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeploymentsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeploymentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentsOutputResponse: Equatable {
    /// <p>The elements from this collection.</p>
    public let items: [DeploymentSummary]?
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///          results.</p>
    public let nextToken: String?

    public init (
        items: [DeploymentSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDeploymentsOutputResponseBody: Equatable {
    public let items: [DeploymentSummary]?
    public let nextToken: String?
}

extension ListDeploymentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DeploymentSummary?].self, forKey: .items)
        var itemsDecoded0:[DeploymentSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DeploymentSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEnvironmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEnvironmentsInput(applicationId: \(String(describing: applicationId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEnvironmentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListEnvironmentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListEnvironmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEnvironmentsInput>
    public typealias MOutput = OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEnvironmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next_token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "max_results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEnvironmentsInput>
    public typealias MOutput = OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInput: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The maximum number of items to return for this call. The call also returns a token that
    ///          you can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results.</p>
    public let nextToken: String?

    public init (
        applicationId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsInputBody: Equatable {
}

extension ListEnvironmentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListEnvironmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEnvironmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEnvironmentsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEnvironmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEnvironmentsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEnvironmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEnvironmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentsOutputResponse: Equatable {
    /// <p>The elements from this collection.</p>
    public let items: [Environment]?
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///          results.</p>
    public let nextToken: String?

    public init (
        items: [Environment]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsOutputResponseBody: Equatable {
    public let items: [Environment]?
    public let nextToken: String?
}

extension ListEnvironmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Environment?].self, forKey: .items)
        var itemsDecoded0:[Environment]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Environment]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHostedConfigurationVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListHostedConfigurationVersionsInput(applicationId: \(String(describing: applicationId)), configurationProfileId: \(String(describing: configurationProfileId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListHostedConfigurationVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListHostedConfigurationVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListHostedConfigurationVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHostedConfigurationVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHostedConfigurationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHostedConfigurationVersionsInput>
    public typealias MOutput = OperationOutput<ListHostedConfigurationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHostedConfigurationVersionsOutputError>
}

public struct ListHostedConfigurationVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListHostedConfigurationVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListHostedConfigurationVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListHostedConfigurationVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next_token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "max_results".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListHostedConfigurationVersionsInput>
    public typealias MOutput = OperationOutput<ListHostedConfigurationVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListHostedConfigurationVersionsOutputError>
}

public struct ListHostedConfigurationVersionsInput: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The configuration profile ID.</p>
    public let configurationProfileId: String?
    /// <p>The maximum number of items to return for this call. The call also returns a token that
    ///          you can specify in a subsequent call to get the next set of results.</p>
    public let maxResults: Int
    /// <p>A token to start the list. Use this token to get the next set of results. </p>
    public let nextToken: String?

    public init (
        applicationId: String? = nil,
        configurationProfileId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListHostedConfigurationVersionsInputBody: Equatable {
}

extension ListHostedConfigurationVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListHostedConfigurationVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHostedConfigurationVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHostedConfigurationVersionsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHostedConfigurationVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListHostedConfigurationVersionsOutputResponse(items: \(String(describing: items)), nextToken: \(String(describing: nextToken)))"}
}

extension ListHostedConfigurationVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListHostedConfigurationVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListHostedConfigurationVersionsOutputResponse: Equatable {
    /// <p>The elements from this collection.</p>
    public let items: [HostedConfigurationVersionSummary]?
    /// <p>The token for the next set of items to return. Use this token to get the next set of
    ///          results.</p>
    public let nextToken: String?

    public init (
        items: [HostedConfigurationVersionSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListHostedConfigurationVersionsOutputResponseBody: Equatable {
    public let items: [HostedConfigurationVersionSummary]?
    public let nextToken: String?
}

extension ListHostedConfigurationVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([HostedConfigurationVersionSummary?].self, forKey: .items)
        var itemsDecoded0:[HostedConfigurationVersionSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [HostedConfigurationVersionSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The resource ARN.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>Metadata to assign to AppConfig resources. Tags help organize and categorize your
    ///          AppConfig resources. Each tag consists of a key and an optional value, both of which you
    ///          define.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Monitor: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alarmArn = "AlarmArn"
        case alarmRoleArn = "AlarmRoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmArn = alarmArn {
            try encodeContainer.encode(alarmArn, forKey: .alarmArn)
        }
        if let alarmRoleArn = alarmRoleArn {
            try encodeContainer.encode(alarmRoleArn, forKey: .alarmRoleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmArn)
        alarmArn = alarmArnDecoded
        let alarmRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alarmRoleArn)
        alarmRoleArn = alarmRoleArnDecoded
    }
}

extension Monitor: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Monitor(alarmArn: \(String(describing: alarmArn)), alarmRoleArn: \(String(describing: alarmRoleArn)))"}
}

/// <p>Amazon CloudWatch alarms to monitor during the deployment process.</p>
public struct Monitor: Equatable {
    /// <p>ARN of the Amazon CloudWatch alarm.</p>
    public let alarmArn: String?
    /// <p>ARN of an IAM role for AppConfig to monitor <code>AlarmArn</code>.</p>
    public let alarmRoleArn: String?

    public init (
        alarmArn: String? = nil,
        alarmRoleArn: String? = nil
    )
    {
        self.alarmArn = alarmArn
        self.alarmRoleArn = alarmRoleArn
    }
}

extension PayloadTooLargeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PayloadTooLargeException(limit: \(String(describing: limit)), measure: \(String(describing: measure)), message: \(String(describing: message)), size: \(String(describing: size)))"}
}

extension PayloadTooLargeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PayloadTooLargeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limit = output.limit
            self.measure = output.measure
            self.message = output.message
            self.size = output.size
        } else {
            self.limit = 0.0
            self.measure = nil
            self.message = nil
            self.size = 0.0
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The configuration size is too large.</p>
public struct PayloadTooLargeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var limit: Float
    public var measure: BytesMeasure?
    public var message: String?
    public var size: Float

    public init (
        limit: Float = 0.0,
        measure: BytesMeasure? = nil,
        message: String? = nil,
        size: Float = 0.0
    )
    {
        self.limit = limit
        self.measure = measure
        self.message = message
        self.size = size
    }
}

struct PayloadTooLargeExceptionBody: Equatable {
    public let message: String?
    public let measure: BytesMeasure?
    public let limit: Float
    public let size: Float
}

extension PayloadTooLargeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case measure = "Measure"
        case message = "Message"
        case size = "Size"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let measureDecoded = try containerValues.decodeIfPresent(BytesMeasure.self, forKey: .measure)
        measure = measureDecoded
        let limitDecoded = try containerValues.decode(Float.self, forKey: .limit)
        limit = limitDecoded
        let sizeDecoded = try containerValues.decode(Float.self, forKey: .size)
        size = sizeDecoded
    }
}

public enum ReplicateTo {
    case `none`
    case ssmDocument
    case sdkUnknown(String)
}

extension ReplicateTo : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReplicateTo] {
        return [
            .none,
            .ssmDocument,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .none: return "NONE"
        case .ssmDocument: return "SSM_DOCUMENT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReplicateTo(rawValue: rawValue) ?? ReplicateTo.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceName: \(String(describing: resourceName)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource could not be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var resourceName: String?

    public init (
        message: String? = nil,
        resourceName: String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceName: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of hosted configuration versions exceeds the limit for the AppConfig
///          configuration store. Delete one or more versions and try again.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartDeploymentInputBodyMiddleware: Middleware {
    public let id: String = "StartDeploymentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDeploymentInput>
    public typealias MOutput = OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDeploymentOutputError>
}

extension StartDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDeploymentInput(applicationId: \(String(describing: applicationId)), configurationProfileId: \(String(describing: configurationProfileId)), configurationVersion: \(String(describing: configurationVersion)), deploymentStrategyId: \(String(describing: deploymentStrategyId)), description: \(String(describing: description)), environmentId: \(String(describing: environmentId)), tags: \(String(describing: tags)))"}
}

extension StartDeploymentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationProfileId = configurationProfileId {
            try encodeContainer.encode(configurationProfileId, forKey: .configurationProfileId)
        }
        if let configurationVersion = configurationVersion {
            try encodeContainer.encode(configurationVersion, forKey: .configurationVersion)
        }
        if let deploymentStrategyId = deploymentStrategyId {
            try encodeContainer.encode(deploymentStrategyId, forKey: .deploymentStrategyId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct StartDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "StartDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDeploymentInput>
    public typealias MOutput = OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDeploymentOutputError>
}

public struct StartDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDeploymentInput>
    public typealias MOutput = OperationOutput<StartDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDeploymentOutputError>
}

public struct StartDeploymentInput: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The configuration profile ID.</p>
    public let configurationProfileId: String?
    /// <p>The configuration version to deploy.</p>
    public let configurationVersion: String?
    /// <p>The deployment strategy ID.</p>
    public let deploymentStrategyId: String?
    /// <p>A description of the deployment.</p>
    public let description: String?
    /// <p>The environment ID.</p>
    public let environmentId: String?
    /// <p>Metadata to assign to the deployment. Tags help organize and categorize your AppConfig
    ///          resources. Each tag consists of a key and an optional value, both of which you
    ///          define.</p>
    public let tags: [String:String]?

    public init (
        applicationId: String? = nil,
        configurationProfileId: String? = nil,
        configurationVersion: String? = nil,
        deploymentStrategyId: String? = nil,
        description: String? = nil,
        environmentId: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.environmentId = environmentId
        self.tags = tags
    }
}

struct StartDeploymentInputBody: Equatable {
    public let deploymentStrategyId: String?
    public let configurationProfileId: String?
    public let configurationVersion: String?
    public let description: String?
    public let tags: [String:String]?
}

extension StartDeploymentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentStrategyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentStrategyId)
        deploymentStrategyId = deploymentStrategyIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDeploymentOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDeploymentOutputResponse(applicationId: \(String(describing: applicationId)), completedAt: \(String(describing: completedAt)), configurationLocationUri: \(String(describing: configurationLocationUri)), configurationName: \(String(describing: configurationName)), configurationProfileId: \(String(describing: configurationProfileId)), configurationVersion: \(String(describing: configurationVersion)), deploymentDurationInMinutes: \(String(describing: deploymentDurationInMinutes)), deploymentNumber: \(String(describing: deploymentNumber)), deploymentStrategyId: \(String(describing: deploymentStrategyId)), description: \(String(describing: description)), environmentId: \(String(describing: environmentId)), eventLog: \(String(describing: eventLog)), finalBakeTimeInMinutes: \(String(describing: finalBakeTimeInMinutes)), growthFactor: \(String(describing: growthFactor)), growthType: \(String(describing: growthType)), percentageComplete: \(String(describing: percentageComplete)), startedAt: \(String(describing: startedAt)), state: \(String(describing: state)))"}
}

extension StartDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.completedAt = output.completedAt
            self.configurationLocationUri = output.configurationLocationUri
            self.configurationName = output.configurationName
            self.configurationProfileId = output.configurationProfileId
            self.configurationVersion = output.configurationVersion
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.deploymentNumber = output.deploymentNumber
            self.deploymentStrategyId = output.deploymentStrategyId
            self.description = output.description
            self.environmentId = output.environmentId
            self.eventLog = output.eventLog
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.percentageComplete = output.percentageComplete
            self.startedAt = output.startedAt
            self.state = output.state
        } else {
            self.applicationId = nil
            self.completedAt = nil
            self.configurationLocationUri = nil
            self.configurationName = nil
            self.configurationProfileId = nil
            self.configurationVersion = nil
            self.deploymentDurationInMinutes = 0
            self.deploymentNumber = 0
            self.deploymentStrategyId = nil
            self.description = nil
            self.environmentId = nil
            self.eventLog = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = 0.0
            self.growthType = nil
            self.percentageComplete = 0.0
            self.startedAt = nil
            self.state = nil
        }
    }
}

public struct StartDeploymentOutputResponse: Equatable {
    /// <p>The ID of the application that was deployed.</p>
    public let applicationId: String?
    /// <p>The time the deployment completed. </p>
    public let completedAt: Date?
    /// <p>Information about the source location of the configuration.</p>
    public let configurationLocationUri: String?
    /// <p>The name of the configuration.</p>
    public let configurationName: String?
    /// <p>The ID of the configuration profile that was deployed.</p>
    public let configurationProfileId: String?
    /// <p>The configuration version that was deployed.</p>
    public let configurationVersion: String?
    /// <p>Total amount of time the deployment lasted.</p>
    public let deploymentDurationInMinutes: Int
    /// <p>The sequence number of the deployment.</p>
    public let deploymentNumber: Int
    /// <p>The ID of the deployment strategy that was deployed.</p>
    public let deploymentStrategyId: String?
    /// <p>The description of the deployment.</p>
    public let description: String?
    /// <p>The ID of the environment that was deployed.</p>
    public let environmentId: String?
    /// <p>A list containing all events related to a deployment. The most recent events are
    ///          displayed first.</p>
    public let eventLog: [DeploymentEvent]?
    /// <p>The amount of time AppConfig monitored for alarms before considering the deployment to be
    ///          complete and no longer eligible for automatic roll back.</p>
    public let finalBakeTimeInMinutes: Int
    /// <p>The percentage of targets to receive a deployed configuration during each
    ///          interval.</p>
    public let growthFactor: Float
    /// <p>The algorithm used to define how percentage grew over time.</p>
    public let growthType: GrowthType?
    /// <p>The percentage of targets for which the deployment is available.</p>
    public let percentageComplete: Float
    /// <p>The time the deployment started.</p>
    public let startedAt: Date?
    /// <p>The state of the deployment.</p>
    public let state: DeploymentState?

    public init (
        applicationId: String? = nil,
        completedAt: Date? = nil,
        configurationLocationUri: String? = nil,
        configurationName: String? = nil,
        configurationProfileId: String? = nil,
        configurationVersion: String? = nil,
        deploymentDurationInMinutes: Int = 0,
        deploymentNumber: Int = 0,
        deploymentStrategyId: String? = nil,
        description: String? = nil,
        environmentId: String? = nil,
        eventLog: [DeploymentEvent]? = nil,
        finalBakeTimeInMinutes: Int = 0,
        growthFactor: Float = 0.0,
        growthType: GrowthType? = nil,
        percentageComplete: Float = 0.0,
        startedAt: Date? = nil,
        state: DeploymentState? = nil
    )
    {
        self.applicationId = applicationId
        self.completedAt = completedAt
        self.configurationLocationUri = configurationLocationUri
        self.configurationName = configurationName
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.deploymentNumber = deploymentNumber
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.environmentId = environmentId
        self.eventLog = eventLog
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.percentageComplete = percentageComplete
        self.startedAt = startedAt
        self.state = state
    }
}

struct StartDeploymentOutputResponseBody: Equatable {
    public let applicationId: String?
    public let environmentId: String?
    public let deploymentStrategyId: String?
    public let configurationProfileId: String?
    public let deploymentNumber: Int
    public let configurationName: String?
    public let configurationLocationUri: String?
    public let configurationVersion: String?
    public let description: String?
    public let deploymentDurationInMinutes: Int
    public let growthType: GrowthType?
    public let growthFactor: Float
    public let finalBakeTimeInMinutes: Int
    public let state: DeploymentState?
    public let eventLog: [DeploymentEvent]?
    public let percentageComplete: Float
    public let startedAt: Date?
    public let completedAt: Date?
}

extension StartDeploymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case completedAt = "CompletedAt"
        case configurationLocationUri = "ConfigurationLocationUri"
        case configurationName = "ConfigurationName"
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case deploymentNumber = "DeploymentNumber"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case environmentId = "EnvironmentId"
        case eventLog = "EventLog"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case percentageComplete = "PercentageComplete"
        case startedAt = "StartedAt"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let deploymentStrategyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentStrategyId)
        deploymentStrategyId = deploymentStrategyIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let deploymentNumberDecoded = try containerValues.decode(Int.self, forKey: .deploymentNumber)
        deploymentNumber = deploymentNumberDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let configurationLocationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationLocationUri)
        configurationLocationUri = configurationLocationUriDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DeploymentState.self, forKey: .state)
        state = stateDecoded
        let eventLogContainer = try containerValues.decodeIfPresent([DeploymentEvent?].self, forKey: .eventLog)
        var eventLogDecoded0:[DeploymentEvent]? = nil
        if let eventLogContainer = eventLogContainer {
            eventLogDecoded0 = [DeploymentEvent]()
            for structure0 in eventLogContainer {
                if let structure0 = structure0 {
                    eventLogDecoded0?.append(structure0)
                }
            }
        }
        eventLog = eventLogDecoded0
        let percentageCompleteDecoded = try containerValues.decode(Float.self, forKey: .percentageComplete)
        percentageComplete = percentageCompleteDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
    }
}

extension StopDeploymentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopDeploymentInput(applicationId: \(String(describing: applicationId)), deploymentNumber: \(String(describing: deploymentNumber)), environmentId: \(String(describing: environmentId)))"}
}

extension StopDeploymentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StopDeploymentInputHeadersMiddleware: Middleware {
    public let id: String = "StopDeploymentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDeploymentInput>
    public typealias MOutput = OperationOutput<StopDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDeploymentOutputError>
}

public struct StopDeploymentInputQueryItemMiddleware: Middleware {
    public let id: String = "StopDeploymentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopDeploymentInput>,
                  next: H) -> Swift.Result<OperationOutput<StopDeploymentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopDeploymentInput>
    public typealias MOutput = OperationOutput<StopDeploymentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopDeploymentOutputError>
}

public struct StopDeploymentInput: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The sequence number of the deployment.</p>
    public let deploymentNumber: Int
    /// <p>The environment ID.</p>
    public let environmentId: String?

    public init (
        applicationId: String? = nil,
        deploymentNumber: Int = 0,
        environmentId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.deploymentNumber = deploymentNumber
        self.environmentId = environmentId
    }
}

struct StopDeploymentInputBody: Equatable {
}

extension StopDeploymentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StopDeploymentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopDeploymentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDeploymentOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDeploymentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopDeploymentOutputResponse(applicationId: \(String(describing: applicationId)), completedAt: \(String(describing: completedAt)), configurationLocationUri: \(String(describing: configurationLocationUri)), configurationName: \(String(describing: configurationName)), configurationProfileId: \(String(describing: configurationProfileId)), configurationVersion: \(String(describing: configurationVersion)), deploymentDurationInMinutes: \(String(describing: deploymentDurationInMinutes)), deploymentNumber: \(String(describing: deploymentNumber)), deploymentStrategyId: \(String(describing: deploymentStrategyId)), description: \(String(describing: description)), environmentId: \(String(describing: environmentId)), eventLog: \(String(describing: eventLog)), finalBakeTimeInMinutes: \(String(describing: finalBakeTimeInMinutes)), growthFactor: \(String(describing: growthFactor)), growthType: \(String(describing: growthType)), percentageComplete: \(String(describing: percentageComplete)), startedAt: \(String(describing: startedAt)), state: \(String(describing: state)))"}
}

extension StopDeploymentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.completedAt = output.completedAt
            self.configurationLocationUri = output.configurationLocationUri
            self.configurationName = output.configurationName
            self.configurationProfileId = output.configurationProfileId
            self.configurationVersion = output.configurationVersion
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.deploymentNumber = output.deploymentNumber
            self.deploymentStrategyId = output.deploymentStrategyId
            self.description = output.description
            self.environmentId = output.environmentId
            self.eventLog = output.eventLog
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.percentageComplete = output.percentageComplete
            self.startedAt = output.startedAt
            self.state = output.state
        } else {
            self.applicationId = nil
            self.completedAt = nil
            self.configurationLocationUri = nil
            self.configurationName = nil
            self.configurationProfileId = nil
            self.configurationVersion = nil
            self.deploymentDurationInMinutes = 0
            self.deploymentNumber = 0
            self.deploymentStrategyId = nil
            self.description = nil
            self.environmentId = nil
            self.eventLog = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = 0.0
            self.growthType = nil
            self.percentageComplete = 0.0
            self.startedAt = nil
            self.state = nil
        }
    }
}

public struct StopDeploymentOutputResponse: Equatable {
    /// <p>The ID of the application that was deployed.</p>
    public let applicationId: String?
    /// <p>The time the deployment completed. </p>
    public let completedAt: Date?
    /// <p>Information about the source location of the configuration.</p>
    public let configurationLocationUri: String?
    /// <p>The name of the configuration.</p>
    public let configurationName: String?
    /// <p>The ID of the configuration profile that was deployed.</p>
    public let configurationProfileId: String?
    /// <p>The configuration version that was deployed.</p>
    public let configurationVersion: String?
    /// <p>Total amount of time the deployment lasted.</p>
    public let deploymentDurationInMinutes: Int
    /// <p>The sequence number of the deployment.</p>
    public let deploymentNumber: Int
    /// <p>The ID of the deployment strategy that was deployed.</p>
    public let deploymentStrategyId: String?
    /// <p>The description of the deployment.</p>
    public let description: String?
    /// <p>The ID of the environment that was deployed.</p>
    public let environmentId: String?
    /// <p>A list containing all events related to a deployment. The most recent events are
    ///          displayed first.</p>
    public let eventLog: [DeploymentEvent]?
    /// <p>The amount of time AppConfig monitored for alarms before considering the deployment to be
    ///          complete and no longer eligible for automatic roll back.</p>
    public let finalBakeTimeInMinutes: Int
    /// <p>The percentage of targets to receive a deployed configuration during each
    ///          interval.</p>
    public let growthFactor: Float
    /// <p>The algorithm used to define how percentage grew over time.</p>
    public let growthType: GrowthType?
    /// <p>The percentage of targets for which the deployment is available.</p>
    public let percentageComplete: Float
    /// <p>The time the deployment started.</p>
    public let startedAt: Date?
    /// <p>The state of the deployment.</p>
    public let state: DeploymentState?

    public init (
        applicationId: String? = nil,
        completedAt: Date? = nil,
        configurationLocationUri: String? = nil,
        configurationName: String? = nil,
        configurationProfileId: String? = nil,
        configurationVersion: String? = nil,
        deploymentDurationInMinutes: Int = 0,
        deploymentNumber: Int = 0,
        deploymentStrategyId: String? = nil,
        description: String? = nil,
        environmentId: String? = nil,
        eventLog: [DeploymentEvent]? = nil,
        finalBakeTimeInMinutes: Int = 0,
        growthFactor: Float = 0.0,
        growthType: GrowthType? = nil,
        percentageComplete: Float = 0.0,
        startedAt: Date? = nil,
        state: DeploymentState? = nil
    )
    {
        self.applicationId = applicationId
        self.completedAt = completedAt
        self.configurationLocationUri = configurationLocationUri
        self.configurationName = configurationName
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.deploymentNumber = deploymentNumber
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.environmentId = environmentId
        self.eventLog = eventLog
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.percentageComplete = percentageComplete
        self.startedAt = startedAt
        self.state = state
    }
}

struct StopDeploymentOutputResponseBody: Equatable {
    public let applicationId: String?
    public let environmentId: String?
    public let deploymentStrategyId: String?
    public let configurationProfileId: String?
    public let deploymentNumber: Int
    public let configurationName: String?
    public let configurationLocationUri: String?
    public let configurationVersion: String?
    public let description: String?
    public let deploymentDurationInMinutes: Int
    public let growthType: GrowthType?
    public let growthFactor: Float
    public let finalBakeTimeInMinutes: Int
    public let state: DeploymentState?
    public let eventLog: [DeploymentEvent]?
    public let percentageComplete: Float
    public let startedAt: Date?
    public let completedAt: Date?
}

extension StopDeploymentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case completedAt = "CompletedAt"
        case configurationLocationUri = "ConfigurationLocationUri"
        case configurationName = "ConfigurationName"
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case deploymentNumber = "DeploymentNumber"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case environmentId = "EnvironmentId"
        case eventLog = "EventLog"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case percentageComplete = "PercentageComplete"
        case startedAt = "StartedAt"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let deploymentStrategyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentStrategyId)
        deploymentStrategyId = deploymentStrategyIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let deploymentNumberDecoded = try containerValues.decode(Int.self, forKey: .deploymentNumber)
        deploymentNumber = deploymentNumberDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let configurationLocationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationLocationUri)
        configurationLocationUri = configurationLocationUriDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DeploymentState.self, forKey: .state)
        state = stateDecoded
        let eventLogContainer = try containerValues.decodeIfPresent([DeploymentEvent?].self, forKey: .eventLog)
        var eventLogDecoded0:[DeploymentEvent]? = nil
        if let eventLogContainer = eventLogContainer {
            eventLogDecoded0 = [DeploymentEvent]()
            for structure0 in eventLogContainer {
                if let structure0 = structure0 {
                    eventLogDecoded0?.append(structure0)
                }
            }
        }
        eventLog = eventLogDecoded0
        let percentageCompleteDecoded = try containerValues.decode(Float.self, forKey: .percentageComplete)
        percentageComplete = percentageCompleteDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the resource for which to retrieve tags.</p>
    public let resourceArn: String?
    /// <p>The key-value string map. The valid character set is [a-zA-Z+-=._:/]. The tag key can be
    ///          up to 128 characters and must not start with <code>aws:</code>. The tag value can be up to
    ///          256 characters.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum TriggeredBy {
    case appconfig
    case cloudwatchAlarm
    case internalError
    case user
    case sdkUnknown(String)
}

extension TriggeredBy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TriggeredBy] {
        return [
            .appconfig,
            .cloudwatchAlarm,
            .internalError,
            .user,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .appconfig: return "APPCONFIG"
        case .cloudwatchAlarm: return "CLOUDWATCH_ALARM"
        case .internalError: return "INTERNAL_ERROR"
        case .user: return "USER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TriggeredBy(rawValue: rawValue) ?? TriggeredBy.sdkUnknown(rawValue)
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the resource for which to remove tags.</p>
    public let resourceArn: String?
    /// <p>The tag keys to delete.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateApplicationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

extension UpdateApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationInput(applicationId: \(String(describing: applicationId)), description: \(String(describing: description)), name: \(String(describing: name)))"}
}

extension UpdateApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInput: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>A description of the application.</p>
    public let description: String?
    /// <p>The name of the application.</p>
    public let name: String?

    public init (
        applicationId: String? = nil,
        description: String? = nil,
        name: String? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.name = name
    }
}

struct UpdateApplicationInputBody: Equatable {
    public let name: String?
    public let description: String?
}

extension UpdateApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationOutputResponse(description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

extension UpdateApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.name = output.name
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct UpdateApplicationOutputResponse: Equatable {
    /// <p>The description of the application.</p>
    public let description: String?
    /// <p>The application ID.</p>
    public let id: String?
    /// <p>The application name.</p>
    public let name: String?

    public init (
        description: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct UpdateApplicationOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
}

extension UpdateApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

public struct UpdateConfigurationProfileInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConfigurationProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationProfileInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationProfileOutputError>
}

extension UpdateConfigurationProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationProfileInput(applicationId: \(String(describing: applicationId)), configurationProfileId: \(String(describing: configurationProfileId)), description: \(String(describing: description)), name: \(String(describing: name)), retrievalRoleArn: \(String(describing: retrievalRoleArn)), validators: \(String(describing: validators)))"}
}

extension UpdateConfigurationProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case validators = "Validators"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let retrievalRoleArn = retrievalRoleArn {
            try encodeContainer.encode(retrievalRoleArn, forKey: .retrievalRoleArn)
        }
        if let validators = validators {
            var validatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validators)
            for validatorlist0 in validators {
                try validatorsContainer.encode(validatorlist0)
            }
        }
    }
}

public struct UpdateConfigurationProfileInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConfigurationProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationProfileInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationProfileOutputError>
}

public struct UpdateConfigurationProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConfigurationProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationProfileInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationProfileOutputError>
}

public struct UpdateConfigurationProfileInput: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The ID of the configuration profile.</p>
    public let configurationProfileId: String?
    /// <p>A description of the configuration profile.</p>
    public let description: String?
    /// <p>The name of the configuration profile.</p>
    public let name: String?
    /// <p>The ARN of an IAM role with permission to access the configuration at the specified
    ///          LocationUri.</p>
    public let retrievalRoleArn: String?
    /// <p>A list of methods for validating the configuration.</p>
    public let validators: [Validator]?

    public init (
        applicationId: String? = nil,
        configurationProfileId: String? = nil,
        description: String? = nil,
        name: String? = nil,
        retrievalRoleArn: String? = nil,
        validators: [Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.description = description
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.validators = validators
    }
}

struct UpdateConfigurationProfileInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let retrievalRoleArn: String?
    public let validators: [Validator]?
}

extension UpdateConfigurationProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case validators = "Validators"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([Validator?].self, forKey: .validators)
        var validatorsDecoded0:[Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
    }
}

extension UpdateConfigurationProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConfigurationProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigurationProfileOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigurationProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationProfileOutputResponse(applicationId: \(String(describing: applicationId)), description: \(String(describing: description)), id: \(String(describing: id)), locationUri: \(String(describing: locationUri)), name: \(String(describing: name)), retrievalRoleArn: \(String(describing: retrievalRoleArn)), validators: \(String(describing: validators)))"}
}

extension UpdateConfigurationProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateConfigurationProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.locationUri = output.locationUri
            self.name = output.name
            self.retrievalRoleArn = output.retrievalRoleArn
            self.validators = output.validators
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.locationUri = nil
            self.name = nil
            self.retrievalRoleArn = nil
            self.validators = nil
        }
    }
}

public struct UpdateConfigurationProfileOutputResponse: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The configuration profile description.</p>
    public let description: String?
    /// <p>The configuration profile ID.</p>
    public let id: String?
    /// <p>The URI location of the configuration.</p>
    public let locationUri: String?
    /// <p>The name of the configuration profile.</p>
    public let name: String?
    /// <p>The ARN of an IAM role with permission to access the configuration at the specified
    ///          LocationUri.</p>
    public let retrievalRoleArn: String?
    /// <p>A list of methods for validating the configuration.</p>
    public let validators: [Validator]?

    public init (
        applicationId: String? = nil,
        description: String? = nil,
        id: String? = nil,
        locationUri: String? = nil,
        name: String? = nil,
        retrievalRoleArn: String? = nil,
        validators: [Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.locationUri = locationUri
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.validators = validators
    }
}

struct UpdateConfigurationProfileOutputResponseBody: Equatable {
    public let applicationId: String?
    public let id: String?
    public let name: String?
    public let description: String?
    public let locationUri: String?
    public let retrievalRoleArn: String?
    public let validators: [Validator]?
}

extension UpdateConfigurationProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case validators = "Validators"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([Validator?].self, forKey: .validators)
        var validatorsDecoded0:[Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
    }
}

public struct UpdateDeploymentStrategyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDeploymentStrategyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeploymentStrategyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeploymentStrategyInput>
    public typealias MOutput = OperationOutput<UpdateDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeploymentStrategyOutputError>
}

extension UpdateDeploymentStrategyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeploymentStrategyInput(deploymentDurationInMinutes: \(String(describing: deploymentDurationInMinutes)), deploymentStrategyId: \(String(describing: deploymentStrategyId)), description: \(String(describing: description)), finalBakeTimeInMinutes: \(String(describing: finalBakeTimeInMinutes)), growthFactor: \(String(describing: growthFactor)), growthType: \(String(describing: growthType)))"}
}

extension UpdateDeploymentStrategyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deploymentDurationInMinutes != 0 {
            try encodeContainer.encode(deploymentDurationInMinutes, forKey: .deploymentDurationInMinutes)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if finalBakeTimeInMinutes != 0 {
            try encodeContainer.encode(finalBakeTimeInMinutes, forKey: .finalBakeTimeInMinutes)
        }
        if growthFactor != 0.0 {
            try encodeContainer.encode(growthFactor, forKey: .growthFactor)
        }
        if let growthType = growthType {
            try encodeContainer.encode(growthType.rawValue, forKey: .growthType)
        }
    }
}

public struct UpdateDeploymentStrategyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDeploymentStrategyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeploymentStrategyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeploymentStrategyInput>
    public typealias MOutput = OperationOutput<UpdateDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeploymentStrategyOutputError>
}

public struct UpdateDeploymentStrategyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDeploymentStrategyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeploymentStrategyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeploymentStrategyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeploymentStrategyInput>
    public typealias MOutput = OperationOutput<UpdateDeploymentStrategyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeploymentStrategyOutputError>
}

public struct UpdateDeploymentStrategyInput: Equatable {
    /// <p>Total amount of time for a deployment to last.</p>
    public let deploymentDurationInMinutes: Int
    /// <p>The deployment strategy ID.</p>
    public let deploymentStrategyId: String?
    /// <p>A description of the deployment strategy.</p>
    public let description: String?
    /// <p>The amount of time AppConfig monitors for alarms before considering the deployment to be
    ///          complete and no longer eligible for automatic roll back.</p>
    public let finalBakeTimeInMinutes: Int
    /// <p>The percentage of targets to receive a deployed configuration during each
    ///          interval.</p>
    public let growthFactor: Float
    /// <p>The algorithm used to define how percentage grows over time. AWS AppConfig supports the
    ///          following growth types:</p>
    ///          <p>
    ///             <b>Linear</b>: For this type, AppConfig processes the
    ///          deployment by increments of the growth factor evenly distributed over the deployment time.
    ///          For example, a linear deployment that uses a growth factor of 20 initially makes the
    ///          configuration available to 20 percent of the targets. After 1/5th of the deployment time
    ///          has passed, the system updates the percentage to 40 percent. This continues until 100% of
    ///          the targets are set to receive the deployed configuration.</p>
    ///
    ///          <p>
    ///             <b>Exponential</b>: For this type, AppConfig processes the
    ///          deployment exponentially using the following formula: <code>G*(2^N)</code>. In this
    ///          formula, <code>G</code> is the growth factor specified by the user and <code>N</code> is
    ///          the number of steps until the configuration is deployed to all targets. For example, if you
    ///          specify a growth factor of 2, then the system rolls out the configuration as
    ///          follows:</p>
    ///          <p>
    ///             <code>2*(2^0)</code>
    ///          </p>
    ///          <p>
    ///             <code>2*(2^1)</code>
    ///          </p>
    ///          <p>
    ///             <code>2*(2^2)</code>
    ///          </p>
    ///          <p>Expressed numerically, the deployment rolls out as follows: 2% of the targets, 4% of the
    ///          targets, 8% of the targets, and continues until the configuration has been deployed to all
    ///          targets.</p>
    public let growthType: GrowthType?

    public init (
        deploymentDurationInMinutes: Int = 0,
        deploymentStrategyId: String? = nil,
        description: String? = nil,
        finalBakeTimeInMinutes: Int = 0,
        growthFactor: Float = 0.0,
        growthType: GrowthType? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
    }
}

struct UpdateDeploymentStrategyInputBody: Equatable {
    public let description: String?
    public let deploymentDurationInMinutes: Int
    public let finalBakeTimeInMinutes: Int
    public let growthFactor: Float
    public let growthType: GrowthType?
}

extension UpdateDeploymentStrategyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let growthFactorDecoded = try containerValues.decode(Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
    }
}

extension UpdateDeploymentStrategyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeploymentStrategyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDeploymentStrategyOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeploymentStrategyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeploymentStrategyOutputResponse(deploymentDurationInMinutes: \(String(describing: deploymentDurationInMinutes)), description: \(String(describing: description)), finalBakeTimeInMinutes: \(String(describing: finalBakeTimeInMinutes)), growthFactor: \(String(describing: growthFactor)), growthType: \(String(describing: growthType)), id: \(String(describing: id)), name: \(String(describing: name)), replicateTo: \(String(describing: replicateTo)))"}
}

extension UpdateDeploymentStrategyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDeploymentStrategyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.description = output.description
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.id = output.id
            self.name = output.name
            self.replicateTo = output.replicateTo
        } else {
            self.deploymentDurationInMinutes = 0
            self.description = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = 0.0
            self.growthType = nil
            self.id = nil
            self.name = nil
            self.replicateTo = nil
        }
    }
}

public struct UpdateDeploymentStrategyOutputResponse: Equatable {
    /// <p>Total amount of time the deployment lasted.</p>
    public let deploymentDurationInMinutes: Int
    /// <p>The description of the deployment strategy.</p>
    public let description: String?
    /// <p>The amount of time AppConfig monitored for alarms before considering the deployment to be
    ///          complete and no longer eligible for automatic roll back.</p>
    public let finalBakeTimeInMinutes: Int
    /// <p>The percentage of targets that received a deployed configuration during each
    ///          interval.</p>
    public let growthFactor: Float
    /// <p>The algorithm used to define how percentage grew over time.</p>
    public let growthType: GrowthType?
    /// <p>The deployment strategy ID.</p>
    public let id: String?
    /// <p>The name of the deployment strategy.</p>
    public let name: String?
    /// <p>Save the deployment strategy to a Systems Manager (SSM) document.</p>
    public let replicateTo: ReplicateTo?

    public init (
        deploymentDurationInMinutes: Int = 0,
        description: String? = nil,
        finalBakeTimeInMinutes: Int = 0,
        growthFactor: Float = 0.0,
        growthType: GrowthType? = nil,
        id: String? = nil,
        name: String? = nil,
        replicateTo: ReplicateTo? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.id = id
        self.name = name
        self.replicateTo = replicateTo
    }
}

struct UpdateDeploymentStrategyOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
    public let deploymentDurationInMinutes: Int
    public let growthType: GrowthType?
    public let growthFactor: Float
    public let finalBakeTimeInMinutes: Int
    public let replicateTo: ReplicateTo?
}

extension UpdateDeploymentStrategyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case id = "Id"
        case name = "Name"
        case replicateTo = "ReplicateTo"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
    }
}

public struct UpdateEnvironmentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnvironmentOutputError>
}

extension UpdateEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEnvironmentInput(applicationId: \(String(describing: applicationId)), description: \(String(describing: description)), environmentId: \(String(describing: environmentId)), monitors: \(String(describing: monitors)), name: \(String(describing: name)))"}
}

extension UpdateEnvironmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case monitors = "Monitors"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let monitors = monitors {
            var monitorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitors)
            for monitorlist0 in monitors {
                try monitorsContainer.encode(monitorlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInput: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>A description of the environment.</p>
    public let description: String?
    /// <p>The environment ID.</p>
    public let environmentId: String?
    /// <p>Amazon CloudWatch alarms to monitor during the deployment process.</p>
    public let monitors: [Monitor]?
    /// <p>The name of the environment.</p>
    public let name: String?

    public init (
        applicationId: String? = nil,
        description: String? = nil,
        environmentId: String? = nil,
        monitors: [Monitor]? = nil,
        name: String? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.environmentId = environmentId
        self.monitors = monitors
        self.name = name
    }
}

struct UpdateEnvironmentInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let monitors: [Monitor]?
}

extension UpdateEnvironmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case monitors = "Monitors"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

extension UpdateEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEnvironmentOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEnvironmentOutputResponse(applicationId: \(String(describing: applicationId)), description: \(String(describing: description)), id: \(String(describing: id)), monitors: \(String(describing: monitors)), name: \(String(describing: name)), state: \(String(describing: state)))"}
}

extension UpdateEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.monitors = output.monitors
            self.name = output.name
            self.state = output.state
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.monitors = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct UpdateEnvironmentOutputResponse: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The description of the environment.</p>
    public let description: String?
    /// <p>The environment ID.</p>
    public let id: String?
    /// <p>Amazon CloudWatch alarms monitored during the deployment.</p>
    public let monitors: [Monitor]?
    /// <p>The name of the environment.</p>
    public let name: String?
    /// <p>The state of the environment. An environment can be in one of the following states:
    ///             <code>READY_FOR_DEPLOYMENT</code>, <code>DEPLOYING</code>, <code>ROLLING_BACK</code>, or
    ///             <code>ROLLED_BACK</code>
    ///          </p>
    public let state: EnvironmentState?

    public init (
        applicationId: String? = nil,
        description: String? = nil,
        id: String? = nil,
        monitors: [Monitor]? = nil,
        name: String? = nil,
        state: EnvironmentState? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.monitors = monitors
        self.name = name
        self.state = state
    }
}

struct UpdateEnvironmentOutputResponseBody: Equatable {
    public let applicationId: String?
    public let id: String?
    public let name: String?
    public let description: String?
    public let state: EnvironmentState?
    public let monitors: [Monitor]?
}

extension UpdateEnvironmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case monitors = "Monitors"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

extension ValidateConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidateConfigurationInput(applicationId: \(String(describing: applicationId)), configurationProfileId: \(String(describing: configurationProfileId)), configurationVersion: \(String(describing: configurationVersion)))"}
}

extension ValidateConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ValidateConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "ValidateConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidateConfigurationInput>
    public typealias MOutput = OperationOutput<ValidateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidateConfigurationOutputError>
}

public struct ValidateConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "ValidateConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let configurationVersion = input.operationInput.configurationVersion {
            let configurationVersionQueryItem = URLQueryItem(name: "configuration_version".urlPercentEncoding(), value: String(configurationVersion).urlPercentEncoding())
            input.builder.withQueryItem(configurationVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidateConfigurationInput>
    public typealias MOutput = OperationOutput<ValidateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidateConfigurationOutputError>
}

public struct ValidateConfigurationInput: Equatable {
    /// <p>The application ID.</p>
    public let applicationId: String?
    /// <p>The configuration profile ID.</p>
    public let configurationProfileId: String?
    /// <p>The version of the configuration to validate.</p>
    public let configurationVersion: String?

    public init (
        applicationId: String? = nil,
        configurationProfileId: String? = nil,
        configurationVersion: String? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
    }
}

struct ValidateConfigurationInputBody: Equatable {
}

extension ValidateConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidateConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ValidateConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ValidateConfigurationOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ValidateConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidateConfigurationOutputResponse()"}
}

extension ValidateConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ValidateConfigurationOutputResponse: Equatable {

    public init() {}
}

struct ValidateConfigurationOutputResponseBody: Equatable {
}

extension ValidateConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Validator: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content = "Content"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ValidatorType.self, forKey: .type)
        type = typeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
    }
}

extension Validator: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Validator(content: \(String(describing: content)), type: \(String(describing: type)))"}
}

/// <p>A validator provides a syntactic or semantic check to ensure the configuration you want
///          to deploy functions as intended. To validate your application configuration data, you
///          provide a schema or a Lambda function that runs against the configuration. The
///          configuration deployment or update can only proceed when the configuration data is
///          valid.</p>
public struct Validator: Equatable {
    /// <p>Either the JSON Schema content or the Amazon Resource Name (ARN) of an AWS Lambda
    ///          function.</p>
    public let content: String?
    /// <p>AppConfig supports validators of type <code>JSON_SCHEMA</code> and
    ///          <code>LAMBDA</code>
    ///          </p>
    public let type: ValidatorType?

    public init (
        content: String? = nil,
        type: ValidatorType? = nil
    )
    {
        self.content = content
        self.type = type
    }
}

public enum ValidatorType {
    case jsonSchema
    case lambda
    case sdkUnknown(String)
}

extension ValidatorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidatorType] {
        return [
            .jsonSchema,
            .lambda,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .jsonSchema: return "JSON_SCHEMA"
        case .lambda: return "LAMBDA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidatorType(rawValue: rawValue) ?? ValidatorType.sdkUnknown(rawValue)
    }
}
