// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[DescribeAddonVersionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeAddonVersionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeAddonVersionsOutputResponse`
extension EksClient {
    public func describeAddonVersionsPaginated(input: DescribeAddonVersionsInput) -> ClientRuntime.PaginatorSequence<DescribeAddonVersionsInput, DescribeAddonVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeAddonVersionsInput, DescribeAddonVersionsOutputResponse>(input: input, inputKey: \DescribeAddonVersionsInput.nextToken, outputKey: \DescribeAddonVersionsOutputResponse.nextToken, paginationFunction: self.describeAddonVersions(input:))
    }
}

extension DescribeAddonVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAddonVersionsInput {
        return DescribeAddonVersionsInput(
            addonName: self.addonName,
            kubernetesVersion: self.kubernetesVersion,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeAddonVersionsPaginated`
/// to access the nested member `[EksClientTypes.AddonInfo]`
/// - Returns: `[EksClientTypes.AddonInfo]`
extension PaginatorSequence where Input == DescribeAddonVersionsInput, Output == DescribeAddonVersionsOutputResponse {
    func addons() async throws -> [EksClientTypes.AddonInfo] {
        return try await self.asyncCompactMap { item in item.addons }
    }
}

/// Paginate over `[ListAddonsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAddonsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAddonsOutputResponse`
extension EksClient {
    public func listAddonsPaginated(input: ListAddonsInput) -> ClientRuntime.PaginatorSequence<ListAddonsInput, ListAddonsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAddonsInput, ListAddonsOutputResponse>(input: input, inputKey: \ListAddonsInput.nextToken, outputKey: \ListAddonsOutputResponse.nextToken, paginationFunction: self.listAddons(input:))
    }
}

extension ListAddonsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAddonsInput {
        return ListAddonsInput(
            clusterName: self.clusterName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAddonsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListAddonsInput, Output == ListAddonsOutputResponse {
    func addons() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.addons }
    }
}

/// Paginate over `[ListClustersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListClustersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListClustersOutputResponse`
extension EksClient {
    public func listClustersPaginated(input: ListClustersInput) -> ClientRuntime.PaginatorSequence<ListClustersInput, ListClustersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListClustersInput, ListClustersOutputResponse>(input: input, inputKey: \ListClustersInput.nextToken, outputKey: \ListClustersOutputResponse.nextToken, paginationFunction: self.listClusters(input:))
    }
}

extension ListClustersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListClustersInput {
        return ListClustersInput(
            include: self.include,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listClustersPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListClustersInput, Output == ListClustersOutputResponse {
    func clusters() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.clusters }
    }
}

/// Paginate over `[ListFargateProfilesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListFargateProfilesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListFargateProfilesOutputResponse`
extension EksClient {
    public func listFargateProfilesPaginated(input: ListFargateProfilesInput) -> ClientRuntime.PaginatorSequence<ListFargateProfilesInput, ListFargateProfilesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFargateProfilesInput, ListFargateProfilesOutputResponse>(input: input, inputKey: \ListFargateProfilesInput.nextToken, outputKey: \ListFargateProfilesOutputResponse.nextToken, paginationFunction: self.listFargateProfiles(input:))
    }
}

extension ListFargateProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFargateProfilesInput {
        return ListFargateProfilesInput(
            clusterName: self.clusterName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listFargateProfilesPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListFargateProfilesInput, Output == ListFargateProfilesOutputResponse {
    func fargateProfileNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.fargateProfileNames }
    }
}

/// Paginate over `[ListIdentityProviderConfigsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListIdentityProviderConfigsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListIdentityProviderConfigsOutputResponse`
extension EksClient {
    public func listIdentityProviderConfigsPaginated(input: ListIdentityProviderConfigsInput) -> ClientRuntime.PaginatorSequence<ListIdentityProviderConfigsInput, ListIdentityProviderConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListIdentityProviderConfigsInput, ListIdentityProviderConfigsOutputResponse>(input: input, inputKey: \ListIdentityProviderConfigsInput.nextToken, outputKey: \ListIdentityProviderConfigsOutputResponse.nextToken, paginationFunction: self.listIdentityProviderConfigs(input:))
    }
}

extension ListIdentityProviderConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIdentityProviderConfigsInput {
        return ListIdentityProviderConfigsInput(
            clusterName: self.clusterName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listIdentityProviderConfigsPaginated`
/// to access the nested member `[EksClientTypes.IdentityProviderConfig]`
/// - Returns: `[EksClientTypes.IdentityProviderConfig]`
extension PaginatorSequence where Input == ListIdentityProviderConfigsInput, Output == ListIdentityProviderConfigsOutputResponse {
    func identityProviderConfigs() async throws -> [EksClientTypes.IdentityProviderConfig] {
        return try await self.asyncCompactMap { item in item.identityProviderConfigs }
    }
}

/// Paginate over `[ListNodegroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListNodegroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListNodegroupsOutputResponse`
extension EksClient {
    public func listNodegroupsPaginated(input: ListNodegroupsInput) -> ClientRuntime.PaginatorSequence<ListNodegroupsInput, ListNodegroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListNodegroupsInput, ListNodegroupsOutputResponse>(input: input, inputKey: \ListNodegroupsInput.nextToken, outputKey: \ListNodegroupsOutputResponse.nextToken, paginationFunction: self.listNodegroups(input:))
    }
}

extension ListNodegroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNodegroupsInput {
        return ListNodegroupsInput(
            clusterName: self.clusterName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listNodegroupsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListNodegroupsInput, Output == ListNodegroupsOutputResponse {
    func nodegroups() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.nodegroups }
    }
}

/// Paginate over `[ListUpdatesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListUpdatesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListUpdatesOutputResponse`
extension EksClient {
    public func listUpdatesPaginated(input: ListUpdatesInput) -> ClientRuntime.PaginatorSequence<ListUpdatesInput, ListUpdatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListUpdatesInput, ListUpdatesOutputResponse>(input: input, inputKey: \ListUpdatesInput.nextToken, outputKey: \ListUpdatesOutputResponse.nextToken, paginationFunction: self.listUpdates(input:))
    }
}

extension ListUpdatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUpdatesInput {
        return ListUpdatesInput(
            addonName: self.addonName,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            nodegroupName: self.nodegroupName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listUpdatesPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListUpdatesInput, Output == ListUpdatesOutputResponse {
    func updateIds() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.updateIds }
    }
}
