// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ECRPUBLICClientTypes.AuthorizationData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationToken
        case expiresAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationToken = self.authorizationToken {
            try encodeContainer.encode(authorizationToken, forKey: .authorizationToken)
        }
        if let expiresAt = self.expiresAt {
            try encodeContainer.encodeTimestamp(expiresAt, format: .epochSeconds, forKey: .expiresAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationToken)
        authorizationToken = authorizationTokenDecoded
        let expiresAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiresAt)
        expiresAt = expiresAtDecoded
    }
}

extension ECRPUBLICClientTypes {
    /// An authorization token data object that corresponds to a public registry.
    public struct AuthorizationData: Swift.Equatable {
        /// A base64-encoded string that contains authorization data for a public Amazon ECR registry. When the string is decoded, it is presented in the format user:password for public registry authentication using docker login.
        public var authorizationToken: Swift.String?
        /// The Unix time in seconds and milliseconds when the authorization token expires. Authorization tokens are valid for 12 hours.
        public var expiresAt: ClientRuntime.Date?

        public init (
            authorizationToken: Swift.String? = nil,
            expiresAt: ClientRuntime.Date? = nil
        )
        {
            self.authorizationToken = authorizationToken
            self.expiresAt = expiresAt
        }
    }

}

extension BatchCheckLayerAvailabilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigests
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerDigests = layerDigests {
            var layerDigestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerDigests)
            for batchedoperationlayerdigest0 in layerDigests {
                try layerDigestsContainer.encode(batchedoperationlayerdigest0)
            }
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension BatchCheckLayerAvailabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchCheckLayerAvailabilityInput: Swift.Equatable {
    /// The digests of the image layers to check.
    /// This member is required.
    public var layerDigests: [Swift.String]?
    /// The AWS account ID associated with the public registry that contains the image layers to check. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository that is associated with the image layers to check.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        layerDigests: [Swift.String]? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.layerDigests = layerDigests
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct BatchCheckLayerAvailabilityInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let layerDigests: [Swift.String]?
}

extension BatchCheckLayerAvailabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigests
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let layerDigestsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerDigests)
        var layerDigestsDecoded0:[Swift.String]? = nil
        if let layerDigestsContainer = layerDigestsContainer {
            layerDigestsDecoded0 = [Swift.String]()
            for string0 in layerDigestsContainer {
                if let string0 = string0 {
                    layerDigestsDecoded0?.append(string0)
                }
            }
        }
        layerDigests = layerDigestsDecoded0
    }
}

extension BatchCheckLayerAvailabilityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCheckLayerAvailabilityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryNotFoundException" : self = .registryNotFoundException(try RegistryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchCheckLayerAvailabilityOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case registryNotFoundException(RegistryNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCheckLayerAvailabilityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchCheckLayerAvailabilityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
            self.layers = output.layers
        } else {
            self.failures = nil
            self.layers = nil
        }
    }
}

public struct BatchCheckLayerAvailabilityOutputResponse: Swift.Equatable {
    /// Any failures associated with the call.
    public var failures: [ECRPUBLICClientTypes.LayerFailure]?
    /// A list of image layer objects corresponding to the image layer references in the request.
    public var layers: [ECRPUBLICClientTypes.Layer]?

    public init (
        failures: [ECRPUBLICClientTypes.LayerFailure]? = nil,
        layers: [ECRPUBLICClientTypes.Layer]? = nil
    )
    {
        self.failures = failures
        self.layers = layers
    }
}

struct BatchCheckLayerAvailabilityOutputResponseBody: Swift.Equatable {
    let layers: [ECRPUBLICClientTypes.Layer]?
    let failures: [ECRPUBLICClientTypes.LayerFailure]?
}

extension BatchCheckLayerAvailabilityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures
        case layers
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layersContainer = try containerValues.decodeIfPresent([ECRPUBLICClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[ECRPUBLICClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [ECRPUBLICClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let failuresContainer = try containerValues.decodeIfPresent([ECRPUBLICClientTypes.LayerFailure?].self, forKey: .failures)
        var failuresDecoded0:[ECRPUBLICClientTypes.LayerFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [ECRPUBLICClientTypes.LayerFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

extension BatchDeleteImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for imageidentifier0 in imageIds {
                try imageIdsContainer.encode(imageidentifier0)
            }
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension BatchDeleteImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchDeleteImageInput: Swift.Equatable {
    /// A list of image ID references that correspond to images to delete. The format of the imageIds reference is imageTag=tag or imageDigest=digest.
    /// This member is required.
    public var imageIds: [ECRPUBLICClientTypes.ImageIdentifier]?
    /// The AWS account ID associated with the registry that contains the image to delete. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The repository in a public registry that contains the image to delete.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        imageIds: [ECRPUBLICClientTypes.ImageIdentifier]? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageIds = imageIds
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct BatchDeleteImageInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let imageIds: [ECRPUBLICClientTypes.ImageIdentifier]?
}

extension BatchDeleteImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdsContainer = try containerValues.decodeIfPresent([ECRPUBLICClientTypes.ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[ECRPUBLICClientTypes.ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [ECRPUBLICClientTypes.ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
    }
}

extension BatchDeleteImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchDeleteImageOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchDeleteImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
            self.imageIds = output.imageIds
        } else {
            self.failures = nil
            self.imageIds = nil
        }
    }
}

public struct BatchDeleteImageOutputResponse: Swift.Equatable {
    /// Any failures associated with the call.
    public var failures: [ECRPUBLICClientTypes.ImageFailure]?
    /// The image IDs of the deleted images.
    public var imageIds: [ECRPUBLICClientTypes.ImageIdentifier]?

    public init (
        failures: [ECRPUBLICClientTypes.ImageFailure]? = nil,
        imageIds: [ECRPUBLICClientTypes.ImageIdentifier]? = nil
    )
    {
        self.failures = failures
        self.imageIds = imageIds
    }
}

struct BatchDeleteImageOutputResponseBody: Swift.Equatable {
    let imageIds: [ECRPUBLICClientTypes.ImageIdentifier]?
    let failures: [ECRPUBLICClientTypes.ImageFailure]?
}

extension BatchDeleteImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures
        case imageIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdsContainer = try containerValues.decodeIfPresent([ECRPUBLICClientTypes.ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[ECRPUBLICClientTypes.ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [ECRPUBLICClientTypes.ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let failuresContainer = try containerValues.decodeIfPresent([ECRPUBLICClientTypes.ImageFailure?].self, forKey: .failures)
        var failuresDecoded0:[ECRPUBLICClientTypes.ImageFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [ECRPUBLICClientTypes.ImageFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

extension CompleteLayerUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigests
        case registryId
        case repositoryName
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerDigests = layerDigests {
            var layerDigestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerDigests)
            for layerdigest0 in layerDigests {
                try layerDigestsContainer.encode(layerdigest0)
            }
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let uploadId = self.uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

extension CompleteLayerUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CompleteLayerUploadInput: Swift.Equatable {
    /// The sha256 digest of the image layer.
    /// This member is required.
    public var layerDigests: [Swift.String]?
    /// The AWS account ID associated with the registry to which to upload layers. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository in a public registry to associate with the image layer.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The upload ID from a previous [InitiateLayerUpload] operation to associate with the image layer.
    /// This member is required.
    public var uploadId: Swift.String?

    public init (
        layerDigests: [Swift.String]? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.layerDigests = layerDigests
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct CompleteLayerUploadInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let uploadId: Swift.String?
    let layerDigests: [Swift.String]?
}

extension CompleteLayerUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigests
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let layerDigestsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerDigests)
        var layerDigestsDecoded0:[Swift.String]? = nil
        if let layerDigestsContainer = layerDigestsContainer {
            layerDigestsDecoded0 = [Swift.String]()
            for string0 in layerDigestsContainer {
                if let string0 = string0 {
                    layerDigestsDecoded0?.append(string0)
                }
            }
        }
        layerDigests = layerDigestsDecoded0
    }
}

extension CompleteLayerUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CompleteLayerUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EmptyUploadException" : self = .emptyUploadException(try EmptyUploadException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLayerException" : self = .invalidLayerException(try InvalidLayerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayerAlreadyExistsException" : self = .layerAlreadyExistsException(try LayerAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayerPartTooSmallException" : self = .layerPartTooSmallException(try LayerPartTooSmallException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryNotFoundException" : self = .registryNotFoundException(try RegistryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UploadNotFoundException" : self = .uploadNotFoundException(try UploadNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CompleteLayerUploadOutputError: Swift.Error, Swift.Equatable {
    case emptyUploadException(EmptyUploadException)
    case invalidLayerException(InvalidLayerException)
    case invalidParameterException(InvalidParameterException)
    case layerAlreadyExistsException(LayerAlreadyExistsException)
    case layerPartTooSmallException(LayerPartTooSmallException)
    case registryNotFoundException(RegistryNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case uploadNotFoundException(UploadNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CompleteLayerUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CompleteLayerUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.layerDigest = output.layerDigest
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.uploadId = output.uploadId
        } else {
            self.layerDigest = nil
            self.registryId = nil
            self.repositoryName = nil
            self.uploadId = nil
        }
    }
}

public struct CompleteLayerUploadOutputResponse: Swift.Equatable {
    /// The sha256 digest of the image layer.
    public var layerDigest: Swift.String?
    /// The public registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?
    /// The upload ID associated with the layer.
    public var uploadId: Swift.String?

    public init (
        layerDigest: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.layerDigest = layerDigest
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct CompleteLayerUploadOutputResponseBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let uploadId: Swift.String?
    let layerDigest: Swift.String?
}

extension CompleteLayerUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigest
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let layerDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
    }
}

extension CreateRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogData
        case repositoryName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogData = self.catalogData {
            try encodeContainer.encode(catalogData, forKey: .catalogData)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateRepositoryInput: Swift.Equatable {
    /// The details about the repository that are publicly visible in the Amazon ECR Public Gallery.
    public var catalogData: ECRPUBLICClientTypes.RepositoryCatalogDataInput?
    /// The name to use for the repository. This appears publicly in the Amazon ECR Public Gallery. The repository name may be specified on its own (such as nginx-web-app) or it can be prepended with a namespace to group the repository into a category (such as project-a/nginx-web-app).
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The metadata that you apply to the repository to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [ECRPUBLICClientTypes.Tag]?

    public init (
        catalogData: ECRPUBLICClientTypes.RepositoryCatalogDataInput? = nil,
        repositoryName: Swift.String? = nil,
        tags: [ECRPUBLICClientTypes.Tag]? = nil
    )
    {
        self.catalogData = catalogData
        self.repositoryName = repositoryName
        self.tags = tags
    }
}

struct CreateRepositoryInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let catalogData: ECRPUBLICClientTypes.RepositoryCatalogDataInput?
    let tags: [ECRPUBLICClientTypes.Tag]?
}

extension CreateRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogData
        case repositoryName
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let catalogDataDecoded = try containerValues.decodeIfPresent(ECRPUBLICClientTypes.RepositoryCatalogDataInput.self, forKey: .catalogData)
        catalogData = catalogDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ECRPUBLICClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ECRPUBLICClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ECRPUBLICClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameterException" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryAlreadyExistsException" : self = .repositoryAlreadyExistsException(try RepositoryAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateRepositoryOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case invalidTagParameterException(InvalidTagParameterException)
    case limitExceededException(LimitExceededException)
    case repositoryAlreadyExistsException(RepositoryAlreadyExistsException)
    case serverException(ServerException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.catalogData = output.catalogData
            self.repository = output.repository
        } else {
            self.catalogData = nil
            self.repository = nil
        }
    }
}

public struct CreateRepositoryOutputResponse: Swift.Equatable {
    /// The catalog data for a repository. This data is publicly visible in the Amazon ECR Public Gallery.
    public var catalogData: ECRPUBLICClientTypes.RepositoryCatalogData?
    /// The repository that was created.
    public var repository: ECRPUBLICClientTypes.Repository?

    public init (
        catalogData: ECRPUBLICClientTypes.RepositoryCatalogData? = nil,
        repository: ECRPUBLICClientTypes.Repository? = nil
    )
    {
        self.catalogData = catalogData
        self.repository = repository
    }
}

struct CreateRepositoryOutputResponseBody: Swift.Equatable {
    let repository: ECRPUBLICClientTypes.Repository?
    let catalogData: ECRPUBLICClientTypes.RepositoryCatalogData?
}

extension CreateRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogData
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(ECRPUBLICClientTypes.Repository.self, forKey: .repository)
        repository = repositoryDecoded
        let catalogDataDecoded = try containerValues.decodeIfPresent(ECRPUBLICClientTypes.RepositoryCatalogData.self, forKey: .catalogData)
        catalogData = catalogDataDecoded
    }
}

extension DeleteRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension DeleteRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRepositoryInput: Swift.Equatable {
    /// If a repository contains images, forces the deletion.
    public var force: Swift.Bool
    /// The AWS account ID associated with the public registry that contains the repository to delete. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to delete.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        force: Swift.Bool = false,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.force = force
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let force: Swift.Bool
}

extension DeleteRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let forceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .force) ?? false
        force = forceDecoded
    }
}

extension DeleteRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotEmptyException" : self = .repositoryNotEmptyException(try RepositoryNotEmptyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRepositoryOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotEmptyException(RepositoryNotEmptyException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DeleteRepositoryOutputResponse: Swift.Equatable {
    /// The repository that was deleted.
    public var repository: ECRPUBLICClientTypes.Repository?

    public init (
        repository: ECRPUBLICClientTypes.Repository? = nil
    )
    {
        self.repository = repository
    }
}

struct DeleteRepositoryOutputResponseBody: Swift.Equatable {
    let repository: ECRPUBLICClientTypes.Repository?
}

extension DeleteRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(ECRPUBLICClientTypes.Repository.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

extension DeleteRepositoryPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension DeleteRepositoryPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRepositoryPolicyInput: Swift.Equatable {
    /// The AWS account ID associated with the public registry that contains the repository policy to delete. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository that is associated with the repository policy to delete.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryPolicyInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
}

extension DeleteRepositoryPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension DeleteRepositoryPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryPolicyNotFoundException" : self = .repositoryPolicyNotFoundException(try RepositoryPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRepositoryPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case repositoryPolicyNotFoundException(RepositoryPolicyNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteRepositoryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.policyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct DeleteRepositoryPolicyOutputResponse: Swift.Equatable {
    /// The JSON repository policy that was deleted from the repository.
    public var policyText: Swift.String?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?

    public init (
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryPolicyOutputResponseBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let policyText: Swift.String?
}

extension DeleteRepositoryPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

extension DescribeImageTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension DescribeImageTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeImageTagsInput: Swift.Equatable {
    /// The maximum number of repository results returned by DescribeImageTags in paginated output. When this parameter is used, DescribeImageTags only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeImageTags request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribeImageTags returns up to 100 results and a nextToken value, if applicable. This option cannot be used when you specify images with imageIds.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated DescribeImageTags request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return. This option cannot be used when you specify images with imageIds.
    public var nextToken: Swift.String?
    /// The AWS account ID associated with the public registry that contains the repository in which to describe images. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository that contains the image tag details to describe.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DescribeImageTagsInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeImageTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeImageTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImageTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeImageTagsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImageTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeImageTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageTagDetails = output.imageTagDetails
            self.nextToken = output.nextToken
        } else {
            self.imageTagDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeImageTagsOutputResponse: Swift.Equatable {
    /// The image tag details for the images in the requested repository.
    public var imageTagDetails: [ECRPUBLICClientTypes.ImageTagDetail]?
    /// The nextToken value to include in a future DescribeImageTags request. When the results of a DescribeImageTags request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        imageTagDetails: [ECRPUBLICClientTypes.ImageTagDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageTagDetails = imageTagDetails
        self.nextToken = nextToken
    }
}

struct DescribeImageTagsOutputResponseBody: Swift.Equatable {
    let imageTagDetails: [ECRPUBLICClientTypes.ImageTagDetail]?
    let nextToken: Swift.String?
}

extension DescribeImageTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageTagDetails
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageTagDetailsContainer = try containerValues.decodeIfPresent([ECRPUBLICClientTypes.ImageTagDetail?].self, forKey: .imageTagDetails)
        var imageTagDetailsDecoded0:[ECRPUBLICClientTypes.ImageTagDetail]? = nil
        if let imageTagDetailsContainer = imageTagDetailsContainer {
            imageTagDetailsDecoded0 = [ECRPUBLICClientTypes.ImageTagDetail]()
            for structure0 in imageTagDetailsContainer {
                if let structure0 = structure0 {
                    imageTagDetailsDecoded0?.append(structure0)
                }
            }
        }
        imageTagDetails = imageTagDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeImagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for imageidentifier0 in imageIds {
                try imageIdsContainer.encode(imageidentifier0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension DescribeImagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeImagesInput: Swift.Equatable {
    /// The list of image IDs for the requested repository.
    public var imageIds: [ECRPUBLICClientTypes.ImageIdentifier]?
    /// The maximum number of repository results returned by DescribeImages in paginated output. When this parameter is used, DescribeImages only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeImages request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribeImages returns up to 100 results and a nextToken value, if applicable. This option cannot be used when you specify images with imageIds.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated DescribeImages request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return. This option cannot be used when you specify images with imageIds.
    public var nextToken: Swift.String?
    /// The AWS account ID associated with the public registry that contains the repository in which to describe images. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The repository that contains the images to describe.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        imageIds: [ECRPUBLICClientTypes.ImageIdentifier]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageIds = imageIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DescribeImagesInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let imageIds: [ECRPUBLICClientTypes.ImageIdentifier]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdsContainer = try containerValues.decodeIfPresent([ECRPUBLICClientTypes.ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[ECRPUBLICClientTypes.ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [ECRPUBLICClientTypes.ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeImagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ImageNotFoundException" : self = .imageNotFoundException(try ImageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeImagesOutputError: Swift.Error, Swift.Equatable {
    case imageNotFoundException(ImageNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageDetails = output.imageDetails
            self.nextToken = output.nextToken
        } else {
            self.imageDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeImagesOutputResponse: Swift.Equatable {
    /// A list of [ImageDetail] objects that contain data about the image.
    public var imageDetails: [ECRPUBLICClientTypes.ImageDetail]?
    /// The nextToken value to include in a future DescribeImages request. When the results of a DescribeImages request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init (
        imageDetails: [ECRPUBLICClientTypes.ImageDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageDetails = imageDetails
        self.nextToken = nextToken
    }
}

struct DescribeImagesOutputResponseBody: Swift.Equatable {
    let imageDetails: [ECRPUBLICClientTypes.ImageDetail]?
    let nextToken: Swift.String?
}

extension DescribeImagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageDetails
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDetailsContainer = try containerValues.decodeIfPresent([ECRPUBLICClientTypes.ImageDetail?].self, forKey: .imageDetails)
        var imageDetailsDecoded0:[ECRPUBLICClientTypes.ImageDetail]? = nil
        if let imageDetailsContainer = imageDetailsContainer {
            imageDetailsDecoded0 = [ECRPUBLICClientTypes.ImageDetail]()
            for structure0 in imageDetailsContainer {
                if let structure0 = structure0 {
                    imageDetailsDecoded0?.append(structure0)
                }
            }
        }
        imageDetails = imageDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRegistriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeRegistriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRegistriesInput: Swift.Equatable {
    /// The maximum number of repository results returned by DescribeRegistries in paginated output. When this parameter is used, DescribeRegistries only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeRegistries request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribeRegistries returns up to 100 results and a nextToken value, if applicable.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated DescribeRegistries request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return. This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeRegistriesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeRegistriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRegistriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRegistriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRegistriesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRegistriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeRegistriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.registries = output.registries
        } else {
            self.nextToken = nil
            self.registries = nil
        }
    }
}

public struct DescribeRegistriesOutputResponse: Swift.Equatable {
    /// The nextToken value to include in a future DescribeRepositories request. When the results of a DescribeRepositories request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// An object containing the details for a public registry.
    /// This member is required.
    public var registries: [ECRPUBLICClientTypes.Registry]?

    public init (
        nextToken: Swift.String? = nil,
        registries: [ECRPUBLICClientTypes.Registry]? = nil
    )
    {
        self.nextToken = nextToken
        self.registries = registries
    }
}

struct DescribeRegistriesOutputResponseBody: Swift.Equatable {
    let registries: [ECRPUBLICClientTypes.Registry]?
    let nextToken: Swift.String?
}

extension DescribeRegistriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case registries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registriesContainer = try containerValues.decodeIfPresent([ECRPUBLICClientTypes.Registry?].self, forKey: .registries)
        var registriesDecoded0:[ECRPUBLICClientTypes.Registry]? = nil
        if let registriesContainer = registriesContainer {
            registriesDecoded0 = [ECRPUBLICClientTypes.Registry]()
            for structure0 in registriesContainer {
                if let structure0 = structure0 {
                    registriesDecoded0?.append(structure0)
                }
            }
        }
        registries = registriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRepositoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case registryId
        case repositoryNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryNames = repositoryNames {
            var repositoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositoryNames)
            for repositoryname0 in repositoryNames {
                try repositoryNamesContainer.encode(repositoryname0)
            }
        }
    }
}

extension DescribeRepositoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRepositoriesInput: Swift.Equatable {
    /// The maximum number of repository results returned by DescribeRepositories in paginated output. When this parameter is used, DescribeRepositories only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeRepositories request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribeRepositories returns up to 100 results and a nextToken value, if applicable. This option cannot be used when you specify repositories with repositoryNames.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated DescribeRepositories request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return. This option cannot be used when you specify repositories with repositoryNames. This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
    public var nextToken: Swift.String?
    /// The AWS account ID associated with the registry that contains the repositories to be described. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// A list of repositories to describe. If this parameter is omitted, then all repositories in a registry are described.
    public var repositoryNames: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryNames: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryNames = repositoryNames
    }
}

struct DescribeRepositoriesInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryNames: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeRepositoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case registryId
        case repositoryNames
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[Swift.String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [Swift.String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRepositoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRepositoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeRepositoriesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRepositoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeRepositoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

public struct DescribeRepositoriesOutputResponse: Swift.Equatable {
    /// The nextToken value to include in a future DescribeRepositories request. When the results of a DescribeRepositories request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// A list of repository objects corresponding to valid repositories.
    public var repositories: [ECRPUBLICClientTypes.Repository]?

    public init (
        nextToken: Swift.String? = nil,
        repositories: [ECRPUBLICClientTypes.Repository]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct DescribeRepositoriesOutputResponseBody: Swift.Equatable {
    let repositories: [ECRPUBLICClientTypes.Repository]?
    let nextToken: Swift.String?
}

extension DescribeRepositoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositories
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([ECRPUBLICClientTypes.Repository?].self, forKey: .repositories)
        var repositoriesDecoded0:[ECRPUBLICClientTypes.Repository]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [ECRPUBLICClientTypes.Repository]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension EmptyUploadException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EmptyUploadExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified layer upload does not contain any layer parts.
public struct EmptyUploadException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EmptyUploadExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EmptyUploadExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetAuthorizationTokenInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetAuthorizationTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAuthorizationTokenInput: Swift.Equatable {

    public init () { }
}

struct GetAuthorizationTokenInputBody: Swift.Equatable {
}

extension GetAuthorizationTokenInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAuthorizationTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAuthorizationTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAuthorizationTokenOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAuthorizationTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAuthorizationTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authorizationData = output.authorizationData
        } else {
            self.authorizationData = nil
        }
    }
}

public struct GetAuthorizationTokenOutputResponse: Swift.Equatable {
    /// An authorization token data object that corresponds to a public registry.
    public var authorizationData: ECRPUBLICClientTypes.AuthorizationData?

    public init (
        authorizationData: ECRPUBLICClientTypes.AuthorizationData? = nil
    )
    {
        self.authorizationData = authorizationData
    }
}

struct GetAuthorizationTokenOutputResponseBody: Swift.Equatable {
    let authorizationData: ECRPUBLICClientTypes.AuthorizationData?
}

extension GetAuthorizationTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationData
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationDataDecoded = try containerValues.decodeIfPresent(ECRPUBLICClientTypes.AuthorizationData.self, forKey: .authorizationData)
        authorizationData = authorizationDataDecoded
    }
}

extension GetRegistryCatalogDataInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetRegistryCatalogDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRegistryCatalogDataInput: Swift.Equatable {

    public init () { }
}

struct GetRegistryCatalogDataInputBody: Swift.Equatable {
}

extension GetRegistryCatalogDataInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRegistryCatalogDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRegistryCatalogDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRegistryCatalogDataOutputError: Swift.Error, Swift.Equatable {
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRegistryCatalogDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRegistryCatalogDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.registryCatalogData = output.registryCatalogData
        } else {
            self.registryCatalogData = nil
        }
    }
}

public struct GetRegistryCatalogDataOutputResponse: Swift.Equatable {
    /// The catalog metadata for the public registry.
    /// This member is required.
    public var registryCatalogData: ECRPUBLICClientTypes.RegistryCatalogData?

    public init (
        registryCatalogData: ECRPUBLICClientTypes.RegistryCatalogData? = nil
    )
    {
        self.registryCatalogData = registryCatalogData
    }
}

struct GetRegistryCatalogDataOutputResponseBody: Swift.Equatable {
    let registryCatalogData: ECRPUBLICClientTypes.RegistryCatalogData?
}

extension GetRegistryCatalogDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryCatalogData
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryCatalogDataDecoded = try containerValues.decodeIfPresent(ECRPUBLICClientTypes.RegistryCatalogData.self, forKey: .registryCatalogData)
        registryCatalogData = registryCatalogDataDecoded
    }
}

extension GetRepositoryCatalogDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetRepositoryCatalogDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRepositoryCatalogDataInput: Swift.Equatable {
    /// The AWS account ID associated with the registry that contains the repositories to be described. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to retrieve the catalog metadata for.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryCatalogDataInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
}

extension GetRepositoryCatalogDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension GetRepositoryCatalogDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryCatalogDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRepositoryCatalogDataOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryCatalogDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRepositoryCatalogDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.catalogData = output.catalogData
        } else {
            self.catalogData = nil
        }
    }
}

public struct GetRepositoryCatalogDataOutputResponse: Swift.Equatable {
    /// The catalog metadata for the repository.
    public var catalogData: ECRPUBLICClientTypes.RepositoryCatalogData?

    public init (
        catalogData: ECRPUBLICClientTypes.RepositoryCatalogData? = nil
    )
    {
        self.catalogData = catalogData
    }
}

struct GetRepositoryCatalogDataOutputResponseBody: Swift.Equatable {
    let catalogData: ECRPUBLICClientTypes.RepositoryCatalogData?
}

extension GetRepositoryCatalogDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogData
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDataDecoded = try containerValues.decodeIfPresent(ECRPUBLICClientTypes.RepositoryCatalogData.self, forKey: .catalogData)
        catalogData = catalogDataDecoded
    }
}

extension GetRepositoryPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetRepositoryPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRepositoryPolicyInput: Swift.Equatable {
    /// The AWS account ID associated with the public registry that contains the repository. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository with the policy to retrieve.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryPolicyInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
}

extension GetRepositoryPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension GetRepositoryPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryPolicyNotFoundException" : self = .repositoryPolicyNotFoundException(try RepositoryPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRepositoryPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case repositoryPolicyNotFoundException(RepositoryPolicyNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRepositoryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.policyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct GetRepositoryPolicyOutputResponse: Swift.Equatable {
    /// The repository policy text associated with the repository. The policy text will be in JSON format.
    public var policyText: Swift.String?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?

    public init (
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryPolicyOutputResponseBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let policyText: Swift.String?
}

extension GetRepositoryPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

extension ECRPUBLICClientTypes.Image: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case imageManifest
        case imageManifestMediaType
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let imageManifest = self.imageManifest {
            try encodeContainer.encode(imageManifest, forKey: .imageManifest)
        }
        if let imageManifestMediaType = self.imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(ECRPUBLICClientTypes.ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imageManifestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifest)
        imageManifest = imageManifestDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
    }
}

extension ECRPUBLICClientTypes {
    /// An object representing an Amazon ECR image.
    public struct Image: Swift.Equatable {
        /// An object containing the image tag and image digest associated with an image.
        public var imageId: ECRPUBLICClientTypes.ImageIdentifier?
        /// The image manifest associated with the image.
        public var imageManifest: Swift.String?
        /// The manifest media type of the image.
        public var imageManifestMediaType: Swift.String?
        /// The AWS account ID associated with the registry containing the image.
        public var registryId: Swift.String?
        /// The name of the repository associated with the image.
        public var repositoryName: Swift.String?

        public init (
            imageId: ECRPUBLICClientTypes.ImageIdentifier? = nil,
            imageManifest: Swift.String? = nil,
            imageManifestMediaType: Swift.String? = nil,
            registryId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.imageId = imageId
            self.imageManifest = imageManifest
            self.imageManifestMediaType = imageManifestMediaType
            self.registryId = registryId
            self.repositoryName = repositoryName
        }
    }

}

extension ImageAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImageAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified image has already been pushed, and there were no changes to the manifest or image tag after the last push.
public struct ImageAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ImageAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ImageAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRPUBLICClientTypes.ImageDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactMediaType
        case imageDigest
        case imageManifestMediaType
        case imagePushedAt
        case imageSizeInBytes
        case imageTags
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactMediaType = self.artifactMediaType {
            try encodeContainer.encode(artifactMediaType, forKey: .artifactMediaType)
        }
        if let imageDigest = self.imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageManifestMediaType = self.imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let imagePushedAt = self.imagePushedAt {
            try encodeContainer.encodeTimestamp(imagePushedAt, format: .epochSeconds, forKey: .imagePushedAt)
        }
        if let imageSizeInBytes = self.imageSizeInBytes {
            try encodeContainer.encode(imageSizeInBytes, forKey: .imageSizeInBytes)
        }
        if let imageTags = imageTags {
            var imageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageTags)
            for imagetag0 in imageTags {
                try imageTagsContainer.encode(imagetag0)
            }
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imageTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageTags)
        var imageTagsDecoded0:[Swift.String]? = nil
        if let imageTagsContainer = imageTagsContainer {
            imageTagsDecoded0 = [Swift.String]()
            for string0 in imageTagsContainer {
                if let string0 = string0 {
                    imageTagsDecoded0?.append(string0)
                }
            }
        }
        imageTags = imageTagsDecoded0
        let imageSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .imageSizeInBytes)
        imageSizeInBytes = imageSizeInBytesDecoded
        let imagePushedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .imagePushedAt)
        imagePushedAt = imagePushedAtDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
        let artifactMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactMediaType)
        artifactMediaType = artifactMediaTypeDecoded
    }
}

extension ECRPUBLICClientTypes {
    /// An object that describes an image returned by a [DescribeImages] operation.
    public struct ImageDetail: Swift.Equatable {
        /// The artifact media type of the image.
        public var artifactMediaType: Swift.String?
        /// The sha256 digest of the image manifest.
        public var imageDigest: Swift.String?
        /// The media type of the image manifest.
        public var imageManifestMediaType: Swift.String?
        /// The date and time, expressed in standard JavaScript date format, at which the current image was pushed to the repository.
        public var imagePushedAt: ClientRuntime.Date?
        /// The size, in bytes, of the image in the repository. If the image is a manifest list, this will be the max size of all manifests in the list. Beginning with Docker version 1.9, the Docker client compresses image layers before pushing them to a V2 Docker registry. The output of the docker images command shows the uncompressed image size, so it may return a larger image size than the image sizes returned by [DescribeImages].
        public var imageSizeInBytes: Swift.Int?
        /// The list of tags associated with this image.
        public var imageTags: [Swift.String]?
        /// The AWS account ID associated with the public registry to which this image belongs.
        public var registryId: Swift.String?
        /// The name of the repository to which this image belongs.
        public var repositoryName: Swift.String?

        public init (
            artifactMediaType: Swift.String? = nil,
            imageDigest: Swift.String? = nil,
            imageManifestMediaType: Swift.String? = nil,
            imagePushedAt: ClientRuntime.Date? = nil,
            imageSizeInBytes: Swift.Int? = nil,
            imageTags: [Swift.String]? = nil,
            registryId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.artifactMediaType = artifactMediaType
            self.imageDigest = imageDigest
            self.imageManifestMediaType = imageManifestMediaType
            self.imagePushedAt = imagePushedAt
            self.imageSizeInBytes = imageSizeInBytes
            self.imageTags = imageTags
            self.registryId = registryId
            self.repositoryName = repositoryName
        }
    }

}

extension ImageDigestDoesNotMatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImageDigestDoesNotMatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified image digest does not match the digest that Amazon ECR calculated for the image.
public struct ImageDigestDoesNotMatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ImageDigestDoesNotMatchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ImageDigestDoesNotMatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRPUBLICClientTypes.ImageFailure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case failureReason
        case imageId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(ECRPUBLICClientTypes.ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(ECRPUBLICClientTypes.ImageFailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension ECRPUBLICClientTypes {
    /// An object representing an Amazon ECR image failure.
    public struct ImageFailure: Swift.Equatable {
        /// The code associated with the failure.
        public var failureCode: ECRPUBLICClientTypes.ImageFailureCode?
        /// The reason for the failure.
        public var failureReason: Swift.String?
        /// The image ID associated with the failure.
        public var imageId: ECRPUBLICClientTypes.ImageIdentifier?

        public init (
            failureCode: ECRPUBLICClientTypes.ImageFailureCode? = nil,
            failureReason: Swift.String? = nil,
            imageId: ECRPUBLICClientTypes.ImageIdentifier? = nil
        )
        {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.imageId = imageId
        }
    }

}

extension ECRPUBLICClientTypes {
    public enum ImageFailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case imagenotfound
        case imagereferencedbymanifestlist
        case imagetagdoesnotmatchdigest
        case invalidimagedigest
        case invalidimagetag
        case kmserror
        case missingdigestandtag
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageFailureCode] {
            return [
                .imagenotfound,
                .imagereferencedbymanifestlist,
                .imagetagdoesnotmatchdigest,
                .invalidimagedigest,
                .invalidimagetag,
                .kmserror,
                .missingdigestandtag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .imagenotfound: return "ImageNotFound"
            case .imagereferencedbymanifestlist: return "ImageReferencedByManifestList"
            case .imagetagdoesnotmatchdigest: return "ImageTagDoesNotMatchDigest"
            case .invalidimagedigest: return "InvalidImageDigest"
            case .invalidimagetag: return "InvalidImageTag"
            case .kmserror: return "KmsError"
            case .missingdigestandtag: return "MissingDigestAndTag"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageFailureCode(rawValue: rawValue) ?? ImageFailureCode.sdkUnknown(rawValue)
        }
    }
}

extension ECRPUBLICClientTypes.ImageIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageDigest
        case imageTag
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageDigest = self.imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageTag = self.imageTag {
            try encodeContainer.encode(imageTag, forKey: .imageTag)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imageTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageTag)
        imageTag = imageTagDecoded
    }
}

extension ECRPUBLICClientTypes {
    /// An object with identifying information for an Amazon ECR image.
    public struct ImageIdentifier: Swift.Equatable {
        /// The sha256 digest of the image manifest.
        public var imageDigest: Swift.String?
        /// The tag used for the image.
        public var imageTag: Swift.String?

        public init (
            imageDigest: Swift.String? = nil,
            imageTag: Swift.String? = nil
        )
        {
            self.imageDigest = imageDigest
            self.imageTag = imageTag
        }
    }

}

extension ImageNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImageNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The image requested does not exist in the specified repository.
public struct ImageNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ImageNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ImageNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImageTagAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImageTagAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified image is tagged with a tag that already exists. The repository is configured for tag immutability.
public struct ImageTagAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ImageTagAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ImageTagAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRPUBLICClientTypes.ImageTagDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case imageDetail
        case imageTag
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let imageDetail = self.imageDetail {
            try encodeContainer.encode(imageDetail, forKey: .imageDetail)
        }
        if let imageTag = self.imageTag {
            try encodeContainer.encode(imageTag, forKey: .imageTag)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageTag)
        imageTag = imageTagDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let imageDetailDecoded = try containerValues.decodeIfPresent(ECRPUBLICClientTypes.ReferencedImageDetail.self, forKey: .imageDetail)
        imageDetail = imageDetailDecoded
    }
}

extension ECRPUBLICClientTypes {
    /// An object representing the image tag details for an image.
    public struct ImageTagDetail: Swift.Equatable {
        /// The time stamp indicating when the image tag was created.
        public var createdAt: ClientRuntime.Date?
        /// An object that describes the details of an image.
        public var imageDetail: ECRPUBLICClientTypes.ReferencedImageDetail?
        /// The tag associated with the image.
        public var imageTag: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            imageDetail: ECRPUBLICClientTypes.ReferencedImageDetail? = nil,
            imageTag: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.imageDetail = imageDetail
            self.imageTag = imageTag
        }
    }

}

extension InitiateLayerUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension InitiateLayerUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct InitiateLayerUploadInput: Swift.Equatable {
    /// The AWS account ID associated with the registry to which you intend to upload layers. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to which you intend to upload layers.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct InitiateLayerUploadInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
}

extension InitiateLayerUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension InitiateLayerUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitiateLayerUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryNotFoundException" : self = .registryNotFoundException(try RegistryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum InitiateLayerUploadOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case registryNotFoundException(RegistryNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitiateLayerUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InitiateLayerUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.partSize = output.partSize
            self.uploadId = output.uploadId
        } else {
            self.partSize = nil
            self.uploadId = nil
        }
    }
}

public struct InitiateLayerUploadOutputResponse: Swift.Equatable {
    /// The size, in bytes, that Amazon ECR expects future layer part uploads to be.
    public var partSize: Swift.Int?
    /// The upload ID for the layer upload. This parameter is passed to further [UploadLayerPart] and [CompleteLayerUpload] operations.
    public var uploadId: Swift.String?

    public init (
        partSize: Swift.Int? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.partSize = partSize
        self.uploadId = uploadId
    }
}

struct InitiateLayerUploadOutputResponseBody: Swift.Equatable {
    let uploadId: Swift.String?
    let partSize: Swift.Int?
}

extension InitiateLayerUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case partSize
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let partSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partSize)
        partSize = partSizeDecoded
    }
}

extension InvalidLayerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidLayerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The layer digest calculation performed by Amazon ECR upon receipt of the image layer does not match the digest specified.
public struct InvalidLayerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLayerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidLayerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLayerPartException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidLayerPartExceptionBody = try responseDecoder.decode(responseBody: data)
            self.lastValidByteReceived = output.lastValidByteReceived
            self.message = output.message
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.uploadId = output.uploadId
        } else {
            self.lastValidByteReceived = nil
            self.message = nil
            self.registryId = nil
            self.repositoryName = nil
            self.uploadId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The layer part size is not valid, or the first byte specified is not consecutive to the last byte of a previous layer part upload.
public struct InvalidLayerPartException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The position of the last byte of the layer part.
    public var lastValidByteReceived: Swift.Int?
    public var message: Swift.String?
    /// The AWS account ID associated with the layer part.
    public var registryId: Swift.String?
    /// The name of the repository.
    public var repositoryName: Swift.String?
    /// The upload ID associated with the layer part.
    public var uploadId: Swift.String?

    public init (
        lastValidByteReceived: Swift.Int? = nil,
        message: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.lastValidByteReceived = lastValidByteReceived
        self.message = message
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct InvalidLayerPartExceptionBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let uploadId: Swift.String?
    let lastValidByteReceived: Swift.Int?
    let message: Swift.String?
}

extension InvalidLayerPartExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastValidByteReceived
        case message
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let lastValidByteReceivedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastValidByteReceived)
        lastValidByteReceived = lastValidByteReceivedDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified parameter is invalid. Review the available parameters for the API request.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidTagParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An invalid parameter has been specified. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
public struct InvalidTagParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTagParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRPUBLICClientTypes.Layer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerAvailability
        case layerDigest
        case layerSize
        case mediaType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerAvailability = self.layerAvailability {
            try encodeContainer.encode(layerAvailability.rawValue, forKey: .layerAvailability)
        }
        if let layerDigest = self.layerDigest {
            try encodeContainer.encode(layerDigest, forKey: .layerDigest)
        }
        if let layerSize = self.layerSize {
            try encodeContainer.encode(layerSize, forKey: .layerSize)
        }
        if let mediaType = self.mediaType {
            try encodeContainer.encode(mediaType, forKey: .mediaType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
        let layerAvailabilityDecoded = try containerValues.decodeIfPresent(ECRPUBLICClientTypes.LayerAvailability.self, forKey: .layerAvailability)
        layerAvailability = layerAvailabilityDecoded
        let layerSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .layerSize)
        layerSize = layerSizeDecoded
        let mediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaType)
        mediaType = mediaTypeDecoded
    }
}

extension ECRPUBLICClientTypes {
    /// An object representing an Amazon ECR image layer.
    public struct Layer: Swift.Equatable {
        /// The availability status of the image layer.
        public var layerAvailability: ECRPUBLICClientTypes.LayerAvailability?
        /// The sha256 digest of the image layer.
        public var layerDigest: Swift.String?
        /// The size, in bytes, of the image layer.
        public var layerSize: Swift.Int?
        /// The media type of the layer, such as application/vnd.docker.image.rootfs.diff.tar.gzip or application/vnd.oci.image.layer.v1.tar+gzip.
        public var mediaType: Swift.String?

        public init (
            layerAvailability: ECRPUBLICClientTypes.LayerAvailability? = nil,
            layerDigest: Swift.String? = nil,
            layerSize: Swift.Int? = nil,
            mediaType: Swift.String? = nil
        )
        {
            self.layerAvailability = layerAvailability
            self.layerDigest = layerDigest
            self.layerSize = layerSize
            self.mediaType = mediaType
        }
    }

}

extension LayerAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LayerAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The image layer already exists in the associated repository.
public struct LayerAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LayerAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LayerAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRPUBLICClientTypes {
    public enum LayerAvailability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [LayerAvailability] {
            return [
                .available,
                .unavailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LayerAvailability(rawValue: rawValue) ?? LayerAvailability.sdkUnknown(rawValue)
        }
    }
}

extension ECRPUBLICClientTypes.LayerFailure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case failureReason
        case layerDigest
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let layerDigest = self.layerDigest {
            try encodeContainer.encode(layerDigest, forKey: .layerDigest)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(ECRPUBLICClientTypes.LayerFailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension ECRPUBLICClientTypes {
    /// An object representing an Amazon ECR image layer failure.
    public struct LayerFailure: Swift.Equatable {
        /// The failure code associated with the failure.
        public var failureCode: ECRPUBLICClientTypes.LayerFailureCode?
        /// The reason for the failure.
        public var failureReason: Swift.String?
        /// The layer digest associated with the failure.
        public var layerDigest: Swift.String?

        public init (
            failureCode: ECRPUBLICClientTypes.LayerFailureCode? = nil,
            failureReason: Swift.String? = nil,
            layerDigest: Swift.String? = nil
        )
        {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.layerDigest = layerDigest
        }
    }

}

extension ECRPUBLICClientTypes {
    public enum LayerFailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidlayerdigest
        case missinglayerdigest
        case sdkUnknown(Swift.String)

        public static var allCases: [LayerFailureCode] {
            return [
                .invalidlayerdigest,
                .missinglayerdigest,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidlayerdigest: return "InvalidLayerDigest"
            case .missinglayerdigest: return "MissingLayerDigest"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LayerFailureCode(rawValue: rawValue) ?? LayerFailureCode.sdkUnknown(rawValue)
        }
    }
}

extension LayerPartTooSmallException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LayerPartTooSmallExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Layer parts must be at least 5 MiB in size.
public struct LayerPartTooSmallException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LayerPartTooSmallExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LayerPartTooSmallExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LayersNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LayersNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified layers could not be found, or the specified layer is not valid for this repository.
public struct LayersNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LayersNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LayersNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation did not succeed because it would have exceeded a service limit for your account. For more information, see [Amazon ECR Service Quotas](https://docs.aws.amazon.com/AmazonECR/latest/userguide/service-quotas.html) in the Amazon Elastic Container Registry User Guide.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resource is an Amazon ECR Public repository.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags for the resource.
    public var tags: [ECRPUBLICClientTypes.Tag]?

    public init (
        tags: [ECRPUBLICClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [ECRPUBLICClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ECRPUBLICClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ECRPUBLICClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ECRPUBLICClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageDigest
        case imageManifest
        case imageManifestMediaType
        case imageTag
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageDigest = self.imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageManifest = self.imageManifest {
            try encodeContainer.encode(imageManifest, forKey: .imageManifest)
        }
        if let imageManifestMediaType = self.imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let imageTag = self.imageTag {
            try encodeContainer.encode(imageTag, forKey: .imageTag)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension PutImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutImageInput: Swift.Equatable {
    /// The image digest of the image manifest corresponding to the image.
    public var imageDigest: Swift.String?
    /// The image manifest corresponding to the image to be uploaded.
    /// This member is required.
    public var imageManifest: Swift.String?
    /// The media type of the image manifest. If you push an image manifest that does not contain the mediaType field, you must specify the imageManifestMediaType in the request.
    public var imageManifestMediaType: Swift.String?
    /// The tag to associate with the image. This parameter is required for images that use the Docker Image Manifest V2 Schema 2 or Open Container Initiative (OCI) formats.
    public var imageTag: Swift.String?
    /// The AWS account ID associated with the public registry that contains the repository in which to put the image. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository in which to put the image.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        imageDigest: Swift.String? = nil,
        imageManifest: Swift.String? = nil,
        imageManifestMediaType: Swift.String? = nil,
        imageTag: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageDigest = imageDigest
        self.imageManifest = imageManifest
        self.imageManifestMediaType = imageManifestMediaType
        self.imageTag = imageTag
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutImageInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let imageManifest: Swift.String?
    let imageManifestMediaType: Swift.String?
    let imageTag: Swift.String?
    let imageDigest: Swift.String?
}

extension PutImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageDigest
        case imageManifest
        case imageManifestMediaType
        case imageTag
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageManifestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifest)
        imageManifest = imageManifestDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
        let imageTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageTag)
        imageTag = imageTagDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
    }
}

extension PutImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ImageAlreadyExistsException" : self = .imageAlreadyExistsException(try ImageAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ImageDigestDoesNotMatchException" : self = .imageDigestDoesNotMatchException(try ImageDigestDoesNotMatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ImageTagAlreadyExistsException" : self = .imageTagAlreadyExistsException(try ImageTagAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayersNotFoundException" : self = .layersNotFoundException(try LayersNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReferencedImagesNotFoundException" : self = .referencedImagesNotFoundException(try ReferencedImagesNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryNotFoundException" : self = .registryNotFoundException(try RegistryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutImageOutputError: Swift.Error, Swift.Equatable {
    case imageAlreadyExistsException(ImageAlreadyExistsException)
    case imageDigestDoesNotMatchException(ImageDigestDoesNotMatchException)
    case imageTagAlreadyExistsException(ImageTagAlreadyExistsException)
    case invalidParameterException(InvalidParameterException)
    case layersNotFoundException(LayersNotFoundException)
    case limitExceededException(LimitExceededException)
    case referencedImagesNotFoundException(ReferencedImagesNotFoundException)
    case registryNotFoundException(RegistryNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.image = output.image
        } else {
            self.image = nil
        }
    }
}

public struct PutImageOutputResponse: Swift.Equatable {
    /// Details of the image uploaded.
    public var image: ECRPUBLICClientTypes.Image?

    public init (
        image: ECRPUBLICClientTypes.Image? = nil
    )
    {
        self.image = image
    }
}

struct PutImageOutputResponseBody: Swift.Equatable {
    let image: ECRPUBLICClientTypes.Image?
}

extension PutImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case image
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(ECRPUBLICClientTypes.Image.self, forKey: .image)
        image = imageDecoded
    }
}

extension PutRegistryCatalogDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }
}

extension PutRegistryCatalogDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutRegistryCatalogDataInput: Swift.Equatable {
    /// The display name for a public registry. The display name is shown as the repository author in the Amazon ECR Public Gallery. The registry display name is only publicly visible in the Amazon ECR Public Gallery for verified accounts.
    public var displayName: Swift.String?

    public init (
        displayName: Swift.String? = nil
    )
    {
        self.displayName = displayName
    }
}

struct PutRegistryCatalogDataInputBody: Swift.Equatable {
    let displayName: Swift.String?
}

extension PutRegistryCatalogDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension PutRegistryCatalogDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRegistryCatalogDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutRegistryCatalogDataOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRegistryCatalogDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutRegistryCatalogDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.registryCatalogData = output.registryCatalogData
        } else {
            self.registryCatalogData = nil
        }
    }
}

public struct PutRegistryCatalogDataOutputResponse: Swift.Equatable {
    /// The catalog data for the public registry.
    /// This member is required.
    public var registryCatalogData: ECRPUBLICClientTypes.RegistryCatalogData?

    public init (
        registryCatalogData: ECRPUBLICClientTypes.RegistryCatalogData? = nil
    )
    {
        self.registryCatalogData = registryCatalogData
    }
}

struct PutRegistryCatalogDataOutputResponseBody: Swift.Equatable {
    let registryCatalogData: ECRPUBLICClientTypes.RegistryCatalogData?
}

extension PutRegistryCatalogDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryCatalogData
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryCatalogDataDecoded = try containerValues.decodeIfPresent(ECRPUBLICClientTypes.RegistryCatalogData.self, forKey: .registryCatalogData)
        registryCatalogData = registryCatalogDataDecoded
    }
}

extension PutRepositoryCatalogDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogData
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogData = self.catalogData {
            try encodeContainer.encode(catalogData, forKey: .catalogData)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension PutRepositoryCatalogDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutRepositoryCatalogDataInput: Swift.Equatable {
    /// An object containing the catalog data for a repository. This data is publicly visible in the Amazon ECR Public Gallery.
    /// This member is required.
    public var catalogData: ECRPUBLICClientTypes.RepositoryCatalogDataInput?
    /// The AWS account ID associated with the public registry the repository is in. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to create or update the catalog data for.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        catalogData: ECRPUBLICClientTypes.RepositoryCatalogDataInput? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.catalogData = catalogData
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutRepositoryCatalogDataInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let catalogData: ECRPUBLICClientTypes.RepositoryCatalogDataInput?
}

extension PutRepositoryCatalogDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogData
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let catalogDataDecoded = try containerValues.decodeIfPresent(ECRPUBLICClientTypes.RepositoryCatalogDataInput.self, forKey: .catalogData)
        catalogData = catalogDataDecoded
    }
}

extension PutRepositoryCatalogDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRepositoryCatalogDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutRepositoryCatalogDataOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRepositoryCatalogDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutRepositoryCatalogDataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.catalogData = output.catalogData
        } else {
            self.catalogData = nil
        }
    }
}

public struct PutRepositoryCatalogDataOutputResponse: Swift.Equatable {
    /// The catalog data for the repository.
    public var catalogData: ECRPUBLICClientTypes.RepositoryCatalogData?

    public init (
        catalogData: ECRPUBLICClientTypes.RepositoryCatalogData? = nil
    )
    {
        self.catalogData = catalogData
    }
}

struct PutRepositoryCatalogDataOutputResponseBody: Swift.Equatable {
    let catalogData: ECRPUBLICClientTypes.RepositoryCatalogData?
}

extension PutRepositoryCatalogDataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogData
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDataDecoded = try containerValues.decodeIfPresent(ECRPUBLICClientTypes.RepositoryCatalogData.self, forKey: .catalogData)
        catalogData = catalogDataDecoded
    }
}

extension ECRPUBLICClientTypes.ReferencedImageDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactMediaType
        case imageDigest
        case imageManifestMediaType
        case imagePushedAt
        case imageSizeInBytes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactMediaType = self.artifactMediaType {
            try encodeContainer.encode(artifactMediaType, forKey: .artifactMediaType)
        }
        if let imageDigest = self.imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageManifestMediaType = self.imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let imagePushedAt = self.imagePushedAt {
            try encodeContainer.encodeTimestamp(imagePushedAt, format: .epochSeconds, forKey: .imagePushedAt)
        }
        if let imageSizeInBytes = self.imageSizeInBytes {
            try encodeContainer.encode(imageSizeInBytes, forKey: .imageSizeInBytes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imageSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .imageSizeInBytes)
        imageSizeInBytes = imageSizeInBytesDecoded
        let imagePushedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .imagePushedAt)
        imagePushedAt = imagePushedAtDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
        let artifactMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactMediaType)
        artifactMediaType = artifactMediaTypeDecoded
    }
}

extension ECRPUBLICClientTypes {
    /// An object that describes the image tag details returned by a [DescribeImageTags] action.
    public struct ReferencedImageDetail: Swift.Equatable {
        /// The artifact media type of the image.
        public var artifactMediaType: Swift.String?
        /// The sha256 digest of the image manifest.
        public var imageDigest: Swift.String?
        /// The media type of the image manifest.
        public var imageManifestMediaType: Swift.String?
        /// The date and time, expressed in standard JavaScript date format, at which the current image tag was pushed to the repository.
        public var imagePushedAt: ClientRuntime.Date?
        /// The size, in bytes, of the image in the repository. If the image is a manifest list, this will be the max size of all manifests in the list. Beginning with Docker version 1.9, the Docker client compresses image layers before pushing them to a V2 Docker registry. The output of the docker images command shows the uncompressed image size, so it may return a larger image size than the image sizes returned by [DescribeImages].
        public var imageSizeInBytes: Swift.Int?

        public init (
            artifactMediaType: Swift.String? = nil,
            imageDigest: Swift.String? = nil,
            imageManifestMediaType: Swift.String? = nil,
            imagePushedAt: ClientRuntime.Date? = nil,
            imageSizeInBytes: Swift.Int? = nil
        )
        {
            self.artifactMediaType = artifactMediaType
            self.imageDigest = imageDigest
            self.imageManifestMediaType = imageManifestMediaType
            self.imagePushedAt = imagePushedAt
            self.imageSizeInBytes = imageSizeInBytes
        }
    }

}

extension ReferencedImagesNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ReferencedImagesNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The manifest list is referencing an image that does not exist.
public struct ReferencedImagesNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReferencedImagesNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReferencedImagesNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRPUBLICClientTypes.Registry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases
        case registryArn
        case registryId
        case registryUri
        case verified
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliases = aliases {
            var aliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliases)
            for registryalias0 in aliases {
                try aliasesContainer.encode(registryalias0)
            }
        }
        if let registryArn = self.registryArn {
            try encodeContainer.encode(registryArn, forKey: .registryArn)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let registryUri = self.registryUri {
            try encodeContainer.encode(registryUri, forKey: .registryUri)
        }
        if let verified = self.verified {
            try encodeContainer.encode(verified, forKey: .verified)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryUri)
        registryUri = registryUriDecoded
        let verifiedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .verified)
        verified = verifiedDecoded
        let aliasesContainer = try containerValues.decodeIfPresent([ECRPUBLICClientTypes.RegistryAlias?].self, forKey: .aliases)
        var aliasesDecoded0:[ECRPUBLICClientTypes.RegistryAlias]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [ECRPUBLICClientTypes.RegistryAlias]()
            for structure0 in aliasesContainer {
                if let structure0 = structure0 {
                    aliasesDecoded0?.append(structure0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

extension ECRPUBLICClientTypes {
    /// The details of a public registry.
    public struct Registry: Swift.Equatable {
        /// An array of objects representing the aliases for a public registry.
        /// This member is required.
        public var aliases: [ECRPUBLICClientTypes.RegistryAlias]?
        /// The Amazon Resource Name (ARN) of the public registry.
        /// This member is required.
        public var registryArn: Swift.String?
        /// The AWS account ID associated with the registry. If you do not specify a registry, the default public registry is assumed.
        /// This member is required.
        public var registryId: Swift.String?
        /// The URI of a public registry. The URI contains a universal prefix and the registry alias.
        /// This member is required.
        public var registryUri: Swift.String?
        /// Whether the account is verified. This indicates whether the account is an AWS Marketplace vendor. If an account is verified, each public repository will received a verified account badge on the Amazon ECR Public Gallery.
        /// This member is required.
        public var verified: Swift.Bool?

        public init (
            aliases: [ECRPUBLICClientTypes.RegistryAlias]? = nil,
            registryArn: Swift.String? = nil,
            registryId: Swift.String? = nil,
            registryUri: Swift.String? = nil,
            verified: Swift.Bool? = nil
        )
        {
            self.aliases = aliases
            self.registryArn = registryArn
            self.registryId = registryId
            self.registryUri = registryUri
            self.verified = verified
        }
    }

}

extension ECRPUBLICClientTypes.RegistryAlias: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultRegistryAlias
        case name
        case primaryRegistryAlias
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultRegistryAlias != false {
            try encodeContainer.encode(defaultRegistryAlias, forKey: .defaultRegistryAlias)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if primaryRegistryAlias != false {
            try encodeContainer.encode(primaryRegistryAlias, forKey: .primaryRegistryAlias)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ECRPUBLICClientTypes.RegistryAliasStatus.self, forKey: .status)
        status = statusDecoded
        let primaryRegistryAliasDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .primaryRegistryAlias) ?? false
        primaryRegistryAlias = primaryRegistryAliasDecoded
        let defaultRegistryAliasDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultRegistryAlias) ?? false
        defaultRegistryAlias = defaultRegistryAliasDecoded
    }
}

extension ECRPUBLICClientTypes {
    /// An object representing the aliases for a public registry. A public registry is given an alias upon creation but a custom alias can be set using the Amazon ECR console. For more information, see [Registries](https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html) in the Amazon Elastic Container Registry User Guide.
    public struct RegistryAlias: Swift.Equatable {
        /// Whether or not the registry alias is the default alias for the registry. When the first public repository is created, your public registry is assigned a default registry alias.
        /// This member is required.
        public var defaultRegistryAlias: Swift.Bool
        /// The name of the registry alias.
        /// This member is required.
        public var name: Swift.String?
        /// Whether or not the registry alias is the primary alias for the registry. If true, the alias is the primary registry alias and is displayed in both the repository URL and the image URI used in the docker pull commands on the Amazon ECR Public Gallery. A registry alias that is not the primary registry alias can be used in the repository URI in a docker pull command.
        /// This member is required.
        public var primaryRegistryAlias: Swift.Bool
        /// The status of the registry alias.
        /// This member is required.
        public var status: ECRPUBLICClientTypes.RegistryAliasStatus?

        public init (
            defaultRegistryAlias: Swift.Bool = false,
            name: Swift.String? = nil,
            primaryRegistryAlias: Swift.Bool = false,
            status: ECRPUBLICClientTypes.RegistryAliasStatus? = nil
        )
        {
            self.defaultRegistryAlias = defaultRegistryAlias
            self.name = name
            self.primaryRegistryAlias = primaryRegistryAlias
            self.status = status
        }
    }

}

extension ECRPUBLICClientTypes {
    public enum RegistryAliasStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistryAliasStatus] {
            return [
                .active,
                .pending,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RegistryAliasStatus(rawValue: rawValue) ?? RegistryAliasStatus.sdkUnknown(rawValue)
        }
    }
}

extension ECRPUBLICClientTypes.RegistryCatalogData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension ECRPUBLICClientTypes {
    /// The metadata for a public registry.
    public struct RegistryCatalogData: Swift.Equatable {
        /// The display name for a public registry. This appears on the Amazon ECR Public Gallery. Only accounts that have the verified account badge can have a registry display name.
        public var displayName: Swift.String?

        public init (
            displayName: Swift.String? = nil
        )
        {
            self.displayName = displayName
        }
    }

}

extension RegistryNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RegistryNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The registry does not exist.
public struct RegistryNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RegistryNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RegistryNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRPUBLICClientTypes.Repository: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case registryId
        case repositoryArn
        case repositoryName
        case repositoryUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryArn = self.repositoryArn {
            try encodeContainer.encode(repositoryArn, forKey: .repositoryArn)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryUri = self.repositoryUri {
            try encodeContainer.encode(repositoryUri, forKey: .repositoryUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryArn)
        repositoryArn = repositoryArnDecoded
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryUri)
        repositoryUri = repositoryUriDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension ECRPUBLICClientTypes {
    /// An object representing a repository.
    public struct Repository: Swift.Equatable {
        /// The date and time, in JavaScript date format, when the repository was created.
        public var createdAt: ClientRuntime.Date?
        /// The AWS account ID associated with the public registry that contains the repository.
        public var registryId: Swift.String?
        /// The Amazon Resource Name (ARN) that identifies the repository. The ARN contains the arn:aws:ecr namespace, followed by the region of the repository, AWS account ID of the repository owner, repository namespace, and repository name. For example, arn:aws:ecr:region:012345678910:repository/test.
        public var repositoryArn: Swift.String?
        /// The name of the repository.
        public var repositoryName: Swift.String?
        /// The URI for the repository. You can use this URI for container image push and pull operations.
        public var repositoryUri: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            registryId: Swift.String? = nil,
            repositoryArn: Swift.String? = nil,
            repositoryName: Swift.String? = nil,
            repositoryUri: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.registryId = registryId
            self.repositoryArn = repositoryArn
            self.repositoryName = repositoryName
            self.repositoryUri = repositoryUri
        }
    }

}

extension RepositoryAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RepositoryAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified repository already exists in the specified registry.
public struct RepositoryAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRPUBLICClientTypes.RepositoryCatalogData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aboutText
        case architectures
        case description
        case logoUrl
        case marketplaceCertified
        case operatingSystems
        case usageText
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aboutText = self.aboutText {
            try encodeContainer.encode(aboutText, forKey: .aboutText)
        }
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for architecture0 in architectures {
                try architecturesContainer.encode(architecture0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let logoUrl = self.logoUrl {
            try encodeContainer.encode(logoUrl, forKey: .logoUrl)
        }
        if let marketplaceCertified = self.marketplaceCertified {
            try encodeContainer.encode(marketplaceCertified, forKey: .marketplaceCertified)
        }
        if let operatingSystems = operatingSystems {
            var operatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operatingSystems)
            for operatingsystem0 in operatingSystems {
                try operatingSystemsContainer.encode(operatingsystem0)
            }
        }
        if let usageText = self.usageText {
            try encodeContainer.encode(usageText, forKey: .usageText)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .architectures)
        var architecturesDecoded0:[Swift.String]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [Swift.String]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
        let operatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .operatingSystems)
        var operatingSystemsDecoded0:[Swift.String]? = nil
        if let operatingSystemsContainer = operatingSystemsContainer {
            operatingSystemsDecoded0 = [Swift.String]()
            for string0 in operatingSystemsContainer {
                if let string0 = string0 {
                    operatingSystemsDecoded0?.append(string0)
                }
            }
        }
        operatingSystems = operatingSystemsDecoded0
        let logoUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logoUrl)
        logoUrl = logoUrlDecoded
        let aboutTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aboutText)
        aboutText = aboutTextDecoded
        let usageTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageText)
        usageText = usageTextDecoded
        let marketplaceCertifiedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .marketplaceCertified)
        marketplaceCertified = marketplaceCertifiedDecoded
    }
}

extension ECRPUBLICClientTypes {
    /// The catalog data for a repository. This data is publicly visible in the Amazon ECR Public Gallery.
    public struct RepositoryCatalogData: Swift.Equatable {
        /// The longform description of the contents of the repository. This text appears in the repository details on the Amazon ECR Public Gallery.
        public var aboutText: Swift.String?
        /// The architecture tags that are associated with the repository. Only supported operating system tags appear publicly in the Amazon ECR Public Gallery. For more information, see [RepositoryCatalogDataInput].
        public var architectures: [Swift.String]?
        /// The short description of the repository.
        public var description: Swift.String?
        /// The URL containing the logo associated with the repository.
        public var logoUrl: Swift.String?
        /// Whether or not the repository is certified by AWS Marketplace.
        public var marketplaceCertified: Swift.Bool?
        /// The operating system tags that are associated with the repository. Only supported operating system tags appear publicly in the Amazon ECR Public Gallery. For more information, see [RepositoryCatalogDataInput].
        public var operatingSystems: [Swift.String]?
        /// The longform usage details of the contents of the repository. The usage text provides context for users of the repository.
        public var usageText: Swift.String?

        public init (
            aboutText: Swift.String? = nil,
            architectures: [Swift.String]? = nil,
            description: Swift.String? = nil,
            logoUrl: Swift.String? = nil,
            marketplaceCertified: Swift.Bool? = nil,
            operatingSystems: [Swift.String]? = nil,
            usageText: Swift.String? = nil
        )
        {
            self.aboutText = aboutText
            self.architectures = architectures
            self.description = description
            self.logoUrl = logoUrl
            self.marketplaceCertified = marketplaceCertified
            self.operatingSystems = operatingSystems
            self.usageText = usageText
        }
    }

}

extension ECRPUBLICClientTypes.RepositoryCatalogDataInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aboutText
        case architectures
        case description
        case logoImageBlob
        case operatingSystems
        case usageText
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aboutText = self.aboutText {
            try encodeContainer.encode(aboutText, forKey: .aboutText)
        }
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for architecture0 in architectures {
                try architecturesContainer.encode(architecture0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let logoImageBlob = self.logoImageBlob {
            try encodeContainer.encode(logoImageBlob.base64EncodedString(), forKey: .logoImageBlob)
        }
        if let operatingSystems = operatingSystems {
            var operatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operatingSystems)
            for operatingsystem0 in operatingSystems {
                try operatingSystemsContainer.encode(operatingsystem0)
            }
        }
        if let usageText = self.usageText {
            try encodeContainer.encode(usageText, forKey: .usageText)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .architectures)
        var architecturesDecoded0:[Swift.String]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [Swift.String]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
        let operatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .operatingSystems)
        var operatingSystemsDecoded0:[Swift.String]? = nil
        if let operatingSystemsContainer = operatingSystemsContainer {
            operatingSystemsDecoded0 = [Swift.String]()
            for string0 in operatingSystemsContainer {
                if let string0 = string0 {
                    operatingSystemsDecoded0?.append(string0)
                }
            }
        }
        operatingSystems = operatingSystemsDecoded0
        let logoImageBlobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .logoImageBlob)
        logoImageBlob = logoImageBlobDecoded
        let aboutTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aboutText)
        aboutText = aboutTextDecoded
        let usageTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageText)
        usageText = usageTextDecoded
    }
}

extension ECRPUBLICClientTypes {
    /// An object containing the catalog data for a repository. This data is publicly visible in the Amazon ECR Public Gallery.
    public struct RepositoryCatalogDataInput: Swift.Equatable {
        /// A detailed description of the contents of the repository. It is publicly visible in the Amazon ECR Public Gallery. The text must be in markdown format.
        public var aboutText: Swift.String?
        /// The system architecture that the images in the repository are compatible with. On the Amazon ECR Public Gallery, the following supported architectures will appear as badges on the repository and are used as search filters.
        ///
        /// * Linux
        ///
        /// * Windows
        ///
        ///
        /// If an unsupported tag is added to your repository catalog data, it will be associated with the repository and can be retrieved using the API but will not be discoverable in the Amazon ECR Public Gallery.
        public var architectures: [Swift.String]?
        /// A short description of the contents of the repository. This text appears in both the image details and also when searching for repositories on the Amazon ECR Public Gallery.
        public var description: Swift.String?
        /// The base64-encoded repository logo payload. The repository logo is only publicly visible in the Amazon ECR Public Gallery for verified accounts.
        public var logoImageBlob: ClientRuntime.Data?
        /// The operating systems that the images in the repository are compatible with. On the Amazon ECR Public Gallery, the following supported operating systems will appear as badges on the repository and are used as search filters.
        ///
        /// * ARM
        ///
        /// * ARM 64
        ///
        /// * x86
        ///
        /// * x86-64
        ///
        ///
        /// If an unsupported tag is added to your repository catalog data, it will be associated with the repository and can be retrieved using the API but will not be discoverable in the Amazon ECR Public Gallery.
        public var operatingSystems: [Swift.String]?
        /// Detailed information on how to use the contents of the repository. It is publicly visible in the Amazon ECR Public Gallery. The usage text provides context, support information, and additional usage details for users of the repository. The text must be in markdown format.
        public var usageText: Swift.String?

        public init (
            aboutText: Swift.String? = nil,
            architectures: [Swift.String]? = nil,
            description: Swift.String? = nil,
            logoImageBlob: ClientRuntime.Data? = nil,
            operatingSystems: [Swift.String]? = nil,
            usageText: Swift.String? = nil
        )
        {
            self.aboutText = aboutText
            self.architectures = architectures
            self.description = description
            self.logoImageBlob = logoImageBlob
            self.operatingSystems = operatingSystems
            self.usageText = usageText
        }
    }

}

extension RepositoryNotEmptyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RepositoryNotEmptyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified repository contains images. To delete a repository that contains images, you must force the deletion with the force parameter.
public struct RepositoryNotEmptyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryNotEmptyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryNotEmptyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RepositoryNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified repository could not be found. Check the spelling of the specified repository and ensure that you are performing operations on the correct registry.
public struct RepositoryNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryPolicyNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RepositoryPolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified repository and registry combination does not have an associated repository policy.
public struct RepositoryPolicyNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryPolicyNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryPolicyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// These errors are usually caused by a server-side issue.
public struct ServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SetRepositoryPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force
        case policyText
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let policyText = self.policyText {
            try encodeContainer.encode(policyText, forKey: .policyText)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension SetRepositoryPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetRepositoryPolicyInput: Swift.Equatable {
    /// If the policy you are attempting to set on a repository policy would prevent you from setting another policy in the future, you must force the [SetRepositoryPolicy] operation. This is intended to prevent accidental repository lock outs.
    public var force: Swift.Bool
    /// The JSON repository policy text to apply to the repository. For more information, see [Amazon ECR Repository Policies](https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policy-examples.html) in the Amazon Elastic Container Registry User Guide.
    /// This member is required.
    public var policyText: Swift.String?
    /// The AWS account ID associated with the registry that contains the repository. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to receive the policy.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init (
        force: Swift.Bool = false,
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.force = force
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct SetRepositoryPolicyInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let policyText: Swift.String?
    let force: Swift.Bool
}

extension SetRepositoryPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
        let forceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .force) ?? false
        force = forceDecoded
    }
}

extension SetRepositoryPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetRepositoryPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SetRepositoryPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetRepositoryPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SetRepositoryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.policyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct SetRepositoryPolicyOutputResponse: Swift.Equatable {
    /// The JSON repository policy text applied to the repository.
    public var policyText: Swift.String?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?

    public init (
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct SetRepositoryPolicyOutputResponseBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let policyText: Swift.String?
}

extension SetRepositoryPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

extension ECRPUBLICClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ECRPUBLICClientTypes {
    /// The metadata that you apply to a resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public struct Tag: Swift.Equatable {
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public var key: Swift.String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to which to add tags. Currently, the supported resource is an Amazon ECR Public repository.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    /// This member is required.
    public var tags: [ECRPUBLICClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [ECRPUBLICClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [ECRPUBLICClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ECRPUBLICClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ECRPUBLICClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ECRPUBLICClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameterException" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case invalidTagParameterException(InvalidTagParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The list of tags on the repository is over the limit. The maximum number of tags that can be applied to a repository is 50.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedCommandException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnsupportedCommandExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The action is not supported in this Region.
public struct UnsupportedCommandException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedCommandExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedCommandExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource from which to delete tags. Currently, the supported resource is an Amazon ECR Public repository.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameterException" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case invalidTagParameterException(InvalidTagParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UploadLayerPartInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerPartBlob
        case partFirstByte
        case partLastByte
        case registryId
        case repositoryName
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerPartBlob = self.layerPartBlob {
            try encodeContainer.encode(layerPartBlob.base64EncodedString(), forKey: .layerPartBlob)
        }
        if let partFirstByte = self.partFirstByte {
            try encodeContainer.encode(partFirstByte, forKey: .partFirstByte)
        }
        if let partLastByte = self.partLastByte {
            try encodeContainer.encode(partLastByte, forKey: .partLastByte)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let uploadId = self.uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

extension UploadLayerPartInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UploadLayerPartInput: Swift.Equatable {
    /// The base64-encoded layer part payload.
    /// This member is required.
    public var layerPartBlob: ClientRuntime.Data?
    /// The position of the first byte of the layer part witin the overall image layer.
    /// This member is required.
    public var partFirstByte: Swift.Int?
    /// The position of the last byte of the layer part within the overall image layer.
    /// This member is required.
    public var partLastByte: Swift.Int?
    /// The AWS account ID associated with the registry to which you are uploading layer parts. If you do not specify a registry, the default public registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to which you are uploading layer parts.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The upload ID from a previous [InitiateLayerUpload] operation to associate with the layer part upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init (
        layerPartBlob: ClientRuntime.Data? = nil,
        partFirstByte: Swift.Int? = nil,
        partLastByte: Swift.Int? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.layerPartBlob = layerPartBlob
        self.partFirstByte = partFirstByte
        self.partLastByte = partLastByte
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct UploadLayerPartInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let uploadId: Swift.String?
    let partFirstByte: Swift.Int?
    let partLastByte: Swift.Int?
    let layerPartBlob: ClientRuntime.Data?
}

extension UploadLayerPartInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerPartBlob
        case partFirstByte
        case partLastByte
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let partFirstByteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partFirstByte)
        partFirstByte = partFirstByteDecoded
        let partLastByteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partLastByte)
        partLastByte = partLastByteDecoded
        let layerPartBlobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .layerPartBlob)
        layerPartBlob = layerPartBlobDecoded
    }
}

extension UploadLayerPartOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UploadLayerPartOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLayerPartException" : self = .invalidLayerPartException(try InvalidLayerPartException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryNotFoundException" : self = .registryNotFoundException(try RegistryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UploadNotFoundException" : self = .uploadNotFoundException(try UploadNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UploadLayerPartOutputError: Swift.Error, Swift.Equatable {
    case invalidLayerPartException(InvalidLayerPartException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case registryNotFoundException(RegistryNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case uploadNotFoundException(UploadNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadLayerPartOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UploadLayerPartOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lastByteReceived = output.lastByteReceived
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.uploadId = output.uploadId
        } else {
            self.lastByteReceived = nil
            self.registryId = nil
            self.repositoryName = nil
            self.uploadId = nil
        }
    }
}

public struct UploadLayerPartOutputResponse: Swift.Equatable {
    /// The integer value of the last byte received in the request.
    public var lastByteReceived: Swift.Int?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?
    /// The upload ID associated with the request.
    public var uploadId: Swift.String?

    public init (
        lastByteReceived: Swift.Int? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.lastByteReceived = lastByteReceived
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct UploadLayerPartOutputResponseBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let uploadId: Swift.String?
    let lastByteReceived: Swift.Int?
}

extension UploadLayerPartOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastByteReceived
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let lastByteReceivedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastByteReceived)
        lastByteReceived = lastByteReceivedDecoded
    }
}

extension UploadNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UploadNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The upload could not be found, or the specified upload ID is not valid for this repository.
public struct UploadNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UploadNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UploadNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
