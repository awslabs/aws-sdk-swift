// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ActorDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActorDoesNotExistException(message: \(String(describing: message)))"}
}

extension ActorDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ActorDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified Amazon Resource Name (ARN) does not exist in the AWS account.</p>
public struct ActorDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ActorDoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension ActorDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Approval: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalState
        case userArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalState = approvalState {
            try encodeContainer.encode(approvalState.rawValue, forKey: .approvalState)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
        let approvalStateDecoded = try containerValues.decodeIfPresent(ApprovalState.self, forKey: .approvalState)
        approvalState = approvalStateDecoded
    }
}

extension Approval: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Approval(approvalState: \(String(describing: approvalState)), userArn: \(String(describing: userArn)))"}
}

/// <p>Returns information about a specific approval on a pull request.</p>
public struct Approval: Equatable {
    /// <p>The state of the approval, APPROVE or REVOKE. REVOKE states are not stored.</p>
    public let approvalState: ApprovalState?
    /// <p>The Amazon Resource Name (ARN) of the user.</p>
    public let userArn: String?

    public init (
        approvalState: ApprovalState? = nil,
        userArn: String? = nil
    )
    {
        self.approvalState = approvalState
        self.userArn = userArn
    }
}

extension ApprovalRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRuleContent
        case approvalRuleId
        case approvalRuleName
        case creationDate
        case lastModifiedDate
        case lastModifiedUser
        case originApprovalRuleTemplate
        case ruleContentSha256
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleContent = approvalRuleContent {
            try encodeContainer.encode(approvalRuleContent, forKey: .approvalRuleContent)
        }
        if let approvalRuleId = approvalRuleId {
            try encodeContainer.encode(approvalRuleId, forKey: .approvalRuleId)
        }
        if let approvalRuleName = approvalRuleName {
            try encodeContainer.encode(approvalRuleName, forKey: .approvalRuleName)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let lastModifiedUser = lastModifiedUser {
            try encodeContainer.encode(lastModifiedUser, forKey: .lastModifiedUser)
        }
        if let originApprovalRuleTemplate = originApprovalRuleTemplate {
            try encodeContainer.encode(originApprovalRuleTemplate, forKey: .originApprovalRuleTemplate)
        }
        if let ruleContentSha256 = ruleContentSha256 {
            try encodeContainer.encode(ruleContentSha256, forKey: .ruleContentSha256)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleId)
        approvalRuleId = approvalRuleIdDecoded
        let approvalRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleName)
        approvalRuleName = approvalRuleNameDecoded
        let approvalRuleContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleContent)
        approvalRuleContent = approvalRuleContentDecoded
        let ruleContentSha256Decoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleContentSha256)
        ruleContentSha256 = ruleContentSha256Decoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedUser)
        lastModifiedUser = lastModifiedUserDecoded
        let originApprovalRuleTemplateDecoded = try containerValues.decodeIfPresent(OriginApprovalRuleTemplate.self, forKey: .originApprovalRuleTemplate)
        originApprovalRuleTemplate = originApprovalRuleTemplateDecoded
    }
}

extension ApprovalRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApprovalRule(approvalRuleContent: \(String(describing: approvalRuleContent)), approvalRuleId: \(String(describing: approvalRuleId)), approvalRuleName: \(String(describing: approvalRuleName)), creationDate: \(String(describing: creationDate)), lastModifiedDate: \(String(describing: lastModifiedDate)), lastModifiedUser: \(String(describing: lastModifiedUser)), originApprovalRuleTemplate: \(String(describing: originApprovalRuleTemplate)), ruleContentSha256: \(String(describing: ruleContentSha256)))"}
}

/// <p>Returns information about an approval rule.</p>
public struct ApprovalRule: Equatable {
    /// <p>The content of the approval rule.</p>
    public let approvalRuleContent: String?
    /// <p>The system-generated ID of the approval rule.</p>
    public let approvalRuleId: String?
    /// <p>The name of the approval rule.</p>
    public let approvalRuleName: String?
    /// <p>The date the approval rule was created, in timestamp format.</p>
    public let creationDate: Date?
    /// <p>The date the approval rule was most recently changed, in timestamp format.</p>
    public let lastModifiedDate: Date?
    /// <p>The Amazon Resource Name (ARN) of the user who made the most recent changes to the approval rule.</p>
    public let lastModifiedUser: String?
    /// <p>The approval rule template used to create the rule.</p>
    public let originApprovalRuleTemplate: OriginApprovalRuleTemplate?
    /// <p>The SHA-256 hash signature for the content of the approval rule.</p>
    public let ruleContentSha256: String?

    public init (
        approvalRuleContent: String? = nil,
        approvalRuleId: String? = nil,
        approvalRuleName: String? = nil,
        creationDate: Date? = nil,
        lastModifiedDate: Date? = nil,
        lastModifiedUser: String? = nil,
        originApprovalRuleTemplate: OriginApprovalRuleTemplate? = nil,
        ruleContentSha256: String? = nil
    )
    {
        self.approvalRuleContent = approvalRuleContent
        self.approvalRuleId = approvalRuleId
        self.approvalRuleName = approvalRuleName
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.lastModifiedUser = lastModifiedUser
        self.originApprovalRuleTemplate = originApprovalRuleTemplate
        self.ruleContentSha256 = ruleContentSha256
    }
}

extension ApprovalRuleContentRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApprovalRuleContentRequiredException(message: \(String(describing: message)))"}
}

extension ApprovalRuleContentRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApprovalRuleContentRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The content for the approval rule is empty. You must provide some content for an approval rule. The content cannot be null.</p>
public struct ApprovalRuleContentRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalRuleContentRequiredExceptionBody: Equatable {
    public let message: String?
}

extension ApprovalRuleContentRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApprovalRuleDoesNotExistException(message: \(String(describing: message)))"}
}

extension ApprovalRuleDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApprovalRuleDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified approval rule does not exist.</p>
public struct ApprovalRuleDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalRuleDoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension ApprovalRuleDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleEventMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRuleContent
        case approvalRuleId
        case approvalRuleName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleContent = approvalRuleContent {
            try encodeContainer.encode(approvalRuleContent, forKey: .approvalRuleContent)
        }
        if let approvalRuleId = approvalRuleId {
            try encodeContainer.encode(approvalRuleId, forKey: .approvalRuleId)
        }
        if let approvalRuleName = approvalRuleName {
            try encodeContainer.encode(approvalRuleName, forKey: .approvalRuleName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleName)
        approvalRuleName = approvalRuleNameDecoded
        let approvalRuleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleId)
        approvalRuleId = approvalRuleIdDecoded
        let approvalRuleContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleContent)
        approvalRuleContent = approvalRuleContentDecoded
    }
}

extension ApprovalRuleEventMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApprovalRuleEventMetadata(approvalRuleContent: \(String(describing: approvalRuleContent)), approvalRuleId: \(String(describing: approvalRuleId)), approvalRuleName: \(String(describing: approvalRuleName)))"}
}

/// <p>Returns information about an event for an approval rule.</p>
public struct ApprovalRuleEventMetadata: Equatable {
    /// <p>The content of the approval rule.</p>
    public let approvalRuleContent: String?
    /// <p>The system-generated ID of the approval rule.</p>
    public let approvalRuleId: String?
    /// <p>The name of the approval rule.</p>
    public let approvalRuleName: String?

    public init (
        approvalRuleContent: String? = nil,
        approvalRuleId: String? = nil,
        approvalRuleName: String? = nil
    )
    {
        self.approvalRuleContent = approvalRuleContent
        self.approvalRuleId = approvalRuleId
        self.approvalRuleName = approvalRuleName
    }
}

extension ApprovalRuleNameAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApprovalRuleNameAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ApprovalRuleNameAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApprovalRuleNameAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An approval rule with that name already exists. Approval rule names must be unique
///             within the scope of a pull request.</p>
public struct ApprovalRuleNameAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalRuleNameAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ApprovalRuleNameAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleNameRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApprovalRuleNameRequiredException(message: \(String(describing: message)))"}
}

extension ApprovalRuleNameRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApprovalRuleNameRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An approval rule name is required, but was not specified.</p>
public struct ApprovalRuleNameRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalRuleNameRequiredExceptionBody: Equatable {
    public let message: String?
}

extension ApprovalRuleNameRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleOverriddenEventMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case overrideStatus
        case revisionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrideStatus = overrideStatus {
            try encodeContainer.encode(overrideStatus.rawValue, forKey: .overrideStatus)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let overrideStatusDecoded = try containerValues.decodeIfPresent(OverrideStatus.self, forKey: .overrideStatus)
        overrideStatus = overrideStatusDecoded
    }
}

extension ApprovalRuleOverriddenEventMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApprovalRuleOverriddenEventMetadata(overrideStatus: \(String(describing: overrideStatus)), revisionId: \(String(describing: revisionId)))"}
}

/// <p>Returns information about an override event for approval rules for a pull request.</p>
public struct ApprovalRuleOverriddenEventMetadata: Equatable {
    /// <p>The status of the override event.</p>
    public let overrideStatus: OverrideStatus?
    /// <p>The revision ID of the pull request when the override event occurred.</p>
    public let revisionId: String?

    public init (
        overrideStatus: OverrideStatus? = nil,
        revisionId: String? = nil
    )
    {
        self.overrideStatus = overrideStatus
        self.revisionId = revisionId
    }
}

extension ApprovalRuleTemplate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateContent
        case approvalRuleTemplateDescription
        case approvalRuleTemplateId
        case approvalRuleTemplateName
        case creationDate
        case lastModifiedDate
        case lastModifiedUser
        case ruleContentSha256
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateContent = approvalRuleTemplateContent {
            try encodeContainer.encode(approvalRuleTemplateContent, forKey: .approvalRuleTemplateContent)
        }
        if let approvalRuleTemplateDescription = approvalRuleTemplateDescription {
            try encodeContainer.encode(approvalRuleTemplateDescription, forKey: .approvalRuleTemplateDescription)
        }
        if let approvalRuleTemplateId = approvalRuleTemplateId {
            try encodeContainer.encode(approvalRuleTemplateId, forKey: .approvalRuleTemplateId)
        }
        if let approvalRuleTemplateName = approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let lastModifiedUser = lastModifiedUser {
            try encodeContainer.encode(lastModifiedUser, forKey: .lastModifiedUser)
        }
        if let ruleContentSha256 = ruleContentSha256 {
            try encodeContainer.encode(ruleContentSha256, forKey: .ruleContentSha256)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateId)
        approvalRuleTemplateId = approvalRuleTemplateIdDecoded
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let approvalRuleTemplateDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateDescription)
        approvalRuleTemplateDescription = approvalRuleTemplateDescriptionDecoded
        let approvalRuleTemplateContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateContent)
        approvalRuleTemplateContent = approvalRuleTemplateContentDecoded
        let ruleContentSha256Decoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleContentSha256)
        ruleContentSha256 = ruleContentSha256Decoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedUser)
        lastModifiedUser = lastModifiedUserDecoded
    }
}

extension ApprovalRuleTemplate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApprovalRuleTemplate(approvalRuleTemplateContent: \(String(describing: approvalRuleTemplateContent)), approvalRuleTemplateDescription: \(String(describing: approvalRuleTemplateDescription)), approvalRuleTemplateId: \(String(describing: approvalRuleTemplateId)), approvalRuleTemplateName: \(String(describing: approvalRuleTemplateName)), creationDate: \(String(describing: creationDate)), lastModifiedDate: \(String(describing: lastModifiedDate)), lastModifiedUser: \(String(describing: lastModifiedUser)), ruleContentSha256: \(String(describing: ruleContentSha256)))"}
}

/// <p>Returns information about an approval rule template.</p>
public struct ApprovalRuleTemplate: Equatable {
    /// <p>The content of the approval rule template.</p>
    public let approvalRuleTemplateContent: String?
    /// <p>The description of the approval rule template.</p>
    public let approvalRuleTemplateDescription: String?
    /// <p>The system-generated ID of the approval rule template.</p>
    public let approvalRuleTemplateId: String?
    /// <p>The name of the approval rule template.</p>
    public let approvalRuleTemplateName: String?
    /// <p>The date the approval rule template was created, in timestamp format.</p>
    public let creationDate: Date?
    /// <p>The date the approval rule template was most recently changed, in timestamp format.</p>
    public let lastModifiedDate: Date?
    /// <p>The Amazon Resource Name (ARN) of the user who made the most recent changes to the approval rule template.</p>
    public let lastModifiedUser: String?
    /// <p>The SHA-256 hash signature for the content of the approval rule template.</p>
    public let ruleContentSha256: String?

    public init (
        approvalRuleTemplateContent: String? = nil,
        approvalRuleTemplateDescription: String? = nil,
        approvalRuleTemplateId: String? = nil,
        approvalRuleTemplateName: String? = nil,
        creationDate: Date? = nil,
        lastModifiedDate: Date? = nil,
        lastModifiedUser: String? = nil,
        ruleContentSha256: String? = nil
    )
    {
        self.approvalRuleTemplateContent = approvalRuleTemplateContent
        self.approvalRuleTemplateDescription = approvalRuleTemplateDescription
        self.approvalRuleTemplateId = approvalRuleTemplateId
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.lastModifiedUser = lastModifiedUser
        self.ruleContentSha256 = ruleContentSha256
    }
}

extension ApprovalRuleTemplateContentRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApprovalRuleTemplateContentRequiredException(message: \(String(describing: message)))"}
}

extension ApprovalRuleTemplateContentRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApprovalRuleTemplateContentRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The content for the approval rule template is empty. You must provide some content for an approval rule template. The content cannot be null.</p>
public struct ApprovalRuleTemplateContentRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalRuleTemplateContentRequiredExceptionBody: Equatable {
    public let message: String?
}

extension ApprovalRuleTemplateContentRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleTemplateDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApprovalRuleTemplateDoesNotExistException(message: \(String(describing: message)))"}
}

extension ApprovalRuleTemplateDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApprovalRuleTemplateDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template
///         was created, and then try again.</p>
public struct ApprovalRuleTemplateDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalRuleTemplateDoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension ApprovalRuleTemplateDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleTemplateInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApprovalRuleTemplateInUseException(message: \(String(describing: message)))"}
}

extension ApprovalRuleTemplateInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApprovalRuleTemplateInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The approval rule template is associated with one or more repositories. You cannot delete a template that is associated with a repository. Remove
///         all associations, and then try again.</p>
public struct ApprovalRuleTemplateInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalRuleTemplateInUseExceptionBody: Equatable {
    public let message: String?
}

extension ApprovalRuleTemplateInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleTemplateNameAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApprovalRuleTemplateNameAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ApprovalRuleTemplateNameAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApprovalRuleTemplateNameAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You cannot create an approval rule template with that name because a template with
///             that name already exists in this AWS Region for your AWS account. Approval rule template
///             names must be unique.</p>
public struct ApprovalRuleTemplateNameAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalRuleTemplateNameAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ApprovalRuleTemplateNameAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalRuleTemplateNameRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApprovalRuleTemplateNameRequiredException(message: \(String(describing: message)))"}
}

extension ApprovalRuleTemplateNameRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApprovalRuleTemplateNameRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An approval rule template name is required, but was not specified.</p>
public struct ApprovalRuleTemplateNameRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalRuleTemplateNameRequiredExceptionBody: Equatable {
    public let message: String?
}

extension ApprovalRuleTemplateNameRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ApprovalState {
    case approve
    case revoke
    case sdkUnknown(String)
}

extension ApprovalState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApprovalState] {
        return [
            .approve,
            .revoke,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .approve: return "APPROVE"
        case .revoke: return "REVOKE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApprovalState(rawValue: rawValue) ?? ApprovalState.sdkUnknown(rawValue)
    }
}

extension ApprovalStateChangedEventMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalStatus
        case revisionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalStatus = approvalStatus {
            try encodeContainer.encode(approvalStatus.rawValue, forKey: .approvalStatus)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let approvalStatusDecoded = try containerValues.decodeIfPresent(ApprovalState.self, forKey: .approvalStatus)
        approvalStatus = approvalStatusDecoded
    }
}

extension ApprovalStateChangedEventMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApprovalStateChangedEventMetadata(approvalStatus: \(String(describing: approvalStatus)), revisionId: \(String(describing: revisionId)))"}
}

/// <p>Returns information about a change in the approval state for a pull request.</p>
public struct ApprovalStateChangedEventMetadata: Equatable {
    /// <p>The approval status for the pull request.</p>
    public let approvalStatus: ApprovalState?
    /// <p>The revision ID of the pull request when the approval state changed.</p>
    public let revisionId: String?

    public init (
        approvalStatus: ApprovalState? = nil,
        revisionId: String? = nil
    )
    {
        self.approvalStatus = approvalStatus
        self.revisionId = revisionId
    }
}

extension ApprovalStateRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApprovalStateRequiredException(message: \(String(describing: message)))"}
}

extension ApprovalStateRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApprovalStateRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An approval state is required, but was not specified.</p>
public struct ApprovalStateRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalStateRequiredExceptionBody: Equatable {
    public let message: String?
}

extension ApprovalStateRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AssociateApprovalRuleTemplateWithRepositoryInputBodyMiddleware: Middleware {
    public let id: String = "AssociateApprovalRuleTemplateWithRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateApprovalRuleTemplateWithRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateApprovalRuleTemplateWithRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateApprovalRuleTemplateWithRepositoryInput>
    public typealias MOutput = OperationOutput<AssociateApprovalRuleTemplateWithRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateApprovalRuleTemplateWithRepositoryOutputError>
}

extension AssociateApprovalRuleTemplateWithRepositoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateApprovalRuleTemplateWithRepositoryInput(approvalRuleTemplateName: \(String(describing: approvalRuleTemplateName)), repositoryName: \(String(describing: repositoryName)))"}
}

extension AssociateApprovalRuleTemplateWithRepositoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateName
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct AssociateApprovalRuleTemplateWithRepositoryInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateApprovalRuleTemplateWithRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateApprovalRuleTemplateWithRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateApprovalRuleTemplateWithRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateApprovalRuleTemplateWithRepositoryInput>
    public typealias MOutput = OperationOutput<AssociateApprovalRuleTemplateWithRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateApprovalRuleTemplateWithRepositoryOutputError>
}

public struct AssociateApprovalRuleTemplateWithRepositoryInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateApprovalRuleTemplateWithRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateApprovalRuleTemplateWithRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateApprovalRuleTemplateWithRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateApprovalRuleTemplateWithRepositoryInput>
    public typealias MOutput = OperationOutput<AssociateApprovalRuleTemplateWithRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateApprovalRuleTemplateWithRepositoryOutputError>
}

public struct AssociateApprovalRuleTemplateWithRepositoryInput: Equatable {
    /// <p>The name for the approval rule template. </p>
    public let approvalRuleTemplateName: String?
    /// <p>The name of the repository that you want to associate with the template.</p>
    public let repositoryName: String?

    public init (
        approvalRuleTemplateName: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.repositoryName = repositoryName
    }
}

struct AssociateApprovalRuleTemplateWithRepositoryInputBody: Equatable {
    public let approvalRuleTemplateName: String?
    public let repositoryName: String?
}

extension AssociateApprovalRuleTemplateWithRepositoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateName
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension AssociateApprovalRuleTemplateWithRepositoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateApprovalRuleTemplateWithRepositoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateDoesNotExistException" : self = .approvalRuleTemplateDoesNotExistException(try ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumRuleTemplatesAssociatedWithRepositoryException" : self = .maximumRuleTemplatesAssociatedWithRepositoryException(try MaximumRuleTemplatesAssociatedWithRepositoryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateApprovalRuleTemplateWithRepositoryOutputError: Equatable {
    case approvalRuleTemplateDoesNotExistException(ApprovalRuleTemplateDoesNotExistException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case maximumRuleTemplatesAssociatedWithRepositoryException(MaximumRuleTemplatesAssociatedWithRepositoryException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateApprovalRuleTemplateWithRepositoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateApprovalRuleTemplateWithRepositoryOutputResponse()"}
}

extension AssociateApprovalRuleTemplateWithRepositoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateApprovalRuleTemplateWithRepositoryOutputResponse: Equatable {

    public init() {}
}

struct AssociateApprovalRuleTemplateWithRepositoryOutputResponseBody: Equatable {
}

extension AssociateApprovalRuleTemplateWithRepositoryOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AuthorDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorDoesNotExistException(message: \(String(describing: message)))"}
}

extension AuthorDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AuthorDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified Amazon Resource Name (ARN) does not exist in the AWS account.</p>
public struct AuthorDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AuthorDoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension AuthorDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case errorMessage
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAssociateApprovalRuleTemplateWithRepositoriesError(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), repositoryName: \(String(describing: repositoryName)))"}
}

/// <p>Returns information about errors in a BatchAssociateApprovalRuleTemplateWithRepositories operation.</p>
public struct BatchAssociateApprovalRuleTemplateWithRepositoriesError: Equatable {
    /// <p>An error code that specifies whether the repository name was not valid or not found.</p>
    public let errorCode: String?
    /// <p>An error message that provides details about why the repository name was not found or not valid.</p>
    public let errorMessage: String?
    /// <p>The name of the repository where the association was not made.</p>
    public let repositoryName: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.repositoryName = repositoryName
    }
}

public struct BatchAssociateApprovalRuleTemplateWithRepositoriesInputBodyMiddleware: Middleware {
    public let id: String = "BatchAssociateApprovalRuleTemplateWithRepositoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAssociateApprovalRuleTemplateWithRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAssociateApprovalRuleTemplateWithRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAssociateApprovalRuleTemplateWithRepositoriesInput>
    public typealias MOutput = OperationOutput<BatchAssociateApprovalRuleTemplateWithRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAssociateApprovalRuleTemplateWithRepositoriesOutputError>
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAssociateApprovalRuleTemplateWithRepositoriesInput(approvalRuleTemplateName: \(String(describing: approvalRuleTemplateName)), repositoryNames: \(String(describing: repositoryNames)))"}
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateName
        case repositoryNames
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let repositoryNames = repositoryNames {
            var repositoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositoryNames)
            for repositorynamelist0 in repositoryNames {
                try repositoryNamesContainer.encode(repositorynamelist0)
            }
        }
    }
}

public struct BatchAssociateApprovalRuleTemplateWithRepositoriesInputHeadersMiddleware: Middleware {
    public let id: String = "BatchAssociateApprovalRuleTemplateWithRepositoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAssociateApprovalRuleTemplateWithRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAssociateApprovalRuleTemplateWithRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAssociateApprovalRuleTemplateWithRepositoriesInput>
    public typealias MOutput = OperationOutput<BatchAssociateApprovalRuleTemplateWithRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAssociateApprovalRuleTemplateWithRepositoriesOutputError>
}

public struct BatchAssociateApprovalRuleTemplateWithRepositoriesInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchAssociateApprovalRuleTemplateWithRepositoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAssociateApprovalRuleTemplateWithRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAssociateApprovalRuleTemplateWithRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAssociateApprovalRuleTemplateWithRepositoriesInput>
    public typealias MOutput = OperationOutput<BatchAssociateApprovalRuleTemplateWithRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAssociateApprovalRuleTemplateWithRepositoriesOutputError>
}

public struct BatchAssociateApprovalRuleTemplateWithRepositoriesInput: Equatable {
    /// <p>The name of the template you want to associate with one or more repositories.</p>
    public let approvalRuleTemplateName: String?
    /// <p>The names of the repositories you want to associate with the template.</p>
    ///         <note>
    ///             <p>The length constraint limit is for each string in the array. The array itself can be empty.</p>
    ///          </note>
    public let repositoryNames: [String]?

    public init (
        approvalRuleTemplateName: String? = nil,
        repositoryNames: [String]? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.repositoryNames = repositoryNames
    }
}

struct BatchAssociateApprovalRuleTemplateWithRepositoriesInputBody: Equatable {
    public let approvalRuleTemplateName: String?
    public let repositoryNames: [String]?
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateName
        case repositoryNames
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let repositoryNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
    }
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateDoesNotExistException" : self = .approvalRuleTemplateDoesNotExistException(try ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumRepositoryNamesExceededException" : self = .maximumRepositoryNamesExceededException(try MaximumRepositoryNamesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNamesRequiredException" : self = .repositoryNamesRequiredException(try RepositoryNamesRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchAssociateApprovalRuleTemplateWithRepositoriesOutputError: Equatable {
    case approvalRuleTemplateDoesNotExistException(ApprovalRuleTemplateDoesNotExistException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case maximumRepositoryNamesExceededException(MaximumRepositoryNamesExceededException)
    case repositoryNamesRequiredException(RepositoryNamesRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAssociateApprovalRuleTemplateWithRepositoriesOutputResponse(associatedRepositoryNames: \(String(describing: associatedRepositoryNames)), errors: \(String(describing: errors)))"}
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchAssociateApprovalRuleTemplateWithRepositoriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.associatedRepositoryNames = output.associatedRepositoryNames
            self.errors = output.errors
        } else {
            self.associatedRepositoryNames = nil
            self.errors = nil
        }
    }
}

public struct BatchAssociateApprovalRuleTemplateWithRepositoriesOutputResponse: Equatable {
    /// <p>A list of names of the repositories that have been associated with the template.</p>
    public let associatedRepositoryNames: [String]?
    /// <p>A list of any errors that might have occurred while attempting to create the association between the template and the repositories.</p>
    public let errors: [BatchAssociateApprovalRuleTemplateWithRepositoriesError]?

    public init (
        associatedRepositoryNames: [String]? = nil,
        errors: [BatchAssociateApprovalRuleTemplateWithRepositoriesError]? = nil
    )
    {
        self.associatedRepositoryNames = associatedRepositoryNames
        self.errors = errors
    }
}

struct BatchAssociateApprovalRuleTemplateWithRepositoriesOutputResponseBody: Equatable {
    public let associatedRepositoryNames: [String]?
    public let errors: [BatchAssociateApprovalRuleTemplateWithRepositoriesError]?
}

extension BatchAssociateApprovalRuleTemplateWithRepositoriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associatedRepositoryNames
        case errors
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedRepositoryNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .associatedRepositoryNames)
        var associatedRepositoryNamesDecoded0:[String]? = nil
        if let associatedRepositoryNamesContainer = associatedRepositoryNamesContainer {
            associatedRepositoryNamesDecoded0 = [String]()
            for string0 in associatedRepositoryNamesContainer {
                if let string0 = string0 {
                    associatedRepositoryNamesDecoded0?.append(string0)
                }
            }
        }
        associatedRepositoryNames = associatedRepositoryNamesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([BatchAssociateApprovalRuleTemplateWithRepositoriesError?].self, forKey: .errors)
        var errorsDecoded0:[BatchAssociateApprovalRuleTemplateWithRepositoriesError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [BatchAssociateApprovalRuleTemplateWithRepositoriesError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension BatchDescribeMergeConflictsError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exceptionName
        case filePath
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exceptionName = exceptionName {
            try encodeContainer.encode(exceptionName, forKey: .exceptionName)
        }
        if let filePath = filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePath)
        filePath = filePathDecoded
        let exceptionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exceptionName)
        exceptionName = exceptionNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchDescribeMergeConflictsError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDescribeMergeConflictsError(exceptionName: \(String(describing: exceptionName)), filePath: \(String(describing: filePath)), message: \(String(describing: message)))"}
}

/// <p>Returns information about errors in a BatchDescribeMergeConflicts operation.</p>
public struct BatchDescribeMergeConflictsError: Equatable {
    /// <p>The name of the exception.</p>
    public let exceptionName: String?
    /// <p>The path to the file.</p>
    public let filePath: String?
    /// <p>The message provided by the exception.</p>
    public let message: String?

    public init (
        exceptionName: String? = nil,
        filePath: String? = nil,
        message: String? = nil
    )
    {
        self.exceptionName = exceptionName
        self.filePath = filePath
        self.message = message
    }
}

public struct BatchDescribeMergeConflictsInputBodyMiddleware: Middleware {
    public let id: String = "BatchDescribeMergeConflictsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDescribeMergeConflictsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDescribeMergeConflictsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDescribeMergeConflictsInput>
    public typealias MOutput = OperationOutput<BatchDescribeMergeConflictsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDescribeMergeConflictsOutputError>
}

extension BatchDescribeMergeConflictsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDescribeMergeConflictsInput(conflictDetailLevel: \(String(describing: conflictDetailLevel)), conflictResolutionStrategy: \(String(describing: conflictResolutionStrategy)), destinationCommitSpecifier: \(String(describing: destinationCommitSpecifier)), filePaths: \(String(describing: filePaths)), maxConflictFiles: \(String(describing: maxConflictFiles)), maxMergeHunks: \(String(describing: maxMergeHunks)), mergeOption: \(String(describing: mergeOption)), nextToken: \(String(describing: nextToken)), repositoryName: \(String(describing: repositoryName)), sourceCommitSpecifier: \(String(describing: sourceCommitSpecifier)))"}
}

extension BatchDescribeMergeConflictsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case filePaths
        case maxConflictFiles
        case maxMergeHunks
        case mergeOption
        case nextToken
        case repositoryName
        case sourceCommitSpecifier
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetailLevel = conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolutionStrategy = conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let filePaths = filePaths {
            var filePathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filePaths)
            for filepaths0 in filePaths {
                try filePathsContainer.encode(filepaths0)
            }
        }
        if let maxConflictFiles = maxConflictFiles {
            try encodeContainer.encode(maxConflictFiles, forKey: .maxConflictFiles)
        }
        if let maxMergeHunks = maxMergeHunks {
            try encodeContainer.encode(maxMergeHunks, forKey: .maxMergeHunks)
        }
        if let mergeOption = mergeOption {
            try encodeContainer.encode(mergeOption.rawValue, forKey: .mergeOption)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
    }
}

public struct BatchDescribeMergeConflictsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDescribeMergeConflictsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDescribeMergeConflictsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDescribeMergeConflictsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDescribeMergeConflictsInput>
    public typealias MOutput = OperationOutput<BatchDescribeMergeConflictsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDescribeMergeConflictsOutputError>
}

public struct BatchDescribeMergeConflictsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDescribeMergeConflictsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDescribeMergeConflictsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDescribeMergeConflictsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDescribeMergeConflictsInput>
    public typealias MOutput = OperationOutput<BatchDescribeMergeConflictsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDescribeMergeConflictsOutputError>
}

public struct BatchDescribeMergeConflictsInput: Equatable {
    /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
    ///             which returns a not-mergeable result if the same file has differences in both branches.
    ///             If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
    ///             both branches has differences on the same line.</p>
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
    ///             automatically merging two versions of a file. The default is NONE, which requires any
    ///             conflicts to be resolved manually before the merge operation is successful.</p>
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, a branch name or a full commit ID).</p>
    public let destinationCommitSpecifier: String?
    /// <p>The path of the target files used to describe the conflicts. If not specified, the default is all conflict files.</p>
    public let filePaths: [String]?
    /// <p>The maximum number of files to include in the output.</p>
    public let maxConflictFiles: Int?
    /// <p>The maximum number of merge hunks to include in the output.</p>
    public let maxMergeHunks: Int?
    /// <p>The merge option or strategy you want to use to merge the code.</p>
    public let mergeOption: MergeOptionTypeEnum?
    /// <p>An enumeration token that, when provided in a request, returns the next batch of the
    ///             results.</p>
    public let nextToken: String?
    /// <p>The name of the repository that contains the merge conflicts you want to review.</p>
    public let repositoryName: String?
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, a branch name or a full commit ID).</p>
    public let sourceCommitSpecifier: String?

    public init (
        conflictDetailLevel: ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: String? = nil,
        filePaths: [String]? = nil,
        maxConflictFiles: Int? = nil,
        maxMergeHunks: Int? = nil,
        mergeOption: MergeOptionTypeEnum? = nil,
        nextToken: String? = nil,
        repositoryName: String? = nil,
        sourceCommitSpecifier: String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.filePaths = filePaths
        self.maxConflictFiles = maxConflictFiles
        self.maxMergeHunks = maxMergeHunks
        self.mergeOption = mergeOption
        self.nextToken = nextToken
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

struct BatchDescribeMergeConflictsInputBody: Equatable {
    public let repositoryName: String?
    public let destinationCommitSpecifier: String?
    public let sourceCommitSpecifier: String?
    public let mergeOption: MergeOptionTypeEnum?
    public let maxMergeHunks: Int?
    public let maxConflictFiles: Int?
    public let filePaths: [String]?
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
    public let nextToken: String?
}

extension BatchDescribeMergeConflictsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case filePaths
        case maxConflictFiles
        case maxMergeHunks
        case mergeOption
        case nextToken
        case repositoryName
        case sourceCommitSpecifier
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let mergeOptionDecoded = try containerValues.decodeIfPresent(MergeOptionTypeEnum.self, forKey: .mergeOption)
        mergeOption = mergeOptionDecoded
        let maxMergeHunksDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxMergeHunks)
        maxMergeHunks = maxMergeHunksDecoded
        let maxConflictFilesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxConflictFiles)
        maxConflictFiles = maxConflictFilesDecoded
        let filePathsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .filePaths)
        var filePathsDecoded0:[String]? = nil
        if let filePathsContainer = filePathsContainer {
            filePathsDecoded0 = [String]()
            for string0 in filePathsContainer {
                if let string0 = string0 {
                    filePathsDecoded0?.append(string0)
                }
            }
        }
        filePaths = filePathsDecoded0
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchDescribeMergeConflictsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDescribeMergeConflictsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxConflictFilesException" : self = .invalidMaxConflictFilesException(try InvalidMaxConflictFilesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxMergeHunksException" : self = .invalidMaxMergeHunksException(try InvalidMaxMergeHunksException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMergeOptionException" : self = .invalidMergeOptionException(try InvalidMergeOptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileContentToLoadExceededException" : self = .maximumFileContentToLoadExceededException(try MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumItemsToCompareExceededException" : self = .maximumItemsToCompareExceededException(try MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MergeOptionRequiredException" : self = .mergeOptionRequiredException(try MergeOptionRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDescribeMergeConflictsOutputError: Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitRequiredException(CommitRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommitException(InvalidCommitException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxConflictFilesException(InvalidMaxConflictFilesException)
    case invalidMaxMergeHunksException(InvalidMaxMergeHunksException)
    case invalidMergeOptionException(InvalidMergeOptionException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case maximumFileContentToLoadExceededException(MaximumFileContentToLoadExceededException)
    case maximumItemsToCompareExceededException(MaximumItemsToCompareExceededException)
    case mergeOptionRequiredException(MergeOptionRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDescribeMergeConflictsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDescribeMergeConflictsOutputResponse(baseCommitId: \(String(describing: baseCommitId)), conflicts: \(String(describing: conflicts)), destinationCommitId: \(String(describing: destinationCommitId)), errors: \(String(describing: errors)), nextToken: \(String(describing: nextToken)), sourceCommitId: \(String(describing: sourceCommitId)))"}
}

extension BatchDescribeMergeConflictsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDescribeMergeConflictsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.baseCommitId = output.baseCommitId
            self.conflicts = output.conflicts
            self.destinationCommitId = output.destinationCommitId
            self.errors = output.errors
            self.nextToken = output.nextToken
            self.sourceCommitId = output.sourceCommitId
        } else {
            self.baseCommitId = nil
            self.conflicts = nil
            self.destinationCommitId = nil
            self.errors = nil
            self.nextToken = nil
            self.sourceCommitId = nil
        }
    }
}

public struct BatchDescribeMergeConflictsOutputResponse: Equatable {
    /// <p>The commit ID of the merge base.</p>
    public let baseCommitId: String?
    /// <p>A list of conflicts for each file, including the conflict metadata and the hunks of the differences between the files.</p>
    public let conflicts: [Conflict]?
    /// <p>The commit ID of the destination commit specifier that was used in the merge evaluation.</p>
    public let destinationCommitId: String?
    /// <p>A list of any errors returned while describing the merge conflicts for each file.</p>
    public let errors: [BatchDescribeMergeConflictsError]?
    /// <p>An enumeration token that can be used in a request to return the next batch of the results.</p>
    public let nextToken: String?
    /// <p>The commit ID of the source commit specifier that was used in the merge evaluation.</p>
    public let sourceCommitId: String?

    public init (
        baseCommitId: String? = nil,
        conflicts: [Conflict]? = nil,
        destinationCommitId: String? = nil,
        errors: [BatchDescribeMergeConflictsError]? = nil,
        nextToken: String? = nil,
        sourceCommitId: String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.conflicts = conflicts
        self.destinationCommitId = destinationCommitId
        self.errors = errors
        self.nextToken = nextToken
        self.sourceCommitId = sourceCommitId
    }
}

struct BatchDescribeMergeConflictsOutputResponseBody: Equatable {
    public let conflicts: [Conflict]?
    public let nextToken: String?
    public let errors: [BatchDescribeMergeConflictsError]?
    public let destinationCommitId: String?
    public let sourceCommitId: String?
    public let baseCommitId: String?
}

extension BatchDescribeMergeConflictsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baseCommitId
        case conflicts
        case destinationCommitId
        case errors
        case nextToken
        case sourceCommitId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictsContainer = try containerValues.decodeIfPresent([Conflict?].self, forKey: .conflicts)
        var conflictsDecoded0:[Conflict]? = nil
        if let conflictsContainer = conflictsContainer {
            conflictsDecoded0 = [Conflict]()
            for structure0 in conflictsContainer {
                if let structure0 = structure0 {
                    conflictsDecoded0?.append(structure0)
                }
            }
        }
        conflicts = conflictsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let errorsContainer = try containerValues.decodeIfPresent([BatchDescribeMergeConflictsError?].self, forKey: .errors)
        var errorsDecoded0:[BatchDescribeMergeConflictsError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [BatchDescribeMergeConflictsError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
        let destinationCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationCommitId)
        destinationCommitId = destinationCommitIdDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let baseCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baseCommitId)
        baseCommitId = baseCommitIdDecoded
    }
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case errorMessage
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDisassociateApprovalRuleTemplateFromRepositoriesError(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), repositoryName: \(String(describing: repositoryName)))"}
}

/// <p>Returns information about errors in a BatchDisassociateApprovalRuleTemplateFromRepositories operation.</p>
public struct BatchDisassociateApprovalRuleTemplateFromRepositoriesError: Equatable {
    /// <p>An error code that specifies whether the repository name was not valid or not
    ///             found.</p>
    public let errorCode: String?
    /// <p>An error message that provides details about why the repository name was either not found or not valid.</p>
    public let errorMessage: String?
    /// <p>The name of the repository where the association with the template was not able to be removed.</p>
    public let repositoryName: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.repositoryName = repositoryName
    }
}

public struct BatchDisassociateApprovalRuleTemplateFromRepositoriesInputBodyMiddleware: Middleware {
    public let id: String = "BatchDisassociateApprovalRuleTemplateFromRepositoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisassociateApprovalRuleTemplateFromRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisassociateApprovalRuleTemplateFromRepositoriesInput>
    public typealias MOutput = OperationOutput<BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputError>
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDisassociateApprovalRuleTemplateFromRepositoriesInput(approvalRuleTemplateName: \(String(describing: approvalRuleTemplateName)), repositoryNames: \(String(describing: repositoryNames)))"}
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateName
        case repositoryNames
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let repositoryNames = repositoryNames {
            var repositoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositoryNames)
            for repositorynamelist0 in repositoryNames {
                try repositoryNamesContainer.encode(repositorynamelist0)
            }
        }
    }
}

public struct BatchDisassociateApprovalRuleTemplateFromRepositoriesInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDisassociateApprovalRuleTemplateFromRepositoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisassociateApprovalRuleTemplateFromRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisassociateApprovalRuleTemplateFromRepositoriesInput>
    public typealias MOutput = OperationOutput<BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputError>
}

public struct BatchDisassociateApprovalRuleTemplateFromRepositoriesInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDisassociateApprovalRuleTemplateFromRepositoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisassociateApprovalRuleTemplateFromRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisassociateApprovalRuleTemplateFromRepositoriesInput>
    public typealias MOutput = OperationOutput<BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputError>
}

public struct BatchDisassociateApprovalRuleTemplateFromRepositoriesInput: Equatable {
    /// <p>The name of the template that you want to disassociate from one or more repositories.</p>
    public let approvalRuleTemplateName: String?
    /// <p>The repository names that you want to disassociate from the approval rule
    ///             template.</p>
    ///         <note>
    ///             <p>The length constraint limit is for each string in the array. The array itself can be empty.</p>
    ///          </note>
    public let repositoryNames: [String]?

    public init (
        approvalRuleTemplateName: String? = nil,
        repositoryNames: [String]? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.repositoryNames = repositoryNames
    }
}

struct BatchDisassociateApprovalRuleTemplateFromRepositoriesInputBody: Equatable {
    public let approvalRuleTemplateName: String?
    public let repositoryNames: [String]?
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateName
        case repositoryNames
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let repositoryNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
    }
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateDoesNotExistException" : self = .approvalRuleTemplateDoesNotExistException(try ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumRepositoryNamesExceededException" : self = .maximumRepositoryNamesExceededException(try MaximumRepositoryNamesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNamesRequiredException" : self = .repositoryNamesRequiredException(try RepositoryNamesRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputError: Equatable {
    case approvalRuleTemplateDoesNotExistException(ApprovalRuleTemplateDoesNotExistException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case maximumRepositoryNamesExceededException(MaximumRepositoryNamesExceededException)
    case repositoryNamesRequiredException(RepositoryNamesRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputResponse(disassociatedRepositoryNames: \(String(describing: disassociatedRepositoryNames)), errors: \(String(describing: errors)))"}
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.disassociatedRepositoryNames = output.disassociatedRepositoryNames
            self.errors = output.errors
        } else {
            self.disassociatedRepositoryNames = nil
            self.errors = nil
        }
    }
}

public struct BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputResponse: Equatable {
    /// <p>A list of repository names that have had their association with the template
    ///             removed.</p>
    public let disassociatedRepositoryNames: [String]?
    /// <p>A list of any errors that might have occurred while attempting to remove the association between the template and the repositories.</p>
    public let errors: [BatchDisassociateApprovalRuleTemplateFromRepositoriesError]?

    public init (
        disassociatedRepositoryNames: [String]? = nil,
        errors: [BatchDisassociateApprovalRuleTemplateFromRepositoriesError]? = nil
    )
    {
        self.disassociatedRepositoryNames = disassociatedRepositoryNames
        self.errors = errors
    }
}

struct BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputResponseBody: Equatable {
    public let disassociatedRepositoryNames: [String]?
    public let errors: [BatchDisassociateApprovalRuleTemplateFromRepositoriesError]?
}

extension BatchDisassociateApprovalRuleTemplateFromRepositoriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case disassociatedRepositoryNames
        case errors
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disassociatedRepositoryNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .disassociatedRepositoryNames)
        var disassociatedRepositoryNamesDecoded0:[String]? = nil
        if let disassociatedRepositoryNamesContainer = disassociatedRepositoryNamesContainer {
            disassociatedRepositoryNamesDecoded0 = [String]()
            for string0 in disassociatedRepositoryNamesContainer {
                if let string0 = string0 {
                    disassociatedRepositoryNamesDecoded0?.append(string0)
                }
            }
        }
        disassociatedRepositoryNames = disassociatedRepositoryNamesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([BatchDisassociateApprovalRuleTemplateFromRepositoriesError?].self, forKey: .errors)
        var errorsDecoded0:[BatchDisassociateApprovalRuleTemplateFromRepositoriesError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [BatchDisassociateApprovalRuleTemplateFromRepositoriesError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension BatchGetCommitsError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commitId
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitId = commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension BatchGetCommitsError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetCommitsError(commitId: \(String(describing: commitId)), errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)))"}
}

/// <p>Returns information about errors in a BatchGetCommits operation.</p>
public struct BatchGetCommitsError: Equatable {
    /// <p>A commit ID that either could not be found or was not in a valid format.</p>
    public let commitId: String?
    /// <p>An error code that specifies whether the commit ID was not valid or not found.</p>
    public let errorCode: String?
    /// <p>An error message that provides detail about why the commit ID either was not found or was not valid.</p>
    public let errorMessage: String?

    public init (
        commitId: String? = nil,
        errorCode: String? = nil,
        errorMessage: String? = nil
    )
    {
        self.commitId = commitId
        self.errorCode = errorCode
        self.errorMessage = errorMessage
    }
}

public struct BatchGetCommitsInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetCommitsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetCommitsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetCommitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetCommitsInput>
    public typealias MOutput = OperationOutput<BatchGetCommitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetCommitsOutputError>
}

extension BatchGetCommitsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetCommitsInput(commitIds: \(String(describing: commitIds)), repositoryName: \(String(describing: repositoryName)))"}
}

extension BatchGetCommitsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commitIds
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitIds = commitIds {
            var commitIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .commitIds)
            for commitidsinputlist0 in commitIds {
                try commitIdsContainer.encode(commitidsinputlist0)
            }
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct BatchGetCommitsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetCommitsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetCommitsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetCommitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetCommitsInput>
    public typealias MOutput = OperationOutput<BatchGetCommitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetCommitsOutputError>
}

public struct BatchGetCommitsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetCommitsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetCommitsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetCommitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetCommitsInput>
    public typealias MOutput = OperationOutput<BatchGetCommitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetCommitsOutputError>
}

public struct BatchGetCommitsInput: Equatable {
    /// <p>The full commit IDs of the commits to get information about.</p>
    ///         <note>
    ///             <p>You must supply the full SHA IDs of each commit. You cannot use shortened SHA
    ///                 IDs.</p>
    ///         </note>
    public let commitIds: [String]?
    /// <p>The name of the repository that contains the commits.</p>
    public let repositoryName: String?

    public init (
        commitIds: [String]? = nil,
        repositoryName: String? = nil
    )
    {
        self.commitIds = commitIds
        self.repositoryName = repositoryName
    }
}

struct BatchGetCommitsInputBody: Equatable {
    public let commitIds: [String]?
    public let repositoryName: String?
}

extension BatchGetCommitsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commitIds
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .commitIds)
        var commitIdsDecoded0:[String]? = nil
        if let commitIdsContainer = commitIdsContainer {
            commitIdsDecoded0 = [String]()
            for string0 in commitIdsContainer {
                if let string0 = string0 {
                    commitIdsDecoded0?.append(string0)
                }
            }
        }
        commitIds = commitIdsDecoded0
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension BatchGetCommitsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetCommitsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommitIdsLimitExceededException" : self = .commitIdsLimitExceededException(try CommitIdsLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitIdsListRequiredException" : self = .commitIdsListRequiredException(try CommitIdsListRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetCommitsOutputError: Equatable {
    case commitIdsLimitExceededException(CommitIdsLimitExceededException)
    case commitIdsListRequiredException(CommitIdsListRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetCommitsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetCommitsOutputResponse(commits: \(String(describing: commits)), errors: \(String(describing: errors)))"}
}

extension BatchGetCommitsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetCommitsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.commits = output.commits
            self.errors = output.errors
        } else {
            self.commits = nil
            self.errors = nil
        }
    }
}

public struct BatchGetCommitsOutputResponse: Equatable {
    /// <p>An array of commit data type objects, each of which contains information about a specified commit.</p>
    public let commits: [Commit]?
    /// <p>Returns any commit IDs for which information could not be found. For example, if one
    ///             of the commit IDs was a shortened SHA ID or that commit was not found in the specified
    ///             repository, the ID returns an error object with more information.</p>
    public let errors: [BatchGetCommitsError]?

    public init (
        commits: [Commit]? = nil,
        errors: [BatchGetCommitsError]? = nil
    )
    {
        self.commits = commits
        self.errors = errors
    }
}

struct BatchGetCommitsOutputResponseBody: Equatable {
    public let commits: [Commit]?
    public let errors: [BatchGetCommitsError]?
}

extension BatchGetCommitsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commits
        case errors
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitsContainer = try containerValues.decodeIfPresent([Commit?].self, forKey: .commits)
        var commitsDecoded0:[Commit]? = nil
        if let commitsContainer = commitsContainer {
            commitsDecoded0 = [Commit]()
            for structure0 in commitsContainer {
                if let structure0 = structure0 {
                    commitsDecoded0?.append(structure0)
                }
            }
        }
        commits = commitsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([BatchGetCommitsError?].self, forKey: .errors)
        var errorsDecoded0:[BatchGetCommitsError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [BatchGetCommitsError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct BatchGetRepositoriesInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetRepositoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetRepositoriesInput>
    public typealias MOutput = OperationOutput<BatchGetRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetRepositoriesOutputError>
}

extension BatchGetRepositoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetRepositoriesInput(repositoryNames: \(String(describing: repositoryNames)))"}
}

extension BatchGetRepositoriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case repositoryNames
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryNames = repositoryNames {
            var repositoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositoryNames)
            for repositorynamelist0 in repositoryNames {
                try repositoryNamesContainer.encode(repositorynamelist0)
            }
        }
    }
}

public struct BatchGetRepositoriesInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetRepositoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetRepositoriesInput>
    public typealias MOutput = OperationOutput<BatchGetRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetRepositoriesOutputError>
}

public struct BatchGetRepositoriesInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetRepositoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetRepositoriesInput>
    public typealias MOutput = OperationOutput<BatchGetRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetRepositoriesOutputError>
}

/// <p>Represents the input of a batch get repositories operation.</p>
public struct BatchGetRepositoriesInput: Equatable {
    /// <p>The names of the repositories to get information about.</p>
    ///         <note>
    ///             <p>The length constraint limit is for each string in the array. The array itself can be empty.</p>
    ///          </note>
    public let repositoryNames: [String]?

    public init (
        repositoryNames: [String]? = nil
    )
    {
        self.repositoryNames = repositoryNames
    }
}

struct BatchGetRepositoriesInputBody: Equatable {
    public let repositoryNames: [String]?
}

extension BatchGetRepositoriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repositoryNames
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
    }
}

extension BatchGetRepositoriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetRepositoriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumRepositoryNamesExceededException" : self = .maximumRepositoryNamesExceededException(try MaximumRepositoryNamesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNamesRequiredException" : self = .repositoryNamesRequiredException(try RepositoryNamesRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetRepositoriesOutputError: Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case maximumRepositoryNamesExceededException(MaximumRepositoryNamesExceededException)
    case repositoryNamesRequiredException(RepositoryNamesRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetRepositoriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetRepositoriesOutputResponse(repositories: \(String(describing: repositories)), repositoriesNotFound: \(String(describing: repositoriesNotFound)))"}
}

extension BatchGetRepositoriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetRepositoriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.repositories = output.repositories
            self.repositoriesNotFound = output.repositoriesNotFound
        } else {
            self.repositories = nil
            self.repositoriesNotFound = nil
        }
    }
}

/// <p>Represents the output of a batch get repositories operation.</p>
public struct BatchGetRepositoriesOutputResponse: Equatable {
    /// <p>A list of repositories returned by the batch get repositories operation.</p>
    public let repositories: [RepositoryMetadata]?
    /// <p>Returns a list of repository names for which information could not be found.</p>
    public let repositoriesNotFound: [String]?

    public init (
        repositories: [RepositoryMetadata]? = nil,
        repositoriesNotFound: [String]? = nil
    )
    {
        self.repositories = repositories
        self.repositoriesNotFound = repositoriesNotFound
    }
}

struct BatchGetRepositoriesOutputResponseBody: Equatable {
    public let repositories: [RepositoryMetadata]?
    public let repositoriesNotFound: [String]?
}

extension BatchGetRepositoriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repositories
        case repositoriesNotFound
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([RepositoryMetadata?].self, forKey: .repositories)
        var repositoriesDecoded0:[RepositoryMetadata]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [RepositoryMetadata]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let repositoriesNotFoundContainer = try containerValues.decodeIfPresent([String?].self, forKey: .repositoriesNotFound)
        var repositoriesNotFoundDecoded0:[String]? = nil
        if let repositoriesNotFoundContainer = repositoriesNotFoundContainer {
            repositoriesNotFoundDecoded0 = [String]()
            for string0 in repositoriesNotFoundContainer {
                if let string0 = string0 {
                    repositoriesNotFoundDecoded0?.append(string0)
                }
            }
        }
        repositoriesNotFound = repositoriesNotFoundDecoded0
    }
}

extension BeforeCommitIdAndAfterCommitIdAreSameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BeforeCommitIdAndAfterCommitIdAreSameException(message: \(String(describing: message)))"}
}

extension BeforeCommitIdAndAfterCommitIdAreSameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BeforeCommitIdAndAfterCommitIdAreSameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The before commit ID and the after commit ID are the same, which is not valid. The before commit ID and the after commit ID must be different commit IDs.</p>
public struct BeforeCommitIdAndAfterCommitIdAreSameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BeforeCommitIdAndAfterCommitIdAreSameExceptionBody: Equatable {
    public let message: String?
}

extension BeforeCommitIdAndAfterCommitIdAreSameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BlobIdDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BlobIdDoesNotExistException(message: \(String(describing: message)))"}
}

extension BlobIdDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BlobIdDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified blob does not exist.</p>
public struct BlobIdDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BlobIdDoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension BlobIdDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BlobIdRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BlobIdRequiredException(message: \(String(describing: message)))"}
}

extension BlobIdRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BlobIdRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A blob ID is required, but was not specified.</p>
public struct BlobIdRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BlobIdRequiredExceptionBody: Equatable {
    public let message: String?
}

extension BlobIdRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BlobMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blobId
        case mode
        case path
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blobId = blobId {
            try encodeContainer.encode(blobId, forKey: .blobId)
        }
        if let mode = mode {
            try encodeContainer.encode(mode, forKey: .mode)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let modeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension BlobMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BlobMetadata(blobId: \(String(describing: blobId)), mode: \(String(describing: mode)), path: \(String(describing: path)))"}
}

/// <p>Returns information about a specific Git blob object.</p>
public struct BlobMetadata: Equatable {
    /// <p>The full ID of the blob.</p>
    public let blobId: String?
    /// <p>The file mode permissions of the blob. File mode permission codes include:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>100644</code> indicates read/write</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>100755</code> indicates read/write/execute</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>160000</code> indicates a submodule</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>120000</code> indicates a symlink</p>
    ///             </li>
    ///          </ul>
    public let mode: String?
    /// <p>The path to the blob and associated file name, if any.</p>
    public let path: String?

    public init (
        blobId: String? = nil,
        mode: String? = nil,
        path: String? = nil
    )
    {
        self.blobId = blobId
        self.mode = mode
        self.path = path
    }
}

extension BranchDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BranchDoesNotExistException(message: \(String(describing: message)))"}
}

extension BranchDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BranchDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified branch does not exist.</p>
public struct BranchDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BranchDoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension BranchDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BranchInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branchName
        case commitId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let commitId = commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let commitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitId)
        commitId = commitIdDecoded
    }
}

extension BranchInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BranchInfo(branchName: \(String(describing: branchName)), commitId: \(String(describing: commitId)))"}
}

/// <p>Returns information about a branch.</p>
public struct BranchInfo: Equatable {
    /// <p>The name of the branch.</p>
    public let branchName: String?
    /// <p>The ID of the last commit made to the branch.</p>
    public let commitId: String?

    public init (
        branchName: String? = nil,
        commitId: String? = nil
    )
    {
        self.branchName = branchName
        self.commitId = commitId
    }
}

extension BranchNameExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BranchNameExistsException(message: \(String(describing: message)))"}
}

extension BranchNameExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BranchNameExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cannot create the branch with the specified name because the commit conflicts with an existing branch with the same name.
///             Branch names must be unique.</p>
public struct BranchNameExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BranchNameExistsExceptionBody: Equatable {
    public let message: String?
}

extension BranchNameExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BranchNameIsTagNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BranchNameIsTagNameException(message: \(String(describing: message)))"}
}

extension BranchNameIsTagNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BranchNameIsTagNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified branch name is not valid because it is a tag name. Enter the name of a
///             branch in the repository. For a list of valid branch names, use <a>ListBranches</a>.</p>
public struct BranchNameIsTagNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BranchNameIsTagNameExceptionBody: Equatable {
    public let message: String?
}

extension BranchNameIsTagNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BranchNameRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BranchNameRequiredException(message: \(String(describing: message)))"}
}

extension BranchNameRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BranchNameRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A branch name is required, but was not specified.</p>
public struct BranchNameRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BranchNameRequiredExceptionBody: Equatable {
    public let message: String?
}

extension BranchNameRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CannotDeleteApprovalRuleFromTemplateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CannotDeleteApprovalRuleFromTemplateException(message: \(String(describing: message)))"}
}

extension CannotDeleteApprovalRuleFromTemplateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CannotDeleteApprovalRuleFromTemplateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The approval rule cannot be deleted from the pull request because it was created by an
///             approval rule template and applied to the pull request automatically.</p>
public struct CannotDeleteApprovalRuleFromTemplateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CannotDeleteApprovalRuleFromTemplateExceptionBody: Equatable {
    public let message: String?
}

extension CannotDeleteApprovalRuleFromTemplateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CannotModifyApprovalRuleFromTemplateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CannotModifyApprovalRuleFromTemplateException(message: \(String(describing: message)))"}
}

extension CannotModifyApprovalRuleFromTemplateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CannotModifyApprovalRuleFromTemplateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The approval rule cannot be modified for the pull request because it was created by an
///             approval rule template and applied to the pull request automatically.</p>
public struct CannotModifyApprovalRuleFromTemplateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CannotModifyApprovalRuleFromTemplateExceptionBody: Equatable {
    public let message: String?
}

extension CannotModifyApprovalRuleFromTemplateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ChangeTypeEnum {
    case added
    case deleted
    case modified
    case sdkUnknown(String)
}

extension ChangeTypeEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChangeTypeEnum] {
        return [
            .added,
            .deleted,
            .modified,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .added: return "A"
        case .deleted: return "D"
        case .modified: return "M"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChangeTypeEnum(rawValue: rawValue) ?? ChangeTypeEnum.sdkUnknown(rawValue)
    }
}

extension ClientRequestTokenRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClientRequestTokenRequiredException(message: \(String(describing: message)))"}
}

extension ClientRequestTokenRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ClientRequestTokenRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A client request token is required. A client request token is an unique,
///             client-generated idempotency token that, when provided in a request, ensures the request
///             cannot be repeated with a changed parameter. If a request is received with the same
///             parameters and a token is included, the request returns information about the initial
///             request that used that token.</p>
public struct ClientRequestTokenRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClientRequestTokenRequiredExceptionBody: Equatable {
    public let message: String?
}

extension ClientRequestTokenRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Comment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorArn
        case callerReactions
        case clientRequestToken
        case commentId
        case content
        case creationDate
        case deleted
        case inReplyTo
        case lastModifiedDate
        case reactionCounts
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorArn = authorArn {
            try encodeContainer.encode(authorArn, forKey: .authorArn)
        }
        if let callerReactions = callerReactions {
            var callerReactionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .callerReactions)
            for callerreactions0 in callerReactions {
                try callerReactionsContainer.encode(callerreactions0)
            }
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let commentId = commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if deleted != false {
            try encodeContainer.encode(deleted, forKey: .deleted)
        }
        if let inReplyTo = inReplyTo {
            try encodeContainer.encode(inReplyTo, forKey: .inReplyTo)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let reactionCounts = reactionCounts {
            var reactionCountsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .reactionCounts)
            for (dictKey0, reactioncountsmap0) in reactionCounts {
                try reactionCountsContainer.encode(reactioncountsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commentId)
        commentId = commentIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let inReplyToDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inReplyTo)
        inReplyTo = inReplyToDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let authorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorArn)
        authorArn = authorArnDecoded
        let deletedDecoded = try containerValues.decode(Bool.self, forKey: .deleted)
        deleted = deletedDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let callerReactionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .callerReactions)
        var callerReactionsDecoded0:[String]? = nil
        if let callerReactionsContainer = callerReactionsContainer {
            callerReactionsDecoded0 = [String]()
            for string0 in callerReactionsContainer {
                if let string0 = string0 {
                    callerReactionsDecoded0?.append(string0)
                }
            }
        }
        callerReactions = callerReactionsDecoded0
        let reactionCountsContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .reactionCounts)
        var reactionCountsDecoded0: [String:Int]? = nil
        if let reactionCountsContainer = reactionCountsContainer {
            reactionCountsDecoded0 = [String:Int]()
            for (key0, count0) in reactionCountsContainer {
                if let count0 = count0 {
                    reactionCountsDecoded0?[key0] = count0
                }
            }
        }
        reactionCounts = reactionCountsDecoded0
    }
}

extension Comment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Comment(authorArn: \(String(describing: authorArn)), callerReactions: \(String(describing: callerReactions)), clientRequestToken: \(String(describing: clientRequestToken)), commentId: \(String(describing: commentId)), content: \(String(describing: content)), creationDate: \(String(describing: creationDate)), deleted: \(String(describing: deleted)), inReplyTo: \(String(describing: inReplyTo)), lastModifiedDate: \(String(describing: lastModifiedDate)), reactionCounts: \(String(describing: reactionCounts)))"}
}

/// <p>Returns information about a specific comment.</p>
public struct Comment: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the person who posted the comment.</p>
    public let authorArn: String?
    /// <p>The emoji reactions to a comment, if any, submitted by the user whose credentials are associated with the call to the API.</p>
    public let callerReactions: [String]?
    /// <p>A unique, client-generated idempotency token that, when provided in a request, ensures
    ///             the request cannot be repeated with a changed parameter. If a request is received with
    ///             the same parameters and a token is included, the request returns information about the
    ///             initial request that used that token.</p>
    public let clientRequestToken: String?
    /// <p>The system-generated comment ID.</p>
    public let commentId: String?
    /// <p>The content of the comment.</p>
    public let content: String?
    /// <p>The date and time the comment was created, in timestamp format.</p>
    public let creationDate: Date?
    /// <p>A Boolean value indicating whether the comment has been deleted.</p>
    public let deleted: Bool
    /// <p>The ID of the comment for which this comment is a reply, if any.</p>
    public let inReplyTo: String?
    /// <p>The date and time the comment was most recently modified, in timestamp format.</p>
    public let lastModifiedDate: Date?
    /// <p>A string to integer map that represents the number of individual users who have responded to a comment with the specified reactions.</p>
    public let reactionCounts: [String:Int]?

    public init (
        authorArn: String? = nil,
        callerReactions: [String]? = nil,
        clientRequestToken: String? = nil,
        commentId: String? = nil,
        content: String? = nil,
        creationDate: Date? = nil,
        deleted: Bool = false,
        inReplyTo: String? = nil,
        lastModifiedDate: Date? = nil,
        reactionCounts: [String:Int]? = nil
    )
    {
        self.authorArn = authorArn
        self.callerReactions = callerReactions
        self.clientRequestToken = clientRequestToken
        self.commentId = commentId
        self.content = content
        self.creationDate = creationDate
        self.deleted = deleted
        self.inReplyTo = inReplyTo
        self.lastModifiedDate = lastModifiedDate
        self.reactionCounts = reactionCounts
    }
}

extension CommentContentRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommentContentRequiredException(message: \(String(describing: message)))"}
}

extension CommentContentRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CommentContentRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The comment is empty. You must provide some content for a comment. The content cannot be null.</p>
public struct CommentContentRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CommentContentRequiredExceptionBody: Equatable {
    public let message: String?
}

extension CommentContentRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommentContentSizeLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommentContentSizeLimitExceededException(message: \(String(describing: message)))"}
}

extension CommentContentSizeLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CommentContentSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The comment is too large. Comments are limited to 1,000 characters.</p>
public struct CommentContentSizeLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CommentContentSizeLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension CommentContentSizeLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommentDeletedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommentDeletedException(message: \(String(describing: message)))"}
}

extension CommentDeletedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CommentDeletedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This comment has already been deleted. You cannot edit or delete a deleted comment.</p>
public struct CommentDeletedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CommentDeletedExceptionBody: Equatable {
    public let message: String?
}

extension CommentDeletedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommentDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommentDoesNotExistException(message: \(String(describing: message)))"}
}

extension CommentDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CommentDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No comment exists with the provided ID. Verify that you have used the correct ID, and
///             then try again.</p>
public struct CommentDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CommentDoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension CommentDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommentIdRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommentIdRequiredException(message: \(String(describing: message)))"}
}

extension CommentIdRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CommentIdRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The comment ID is missing or null. A comment ID is required.</p>
public struct CommentIdRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CommentIdRequiredExceptionBody: Equatable {
    public let message: String?
}

extension CommentIdRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommentNotCreatedByCallerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommentNotCreatedByCallerException(message: \(String(describing: message)))"}
}

extension CommentNotCreatedByCallerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CommentNotCreatedByCallerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You cannot modify or delete this comment. Only comment authors can modify or delete their comments.</p>
public struct CommentNotCreatedByCallerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CommentNotCreatedByCallerExceptionBody: Equatable {
    public let message: String?
}

extension CommentNotCreatedByCallerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommentsForComparedCommit: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case afterBlobId
        case afterCommitId
        case beforeBlobId
        case beforeCommitId
        case comments
        case location
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterBlobId = afterBlobId {
            try encodeContainer.encode(afterBlobId, forKey: .afterBlobId)
        }
        if let afterCommitId = afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeBlobId = beforeBlobId {
            try encodeContainer.encode(beforeBlobId, forKey: .beforeBlobId)
        }
        if let beforeCommitId = beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let comments = comments {
            var commentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .comments)
            for comments0 in comments {
                try commentsContainer.encode(comments0)
            }
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let beforeBlobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beforeBlobId)
        beforeBlobId = beforeBlobIdDecoded
        let afterBlobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterBlobId)
        afterBlobId = afterBlobIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Location.self, forKey: .location)
        location = locationDecoded
        let commentsContainer = try containerValues.decodeIfPresent([Comment?].self, forKey: .comments)
        var commentsDecoded0:[Comment]? = nil
        if let commentsContainer = commentsContainer {
            commentsDecoded0 = [Comment]()
            for structure0 in commentsContainer {
                if let structure0 = structure0 {
                    commentsDecoded0?.append(structure0)
                }
            }
        }
        comments = commentsDecoded0
    }
}

extension CommentsForComparedCommit: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommentsForComparedCommit(afterBlobId: \(String(describing: afterBlobId)), afterCommitId: \(String(describing: afterCommitId)), beforeBlobId: \(String(describing: beforeBlobId)), beforeCommitId: \(String(describing: beforeCommitId)), comments: \(String(describing: comments)), location: \(String(describing: location)), repositoryName: \(String(describing: repositoryName)))"}
}

/// <p>Returns information about comments on the comparison between two commits.</p>
public struct CommentsForComparedCommit: Equatable {
    /// <p>The full blob ID of the commit used to establish the after of the comparison.</p>
    public let afterBlobId: String?
    /// <p>The full commit ID of the commit used to establish the after of the comparison.</p>
    public let afterCommitId: String?
    /// <p>The full blob ID of the commit used to establish the before of the comparison.</p>
    public let beforeBlobId: String?
    /// <p>The full commit ID of the commit used to establish the before of the
    ///             comparison.</p>
    public let beforeCommitId: String?
    /// <p>An array of comment objects. Each comment object contains information about a comment on the comparison
    ///          between commits.</p>
    public let comments: [Comment]?
    /// <p>Location information about the comment on the comparison, including the file name,
    ///             line number, and whether the version of the file where the comment was made is BEFORE or
    ///             AFTER.</p>
    public let location: Location?
    /// <p>The name of the repository that contains the compared commits.</p>
    public let repositoryName: String?

    public init (
        afterBlobId: String? = nil,
        afterCommitId: String? = nil,
        beforeBlobId: String? = nil,
        beforeCommitId: String? = nil,
        comments: [Comment]? = nil,
        location: Location? = nil,
        repositoryName: String? = nil
    )
    {
        self.afterBlobId = afterBlobId
        self.afterCommitId = afterCommitId
        self.beforeBlobId = beforeBlobId
        self.beforeCommitId = beforeCommitId
        self.comments = comments
        self.location = location
        self.repositoryName = repositoryName
    }
}

extension CommentsForPullRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case afterBlobId
        case afterCommitId
        case beforeBlobId
        case beforeCommitId
        case comments
        case location
        case pullRequestId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterBlobId = afterBlobId {
            try encodeContainer.encode(afterBlobId, forKey: .afterBlobId)
        }
        if let afterCommitId = afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeBlobId = beforeBlobId {
            try encodeContainer.encode(beforeBlobId, forKey: .beforeBlobId)
        }
        if let beforeCommitId = beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let comments = comments {
            var commentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .comments)
            for comments0 in comments {
                try commentsContainer.encode(comments0)
            }
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let beforeBlobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beforeBlobId)
        beforeBlobId = beforeBlobIdDecoded
        let afterBlobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterBlobId)
        afterBlobId = afterBlobIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Location.self, forKey: .location)
        location = locationDecoded
        let commentsContainer = try containerValues.decodeIfPresent([Comment?].self, forKey: .comments)
        var commentsDecoded0:[Comment]? = nil
        if let commentsContainer = commentsContainer {
            commentsDecoded0 = [Comment]()
            for structure0 in commentsContainer {
                if let structure0 = structure0 {
                    commentsDecoded0?.append(structure0)
                }
            }
        }
        comments = commentsDecoded0
    }
}

extension CommentsForPullRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommentsForPullRequest(afterBlobId: \(String(describing: afterBlobId)), afterCommitId: \(String(describing: afterCommitId)), beforeBlobId: \(String(describing: beforeBlobId)), beforeCommitId: \(String(describing: beforeCommitId)), comments: \(String(describing: comments)), location: \(String(describing: location)), pullRequestId: \(String(describing: pullRequestId)), repositoryName: \(String(describing: repositoryName)))"}
}

/// <p>Returns information about comments on a pull request.</p>
public struct CommentsForPullRequest: Equatable {
    /// <p>The full blob ID of the file on which you want to comment on the source commit.</p>
    public let afterBlobId: String?
    /// <p>The full commit ID of the commit that was the tip of the source branch at the time the
    ///             comment was made. </p>
    public let afterCommitId: String?
    /// <p>The full blob ID of the file on which you want to comment on the destination commit.</p>
    public let beforeBlobId: String?
    /// <p>The full commit ID of the commit that was the tip of the destination branch when the
    ///             pull request was created. This commit is superceded by the after commit in the source
    ///             branch when and if you merge the source branch into the destination branch.</p>
    public let beforeCommitId: String?
    /// <p>An array of comment objects. Each comment object contains information about a comment on the pull request.</p>
    public let comments: [Comment]?
    /// <p>Location information about the comment on the pull request, including the file name,
    ///             line number, and whether the version of the file where the comment was made is BEFORE
    ///             (destination branch) or AFTER (source branch).</p>
    public let location: Location?
    /// <p>The system-generated ID of the pull request.</p>
    public let pullRequestId: String?
    /// <p>The name of the repository that contains the pull request.</p>
    public let repositoryName: String?

    public init (
        afterBlobId: String? = nil,
        afterCommitId: String? = nil,
        beforeBlobId: String? = nil,
        beforeCommitId: String? = nil,
        comments: [Comment]? = nil,
        location: Location? = nil,
        pullRequestId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.afterBlobId = afterBlobId
        self.afterCommitId = afterCommitId
        self.beforeBlobId = beforeBlobId
        self.beforeCommitId = beforeCommitId
        self.comments = comments
        self.location = location
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
    }
}

extension Commit: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalData
        case author
        case commitId
        case committer
        case message
        case parents
        case treeId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalData = additionalData {
            try encodeContainer.encode(additionalData, forKey: .additionalData)
        }
        if let author = author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let commitId = commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let committer = committer {
            try encodeContainer.encode(committer, forKey: .committer)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let parents = parents {
            var parentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parents)
            for parentlist0 in parents {
                try parentsContainer.encode(parentlist0)
            }
        }
        if let treeId = treeId {
            try encodeContainer.encode(treeId, forKey: .treeId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treeId)
        treeId = treeIdDecoded
        let parentsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .parents)
        var parentsDecoded0:[String]? = nil
        if let parentsContainer = parentsContainer {
            parentsDecoded0 = [String]()
            for string0 in parentsContainer {
                if let string0 = string0 {
                    parentsDecoded0?.append(string0)
                }
            }
        }
        parents = parentsDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let authorDecoded = try containerValues.decodeIfPresent(UserInfo.self, forKey: .author)
        author = authorDecoded
        let committerDecoded = try containerValues.decodeIfPresent(UserInfo.self, forKey: .committer)
        committer = committerDecoded
        let additionalDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .additionalData)
        additionalData = additionalDataDecoded
    }
}

extension Commit: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Commit(additionalData: \(String(describing: additionalData)), author: \(String(describing: author)), commitId: \(String(describing: commitId)), committer: \(String(describing: committer)), message: \(String(describing: message)), parents: \(String(describing: parents)), treeId: \(String(describing: treeId)))"}
}

/// <p>Returns information about a specific commit.</p>
public struct Commit: Equatable {
    /// <p>Any other data associated with the specified commit.</p>
    public let additionalData: String?
    /// <p>Information about the author of the specified commit. Information includes
    ///             the date in timestamp format with GMT offset, the name of the author, and the email address for the author, as configured
    ///             in Git.</p>
    public let author: UserInfo?
    /// <p>The full SHA ID of the specified commit. </p>
    public let commitId: String?
    /// <p>Information about the person who committed the specified commit, also known as the committer. Information includes
    ///         the date in timestamp format with GMT offset, the name of the committer, and the email address for the committer, as configured
    ///         in Git.</p>
    ///         <p>For more information
    ///             about the difference between an author and a committer in Git, see <a href="http://git-scm.com/book/ch2-3.html">Viewing the Commit History</a> in Pro Git
    ///             by Scott Chacon and Ben Straub.</p>
    public let committer: UserInfo?
    /// <p>The commit message associated with the specified commit.</p>
    public let message: String?
    /// <p>A list of parent commits for the specified commit. Each parent commit ID is the full commit ID.</p>
    public let parents: [String]?
    /// <p>Tree information for the specified commit.</p>
    public let treeId: String?

    public init (
        additionalData: String? = nil,
        author: UserInfo? = nil,
        commitId: String? = nil,
        committer: UserInfo? = nil,
        message: String? = nil,
        parents: [String]? = nil,
        treeId: String? = nil
    )
    {
        self.additionalData = additionalData
        self.author = author
        self.commitId = commitId
        self.committer = committer
        self.message = message
        self.parents = parents
        self.treeId = treeId
    }
}

extension CommitDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommitDoesNotExistException(message: \(String(describing: message)))"}
}

extension CommitDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CommitDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
public struct CommitDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CommitDoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension CommitDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitIdDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommitIdDoesNotExistException(message: \(String(describing: message)))"}
}

extension CommitIdDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CommitIdDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified commit ID does not exist.</p>
public struct CommitIdDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CommitIdDoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension CommitIdDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitIdRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommitIdRequiredException(message: \(String(describing: message)))"}
}

extension CommitIdRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CommitIdRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A commit ID was not specified.</p>
public struct CommitIdRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CommitIdRequiredExceptionBody: Equatable {
    public let message: String?
}

extension CommitIdRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitIdsLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommitIdsLimitExceededException(message: \(String(describing: message)))"}
}

extension CommitIdsLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CommitIdsLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of allowed commit IDs in a batch request is 100. Verify that your batch requests contains no more than 100 commit IDs, and then try again.</p>
public struct CommitIdsLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CommitIdsLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension CommitIdsLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitIdsListRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommitIdsListRequiredException(message: \(String(describing: message)))"}
}

extension CommitIdsListRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CommitIdsListRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A list of commit IDs is required, but was either not specified or the list was empty.</p>
public struct CommitIdsListRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CommitIdsListRequiredExceptionBody: Equatable {
    public let message: String?
}

extension CommitIdsListRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitMessageLengthExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommitMessageLengthExceededException(message: \(String(describing: message)))"}
}

extension CommitMessageLengthExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CommitMessageLengthExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The commit message is too long. Provide a shorter string. </p>
public struct CommitMessageLengthExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CommitMessageLengthExceededExceptionBody: Equatable {
    public let message: String?
}

extension CommitMessageLengthExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CommitRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CommitRequiredException(message: \(String(describing: message)))"}
}

extension CommitRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CommitRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A commit was not specified.</p>
public struct CommitRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CommitRequiredExceptionBody: Equatable {
    public let message: String?
}

extension CommitRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConcurrentReferenceUpdateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentReferenceUpdateException(message: \(String(describing: message)))"}
}

extension ConcurrentReferenceUpdateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentReferenceUpdateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
public struct ConcurrentReferenceUpdateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentReferenceUpdateExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentReferenceUpdateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Conflict: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conflictMetadata
        case mergeHunks
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictMetadata = conflictMetadata {
            try encodeContainer.encode(conflictMetadata, forKey: .conflictMetadata)
        }
        if let mergeHunks = mergeHunks {
            var mergeHunksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mergeHunks)
            for mergehunks0 in mergeHunks {
                try mergeHunksContainer.encode(mergehunks0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictMetadataDecoded = try containerValues.decodeIfPresent(ConflictMetadata.self, forKey: .conflictMetadata)
        conflictMetadata = conflictMetadataDecoded
        let mergeHunksContainer = try containerValues.decodeIfPresent([MergeHunk?].self, forKey: .mergeHunks)
        var mergeHunksDecoded0:[MergeHunk]? = nil
        if let mergeHunksContainer = mergeHunksContainer {
            mergeHunksDecoded0 = [MergeHunk]()
            for structure0 in mergeHunksContainer {
                if let structure0 = structure0 {
                    mergeHunksDecoded0?.append(structure0)
                }
            }
        }
        mergeHunks = mergeHunksDecoded0
    }
}

extension Conflict: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Conflict(conflictMetadata: \(String(describing: conflictMetadata)), mergeHunks: \(String(describing: mergeHunks)))"}
}

/// <p>Information about conflicts in a merge operation.</p>
public struct Conflict: Equatable {
    /// <p>Metadata about a conflict in a merge operation.</p>
    public let conflictMetadata: ConflictMetadata?
    /// <p>A list of hunks that contain the differences between files or lines causing the conflict.</p>
    public let mergeHunks: [MergeHunk]?

    public init (
        conflictMetadata: ConflictMetadata? = nil,
        mergeHunks: [MergeHunk]? = nil
    )
    {
        self.conflictMetadata = conflictMetadata
        self.mergeHunks = mergeHunks
    }
}

public enum ConflictDetailLevelTypeEnum {
    case fileLevel
    case lineLevel
    case sdkUnknown(String)
}

extension ConflictDetailLevelTypeEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConflictDetailLevelTypeEnum] {
        return [
            .fileLevel,
            .lineLevel,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fileLevel: return "FILE_LEVEL"
        case .lineLevel: return "LINE_LEVEL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConflictDetailLevelTypeEnum(rawValue: rawValue) ?? ConflictDetailLevelTypeEnum.sdkUnknown(rawValue)
    }
}

extension ConflictMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentConflict
        case fileModeConflict
        case fileModes
        case filePath
        case fileSizes
        case isBinaryFile
        case mergeOperations
        case numberOfConflicts
        case objectTypeConflict
        case objectTypes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if contentConflict != false {
            try encodeContainer.encode(contentConflict, forKey: .contentConflict)
        }
        if fileModeConflict != false {
            try encodeContainer.encode(fileModeConflict, forKey: .fileModeConflict)
        }
        if let fileModes = fileModes {
            try encodeContainer.encode(fileModes, forKey: .fileModes)
        }
        if let filePath = filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let fileSizes = fileSizes {
            try encodeContainer.encode(fileSizes, forKey: .fileSizes)
        }
        if let isBinaryFile = isBinaryFile {
            try encodeContainer.encode(isBinaryFile, forKey: .isBinaryFile)
        }
        if let mergeOperations = mergeOperations {
            try encodeContainer.encode(mergeOperations, forKey: .mergeOperations)
        }
        if numberOfConflicts != 0 {
            try encodeContainer.encode(numberOfConflicts, forKey: .numberOfConflicts)
        }
        if objectTypeConflict != false {
            try encodeContainer.encode(objectTypeConflict, forKey: .objectTypeConflict)
        }
        if let objectTypes = objectTypes {
            try encodeContainer.encode(objectTypes, forKey: .objectTypes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fileSizesDecoded = try containerValues.decodeIfPresent(FileSizes.self, forKey: .fileSizes)
        fileSizes = fileSizesDecoded
        let fileModesDecoded = try containerValues.decodeIfPresent(FileModes.self, forKey: .fileModes)
        fileModes = fileModesDecoded
        let objectTypesDecoded = try containerValues.decodeIfPresent(ObjectTypes.self, forKey: .objectTypes)
        objectTypes = objectTypesDecoded
        let numberOfConflictsDecoded = try containerValues.decode(Int.self, forKey: .numberOfConflicts)
        numberOfConflicts = numberOfConflictsDecoded
        let isBinaryFileDecoded = try containerValues.decodeIfPresent(IsBinaryFile.self, forKey: .isBinaryFile)
        isBinaryFile = isBinaryFileDecoded
        let contentConflictDecoded = try containerValues.decode(Bool.self, forKey: .contentConflict)
        contentConflict = contentConflictDecoded
        let fileModeConflictDecoded = try containerValues.decode(Bool.self, forKey: .fileModeConflict)
        fileModeConflict = fileModeConflictDecoded
        let objectTypeConflictDecoded = try containerValues.decode(Bool.self, forKey: .objectTypeConflict)
        objectTypeConflict = objectTypeConflictDecoded
        let mergeOperationsDecoded = try containerValues.decodeIfPresent(MergeOperations.self, forKey: .mergeOperations)
        mergeOperations = mergeOperationsDecoded
    }
}

extension ConflictMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictMetadata(contentConflict: \(String(describing: contentConflict)), fileModeConflict: \(String(describing: fileModeConflict)), fileModes: \(String(describing: fileModes)), filePath: \(String(describing: filePath)), fileSizes: \(String(describing: fileSizes)), isBinaryFile: \(String(describing: isBinaryFile)), mergeOperations: \(String(describing: mergeOperations)), numberOfConflicts: \(String(describing: numberOfConflicts)), objectTypeConflict: \(String(describing: objectTypeConflict)), objectTypes: \(String(describing: objectTypes)))"}
}

/// <p>Information about the metadata for a conflict in a merge operation.</p>
public struct ConflictMetadata: Equatable {
    /// <p>A boolean value indicating whether there are conflicts in the content of a file.</p>
    public let contentConflict: Bool
    /// <p>A boolean value indicating whether there are conflicts in the file mode of a file.</p>
    public let fileModeConflict: Bool
    /// <p>The file modes of the file in the source, destination, and base of the merge.</p>
    public let fileModes: FileModes?
    /// <p>The path of the file that contains conflicts.</p>
    public let filePath: String?
    /// <p>The file sizes of the file in the source, destination, and base of the merge.</p>
    public let fileSizes: FileSizes?
    /// <p>A boolean value (true or false) indicating whether the file is binary or textual in the source, destination, and base of the merge.</p>
    public let isBinaryFile: IsBinaryFile?
    /// <p>Whether an add, modify, or delete operation caused the conflict between the source and destination of the merge.</p>
    public let mergeOperations: MergeOperations?
    /// <p>The number of conflicts, including both hunk conflicts and metadata conflicts.</p>
    public let numberOfConflicts: Int
    /// <p>A boolean value (true or false) indicating whether there are conflicts between the branches in the object type of a file, folder, or submodule.</p>
    public let objectTypeConflict: Bool
    /// <p>Information about any object type conflicts in a merge operation.</p>
    public let objectTypes: ObjectTypes?

    public init (
        contentConflict: Bool = false,
        fileModeConflict: Bool = false,
        fileModes: FileModes? = nil,
        filePath: String? = nil,
        fileSizes: FileSizes? = nil,
        isBinaryFile: IsBinaryFile? = nil,
        mergeOperations: MergeOperations? = nil,
        numberOfConflicts: Int = 0,
        objectTypeConflict: Bool = false,
        objectTypes: ObjectTypes? = nil
    )
    {
        self.contentConflict = contentConflict
        self.fileModeConflict = fileModeConflict
        self.fileModes = fileModes
        self.filePath = filePath
        self.fileSizes = fileSizes
        self.isBinaryFile = isBinaryFile
        self.mergeOperations = mergeOperations
        self.numberOfConflicts = numberOfConflicts
        self.objectTypeConflict = objectTypeConflict
        self.objectTypes = objectTypes
    }
}

extension ConflictResolution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deleteFiles
        case replaceContents
        case setFileModes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteFiles = deleteFiles {
            var deleteFilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deleteFiles)
            for deletefileentries0 in deleteFiles {
                try deleteFilesContainer.encode(deletefileentries0)
            }
        }
        if let replaceContents = replaceContents {
            var replaceContentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replaceContents)
            for replacecontententries0 in replaceContents {
                try replaceContentsContainer.encode(replacecontententries0)
            }
        }
        if let setFileModes = setFileModes {
            var setFileModesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .setFileModes)
            for setfilemodeentries0 in setFileModes {
                try setFileModesContainer.encode(setfilemodeentries0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replaceContentsContainer = try containerValues.decodeIfPresent([ReplaceContentEntry?].self, forKey: .replaceContents)
        var replaceContentsDecoded0:[ReplaceContentEntry]? = nil
        if let replaceContentsContainer = replaceContentsContainer {
            replaceContentsDecoded0 = [ReplaceContentEntry]()
            for structure0 in replaceContentsContainer {
                if let structure0 = structure0 {
                    replaceContentsDecoded0?.append(structure0)
                }
            }
        }
        replaceContents = replaceContentsDecoded0
        let deleteFilesContainer = try containerValues.decodeIfPresent([DeleteFileEntry?].self, forKey: .deleteFiles)
        var deleteFilesDecoded0:[DeleteFileEntry]? = nil
        if let deleteFilesContainer = deleteFilesContainer {
            deleteFilesDecoded0 = [DeleteFileEntry]()
            for structure0 in deleteFilesContainer {
                if let structure0 = structure0 {
                    deleteFilesDecoded0?.append(structure0)
                }
            }
        }
        deleteFiles = deleteFilesDecoded0
        let setFileModesContainer = try containerValues.decodeIfPresent([SetFileModeEntry?].self, forKey: .setFileModes)
        var setFileModesDecoded0:[SetFileModeEntry]? = nil
        if let setFileModesContainer = setFileModesContainer {
            setFileModesDecoded0 = [SetFileModeEntry]()
            for structure0 in setFileModesContainer {
                if let structure0 = structure0 {
                    setFileModesDecoded0?.append(structure0)
                }
            }
        }
        setFileModes = setFileModesDecoded0
    }
}

extension ConflictResolution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictResolution(deleteFiles: \(String(describing: deleteFiles)), replaceContents: \(String(describing: replaceContents)), setFileModes: \(String(describing: setFileModes)))"}
}

/// <p>If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when
///             resolving conflicts during a merge.</p>
public struct ConflictResolution: Equatable {
    /// <p>Files to be deleted as part of the merge conflict resolution.</p>
    public let deleteFiles: [DeleteFileEntry]?
    /// <p>Files to have content replaced as part of the merge conflict resolution.</p>
    public let replaceContents: [ReplaceContentEntry]?
    /// <p>File modes that are set as part of the merge conflict resolution.</p>
    public let setFileModes: [SetFileModeEntry]?

    public init (
        deleteFiles: [DeleteFileEntry]? = nil,
        replaceContents: [ReplaceContentEntry]? = nil,
        setFileModes: [SetFileModeEntry]? = nil
    )
    {
        self.deleteFiles = deleteFiles
        self.replaceContents = replaceContents
        self.setFileModes = setFileModes
    }
}

public enum ConflictResolutionStrategyTypeEnum {
    case acceptDestination
    case acceptSource
    case automerge
    case `none`
    case sdkUnknown(String)
}

extension ConflictResolutionStrategyTypeEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConflictResolutionStrategyTypeEnum] {
        return [
            .acceptDestination,
            .acceptSource,
            .automerge,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .acceptDestination: return "ACCEPT_DESTINATION"
        case .acceptSource: return "ACCEPT_SOURCE"
        case .automerge: return "AUTOMERGE"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConflictResolutionStrategyTypeEnum(rawValue: rawValue) ?? ConflictResolutionStrategyTypeEnum.sdkUnknown(rawValue)
    }
}

public struct CreateApprovalRuleTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateApprovalRuleTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApprovalRuleTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApprovalRuleTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApprovalRuleTemplateInput>
    public typealias MOutput = OperationOutput<CreateApprovalRuleTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApprovalRuleTemplateOutputError>
}

extension CreateApprovalRuleTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApprovalRuleTemplateInput(approvalRuleTemplateContent: \(String(describing: approvalRuleTemplateContent)), approvalRuleTemplateDescription: \(String(describing: approvalRuleTemplateDescription)), approvalRuleTemplateName: \(String(describing: approvalRuleTemplateName)))"}
}

extension CreateApprovalRuleTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateContent
        case approvalRuleTemplateDescription
        case approvalRuleTemplateName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateContent = approvalRuleTemplateContent {
            try encodeContainer.encode(approvalRuleTemplateContent, forKey: .approvalRuleTemplateContent)
        }
        if let approvalRuleTemplateDescription = approvalRuleTemplateDescription {
            try encodeContainer.encode(approvalRuleTemplateDescription, forKey: .approvalRuleTemplateDescription)
        }
        if let approvalRuleTemplateName = approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
    }
}

public struct CreateApprovalRuleTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApprovalRuleTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApprovalRuleTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApprovalRuleTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApprovalRuleTemplateInput>
    public typealias MOutput = OperationOutput<CreateApprovalRuleTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApprovalRuleTemplateOutputError>
}

public struct CreateApprovalRuleTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApprovalRuleTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApprovalRuleTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApprovalRuleTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApprovalRuleTemplateInput>
    public typealias MOutput = OperationOutput<CreateApprovalRuleTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApprovalRuleTemplateOutputError>
}

public struct CreateApprovalRuleTemplateInput: Equatable {
    /// <p>The content of the approval rule that is created on pull requests in associated
    ///             repositories. If you specify one or more destination references (branches), approval
    ///             rules are created in an associated repository only if their destination references
    ///             (branches) match those specified in the template.</p>
    ///         <note>
    ///             <p>When you create the content of the approval rule template, you can specify
    ///                 approvers in an approval pool in one of two ways:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>
    ///                      <b>CodeCommitApprovers</b>: This option only
    ///                         requires an AWS account and a resource. It can be used for both IAM users
    ///                         and federated access users whose name matches the provided resource name.
    ///                         This is a very powerful option that offers a great deal of flexibility. For
    ///                         example, if you specify the AWS account <i>123456789012</i>
    ///                         and <i>Mary_Major</i>, all of the following are counted as
    ///                         approvals coming from that user:</p>
    ///                     <ul>
    ///                      <li>
    ///                             <p>An IAM user in the account
    ///                                 (arn:aws:iam::<i>123456789012</i>:user/<i>Mary_Major</i>)</p>
    ///                         </li>
    ///                      <li>
    ///                             <p>A federated user identified in IAM as Mary_Major
    ///                                 (arn:aws:sts::<i>123456789012</i>:federated-user/<i>Mary_Major</i>)</p>
    ///                         </li>
    ///                   </ul>
    ///                     <p>This option does not recognize an active session of someone assuming the
    ///                         role of CodeCommitReview with a role session name of
    ///                             <i>Mary_Major</i>
    ///                             (arn:aws:sts::<i>123456789012</i>:assumed-role/CodeCommitReview/<i>Mary_Major</i>)
    ///                         unless you include a wildcard (*Mary_Major).</p>
    ///                 </li>
    ///                <li>
    ///                     <p>
    ///                      <b>Fully qualified ARN</b>: This option allows
    ///                         you to specify the fully qualified Amazon Resource Name (ARN) of the IAM
    ///                         user or role. </p>
    ///                 </li>
    ///             </ul>
    ///             <p>For more information about IAM ARNs, wildcards, and formats, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM
    ///                     Identifiers</a> in the <i>IAM User Guide</i>.</p>
    ///
    ///         </note>
    public let approvalRuleTemplateContent: String?
    /// <p>The description of the approval rule template. Consider providing a description that
    ///             explains what this template does and when it might be appropriate to associate it with
    ///             repositories.</p>
    public let approvalRuleTemplateDescription: String?
    /// <p>The name of the approval rule template. Provide descriptive names, because this name
    ///             is applied to the approval rules created automatically in associated
    ///             repositories.</p>
    public let approvalRuleTemplateName: String?

    public init (
        approvalRuleTemplateContent: String? = nil,
        approvalRuleTemplateDescription: String? = nil,
        approvalRuleTemplateName: String? = nil
    )
    {
        self.approvalRuleTemplateContent = approvalRuleTemplateContent
        self.approvalRuleTemplateDescription = approvalRuleTemplateDescription
        self.approvalRuleTemplateName = approvalRuleTemplateName
    }
}

struct CreateApprovalRuleTemplateInputBody: Equatable {
    public let approvalRuleTemplateName: String?
    public let approvalRuleTemplateContent: String?
    public let approvalRuleTemplateDescription: String?
}

extension CreateApprovalRuleTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateContent
        case approvalRuleTemplateDescription
        case approvalRuleTemplateName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let approvalRuleTemplateContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateContent)
        approvalRuleTemplateContent = approvalRuleTemplateContentDecoded
        let approvalRuleTemplateDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateDescription)
        approvalRuleTemplateDescription = approvalRuleTemplateDescriptionDecoded
    }
}

extension CreateApprovalRuleTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApprovalRuleTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateContentRequiredException" : self = .approvalRuleTemplateContentRequiredException(try ApprovalRuleTemplateContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameAlreadyExistsException" : self = .approvalRuleTemplateNameAlreadyExistsException(try ApprovalRuleTemplateNameAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateContentException" : self = .invalidApprovalRuleTemplateContentException(try InvalidApprovalRuleTemplateContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateDescriptionException" : self = .invalidApprovalRuleTemplateDescriptionException(try InvalidApprovalRuleTemplateDescriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfRuleTemplatesExceededException" : self = .numberOfRuleTemplatesExceededException(try NumberOfRuleTemplatesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApprovalRuleTemplateOutputError: Equatable {
    case approvalRuleTemplateContentRequiredException(ApprovalRuleTemplateContentRequiredException)
    case approvalRuleTemplateNameAlreadyExistsException(ApprovalRuleTemplateNameAlreadyExistsException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case invalidApprovalRuleTemplateContentException(InvalidApprovalRuleTemplateContentException)
    case invalidApprovalRuleTemplateDescriptionException(InvalidApprovalRuleTemplateDescriptionException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case numberOfRuleTemplatesExceededException(NumberOfRuleTemplatesExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApprovalRuleTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApprovalRuleTemplateOutputResponse(approvalRuleTemplate: \(String(describing: approvalRuleTemplate)))"}
}

extension CreateApprovalRuleTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateApprovalRuleTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.approvalRuleTemplate = output.approvalRuleTemplate
        } else {
            self.approvalRuleTemplate = nil
        }
    }
}

public struct CreateApprovalRuleTemplateOutputResponse: Equatable {
    /// <p>The content and structure of the created approval rule template.</p>
    public let approvalRuleTemplate: ApprovalRuleTemplate?

    public init (
        approvalRuleTemplate: ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

struct CreateApprovalRuleTemplateOutputResponseBody: Equatable {
    public let approvalRuleTemplate: ApprovalRuleTemplate?
}

extension CreateApprovalRuleTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateDecoded = try containerValues.decodeIfPresent(ApprovalRuleTemplate.self, forKey: .approvalRuleTemplate)
        approvalRuleTemplate = approvalRuleTemplateDecoded
    }
}

public struct CreateBranchInputBodyMiddleware: Middleware {
    public let id: String = "CreateBranchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBranchInput>
    public typealias MOutput = OperationOutput<CreateBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBranchOutputError>
}

extension CreateBranchInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBranchInput(branchName: \(String(describing: branchName)), commitId: \(String(describing: commitId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension CreateBranchInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branchName
        case commitId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let commitId = commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct CreateBranchInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBranchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBranchInput>
    public typealias MOutput = OperationOutput<CreateBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBranchOutputError>
}

public struct CreateBranchInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBranchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBranchInput>
    public typealias MOutput = OperationOutput<CreateBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBranchOutputError>
}

/// <p>Represents the input of a create branch operation.</p>
public struct CreateBranchInput: Equatable {
    /// <p>The name of the new branch to create.</p>
    public let branchName: String?
    /// <p>The ID of the commit to point the new branch to.</p>
    public let commitId: String?
    /// <p>The name of the repository in which you want to create the new branch.</p>
    public let repositoryName: String?

    public init (
        branchName: String? = nil,
        commitId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.branchName = branchName
        self.commitId = commitId
        self.repositoryName = repositoryName
    }
}

struct CreateBranchInputBody: Equatable {
    public let repositoryName: String?
    public let branchName: String?
    public let commitId: String?
}

extension CreateBranchInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case branchName
        case commitId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let commitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitId)
        commitId = commitIdDecoded
    }
}

extension CreateBranchOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBranchOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BranchNameExistsException" : self = .branchNameExistsException(try BranchNameExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitIdRequiredException" : self = .commitIdRequiredException(try CommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBranchOutputError: Equatable {
    case branchNameExistsException(BranchNameExistsException)
    case branchNameRequiredException(BranchNameRequiredException)
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitIdRequiredException(CommitIdRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBranchOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBranchOutputResponse()"}
}

extension CreateBranchOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateBranchOutputResponse: Equatable {

    public init() {}
}

struct CreateBranchOutputResponseBody: Equatable {
}

extension CreateBranchOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateCommitInputBodyMiddleware: Middleware {
    public let id: String = "CreateCommitInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCommitInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCommitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCommitInput>
    public typealias MOutput = OperationOutput<CreateCommitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCommitOutputError>
}

extension CreateCommitInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCommitInput(authorName: \(String(describing: authorName)), branchName: \(String(describing: branchName)), commitMessage: \(String(describing: commitMessage)), deleteFiles: \(String(describing: deleteFiles)), email: \(String(describing: email)), keepEmptyFolders: \(String(describing: keepEmptyFolders)), parentCommitId: \(String(describing: parentCommitId)), putFiles: \(String(describing: putFiles)), repositoryName: \(String(describing: repositoryName)), setFileModes: \(String(describing: setFileModes)))"}
}

extension CreateCommitInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorName
        case branchName
        case commitMessage
        case deleteFiles
        case email
        case keepEmptyFolders
        case parentCommitId
        case putFiles
        case repositoryName
        case setFileModes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let commitMessage = commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let deleteFiles = deleteFiles {
            var deleteFilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deleteFiles)
            for deletefileentries0 in deleteFiles {
                try deleteFilesContainer.encode(deletefileentries0)
            }
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if keepEmptyFolders != false {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let parentCommitId = parentCommitId {
            try encodeContainer.encode(parentCommitId, forKey: .parentCommitId)
        }
        if let putFiles = putFiles {
            var putFilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .putFiles)
            for putfileentries0 in putFiles {
                try putFilesContainer.encode(putfileentries0)
            }
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let setFileModes = setFileModes {
            var setFileModesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .setFileModes)
            for setfilemodeentries0 in setFileModes {
                try setFileModesContainer.encode(setfilemodeentries0)
            }
        }
    }
}

public struct CreateCommitInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCommitInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCommitInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCommitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCommitInput>
    public typealias MOutput = OperationOutput<CreateCommitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCommitOutputError>
}

public struct CreateCommitInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCommitInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCommitInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCommitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCommitInput>
    public typealias MOutput = OperationOutput<CreateCommitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCommitOutputError>
}

public struct CreateCommitInput: Equatable {
    /// <p>The name of the author who created the commit. This information is used as both the
    ///             author and committer for the commit.</p>
    public let authorName: String?
    /// <p>The name of the branch where you create the commit.</p>
    public let branchName: String?
    /// <p>The commit message you want to include in the commit. Commit messages are limited to
    ///             256 KB. If no message is specified, a default message is used.</p>
    public let commitMessage: String?
    /// <p>The files to delete in this commit. These files still exist in earlier commits.</p>
    public let deleteFiles: [DeleteFileEntry]?
    /// <p>The email address of the person who created the commit.</p>
    public let email: String?
    /// <p>If the commit contains deletions, whether to keep a folder or folder structure if the
    ///             changes leave the folders empty. If true, a ..gitkeep file is created for empty folders.
    ///             The default is false.</p>
    public let keepEmptyFolders: Bool
    /// <p>The ID of the commit that is the parent of the commit you create. Not required if this
    ///             is an empty repository.</p>
    public let parentCommitId: String?
    /// <p>The files to add or update in this commit.</p>
    public let putFiles: [PutFileEntry]?
    /// <p>The name of the repository where you create the commit.</p>
    public let repositoryName: String?
    /// <p>The file modes to update for files in this commit.</p>
    public let setFileModes: [SetFileModeEntry]?

    public init (
        authorName: String? = nil,
        branchName: String? = nil,
        commitMessage: String? = nil,
        deleteFiles: [DeleteFileEntry]? = nil,
        email: String? = nil,
        keepEmptyFolders: Bool = false,
        parentCommitId: String? = nil,
        putFiles: [PutFileEntry]? = nil,
        repositoryName: String? = nil,
        setFileModes: [SetFileModeEntry]? = nil
    )
    {
        self.authorName = authorName
        self.branchName = branchName
        self.commitMessage = commitMessage
        self.deleteFiles = deleteFiles
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.parentCommitId = parentCommitId
        self.putFiles = putFiles
        self.repositoryName = repositoryName
        self.setFileModes = setFileModes
    }
}

struct CreateCommitInputBody: Equatable {
    public let repositoryName: String?
    public let branchName: String?
    public let parentCommitId: String?
    public let authorName: String?
    public let email: String?
    public let commitMessage: String?
    public let keepEmptyFolders: Bool
    public let putFiles: [PutFileEntry]?
    public let deleteFiles: [DeleteFileEntry]?
    public let setFileModes: [SetFileModeEntry]?
}

extension CreateCommitInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorName
        case branchName
        case commitMessage
        case deleteFiles
        case email
        case keepEmptyFolders
        case parentCommitId
        case putFiles
        case repositoryName
        case setFileModes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let parentCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentCommitId)
        parentCommitId = parentCommitIdDecoded
        let authorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let keepEmptyFoldersDecoded = try containerValues.decode(Bool.self, forKey: .keepEmptyFolders)
        keepEmptyFolders = keepEmptyFoldersDecoded
        let putFilesContainer = try containerValues.decodeIfPresent([PutFileEntry?].self, forKey: .putFiles)
        var putFilesDecoded0:[PutFileEntry]? = nil
        if let putFilesContainer = putFilesContainer {
            putFilesDecoded0 = [PutFileEntry]()
            for structure0 in putFilesContainer {
                if let structure0 = structure0 {
                    putFilesDecoded0?.append(structure0)
                }
            }
        }
        putFiles = putFilesDecoded0
        let deleteFilesContainer = try containerValues.decodeIfPresent([DeleteFileEntry?].self, forKey: .deleteFiles)
        var deleteFilesDecoded0:[DeleteFileEntry]? = nil
        if let deleteFilesContainer = deleteFilesContainer {
            deleteFilesDecoded0 = [DeleteFileEntry]()
            for structure0 in deleteFilesContainer {
                if let structure0 = structure0 {
                    deleteFilesDecoded0?.append(structure0)
                }
            }
        }
        deleteFiles = deleteFilesDecoded0
        let setFileModesContainer = try containerValues.decodeIfPresent([SetFileModeEntry?].self, forKey: .setFileModes)
        var setFileModesDecoded0:[SetFileModeEntry]? = nil
        if let setFileModesContainer = setFileModesContainer {
            setFileModesDecoded0 = [SetFileModeEntry]()
            for structure0 in setFileModesContainer {
                if let structure0 = structure0 {
                    setFileModesDecoded0?.append(structure0)
                }
            }
        }
        setFileModes = setFileModesDecoded0
    }
}

extension CreateCommitOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCommitOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BranchDoesNotExistException" : self = .branchDoesNotExistException(try BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameIsTagNameException" : self = .branchNameIsTagNameException(try BranchNameIsTagNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitMessageLengthExceededException" : self = .commitMessageLengthExceededException(try CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNameConflictsWithFileNameException" : self = .directoryNameConflictsWithFileNameException(try DirectoryNameConflictsWithFileNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileContentAndSourceFileSpecifiedException" : self = .fileContentAndSourceFileSpecifiedException(try FileContentAndSourceFileSpecifiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileContentSizeLimitExceededException" : self = .fileContentSizeLimitExceededException(try FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileDoesNotExistException" : self = .fileDoesNotExistException(try FileDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileEntryRequiredException" : self = .fileEntryRequiredException(try FileEntryRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileModeRequiredException" : self = .fileModeRequiredException(try FileModeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileNameConflictsWithDirectoryNameException" : self = .fileNameConflictsWithDirectoryNameException(try FileNameConflictsWithDirectoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilePathConflictsWithSubmodulePathException" : self = .filePathConflictsWithSubmodulePathException(try FilePathConflictsWithSubmodulePathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FolderContentSizeLimitExceededException" : self = .folderContentSizeLimitExceededException(try FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDeletionParameterException" : self = .invalidDeletionParameterException(try InvalidDeletionParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailException" : self = .invalidEmailException(try InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFileModeException" : self = .invalidFileModeException(try InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParentCommitIdException" : self = .invalidParentCommitIdException(try InvalidParentCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileEntriesExceededException" : self = .maximumFileEntriesExceededException(try MaximumFileEntriesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameLengthExceededException" : self = .nameLengthExceededException(try NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoChangeException" : self = .noChangeException(try NoChangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParentCommitDoesNotExistException" : self = .parentCommitDoesNotExistException(try ParentCommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParentCommitIdOutdatedException" : self = .parentCommitIdOutdatedException(try ParentCommitIdOutdatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParentCommitIdRequiredException" : self = .parentCommitIdRequiredException(try ParentCommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PutFileEntryConflictException" : self = .putFileEntryConflictException(try PutFileEntryConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RestrictedSourceFileException" : self = .restrictedSourceFileException(try RestrictedSourceFileException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SamePathRequestException" : self = .samePathRequestException(try SamePathRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SourceFileOrContentRequiredException" : self = .sourceFileOrContentRequiredException(try SourceFileOrContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCommitOutputError: Equatable {
    case branchDoesNotExistException(BranchDoesNotExistException)
    case branchNameIsTagNameException(BranchNameIsTagNameException)
    case branchNameRequiredException(BranchNameRequiredException)
    case commitMessageLengthExceededException(CommitMessageLengthExceededException)
    case directoryNameConflictsWithFileNameException(DirectoryNameConflictsWithFileNameException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileContentAndSourceFileSpecifiedException(FileContentAndSourceFileSpecifiedException)
    case fileContentSizeLimitExceededException(FileContentSizeLimitExceededException)
    case fileDoesNotExistException(FileDoesNotExistException)
    case fileEntryRequiredException(FileEntryRequiredException)
    case fileModeRequiredException(FileModeRequiredException)
    case fileNameConflictsWithDirectoryNameException(FileNameConflictsWithDirectoryNameException)
    case filePathConflictsWithSubmodulePathException(FilePathConflictsWithSubmodulePathException)
    case folderContentSizeLimitExceededException(FolderContentSizeLimitExceededException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidDeletionParameterException(InvalidDeletionParameterException)
    case invalidEmailException(InvalidEmailException)
    case invalidFileModeException(InvalidFileModeException)
    case invalidParentCommitIdException(InvalidParentCommitIdException)
    case invalidPathException(InvalidPathException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case maximumFileEntriesExceededException(MaximumFileEntriesExceededException)
    case nameLengthExceededException(NameLengthExceededException)
    case noChangeException(NoChangeException)
    case parentCommitDoesNotExistException(ParentCommitDoesNotExistException)
    case parentCommitIdOutdatedException(ParentCommitIdOutdatedException)
    case parentCommitIdRequiredException(ParentCommitIdRequiredException)
    case pathRequiredException(PathRequiredException)
    case putFileEntryConflictException(PutFileEntryConflictException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case restrictedSourceFileException(RestrictedSourceFileException)
    case samePathRequestException(SamePathRequestException)
    case sourceFileOrContentRequiredException(SourceFileOrContentRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCommitOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCommitOutputResponse(commitId: \(String(describing: commitId)), filesAdded: \(String(describing: filesAdded)), filesDeleted: \(String(describing: filesDeleted)), filesUpdated: \(String(describing: filesUpdated)), treeId: \(String(describing: treeId)))"}
}

extension CreateCommitOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCommitOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.commitId = output.commitId
            self.filesAdded = output.filesAdded
            self.filesDeleted = output.filesDeleted
            self.filesUpdated = output.filesUpdated
            self.treeId = output.treeId
        } else {
            self.commitId = nil
            self.filesAdded = nil
            self.filesDeleted = nil
            self.filesUpdated = nil
            self.treeId = nil
        }
    }
}

public struct CreateCommitOutputResponse: Equatable {
    /// <p>The full commit ID of the commit that contains your committed file changes.</p>
    public let commitId: String?
    /// <p>The files added as part of the committed file changes.</p>
    public let filesAdded: [FileMetadata]?
    /// <p>The files deleted as part of the committed file changes.</p>
    public let filesDeleted: [FileMetadata]?
    /// <p>The files updated as part of the commited file changes.</p>
    public let filesUpdated: [FileMetadata]?
    /// <p>The full SHA-1 pointer of the tree information for the commit that contains the commited file changes.</p>
    public let treeId: String?

    public init (
        commitId: String? = nil,
        filesAdded: [FileMetadata]? = nil,
        filesDeleted: [FileMetadata]? = nil,
        filesUpdated: [FileMetadata]? = nil,
        treeId: String? = nil
    )
    {
        self.commitId = commitId
        self.filesAdded = filesAdded
        self.filesDeleted = filesDeleted
        self.filesUpdated = filesUpdated
        self.treeId = treeId
    }
}

struct CreateCommitOutputResponseBody: Equatable {
    public let commitId: String?
    public let treeId: String?
    public let filesAdded: [FileMetadata]?
    public let filesUpdated: [FileMetadata]?
    public let filesDeleted: [FileMetadata]?
}

extension CreateCommitOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commitId
        case filesAdded
        case filesDeleted
        case filesUpdated
        case treeId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treeId)
        treeId = treeIdDecoded
        let filesAddedContainer = try containerValues.decodeIfPresent([FileMetadata?].self, forKey: .filesAdded)
        var filesAddedDecoded0:[FileMetadata]? = nil
        if let filesAddedContainer = filesAddedContainer {
            filesAddedDecoded0 = [FileMetadata]()
            for structure0 in filesAddedContainer {
                if let structure0 = structure0 {
                    filesAddedDecoded0?.append(structure0)
                }
            }
        }
        filesAdded = filesAddedDecoded0
        let filesUpdatedContainer = try containerValues.decodeIfPresent([FileMetadata?].self, forKey: .filesUpdated)
        var filesUpdatedDecoded0:[FileMetadata]? = nil
        if let filesUpdatedContainer = filesUpdatedContainer {
            filesUpdatedDecoded0 = [FileMetadata]()
            for structure0 in filesUpdatedContainer {
                if let structure0 = structure0 {
                    filesUpdatedDecoded0?.append(structure0)
                }
            }
        }
        filesUpdated = filesUpdatedDecoded0
        let filesDeletedContainer = try containerValues.decodeIfPresent([FileMetadata?].self, forKey: .filesDeleted)
        var filesDeletedDecoded0:[FileMetadata]? = nil
        if let filesDeletedContainer = filesDeletedContainer {
            filesDeletedDecoded0 = [FileMetadata]()
            for structure0 in filesDeletedContainer {
                if let structure0 = structure0 {
                    filesDeletedDecoded0?.append(structure0)
                }
            }
        }
        filesDeleted = filesDeletedDecoded0
    }
}

public struct CreatePullRequestApprovalRuleInputBodyMiddleware: Middleware {
    public let id: String = "CreatePullRequestApprovalRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePullRequestApprovalRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePullRequestApprovalRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePullRequestApprovalRuleInput>
    public typealias MOutput = OperationOutput<CreatePullRequestApprovalRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePullRequestApprovalRuleOutputError>
}

extension CreatePullRequestApprovalRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePullRequestApprovalRuleInput(approvalRuleContent: \(String(describing: approvalRuleContent)), approvalRuleName: \(String(describing: approvalRuleName)), pullRequestId: \(String(describing: pullRequestId)))"}
}

extension CreatePullRequestApprovalRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRuleContent
        case approvalRuleName
        case pullRequestId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleContent = approvalRuleContent {
            try encodeContainer.encode(approvalRuleContent, forKey: .approvalRuleContent)
        }
        if let approvalRuleName = approvalRuleName {
            try encodeContainer.encode(approvalRuleName, forKey: .approvalRuleName)
        }
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
    }
}

public struct CreatePullRequestApprovalRuleInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePullRequestApprovalRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePullRequestApprovalRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePullRequestApprovalRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePullRequestApprovalRuleInput>
    public typealias MOutput = OperationOutput<CreatePullRequestApprovalRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePullRequestApprovalRuleOutputError>
}

public struct CreatePullRequestApprovalRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePullRequestApprovalRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePullRequestApprovalRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePullRequestApprovalRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePullRequestApprovalRuleInput>
    public typealias MOutput = OperationOutput<CreatePullRequestApprovalRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePullRequestApprovalRuleOutputError>
}

public struct CreatePullRequestApprovalRuleInput: Equatable {
    /// <p>The content of the approval rule, including the number of approvals needed and the structure of an approval pool defined for approvals, if any. For more information
    ///         about approval pools, see the AWS CodeCommit User Guide.</p>
    ///         <note>
    ///             <p>When you create the content of the approval rule, you can specify approvers in an
    ///                 approval pool in one of two ways:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>
    ///                      <b>CodeCommitApprovers</b>: This option only
    ///                         requires an AWS account and a resource. It can be used for both IAM users
    ///                         and federated access users whose name matches the provided resource name.
    ///                         This is a very powerful option that offers a great deal of flexibility. For
    ///                         example, if you specify the AWS account <i>123456789012</i>
    ///                         and <i>Mary_Major</i>, all of the following would be counted
    ///                         as approvals coming from that user:</p>
    ///                     <ul>
    ///                      <li>
    ///                             <p>An IAM user in the account
    ///                                     (arn:aws:iam::<i>123456789012</i>:user/<i>Mary_Major</i>)</p>
    ///                         </li>
    ///                      <li>
    ///                             <p>A federated user identified in IAM as Mary_Major
    ///                                     (arn:aws:sts::<i>123456789012</i>:federated-user/<i>Mary_Major</i>)</p>
    ///                         </li>
    ///                   </ul>
    ///                     <p>This option does not recognize an active session of someone assuming the
    ///                         role of CodeCommitReview with a role session name of
    ///                             <i>Mary_Major</i>
    ///                             (arn:aws:sts::<i>123456789012</i>:assumed-role/CodeCommitReview/<i>Mary_Major</i>)
    ///                         unless you include a wildcard (*Mary_Major).</p>
    ///                 </li>
    ///                <li>
    ///                     <p>
    ///                      <b>Fully qualified ARN</b>: This option allows
    ///                         you to specify the fully qualified Amazon Resource Name (ARN) of the IAM
    ///                         user or role. </p>
    ///                 </li>
    ///             </ul>
    ///             <p>For more information about IAM ARNs, wildcards, and formats, see
    ///                <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM
    ///                 Identifiers</a> in the <i>IAM User Guide</i>.</p>
    ///
    ///         </note>
    public let approvalRuleContent: String?
    /// <p>The name for the approval rule.</p>
    public let approvalRuleName: String?
    /// <p>The system-generated ID of the pull request for which you want to create the approval rule.</p>
    public let pullRequestId: String?

    public init (
        approvalRuleContent: String? = nil,
        approvalRuleName: String? = nil,
        pullRequestId: String? = nil
    )
    {
        self.approvalRuleContent = approvalRuleContent
        self.approvalRuleName = approvalRuleName
        self.pullRequestId = pullRequestId
    }
}

struct CreatePullRequestApprovalRuleInputBody: Equatable {
    public let pullRequestId: String?
    public let approvalRuleName: String?
    public let approvalRuleContent: String?
}

extension CreatePullRequestApprovalRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleContent
        case approvalRuleName
        case pullRequestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let approvalRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleName)
        approvalRuleName = approvalRuleNameDecoded
        let approvalRuleContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleContent)
        approvalRuleContent = approvalRuleContentDecoded
    }
}

extension CreatePullRequestApprovalRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePullRequestApprovalRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ApprovalRuleContentRequiredException" : self = .approvalRuleContentRequiredException(try ApprovalRuleContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleNameAlreadyExistsException" : self = .approvalRuleNameAlreadyExistsException(try ApprovalRuleNameAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleNameRequiredException" : self = .approvalRuleNameRequiredException(try ApprovalRuleNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleContentException" : self = .invalidApprovalRuleContentException(try InvalidApprovalRuleContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleNameException" : self = .invalidApprovalRuleNameException(try InvalidApprovalRuleNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NumberOfRulesExceededException" : self = .numberOfRulesExceededException(try NumberOfRulesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePullRequestApprovalRuleOutputError: Equatable {
    case approvalRuleContentRequiredException(ApprovalRuleContentRequiredException)
    case approvalRuleNameAlreadyExistsException(ApprovalRuleNameAlreadyExistsException)
    case approvalRuleNameRequiredException(ApprovalRuleNameRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidApprovalRuleContentException(InvalidApprovalRuleContentException)
    case invalidApprovalRuleNameException(InvalidApprovalRuleNameException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case numberOfRulesExceededException(NumberOfRulesExceededException)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePullRequestApprovalRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePullRequestApprovalRuleOutputResponse(approvalRule: \(String(describing: approvalRule)))"}
}

extension CreatePullRequestApprovalRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePullRequestApprovalRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.approvalRule = output.approvalRule
        } else {
            self.approvalRule = nil
        }
    }
}

public struct CreatePullRequestApprovalRuleOutputResponse: Equatable {
    /// <p>Information about the created approval rule.</p>
    public let approvalRule: ApprovalRule?

    public init (
        approvalRule: ApprovalRule? = nil
    )
    {
        self.approvalRule = approvalRule
    }
}

struct CreatePullRequestApprovalRuleOutputResponseBody: Equatable {
    public let approvalRule: ApprovalRule?
}

extension CreatePullRequestApprovalRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRule
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleDecoded = try containerValues.decodeIfPresent(ApprovalRule.self, forKey: .approvalRule)
        approvalRule = approvalRuleDecoded
    }
}

public struct CreatePullRequestInputBodyMiddleware: Middleware {
    public let id: String = "CreatePullRequestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePullRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePullRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePullRequestInput>
    public typealias MOutput = OperationOutput<CreatePullRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePullRequestOutputError>
}

extension CreatePullRequestInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePullRequestInput(clientRequestToken: \(String(describing: clientRequestToken)), description: \(String(describing: description)), targets: \(String(describing: targets)), title: \(String(describing: title)))"}
}

extension CreatePullRequestInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case description
        case targets
        case title
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targetlist0 in targets {
                try targetsContainer.encode(targetlist0)
            }
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

public struct CreatePullRequestInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePullRequestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePullRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePullRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePullRequestInput>
    public typealias MOutput = OperationOutput<CreatePullRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePullRequestOutputError>
}

public struct CreatePullRequestInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePullRequestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePullRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePullRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePullRequestInput>
    public typealias MOutput = OperationOutput<CreatePullRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePullRequestOutputError>
}

public struct CreatePullRequestInput: Equatable {
    /// <p>A unique, client-generated idempotency token that, when provided in a request, ensures
    ///             the request cannot be repeated with a changed parameter. If a request is received with
    ///             the same parameters and a token is included, the request returns information about the
    ///             initial request that used that token.</p>
    ///         <note>
    ///             <p>The AWS SDKs prepopulate client request tokens. If you are using an AWS SDK, an
    ///                 idempotency token is created for you.</p>
    ///         </note>
    public var clientRequestToken: String?
    /// <p>A description of the pull request.</p>
    public let description: String?
    /// <p>The targets for the pull request, including the source of the code to be reviewed (the
    ///             source branch) and the destination where the creator of the pull request intends the
    ///             code to be merged after the pull request is closed (the destination branch).</p>
    public let targets: [Target]?
    /// <p>The title of the pull request. This title is used to identify the pull request to
    ///             other users in the repository.</p>
    public let title: String?

    public init (
        clientRequestToken: String? = nil,
        description: String? = nil,
        targets: [Target]? = nil,
        title: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.targets = targets
        self.title = title
    }
}

struct CreatePullRequestInputBody: Equatable {
    public let title: String?
    public let description: String?
    public let targets: [Target]?
    public let clientRequestToken: String?
}

extension CreatePullRequestInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case description
        case targets
        case title
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreatePullRequestOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePullRequestOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientRequestTokenRequiredException" : self = .clientRequestTokenRequiredException(try ClientRequestTokenRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotencyParameterMismatchException" : self = .idempotencyParameterMismatchException(try IdempotencyParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientRequestTokenException" : self = .invalidClientRequestTokenException(try InvalidClientRequestTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDescriptionException" : self = .invalidDescriptionException(try InvalidDescriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReferenceNameException" : self = .invalidReferenceNameException(try InvalidReferenceNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTargetException" : self = .invalidTargetException(try InvalidTargetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTargetsException" : self = .invalidTargetsException(try InvalidTargetsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTitleException" : self = .invalidTitleException(try InvalidTitleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumOpenPullRequestsExceededException" : self = .maximumOpenPullRequestsExceededException(try MaximumOpenPullRequestsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MultipleRepositoriesInPullRequestException" : self = .multipleRepositoriesInPullRequestException(try MultipleRepositoriesInPullRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReferenceDoesNotExistException" : self = .referenceDoesNotExistException(try ReferenceDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReferenceNameRequiredException" : self = .referenceNameRequiredException(try ReferenceNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReferenceTypeNotSupportedException" : self = .referenceTypeNotSupportedException(try ReferenceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SourceAndDestinationAreSameException" : self = .sourceAndDestinationAreSameException(try SourceAndDestinationAreSameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetRequiredException" : self = .targetRequiredException(try TargetRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetsRequiredException" : self = .targetsRequiredException(try TargetsRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TitleRequiredException" : self = .titleRequiredException(try TitleRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePullRequestOutputError: Equatable {
    case clientRequestTokenRequiredException(ClientRequestTokenRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case idempotencyParameterMismatchException(IdempotencyParameterMismatchException)
    case invalidClientRequestTokenException(InvalidClientRequestTokenException)
    case invalidDescriptionException(InvalidDescriptionException)
    case invalidReferenceNameException(InvalidReferenceNameException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidTargetException(InvalidTargetException)
    case invalidTargetsException(InvalidTargetsException)
    case invalidTitleException(InvalidTitleException)
    case maximumOpenPullRequestsExceededException(MaximumOpenPullRequestsExceededException)
    case multipleRepositoriesInPullRequestException(MultipleRepositoriesInPullRequestException)
    case referenceDoesNotExistException(ReferenceDoesNotExistException)
    case referenceNameRequiredException(ReferenceNameRequiredException)
    case referenceTypeNotSupportedException(ReferenceTypeNotSupportedException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case sourceAndDestinationAreSameException(SourceAndDestinationAreSameException)
    case targetRequiredException(TargetRequiredException)
    case targetsRequiredException(TargetsRequiredException)
    case titleRequiredException(TitleRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePullRequestOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePullRequestOutputResponse(pullRequest: \(String(describing: pullRequest)))"}
}

extension CreatePullRequestOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePullRequestOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct CreatePullRequestOutputResponse: Equatable {
    /// <p>Information about the newly created pull request.</p>
    public let pullRequest: PullRequest?

    public init (
        pullRequest: PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct CreatePullRequestOutputResponseBody: Equatable {
    public let pullRequest: PullRequest?
}

extension CreatePullRequestOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pullRequest
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

public struct CreateRepositoryInputBodyMiddleware: Middleware {
    public let id: String = "CreateRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRepositoryOutputError>
}

extension CreateRepositoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRepositoryInput(repositoryDescription: \(String(describing: repositoryDescription)), repositoryName: \(String(describing: repositoryName)), tags: \(String(describing: tags)))"}
}

extension CreateRepositoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case repositoryDescription
        case repositoryName
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryDescription = repositoryDescription {
            try encodeContainer.encode(repositoryDescription, forKey: .repositoryDescription)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateRepositoryInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRepositoryOutputError>
}

/// <p>Represents the input of a create repository operation.</p>
public struct CreateRepositoryInput: Equatable {
    /// <p>A comment or description about the new repository.</p>
    ///         <note>
    ///             <p>The description field for a repository accepts all HTML characters and all valid
    ///                 Unicode characters. Applications that do not HTML-encode the description and display
    ///                 it in a webpage can expose users to potentially malicious code. Make sure that you
    ///                 HTML-encode the description field in any application that uses this API to display
    ///                 the repository description on a webpage.</p>
    ///          </note>
    public let repositoryDescription: String?
    /// <p>The name of the new repository to be created.</p>
    ///         <note>
    ///             <p>The repository name must be unique across the calling AWS account. Repository names
    ///                 are limited to 100 alphanumeric, dash, and underscore characters, and cannot include
    ///                 certain characters. For more information about the limits on repository names, see
    ///                     <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">Limits</a> in the <i>AWS CodeCommit User Guide</i>. The
    ///                 suffix .git is prohibited.</p>
    ///          </note>
    public let repositoryName: String?
    /// <p>One or more tag key-value pairs to use when tagging this repository.</p>
    public let tags: [String:String]?

    public init (
        repositoryDescription: String? = nil,
        repositoryName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.repositoryDescription = repositoryDescription
        self.repositoryName = repositoryName
        self.tags = tags
    }
}

struct CreateRepositoryInputBody: Equatable {
    public let repositoryName: String?
    public let repositoryDescription: String?
    public let tags: [String:String]?
}

extension CreateRepositoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repositoryDescription
        case repositoryName
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryDescription)
        repositoryDescription = repositoryDescriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRepositoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRepositoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryDescriptionException" : self = .invalidRepositoryDescriptionException(try InvalidRepositoryDescriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSystemTagUsageException" : self = .invalidSystemTagUsageException(try InvalidSystemTagUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagsMapException" : self = .invalidTagsMapException(try InvalidTagsMapException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryLimitExceededException" : self = .repositoryLimitExceededException(try RepositoryLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameExistsException" : self = .repositoryNameExistsException(try RepositoryNameExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRepositoryOutputError: Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidRepositoryDescriptionException(InvalidRepositoryDescriptionException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidSystemTagUsageException(InvalidSystemTagUsageException)
    case invalidTagsMapException(InvalidTagsMapException)
    case repositoryLimitExceededException(RepositoryLimitExceededException)
    case repositoryNameExistsException(RepositoryNameExistsException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case tagPolicyException(TagPolicyException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRepositoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRepositoryOutputResponse(repositoryMetadata: \(String(describing: repositoryMetadata)))"}
}

extension CreateRepositoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.repositoryMetadata = output.repositoryMetadata
        } else {
            self.repositoryMetadata = nil
        }
    }
}

/// <p>Represents the output of a create repository operation.</p>
public struct CreateRepositoryOutputResponse: Equatable {
    /// <p>Information about the newly created repository.</p>
    public let repositoryMetadata: RepositoryMetadata?

    public init (
        repositoryMetadata: RepositoryMetadata? = nil
    )
    {
        self.repositoryMetadata = repositoryMetadata
    }
}

struct CreateRepositoryOutputResponseBody: Equatable {
    public let repositoryMetadata: RepositoryMetadata?
}

extension CreateRepositoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repositoryMetadata
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryMetadataDecoded = try containerValues.decodeIfPresent(RepositoryMetadata.self, forKey: .repositoryMetadata)
        repositoryMetadata = repositoryMetadataDecoded
    }
}

public struct CreateUnreferencedMergeCommitInputBodyMiddleware: Middleware {
    public let id: String = "CreateUnreferencedMergeCommitInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUnreferencedMergeCommitInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUnreferencedMergeCommitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUnreferencedMergeCommitInput>
    public typealias MOutput = OperationOutput<CreateUnreferencedMergeCommitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUnreferencedMergeCommitOutputError>
}

extension CreateUnreferencedMergeCommitInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUnreferencedMergeCommitInput(authorName: \(String(describing: authorName)), commitMessage: \(String(describing: commitMessage)), conflictDetailLevel: \(String(describing: conflictDetailLevel)), conflictResolution: \(String(describing: conflictResolution)), conflictResolutionStrategy: \(String(describing: conflictResolutionStrategy)), destinationCommitSpecifier: \(String(describing: destinationCommitSpecifier)), email: \(String(describing: email)), keepEmptyFolders: \(String(describing: keepEmptyFolders)), mergeOption: \(String(describing: mergeOption)), repositoryName: \(String(describing: repositoryName)), sourceCommitSpecifier: \(String(describing: sourceCommitSpecifier)))"}
}

extension CreateUnreferencedMergeCommitInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case email
        case keepEmptyFolders
        case mergeOption
        case repositoryName
        case sourceCommitSpecifier
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let commitMessage = commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let conflictDetailLevel = conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolution = conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let conflictResolutionStrategy = conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if keepEmptyFolders != false {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let mergeOption = mergeOption {
            try encodeContainer.encode(mergeOption.rawValue, forKey: .mergeOption)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
    }
}

public struct CreateUnreferencedMergeCommitInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUnreferencedMergeCommitInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUnreferencedMergeCommitInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUnreferencedMergeCommitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUnreferencedMergeCommitInput>
    public typealias MOutput = OperationOutput<CreateUnreferencedMergeCommitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUnreferencedMergeCommitOutputError>
}

public struct CreateUnreferencedMergeCommitInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUnreferencedMergeCommitInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUnreferencedMergeCommitInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUnreferencedMergeCommitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUnreferencedMergeCommitInput>
    public typealias MOutput = OperationOutput<CreateUnreferencedMergeCommitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUnreferencedMergeCommitOutputError>
}

public struct CreateUnreferencedMergeCommitInput: Equatable {
    /// <p>The name of the author who created the unreferenced commit. This information is used
    ///             as both the author and committer for the commit.</p>
    public let authorName: String?
    /// <p>The commit message for the unreferenced commit.</p>
    public let commitMessage: String?
    /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
    ///             which returns a not-mergeable result if the same file has differences in both branches.
    ///             If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
    ///             both branches has differences on the same line.</p>
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    /// <p>If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when
    ///             resolving conflicts during a merge.</p>
    public let conflictResolution: ConflictResolution?
    /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
    ///             automatically merging two versions of a file. The default is NONE, which requires any
    ///             conflicts to be resolved manually before the merge operation is successful.</p>
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, a branch name or a full commit ID).</p>
    public let destinationCommitSpecifier: String?
    /// <p>The email address for the person who created the unreferenced commit.</p>
    public let email: String?
    /// <p>If the commit contains deletions, whether to keep a folder or folder structure if the
    ///             changes leave the folders empty. If this is specified as true, a .gitkeep file is
    ///             created for empty folders. The default is false.</p>
    public let keepEmptyFolders: Bool
    /// <p>The merge option or strategy you want to use to merge the code.</p>
    public let mergeOption: MergeOptionTypeEnum?
    /// <p>The name of the repository where you want to create the unreferenced merge commit.</p>
    public let repositoryName: String?
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, a branch name or a full commit ID).</p>
    public let sourceCommitSpecifier: String?

    public init (
        authorName: String? = nil,
        commitMessage: String? = nil,
        conflictDetailLevel: ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: ConflictResolution? = nil,
        conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: String? = nil,
        email: String? = nil,
        keepEmptyFolders: Bool = false,
        mergeOption: MergeOptionTypeEnum? = nil,
        repositoryName: String? = nil,
        sourceCommitSpecifier: String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.mergeOption = mergeOption
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

struct CreateUnreferencedMergeCommitInputBody: Equatable {
    public let repositoryName: String?
    public let sourceCommitSpecifier: String?
    public let destinationCommitSpecifier: String?
    public let mergeOption: MergeOptionTypeEnum?
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
    public let authorName: String?
    public let email: String?
    public let commitMessage: String?
    public let keepEmptyFolders: Bool
    public let conflictResolution: ConflictResolution?
}

extension CreateUnreferencedMergeCommitInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case email
        case keepEmptyFolders
        case mergeOption
        case repositoryName
        case sourceCommitSpecifier
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let mergeOptionDecoded = try containerValues.decodeIfPresent(MergeOptionTypeEnum.self, forKey: .mergeOption)
        mergeOption = mergeOptionDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let authorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let keepEmptyFoldersDecoded = try containerValues.decode(Bool.self, forKey: .keepEmptyFolders)
        keepEmptyFolders = keepEmptyFoldersDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
    }
}

extension CreateUnreferencedMergeCommitOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUnreferencedMergeCommitOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitMessageLengthExceededException" : self = .commitMessageLengthExceededException(try CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentReferenceUpdateException" : self = .concurrentReferenceUpdateException(try ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileContentSizeLimitExceededException" : self = .fileContentSizeLimitExceededException(try FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileModeRequiredException" : self = .fileModeRequiredException(try FileModeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FolderContentSizeLimitExceededException" : self = .folderContentSizeLimitExceededException(try FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionException" : self = .invalidConflictResolutionException(try InvalidConflictResolutionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailException" : self = .invalidEmailException(try InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFileModeException" : self = .invalidFileModeException(try InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMergeOptionException" : self = .invalidMergeOptionException(try InvalidMergeOptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementContentException" : self = .invalidReplacementContentException(try InvalidReplacementContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementTypeException" : self = .invalidReplacementTypeException(try InvalidReplacementTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManualMergeRequiredException" : self = .manualMergeRequiredException(try ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumConflictResolutionEntriesExceededException" : self = .maximumConflictResolutionEntriesExceededException(try MaximumConflictResolutionEntriesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileContentToLoadExceededException" : self = .maximumFileContentToLoadExceededException(try MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumItemsToCompareExceededException" : self = .maximumItemsToCompareExceededException(try MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MergeOptionRequiredException" : self = .mergeOptionRequiredException(try MergeOptionRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MultipleConflictResolutionEntriesException" : self = .multipleConflictResolutionEntriesException(try MultipleConflictResolutionEntriesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameLengthExceededException" : self = .nameLengthExceededException(try NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementContentRequiredException" : self = .replacementContentRequiredException(try ReplacementContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementTypeRequiredException" : self = .replacementTypeRequiredException(try ReplacementTypeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUnreferencedMergeCommitOutputError: Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitMessageLengthExceededException(CommitMessageLengthExceededException)
    case commitRequiredException(CommitRequiredException)
    case concurrentReferenceUpdateException(ConcurrentReferenceUpdateException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileContentSizeLimitExceededException(FileContentSizeLimitExceededException)
    case fileModeRequiredException(FileModeRequiredException)
    case folderContentSizeLimitExceededException(FolderContentSizeLimitExceededException)
    case invalidCommitException(InvalidCommitException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionException(InvalidConflictResolutionException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidEmailException(InvalidEmailException)
    case invalidFileModeException(InvalidFileModeException)
    case invalidMergeOptionException(InvalidMergeOptionException)
    case invalidPathException(InvalidPathException)
    case invalidReplacementContentException(InvalidReplacementContentException)
    case invalidReplacementTypeException(InvalidReplacementTypeException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case manualMergeRequiredException(ManualMergeRequiredException)
    case maximumConflictResolutionEntriesExceededException(MaximumConflictResolutionEntriesExceededException)
    case maximumFileContentToLoadExceededException(MaximumFileContentToLoadExceededException)
    case maximumItemsToCompareExceededException(MaximumItemsToCompareExceededException)
    case mergeOptionRequiredException(MergeOptionRequiredException)
    case multipleConflictResolutionEntriesException(MultipleConflictResolutionEntriesException)
    case nameLengthExceededException(NameLengthExceededException)
    case pathRequiredException(PathRequiredException)
    case replacementContentRequiredException(ReplacementContentRequiredException)
    case replacementTypeRequiredException(ReplacementTypeRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUnreferencedMergeCommitOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUnreferencedMergeCommitOutputResponse(commitId: \(String(describing: commitId)), treeId: \(String(describing: treeId)))"}
}

extension CreateUnreferencedMergeCommitOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUnreferencedMergeCommitOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.commitId = output.commitId
            self.treeId = output.treeId
        } else {
            self.commitId = nil
            self.treeId = nil
        }
    }
}

public struct CreateUnreferencedMergeCommitOutputResponse: Equatable {
    /// <p>The full commit ID of the commit that contains your merge results.</p>
    public let commitId: String?
    /// <p>The full SHA-1 pointer of the tree information for the commit that contains the merge results.</p>
    public let treeId: String?

    public init (
        commitId: String? = nil,
        treeId: String? = nil
    )
    {
        self.commitId = commitId
        self.treeId = treeId
    }
}

struct CreateUnreferencedMergeCommitOutputResponseBody: Equatable {
    public let commitId: String?
    public let treeId: String?
}

extension CreateUnreferencedMergeCommitOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commitId
        case treeId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treeId)
        treeId = treeIdDecoded
    }
}

extension DefaultBranchCannotBeDeletedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefaultBranchCannotBeDeletedException(message: \(String(describing: message)))"}
}

extension DefaultBranchCannotBeDeletedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DefaultBranchCannotBeDeletedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified branch is the default branch for the repository, and cannot be deleted. To delete this branch, you must first set another branch as the default branch.</p>
public struct DefaultBranchCannotBeDeletedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DefaultBranchCannotBeDeletedExceptionBody: Equatable {
    public let message: String?
}

extension DefaultBranchCannotBeDeletedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DeleteApprovalRuleTemplateInputBodyMiddleware: Middleware {
    public let id: String = "DeleteApprovalRuleTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApprovalRuleTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApprovalRuleTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApprovalRuleTemplateInput>
    public typealias MOutput = OperationOutput<DeleteApprovalRuleTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApprovalRuleTemplateOutputError>
}

extension DeleteApprovalRuleTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApprovalRuleTemplateInput(approvalRuleTemplateName: \(String(describing: approvalRuleTemplateName)))"}
}

extension DeleteApprovalRuleTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
    }
}

public struct DeleteApprovalRuleTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApprovalRuleTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApprovalRuleTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApprovalRuleTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApprovalRuleTemplateInput>
    public typealias MOutput = OperationOutput<DeleteApprovalRuleTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApprovalRuleTemplateOutputError>
}

public struct DeleteApprovalRuleTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApprovalRuleTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApprovalRuleTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApprovalRuleTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApprovalRuleTemplateInput>
    public typealias MOutput = OperationOutput<DeleteApprovalRuleTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApprovalRuleTemplateOutputError>
}

public struct DeleteApprovalRuleTemplateInput: Equatable {
    /// <p>The name of the approval rule template to delete.</p>
    public let approvalRuleTemplateName: String?

    public init (
        approvalRuleTemplateName: String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
    }
}

struct DeleteApprovalRuleTemplateInputBody: Equatable {
    public let approvalRuleTemplateName: String?
}

extension DeleteApprovalRuleTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
    }
}

extension DeleteApprovalRuleTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApprovalRuleTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateInUseException" : self = .approvalRuleTemplateInUseException(try ApprovalRuleTemplateInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApprovalRuleTemplateOutputError: Equatable {
    case approvalRuleTemplateInUseException(ApprovalRuleTemplateInUseException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApprovalRuleTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApprovalRuleTemplateOutputResponse(approvalRuleTemplateId: \(String(describing: approvalRuleTemplateId)))"}
}

extension DeleteApprovalRuleTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteApprovalRuleTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.approvalRuleTemplateId = output.approvalRuleTemplateId
        } else {
            self.approvalRuleTemplateId = nil
        }
    }
}

public struct DeleteApprovalRuleTemplateOutputResponse: Equatable {
    /// <p>The system-generated ID of the deleted approval rule template. If the template has
    ///             been previously deleted, the only response is a 200 OK.</p>
    public let approvalRuleTemplateId: String?

    public init (
        approvalRuleTemplateId: String? = nil
    )
    {
        self.approvalRuleTemplateId = approvalRuleTemplateId
    }
}

struct DeleteApprovalRuleTemplateOutputResponseBody: Equatable {
    public let approvalRuleTemplateId: String?
}

extension DeleteApprovalRuleTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateId)
        approvalRuleTemplateId = approvalRuleTemplateIdDecoded
    }
}

public struct DeleteBranchInputBodyMiddleware: Middleware {
    public let id: String = "DeleteBranchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBranchInput>
    public typealias MOutput = OperationOutput<DeleteBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBranchOutputError>
}

extension DeleteBranchInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBranchInput(branchName: \(String(describing: branchName)), repositoryName: \(String(describing: repositoryName)))"}
}

extension DeleteBranchInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branchName
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DeleteBranchInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBranchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBranchInput>
    public typealias MOutput = OperationOutput<DeleteBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBranchOutputError>
}

public struct DeleteBranchInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBranchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBranchInput>
    public typealias MOutput = OperationOutput<DeleteBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBranchOutputError>
}

/// <p>Represents the input of a delete branch operation.</p>
public struct DeleteBranchInput: Equatable {
    /// <p>The name of the branch to delete.</p>
    public let branchName: String?
    /// <p>The name of the repository that contains the branch to be deleted.</p>
    public let repositoryName: String?

    public init (
        branchName: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.branchName = branchName
        self.repositoryName = repositoryName
    }
}

struct DeleteBranchInputBody: Equatable {
    public let repositoryName: String?
    public let branchName: String?
}

extension DeleteBranchInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case branchName
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchName)
        branchName = branchNameDecoded
    }
}

extension DeleteBranchOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBranchOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DefaultBranchCannotBeDeletedException" : self = .defaultBranchCannotBeDeletedException(try DefaultBranchCannotBeDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBranchOutputError: Equatable {
    case branchNameRequiredException(BranchNameRequiredException)
    case defaultBranchCannotBeDeletedException(DefaultBranchCannotBeDeletedException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBranchOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBranchOutputResponse(deletedBranch: \(String(describing: deletedBranch)))"}
}

extension DeleteBranchOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteBranchOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deletedBranch = output.deletedBranch
        } else {
            self.deletedBranch = nil
        }
    }
}

/// <p>Represents the output of a delete branch operation.</p>
public struct DeleteBranchOutputResponse: Equatable {
    /// <p>Information about the branch deleted by the operation, including the branch name and the commit ID that was the tip of the branch.</p>
    public let deletedBranch: BranchInfo?

    public init (
        deletedBranch: BranchInfo? = nil
    )
    {
        self.deletedBranch = deletedBranch
    }
}

struct DeleteBranchOutputResponseBody: Equatable {
    public let deletedBranch: BranchInfo?
}

extension DeleteBranchOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deletedBranch
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletedBranchDecoded = try containerValues.decodeIfPresent(BranchInfo.self, forKey: .deletedBranch)
        deletedBranch = deletedBranchDecoded
    }
}

public struct DeleteCommentContentInputBodyMiddleware: Middleware {
    public let id: String = "DeleteCommentContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCommentContentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCommentContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCommentContentInput>
    public typealias MOutput = OperationOutput<DeleteCommentContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCommentContentOutputError>
}

extension DeleteCommentContentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCommentContentInput(commentId: \(String(describing: commentId)))"}
}

extension DeleteCommentContentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commentId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
    }
}

public struct DeleteCommentContentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCommentContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCommentContentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCommentContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCommentContentInput>
    public typealias MOutput = OperationOutput<DeleteCommentContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCommentContentOutputError>
}

public struct DeleteCommentContentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCommentContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCommentContentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCommentContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCommentContentInput>
    public typealias MOutput = OperationOutput<DeleteCommentContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCommentContentOutputError>
}

public struct DeleteCommentContentInput: Equatable {
    /// <p>The unique, system-generated ID of the comment. To get this ID, use  <a>GetCommentsForComparedCommit</a>
    ///          or <a>GetCommentsForPullRequest</a>.</p>
    public let commentId: String?

    public init (
        commentId: String? = nil
    )
    {
        self.commentId = commentId
    }
}

struct DeleteCommentContentInputBody: Equatable {
    public let commentId: String?
}

extension DeleteCommentContentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commentId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commentId)
        commentId = commentIdDecoded
    }
}

extension DeleteCommentContentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCommentContentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommentDeletedException" : self = .commentDeletedException(try CommentDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentDoesNotExistException" : self = .commentDoesNotExistException(try CommentDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentIdRequiredException" : self = .commentIdRequiredException(try CommentIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommentIdException" : self = .invalidCommentIdException(try InvalidCommentIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCommentContentOutputError: Equatable {
    case commentDeletedException(CommentDeletedException)
    case commentDoesNotExistException(CommentDoesNotExistException)
    case commentIdRequiredException(CommentIdRequiredException)
    case invalidCommentIdException(InvalidCommentIdException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCommentContentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCommentContentOutputResponse(comment: \(String(describing: comment)))"}
}

extension DeleteCommentContentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteCommentContentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.comment = output.comment
        } else {
            self.comment = nil
        }
    }
}

public struct DeleteCommentContentOutputResponse: Equatable {
    /// <p>Information about the comment you just deleted.</p>
    public let comment: Comment?

    public init (
        comment: Comment? = nil
    )
    {
        self.comment = comment
    }
}

struct DeleteCommentContentOutputResponseBody: Equatable {
    public let comment: Comment?
}

extension DeleteCommentContentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comment
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension DeleteFileEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filePath
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filePath = filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePath)
        filePath = filePathDecoded
    }
}

extension DeleteFileEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFileEntry(filePath: \(String(describing: filePath)))"}
}

/// <p>A file that is deleted as part of a commit.</p>
public struct DeleteFileEntry: Equatable {
    /// <p>The full path of the file to be deleted, including the name of the file.</p>
    public let filePath: String?

    public init (
        filePath: String? = nil
    )
    {
        self.filePath = filePath
    }
}

public struct DeleteFileInputBodyMiddleware: Middleware {
    public let id: String = "DeleteFileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFileInput>
    public typealias MOutput = OperationOutput<DeleteFileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFileOutputError>
}

extension DeleteFileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFileInput(branchName: \(String(describing: branchName)), commitMessage: \(String(describing: commitMessage)), email: \(String(describing: email)), filePath: \(String(describing: filePath)), keepEmptyFolders: \(String(describing: keepEmptyFolders)), name: \(String(describing: name)), parentCommitId: \(String(describing: parentCommitId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension DeleteFileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branchName
        case commitMessage
        case email
        case filePath
        case keepEmptyFolders
        case name
        case parentCommitId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let commitMessage = commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let filePath = filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if keepEmptyFolders != false {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentCommitId = parentCommitId {
            try encodeContainer.encode(parentCommitId, forKey: .parentCommitId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DeleteFileInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFileInput>
    public typealias MOutput = OperationOutput<DeleteFileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFileOutputError>
}

public struct DeleteFileInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFileInput>
    public typealias MOutput = OperationOutput<DeleteFileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFileOutputError>
}

public struct DeleteFileInput: Equatable {
    /// <p>The name of the branch where the commit that deletes the file is made.</p>
    public let branchName: String?
    /// <p>The commit message you want to include as part of deleting the file. Commit messages
    ///             are limited to 256 KB. If no message is specified, a default message is used.</p>
    public let commitMessage: String?
    /// <p>The email address for the commit that deletes the file. If no email address is
    ///             specified, the email address is left blank.</p>
    public let email: String?
    /// <p>The fully qualified path to the file that to be deleted, including the full name and
    ///             extension of that file. For example, /examples/file.md is a fully qualified path to a
    ///             file named file.md in a folder named examples.</p>
    public let filePath: String?
    /// <p>If a file is the only object in the folder or directory, specifies whether to delete
    ///             the folder or directory that contains the file. By default, empty folders are deleted.
    ///             This includes empty folders that are part of the directory structure. For example, if
    ///             the path to a file is dir1/dir2/dir3/dir4, and dir2 and dir3 are empty, deleting the
    ///             last file in dir4 also deletes the empty folders dir4, dir3, and dir2.</p>
    public let keepEmptyFolders: Bool
    /// <p>The name of the author of the commit that deletes the file. If no name is specified,
    ///             the user's ARN is used as the author name and committer name.</p>
    public let name: String?
    /// <p>The ID of the commit that is the tip of the branch where you want to create the commit
    ///             that deletes the file. This must be the HEAD commit for the branch. The commit that
    ///             deletes the file is created from this commit ID.</p>
    public let parentCommitId: String?
    /// <p>The name of the repository that contains the file to delete.</p>
    public let repositoryName: String?

    public init (
        branchName: String? = nil,
        commitMessage: String? = nil,
        email: String? = nil,
        filePath: String? = nil,
        keepEmptyFolders: Bool = false,
        name: String? = nil,
        parentCommitId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.branchName = branchName
        self.commitMessage = commitMessage
        self.email = email
        self.filePath = filePath
        self.keepEmptyFolders = keepEmptyFolders
        self.name = name
        self.parentCommitId = parentCommitId
        self.repositoryName = repositoryName
    }
}

struct DeleteFileInputBody: Equatable {
    public let repositoryName: String?
    public let branchName: String?
    public let filePath: String?
    public let parentCommitId: String?
    public let keepEmptyFolders: Bool
    public let commitMessage: String?
    public let name: String?
    public let email: String?
}

extension DeleteFileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case branchName
        case commitMessage
        case email
        case filePath
        case keepEmptyFolders
        case name
        case parentCommitId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePath)
        filePath = filePathDecoded
        let parentCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentCommitId)
        parentCommitId = parentCommitIdDecoded
        let keepEmptyFoldersDecoded = try containerValues.decode(Bool.self, forKey: .keepEmptyFolders)
        keepEmptyFolders = keepEmptyFoldersDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
    }
}

extension DeleteFileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BranchDoesNotExistException" : self = .branchDoesNotExistException(try BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameIsTagNameException" : self = .branchNameIsTagNameException(try BranchNameIsTagNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitMessageLengthExceededException" : self = .commitMessageLengthExceededException(try CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileDoesNotExistException" : self = .fileDoesNotExistException(try FileDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailException" : self = .invalidEmailException(try InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParentCommitIdException" : self = .invalidParentCommitIdException(try InvalidParentCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameLengthExceededException" : self = .nameLengthExceededException(try NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParentCommitDoesNotExistException" : self = .parentCommitDoesNotExistException(try ParentCommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParentCommitIdOutdatedException" : self = .parentCommitIdOutdatedException(try ParentCommitIdOutdatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParentCommitIdRequiredException" : self = .parentCommitIdRequiredException(try ParentCommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFileOutputError: Equatable {
    case branchDoesNotExistException(BranchDoesNotExistException)
    case branchNameIsTagNameException(BranchNameIsTagNameException)
    case branchNameRequiredException(BranchNameRequiredException)
    case commitMessageLengthExceededException(CommitMessageLengthExceededException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileDoesNotExistException(FileDoesNotExistException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidEmailException(InvalidEmailException)
    case invalidParentCommitIdException(InvalidParentCommitIdException)
    case invalidPathException(InvalidPathException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case nameLengthExceededException(NameLengthExceededException)
    case parentCommitDoesNotExistException(ParentCommitDoesNotExistException)
    case parentCommitIdOutdatedException(ParentCommitIdOutdatedException)
    case parentCommitIdRequiredException(ParentCommitIdRequiredException)
    case pathRequiredException(PathRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFileOutputResponse(blobId: \(String(describing: blobId)), commitId: \(String(describing: commitId)), filePath: \(String(describing: filePath)), treeId: \(String(describing: treeId)))"}
}

extension DeleteFileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteFileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.blobId = output.blobId
            self.commitId = output.commitId
            self.filePath = output.filePath
            self.treeId = output.treeId
        } else {
            self.blobId = nil
            self.commitId = nil
            self.filePath = nil
            self.treeId = nil
        }
    }
}

public struct DeleteFileOutputResponse: Equatable {
    /// <p>The blob ID removed from the tree as part of deleting the file.</p>
    public let blobId: String?
    /// <p>The full commit ID of the commit that contains the change that deletes the file.</p>
    public let commitId: String?
    /// <p>The fully qualified path to the file to be deleted, including the full name and
    ///             extension of that file.</p>
    public let filePath: String?
    /// <p>The full SHA-1 pointer of the tree information for the commit that contains the delete file change.</p>
    public let treeId: String?

    public init (
        blobId: String? = nil,
        commitId: String? = nil,
        filePath: String? = nil,
        treeId: String? = nil
    )
    {
        self.blobId = blobId
        self.commitId = commitId
        self.filePath = filePath
        self.treeId = treeId
    }
}

struct DeleteFileOutputResponseBody: Equatable {
    public let commitId: String?
    public let blobId: String?
    public let treeId: String?
    public let filePath: String?
}

extension DeleteFileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case blobId
        case commitId
        case filePath
        case treeId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let blobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treeId)
        treeId = treeIdDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePath)
        filePath = filePathDecoded
    }
}

public struct DeletePullRequestApprovalRuleInputBodyMiddleware: Middleware {
    public let id: String = "DeletePullRequestApprovalRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePullRequestApprovalRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePullRequestApprovalRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePullRequestApprovalRuleInput>
    public typealias MOutput = OperationOutput<DeletePullRequestApprovalRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePullRequestApprovalRuleOutputError>
}

extension DeletePullRequestApprovalRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePullRequestApprovalRuleInput(approvalRuleName: \(String(describing: approvalRuleName)), pullRequestId: \(String(describing: pullRequestId)))"}
}

extension DeletePullRequestApprovalRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRuleName
        case pullRequestId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleName = approvalRuleName {
            try encodeContainer.encode(approvalRuleName, forKey: .approvalRuleName)
        }
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
    }
}

public struct DeletePullRequestApprovalRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePullRequestApprovalRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePullRequestApprovalRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePullRequestApprovalRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePullRequestApprovalRuleInput>
    public typealias MOutput = OperationOutput<DeletePullRequestApprovalRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePullRequestApprovalRuleOutputError>
}

public struct DeletePullRequestApprovalRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePullRequestApprovalRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePullRequestApprovalRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePullRequestApprovalRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePullRequestApprovalRuleInput>
    public typealias MOutput = OperationOutput<DeletePullRequestApprovalRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePullRequestApprovalRuleOutputError>
}

public struct DeletePullRequestApprovalRuleInput: Equatable {
    /// <p>The name of the approval rule you want to delete.</p>
    public let approvalRuleName: String?
    /// <p>The system-generated ID of the pull request that contains the approval rule you want to delete.</p>
    public let pullRequestId: String?

    public init (
        approvalRuleName: String? = nil,
        pullRequestId: String? = nil
    )
    {
        self.approvalRuleName = approvalRuleName
        self.pullRequestId = pullRequestId
    }
}

struct DeletePullRequestApprovalRuleInputBody: Equatable {
    public let pullRequestId: String?
    public let approvalRuleName: String?
}

extension DeletePullRequestApprovalRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleName
        case pullRequestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let approvalRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleName)
        approvalRuleName = approvalRuleNameDecoded
    }
}

extension DeletePullRequestApprovalRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePullRequestApprovalRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ApprovalRuleNameRequiredException" : self = .approvalRuleNameRequiredException(try ApprovalRuleNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CannotDeleteApprovalRuleFromTemplateException" : self = .cannotDeleteApprovalRuleFromTemplateException(try CannotDeleteApprovalRuleFromTemplateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleNameException" : self = .invalidApprovalRuleNameException(try InvalidApprovalRuleNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePullRequestApprovalRuleOutputError: Equatable {
    case approvalRuleNameRequiredException(ApprovalRuleNameRequiredException)
    case cannotDeleteApprovalRuleFromTemplateException(CannotDeleteApprovalRuleFromTemplateException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidApprovalRuleNameException(InvalidApprovalRuleNameException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePullRequestApprovalRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePullRequestApprovalRuleOutputResponse(approvalRuleId: \(String(describing: approvalRuleId)))"}
}

extension DeletePullRequestApprovalRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeletePullRequestApprovalRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.approvalRuleId = output.approvalRuleId
        } else {
            self.approvalRuleId = nil
        }
    }
}

public struct DeletePullRequestApprovalRuleOutputResponse: Equatable {
    /// <p>The ID of the deleted approval rule. </p>
    ///         <note>
    ///             <p>If the approval rule was deleted in an earlier API call, the response is 200 OK without
    ///                 content.</p>
    ///          </note>
    public let approvalRuleId: String?

    public init (
        approvalRuleId: String? = nil
    )
    {
        self.approvalRuleId = approvalRuleId
    }
}

struct DeletePullRequestApprovalRuleOutputResponseBody: Equatable {
    public let approvalRuleId: String?
}

extension DeletePullRequestApprovalRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleId)
        approvalRuleId = approvalRuleIdDecoded
    }
}

public struct DeleteRepositoryInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryOutputError>
}

extension DeleteRepositoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRepositoryInput(repositoryName: \(String(describing: repositoryName)))"}
}

extension DeleteRepositoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DeleteRepositoryInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryOutputError>
}

/// <p>Represents the input of a delete repository operation.</p>
public struct DeleteRepositoryInput: Equatable {
    /// <p>The name of the repository to delete.</p>
    public let repositoryName: String?

    public init (
        repositoryName: String? = nil
    )
    {
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryInputBody: Equatable {
    public let repositoryName: String?
}

extension DeleteRepositoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension DeleteRepositoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRepositoryOutputError: Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRepositoryOutputResponse(repositoryId: \(String(describing: repositoryId)))"}
}

extension DeleteRepositoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.repositoryId = output.repositoryId
        } else {
            self.repositoryId = nil
        }
    }
}

/// <p>Represents the output of a delete repository operation.</p>
public struct DeleteRepositoryOutputResponse: Equatable {
    /// <p>The ID of the repository that was deleted.</p>
    public let repositoryId: String?

    public init (
        repositoryId: String? = nil
    )
    {
        self.repositoryId = repositoryId
    }
}

struct DeleteRepositoryOutputResponseBody: Equatable {
    public let repositoryId: String?
}

extension DeleteRepositoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repositoryId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryId)
        repositoryId = repositoryIdDecoded
    }
}

public struct DescribeMergeConflictsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeMergeConflictsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMergeConflictsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMergeConflictsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMergeConflictsInput>
    public typealias MOutput = OperationOutput<DescribeMergeConflictsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMergeConflictsOutputError>
}

extension DescribeMergeConflictsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMergeConflictsInput(conflictDetailLevel: \(String(describing: conflictDetailLevel)), conflictResolutionStrategy: \(String(describing: conflictResolutionStrategy)), destinationCommitSpecifier: \(String(describing: destinationCommitSpecifier)), filePath: \(String(describing: filePath)), maxMergeHunks: \(String(describing: maxMergeHunks)), mergeOption: \(String(describing: mergeOption)), nextToken: \(String(describing: nextToken)), repositoryName: \(String(describing: repositoryName)), sourceCommitSpecifier: \(String(describing: sourceCommitSpecifier)))"}
}

extension DescribeMergeConflictsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case filePath
        case maxMergeHunks
        case mergeOption
        case nextToken
        case repositoryName
        case sourceCommitSpecifier
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetailLevel = conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolutionStrategy = conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let filePath = filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let maxMergeHunks = maxMergeHunks {
            try encodeContainer.encode(maxMergeHunks, forKey: .maxMergeHunks)
        }
        if let mergeOption = mergeOption {
            try encodeContainer.encode(mergeOption.rawValue, forKey: .mergeOption)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
    }
}

public struct DescribeMergeConflictsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeMergeConflictsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMergeConflictsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMergeConflictsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMergeConflictsInput>
    public typealias MOutput = OperationOutput<DescribeMergeConflictsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMergeConflictsOutputError>
}

public struct DescribeMergeConflictsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeMergeConflictsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMergeConflictsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMergeConflictsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMergeConflictsInput>
    public typealias MOutput = OperationOutput<DescribeMergeConflictsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMergeConflictsOutputError>
}

public struct DescribeMergeConflictsInput: Equatable {
    /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
    ///             which returns a not-mergeable result if the same file has differences in both branches.
    ///             If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
    ///             both branches has differences on the same line.</p>
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
    ///             automatically merging two versions of a file. The default is NONE, which requires any
    ///             conflicts to be resolved manually before the merge operation is successful.</p>
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, a branch name or a full commit ID).</p>
    public let destinationCommitSpecifier: String?
    /// <p>The path of the target files used to describe the conflicts. </p>
    public let filePath: String?
    /// <p>The maximum number of merge hunks to include in the output.</p>
    public let maxMergeHunks: Int?
    /// <p>The merge option or strategy you want to use to merge the code.</p>
    public let mergeOption: MergeOptionTypeEnum?
    /// <p>An enumeration token that, when provided in a request, returns the next batch of the
    ///             results.</p>
    public let nextToken: String?
    /// <p>The name of the repository where you want to get information about a merge conflict.</p>
    public let repositoryName: String?
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, a branch name or a full commit ID).</p>
    public let sourceCommitSpecifier: String?

    public init (
        conflictDetailLevel: ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: String? = nil,
        filePath: String? = nil,
        maxMergeHunks: Int? = nil,
        mergeOption: MergeOptionTypeEnum? = nil,
        nextToken: String? = nil,
        repositoryName: String? = nil,
        sourceCommitSpecifier: String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.filePath = filePath
        self.maxMergeHunks = maxMergeHunks
        self.mergeOption = mergeOption
        self.nextToken = nextToken
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

struct DescribeMergeConflictsInputBody: Equatable {
    public let repositoryName: String?
    public let destinationCommitSpecifier: String?
    public let sourceCommitSpecifier: String?
    public let mergeOption: MergeOptionTypeEnum?
    public let maxMergeHunks: Int?
    public let filePath: String?
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
    public let nextToken: String?
}

extension DescribeMergeConflictsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case filePath
        case maxMergeHunks
        case mergeOption
        case nextToken
        case repositoryName
        case sourceCommitSpecifier
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let mergeOptionDecoded = try containerValues.decodeIfPresent(MergeOptionTypeEnum.self, forKey: .mergeOption)
        mergeOption = mergeOptionDecoded
        let maxMergeHunksDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxMergeHunks)
        maxMergeHunks = maxMergeHunksDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePath)
        filePath = filePathDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMergeConflictsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMergeConflictsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileDoesNotExistException" : self = .fileDoesNotExistException(try FileDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxMergeHunksException" : self = .invalidMaxMergeHunksException(try InvalidMaxMergeHunksException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMergeOptionException" : self = .invalidMergeOptionException(try InvalidMergeOptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileContentToLoadExceededException" : self = .maximumFileContentToLoadExceededException(try MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumItemsToCompareExceededException" : self = .maximumItemsToCompareExceededException(try MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MergeOptionRequiredException" : self = .mergeOptionRequiredException(try MergeOptionRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMergeConflictsOutputError: Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitRequiredException(CommitRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileDoesNotExistException(FileDoesNotExistException)
    case invalidCommitException(InvalidCommitException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxMergeHunksException(InvalidMaxMergeHunksException)
    case invalidMergeOptionException(InvalidMergeOptionException)
    case invalidPathException(InvalidPathException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case maximumFileContentToLoadExceededException(MaximumFileContentToLoadExceededException)
    case maximumItemsToCompareExceededException(MaximumItemsToCompareExceededException)
    case mergeOptionRequiredException(MergeOptionRequiredException)
    case pathRequiredException(PathRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMergeConflictsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMergeConflictsOutputResponse(baseCommitId: \(String(describing: baseCommitId)), conflictMetadata: \(String(describing: conflictMetadata)), destinationCommitId: \(String(describing: destinationCommitId)), mergeHunks: \(String(describing: mergeHunks)), nextToken: \(String(describing: nextToken)), sourceCommitId: \(String(describing: sourceCommitId)))"}
}

extension DescribeMergeConflictsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeMergeConflictsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.baseCommitId = output.baseCommitId
            self.conflictMetadata = output.conflictMetadata
            self.destinationCommitId = output.destinationCommitId
            self.mergeHunks = output.mergeHunks
            self.nextToken = output.nextToken
            self.sourceCommitId = output.sourceCommitId
        } else {
            self.baseCommitId = nil
            self.conflictMetadata = nil
            self.destinationCommitId = nil
            self.mergeHunks = nil
            self.nextToken = nil
            self.sourceCommitId = nil
        }
    }
}

public struct DescribeMergeConflictsOutputResponse: Equatable {
    /// <p>The commit ID of the merge base.</p>
    public let baseCommitId: String?
    /// <p>Contains metadata about the conflicts found in the merge.</p>
    public let conflictMetadata: ConflictMetadata?
    /// <p>The commit ID of the destination commit specifier that was used in the merge evaluation.</p>
    public let destinationCommitId: String?
    /// <p>A list of merge hunks of the differences between the files or lines.</p>
    public let mergeHunks: [MergeHunk]?
    /// <p>An enumeration token that can be used in a request to return the next batch of the results.</p>
    public let nextToken: String?
    /// <p>The commit ID of the source commit specifier that was used in the merge evaluation.</p>
    public let sourceCommitId: String?

    public init (
        baseCommitId: String? = nil,
        conflictMetadata: ConflictMetadata? = nil,
        destinationCommitId: String? = nil,
        mergeHunks: [MergeHunk]? = nil,
        nextToken: String? = nil,
        sourceCommitId: String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.conflictMetadata = conflictMetadata
        self.destinationCommitId = destinationCommitId
        self.mergeHunks = mergeHunks
        self.nextToken = nextToken
        self.sourceCommitId = sourceCommitId
    }
}

struct DescribeMergeConflictsOutputResponseBody: Equatable {
    public let conflictMetadata: ConflictMetadata?
    public let mergeHunks: [MergeHunk]?
    public let nextToken: String?
    public let destinationCommitId: String?
    public let sourceCommitId: String?
    public let baseCommitId: String?
}

extension DescribeMergeConflictsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baseCommitId
        case conflictMetadata
        case destinationCommitId
        case mergeHunks
        case nextToken
        case sourceCommitId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictMetadataDecoded = try containerValues.decodeIfPresent(ConflictMetadata.self, forKey: .conflictMetadata)
        conflictMetadata = conflictMetadataDecoded
        let mergeHunksContainer = try containerValues.decodeIfPresent([MergeHunk?].self, forKey: .mergeHunks)
        var mergeHunksDecoded0:[MergeHunk]? = nil
        if let mergeHunksContainer = mergeHunksContainer {
            mergeHunksDecoded0 = [MergeHunk]()
            for structure0 in mergeHunksContainer {
                if let structure0 = structure0 {
                    mergeHunksDecoded0?.append(structure0)
                }
            }
        }
        mergeHunks = mergeHunksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let destinationCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationCommitId)
        destinationCommitId = destinationCommitIdDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let baseCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baseCommitId)
        baseCommitId = baseCommitIdDecoded
    }
}

public struct DescribePullRequestEventsInputBodyMiddleware: Middleware {
    public let id: String = "DescribePullRequestEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePullRequestEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePullRequestEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePullRequestEventsInput>
    public typealias MOutput = OperationOutput<DescribePullRequestEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePullRequestEventsOutputError>
}

extension DescribePullRequestEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePullRequestEventsInput(actorArn: \(String(describing: actorArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), pullRequestEventType: \(String(describing: pullRequestEventType)), pullRequestId: \(String(describing: pullRequestId)))"}
}

extension DescribePullRequestEventsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actorArn
        case maxResults
        case nextToken
        case pullRequestEventType
        case pullRequestId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actorArn = actorArn {
            try encodeContainer.encode(actorArn, forKey: .actorArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pullRequestEventType = pullRequestEventType {
            try encodeContainer.encode(pullRequestEventType.rawValue, forKey: .pullRequestEventType)
        }
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
    }
}

public struct DescribePullRequestEventsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePullRequestEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePullRequestEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePullRequestEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePullRequestEventsInput>
    public typealias MOutput = OperationOutput<DescribePullRequestEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePullRequestEventsOutputError>
}

public struct DescribePullRequestEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePullRequestEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePullRequestEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePullRequestEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePullRequestEventsInput>
    public typealias MOutput = OperationOutput<DescribePullRequestEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePullRequestEventsOutputError>
}

public struct DescribePullRequestEventsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the user whose actions resulted in the event.
    ///             Examples include updating the pull request with more commits or changing the status of a
    ///             pull request.</p>
    public let actorArn: String?
    /// <p>A non-zero, non-negative integer used to limit the number of returned results.
    ///             The default is 100 events, which is also the maximum number of events that can be returned in a result.</p>
    public let maxResults: Int?
    /// <p>An enumeration token that, when provided in a request, returns the next batch of the
    ///             results.</p>
    public let nextToken: String?
    /// <p>Optional. The pull request event type about which you want to return information.</p>
    public let pullRequestEventType: PullRequestEventType?
    /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
    public let pullRequestId: String?

    public init (
        actorArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        pullRequestEventType: PullRequestEventType? = nil,
        pullRequestId: String? = nil
    )
    {
        self.actorArn = actorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pullRequestEventType = pullRequestEventType
        self.pullRequestId = pullRequestId
    }
}

struct DescribePullRequestEventsInputBody: Equatable {
    public let pullRequestId: String?
    public let pullRequestEventType: PullRequestEventType?
    public let actorArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribePullRequestEventsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actorArn
        case maxResults
        case nextToken
        case pullRequestEventType
        case pullRequestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let pullRequestEventTypeDecoded = try containerValues.decodeIfPresent(PullRequestEventType.self, forKey: .pullRequestEventType)
        pullRequestEventType = pullRequestEventTypeDecoded
        let actorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actorArn)
        actorArn = actorArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribePullRequestEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePullRequestEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ActorDoesNotExistException" : self = .actorDoesNotExistException(try ActorDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidActorArnException" : self = .invalidActorArnException(try InvalidActorArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestEventTypeException" : self = .invalidPullRequestEventTypeException(try InvalidPullRequestEventTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePullRequestEventsOutputError: Equatable {
    case actorDoesNotExistException(ActorDoesNotExistException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidActorArnException(InvalidActorArnException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidPullRequestEventTypeException(InvalidPullRequestEventTypeException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePullRequestEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePullRequestEventsOutputResponse(nextToken: \(String(describing: nextToken)), pullRequestEvents: \(String(describing: pullRequestEvents)))"}
}

extension DescribePullRequestEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePullRequestEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.pullRequestEvents = output.pullRequestEvents
        } else {
            self.nextToken = nil
            self.pullRequestEvents = nil
        }
    }
}

public struct DescribePullRequestEventsOutputResponse: Equatable {
    /// <p>An enumeration token that can be used in a request to return the next batch of the results.</p>
    public let nextToken: String?
    /// <p>Information about the pull request events.</p>
    public let pullRequestEvents: [PullRequestEvent]?

    public init (
        nextToken: String? = nil,
        pullRequestEvents: [PullRequestEvent]? = nil
    )
    {
        self.nextToken = nextToken
        self.pullRequestEvents = pullRequestEvents
    }
}

struct DescribePullRequestEventsOutputResponseBody: Equatable {
    public let pullRequestEvents: [PullRequestEvent]?
    public let nextToken: String?
}

extension DescribePullRequestEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case pullRequestEvents
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestEventsContainer = try containerValues.decodeIfPresent([PullRequestEvent?].self, forKey: .pullRequestEvents)
        var pullRequestEventsDecoded0:[PullRequestEvent]? = nil
        if let pullRequestEventsContainer = pullRequestEventsContainer {
            pullRequestEventsDecoded0 = [PullRequestEvent]()
            for structure0 in pullRequestEventsContainer {
                if let structure0 = structure0 {
                    pullRequestEventsDecoded0?.append(structure0)
                }
            }
        }
        pullRequestEvents = pullRequestEventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension Difference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case afterBlob
        case beforeBlob
        case changeType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterBlob = afterBlob {
            try encodeContainer.encode(afterBlob, forKey: .afterBlob)
        }
        if let beforeBlob = beforeBlob {
            try encodeContainer.encode(beforeBlob, forKey: .beforeBlob)
        }
        if let changeType = changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beforeBlobDecoded = try containerValues.decodeIfPresent(BlobMetadata.self, forKey: .beforeBlob)
        beforeBlob = beforeBlobDecoded
        let afterBlobDecoded = try containerValues.decodeIfPresent(BlobMetadata.self, forKey: .afterBlob)
        afterBlob = afterBlobDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(ChangeTypeEnum.self, forKey: .changeType)
        changeType = changeTypeDecoded
    }
}

extension Difference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Difference(afterBlob: \(String(describing: afterBlob)), beforeBlob: \(String(describing: beforeBlob)), changeType: \(String(describing: changeType)))"}
}

/// <p>Returns information about a set of differences for a commit specifier.</p>
public struct Difference: Equatable {
    /// <p>Information about an <code>afterBlob</code> data type object, including the ID,
    ///             the file mode permission code, and the path.</p>
    public let afterBlob: BlobMetadata?
    /// <p>Information about a <code>beforeBlob</code> data type object, including the ID,
    ///             the file mode permission code, and the path.</p>
    public let beforeBlob: BlobMetadata?
    /// <p>Whether the change type of the difference is an addition (A), deletion (D), or modification (M).</p>
    public let changeType: ChangeTypeEnum?

    public init (
        afterBlob: BlobMetadata? = nil,
        beforeBlob: BlobMetadata? = nil,
        changeType: ChangeTypeEnum? = nil
    )
    {
        self.afterBlob = afterBlob
        self.beforeBlob = beforeBlob
        self.changeType = changeType
    }
}

extension DirectoryNameConflictsWithFileNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryNameConflictsWithFileNameException(message: \(String(describing: message)))"}
}

extension DirectoryNameConflictsWithFileNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DirectoryNameConflictsWithFileNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A file cannot be added to the repository because the specified path name has the same name as a file that already exists in this repository.
///         Either provide a different name for the file, or specify a different path for the file.</p>
public struct DirectoryNameConflictsWithFileNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryNameConflictsWithFileNameExceptionBody: Equatable {
    public let message: String?
}

extension DirectoryNameConflictsWithFileNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DisassociateApprovalRuleTemplateFromRepositoryInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateApprovalRuleTemplateFromRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateApprovalRuleTemplateFromRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateApprovalRuleTemplateFromRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateApprovalRuleTemplateFromRepositoryInput>
    public typealias MOutput = OperationOutput<DisassociateApprovalRuleTemplateFromRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateApprovalRuleTemplateFromRepositoryOutputError>
}

extension DisassociateApprovalRuleTemplateFromRepositoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateApprovalRuleTemplateFromRepositoryInput(approvalRuleTemplateName: \(String(describing: approvalRuleTemplateName)), repositoryName: \(String(describing: repositoryName)))"}
}

extension DisassociateApprovalRuleTemplateFromRepositoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateName
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DisassociateApprovalRuleTemplateFromRepositoryInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateApprovalRuleTemplateFromRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateApprovalRuleTemplateFromRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateApprovalRuleTemplateFromRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateApprovalRuleTemplateFromRepositoryInput>
    public typealias MOutput = OperationOutput<DisassociateApprovalRuleTemplateFromRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateApprovalRuleTemplateFromRepositoryOutputError>
}

public struct DisassociateApprovalRuleTemplateFromRepositoryInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateApprovalRuleTemplateFromRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateApprovalRuleTemplateFromRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateApprovalRuleTemplateFromRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateApprovalRuleTemplateFromRepositoryInput>
    public typealias MOutput = OperationOutput<DisassociateApprovalRuleTemplateFromRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateApprovalRuleTemplateFromRepositoryOutputError>
}

public struct DisassociateApprovalRuleTemplateFromRepositoryInput: Equatable {
    /// <p>The name of the approval rule template to disassociate from a specified repository.</p>
    public let approvalRuleTemplateName: String?
    /// <p>The name of the repository you want to disassociate from the template.</p>
    public let repositoryName: String?

    public init (
        approvalRuleTemplateName: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.repositoryName = repositoryName
    }
}

struct DisassociateApprovalRuleTemplateFromRepositoryInputBody: Equatable {
    public let approvalRuleTemplateName: String?
    public let repositoryName: String?
}

extension DisassociateApprovalRuleTemplateFromRepositoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateName
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension DisassociateApprovalRuleTemplateFromRepositoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateApprovalRuleTemplateFromRepositoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateDoesNotExistException" : self = .approvalRuleTemplateDoesNotExistException(try ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateApprovalRuleTemplateFromRepositoryOutputError: Equatable {
    case approvalRuleTemplateDoesNotExistException(ApprovalRuleTemplateDoesNotExistException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateApprovalRuleTemplateFromRepositoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateApprovalRuleTemplateFromRepositoryOutputResponse()"}
}

extension DisassociateApprovalRuleTemplateFromRepositoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateApprovalRuleTemplateFromRepositoryOutputResponse: Equatable {

    public init() {}
}

struct DisassociateApprovalRuleTemplateFromRepositoryOutputResponseBody: Equatable {
}

extension DisassociateApprovalRuleTemplateFromRepositoryOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EncryptionIntegrityChecksFailedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionIntegrityChecksFailedException(message: \(String(describing: message)))"}
}

extension EncryptionIntegrityChecksFailedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EncryptionIntegrityChecksFailedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An encryption integrity check failed.</p>
public struct EncryptionIntegrityChecksFailedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EncryptionIntegrityChecksFailedExceptionBody: Equatable {
    public let message: String?
}

extension EncryptionIntegrityChecksFailedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EncryptionKeyAccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionKeyAccessDeniedException(message: \(String(describing: message)))"}
}

extension EncryptionKeyAccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EncryptionKeyAccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An encryption key could not be accessed.</p>
public struct EncryptionKeyAccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EncryptionKeyAccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension EncryptionKeyAccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EncryptionKeyDisabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionKeyDisabledException(message: \(String(describing: message)))"}
}

extension EncryptionKeyDisabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EncryptionKeyDisabledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The encryption key is disabled.</p>
public struct EncryptionKeyDisabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EncryptionKeyDisabledExceptionBody: Equatable {
    public let message: String?
}

extension EncryptionKeyDisabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EncryptionKeyNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionKeyNotFoundException(message: \(String(describing: message)))"}
}

extension EncryptionKeyNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EncryptionKeyNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No encryption key was found.</p>
public struct EncryptionKeyNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EncryptionKeyNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension EncryptionKeyNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EncryptionKeyUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionKeyUnavailableException(message: \(String(describing: message)))"}
}

extension EncryptionKeyUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EncryptionKeyUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The encryption key is not available.</p>
public struct EncryptionKeyUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EncryptionKeyUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension EncryptionKeyUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct EvaluatePullRequestApprovalRulesInputBodyMiddleware: Middleware {
    public let id: String = "EvaluatePullRequestApprovalRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EvaluatePullRequestApprovalRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<EvaluatePullRequestApprovalRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EvaluatePullRequestApprovalRulesInput>
    public typealias MOutput = OperationOutput<EvaluatePullRequestApprovalRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EvaluatePullRequestApprovalRulesOutputError>
}

extension EvaluatePullRequestApprovalRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EvaluatePullRequestApprovalRulesInput(pullRequestId: \(String(describing: pullRequestId)), revisionId: \(String(describing: revisionId)))"}
}

extension EvaluatePullRequestApprovalRulesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pullRequestId
        case revisionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

public struct EvaluatePullRequestApprovalRulesInputHeadersMiddleware: Middleware {
    public let id: String = "EvaluatePullRequestApprovalRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EvaluatePullRequestApprovalRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<EvaluatePullRequestApprovalRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EvaluatePullRequestApprovalRulesInput>
    public typealias MOutput = OperationOutput<EvaluatePullRequestApprovalRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EvaluatePullRequestApprovalRulesOutputError>
}

public struct EvaluatePullRequestApprovalRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "EvaluatePullRequestApprovalRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EvaluatePullRequestApprovalRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<EvaluatePullRequestApprovalRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EvaluatePullRequestApprovalRulesInput>
    public typealias MOutput = OperationOutput<EvaluatePullRequestApprovalRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EvaluatePullRequestApprovalRulesOutputError>
}

public struct EvaluatePullRequestApprovalRulesInput: Equatable {
    /// <p>The system-generated ID of the pull request you want to evaluate.</p>
    public let pullRequestId: String?
    /// <p>The system-generated ID for the pull request revision. To retrieve the most recent
    ///             revision ID for a pull request, use
    ///             <a>GetPullRequest</a>.</p>
    public let revisionId: String?

    public init (
        pullRequestId: String? = nil,
        revisionId: String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

struct EvaluatePullRequestApprovalRulesInputBody: Equatable {
    public let pullRequestId: String?
    public let revisionId: String?
}

extension EvaluatePullRequestApprovalRulesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pullRequestId
        case revisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension EvaluatePullRequestApprovalRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EvaluatePullRequestApprovalRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRevisionIdException" : self = .invalidRevisionIdException(try InvalidRevisionIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RevisionIdRequiredException" : self = .revisionIdRequiredException(try RevisionIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RevisionNotCurrentException" : self = .revisionNotCurrentException(try RevisionNotCurrentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EvaluatePullRequestApprovalRulesOutputError: Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidRevisionIdException(InvalidRevisionIdException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case revisionIdRequiredException(RevisionIdRequiredException)
    case revisionNotCurrentException(RevisionNotCurrentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EvaluatePullRequestApprovalRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EvaluatePullRequestApprovalRulesOutputResponse(evaluation: \(String(describing: evaluation)))"}
}

extension EvaluatePullRequestApprovalRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EvaluatePullRequestApprovalRulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.evaluation = output.evaluation
        } else {
            self.evaluation = nil
        }
    }
}

public struct EvaluatePullRequestApprovalRulesOutputResponse: Equatable {
    /// <p>The result of the evaluation, including the names of the rules whose conditions have been met (if any), the names of the rules whose conditions have
    ///         not been met (if any), whether the pull request is in the approved state, and whether the pull request approval rule has been set aside by an override. </p>
    public let evaluation: Evaluation?

    public init (
        evaluation: Evaluation? = nil
    )
    {
        self.evaluation = evaluation
    }
}

struct EvaluatePullRequestApprovalRulesOutputResponseBody: Equatable {
    public let evaluation: Evaluation?
}

extension EvaluatePullRequestApprovalRulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case evaluation
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evaluationDecoded = try containerValues.decodeIfPresent(Evaluation.self, forKey: .evaluation)
        evaluation = evaluationDecoded
    }
}

extension Evaluation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRulesNotSatisfied
        case approvalRulesSatisfied
        case approved
        case overridden
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRulesNotSatisfied = approvalRulesNotSatisfied {
            var approvalRulesNotSatisfiedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvalRulesNotSatisfied)
            for approvalrulesnotsatisfiedlist0 in approvalRulesNotSatisfied {
                try approvalRulesNotSatisfiedContainer.encode(approvalrulesnotsatisfiedlist0)
            }
        }
        if let approvalRulesSatisfied = approvalRulesSatisfied {
            var approvalRulesSatisfiedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvalRulesSatisfied)
            for approvalrulessatisfiedlist0 in approvalRulesSatisfied {
                try approvalRulesSatisfiedContainer.encode(approvalrulessatisfiedlist0)
            }
        }
        if approved != false {
            try encodeContainer.encode(approved, forKey: .approved)
        }
        if overridden != false {
            try encodeContainer.encode(overridden, forKey: .overridden)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvedDecoded = try containerValues.decode(Bool.self, forKey: .approved)
        approved = approvedDecoded
        let overriddenDecoded = try containerValues.decode(Bool.self, forKey: .overridden)
        overridden = overriddenDecoded
        let approvalRulesSatisfiedContainer = try containerValues.decodeIfPresent([String?].self, forKey: .approvalRulesSatisfied)
        var approvalRulesSatisfiedDecoded0:[String]? = nil
        if let approvalRulesSatisfiedContainer = approvalRulesSatisfiedContainer {
            approvalRulesSatisfiedDecoded0 = [String]()
            for string0 in approvalRulesSatisfiedContainer {
                if let string0 = string0 {
                    approvalRulesSatisfiedDecoded0?.append(string0)
                }
            }
        }
        approvalRulesSatisfied = approvalRulesSatisfiedDecoded0
        let approvalRulesNotSatisfiedContainer = try containerValues.decodeIfPresent([String?].self, forKey: .approvalRulesNotSatisfied)
        var approvalRulesNotSatisfiedDecoded0:[String]? = nil
        if let approvalRulesNotSatisfiedContainer = approvalRulesNotSatisfiedContainer {
            approvalRulesNotSatisfiedDecoded0 = [String]()
            for string0 in approvalRulesNotSatisfiedContainer {
                if let string0 = string0 {
                    approvalRulesNotSatisfiedDecoded0?.append(string0)
                }
            }
        }
        approvalRulesNotSatisfied = approvalRulesNotSatisfiedDecoded0
    }
}

extension Evaluation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Evaluation(approvalRulesNotSatisfied: \(String(describing: approvalRulesNotSatisfied)), approvalRulesSatisfied: \(String(describing: approvalRulesSatisfied)), approved: \(String(describing: approved)), overridden: \(String(describing: overridden)))"}
}

/// <p>Returns information about the approval rules applied to a pull request and whether conditions have been met.</p>
public struct Evaluation: Equatable {
    /// <p>The names of the approval rules that have not had their conditions met.</p>
    public let approvalRulesNotSatisfied: [String]?
    /// <p>The names of the approval rules that have had their conditions met.</p>
    public let approvalRulesSatisfied: [String]?
    /// <p>Whether the state of the pull request is approved.</p>
    public let approved: Bool
    /// <p>Whether the approval rule requirements for the pull request have been overridden and no longer need to be met.</p>
    public let overridden: Bool

    public init (
        approvalRulesNotSatisfied: [String]? = nil,
        approvalRulesSatisfied: [String]? = nil,
        approved: Bool = false,
        overridden: Bool = false
    )
    {
        self.approvalRulesNotSatisfied = approvalRulesNotSatisfied
        self.approvalRulesSatisfied = approvalRulesSatisfied
        self.approved = approved
        self.overridden = overridden
    }
}

extension File: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case absolutePath
        case blobId
        case fileMode
        case relativePath
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absolutePath = absolutePath {
            try encodeContainer.encode(absolutePath, forKey: .absolutePath)
        }
        if let blobId = blobId {
            try encodeContainer.encode(blobId, forKey: .blobId)
        }
        if let fileMode = fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
        if let relativePath = relativePath {
            try encodeContainer.encode(relativePath, forKey: .relativePath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let absolutePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .absolutePath)
        absolutePath = absolutePathDecoded
        let relativePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .relativePath)
        relativePath = relativePathDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
    }
}

extension File: CustomDebugStringConvertible {
    public var debugDescription: String {
        "File(absolutePath: \(String(describing: absolutePath)), blobId: \(String(describing: blobId)), fileMode: \(String(describing: fileMode)), relativePath: \(String(describing: relativePath)))"}
}

/// <p>Returns information about a file in a repository.</p>
public struct File: Equatable {
    /// <p>The fully qualified path to the file in the repository.</p>
    public let absolutePath: String?
    /// <p>The blob ID that contains the file information.</p>
    public let blobId: String?
    /// <p>The extrapolated file mode permissions for the file. Valid values include EXECUTABLE and NORMAL.</p>
    public let fileMode: FileModeTypeEnum?
    /// <p>The relative path of the file from the folder where the query originated.</p>
    public let relativePath: String?

    public init (
        absolutePath: String? = nil,
        blobId: String? = nil,
        fileMode: FileModeTypeEnum? = nil,
        relativePath: String? = nil
    )
    {
        self.absolutePath = absolutePath
        self.blobId = blobId
        self.fileMode = fileMode
        self.relativePath = relativePath
    }
}

extension FileContentAndSourceFileSpecifiedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileContentAndSourceFileSpecifiedException(message: \(String(describing: message)))"}
}

extension FileContentAndSourceFileSpecifiedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FileContentAndSourceFileSpecifiedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The commit cannot be created because both a source file and file content have been
///             specified for the same file. You cannot provide both. Either specify a source file or
///             provide the file content directly.</p>
public struct FileContentAndSourceFileSpecifiedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FileContentAndSourceFileSpecifiedExceptionBody: Equatable {
    public let message: String?
}

extension FileContentAndSourceFileSpecifiedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileContentRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileContentRequiredException(message: \(String(describing: message)))"}
}

extension FileContentRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FileContentRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The file cannot be added because it is empty. Empty files cannot be added to the repository with this API.</p>
public struct FileContentRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FileContentRequiredExceptionBody: Equatable {
    public let message: String?
}

extension FileContentRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileContentSizeLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileContentSizeLimitExceededException(message: \(String(describing: message)))"}
}

extension FileContentSizeLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FileContentSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and
///             the combined file content change size is 7 MB. Consider making these changes using a Git
///             client.</p>
public struct FileContentSizeLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FileContentSizeLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension FileContentSizeLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileDoesNotExistException(message: \(String(describing: message)))"}
}

extension FileDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FileDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified file does not exist. Verify that you have used the correct file name,
///             full path, and extension.</p>
public struct FileDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FileDoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension FileDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileEntryRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileEntryRequiredException(message: \(String(describing: message)))"}
}

extension FileEntryRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FileEntryRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The commit cannot be created because no files have been specified as added, updated, or changed (PutFile or DeleteFile) for the commit.</p>
public struct FileEntryRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FileEntryRequiredExceptionBody: Equatable {
    public let message: String?
}

extension FileEntryRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case absolutePath
        case blobId
        case fileMode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absolutePath = absolutePath {
            try encodeContainer.encode(absolutePath, forKey: .absolutePath)
        }
        if let blobId = blobId {
            try encodeContainer.encode(blobId, forKey: .blobId)
        }
        if let fileMode = fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let absolutePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .absolutePath)
        absolutePath = absolutePathDecoded
        let blobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
    }
}

extension FileMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileMetadata(absolutePath: \(String(describing: absolutePath)), blobId: \(String(describing: blobId)), fileMode: \(String(describing: fileMode)))"}
}

/// <p>A file to be added, updated, or deleted as part of a commit.</p>
public struct FileMetadata: Equatable {
    /// <p>The full path to the file to be added or updated, including the name of the
    ///             file.</p>
    public let absolutePath: String?
    /// <p>The blob ID that contains the file information.</p>
    public let blobId: String?
    /// <p>The extrapolated file mode permissions for the file. Valid values include EXECUTABLE and NORMAL.</p>
    public let fileMode: FileModeTypeEnum?

    public init (
        absolutePath: String? = nil,
        blobId: String? = nil,
        fileMode: FileModeTypeEnum? = nil
    )
    {
        self.absolutePath = absolutePath
        self.blobId = blobId
        self.fileMode = fileMode
    }
}

extension FileModeRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileModeRequiredException(message: \(String(describing: message)))"}
}

extension FileModeRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FileModeRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The commit cannot be created because no file mode has been specified. A file mode is
///             required to update mode permissions for a file.</p>
public struct FileModeRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FileModeRequiredExceptionBody: Equatable {
    public let message: String?
}

extension FileModeRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum FileModeTypeEnum {
    case executable
    case normal
    case symlink
    case sdkUnknown(String)
}

extension FileModeTypeEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FileModeTypeEnum] {
        return [
            .executable,
            .normal,
            .symlink,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .executable: return "EXECUTABLE"
        case .normal: return "NORMAL"
        case .symlink: return "SYMLINK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FileModeTypeEnum(rawValue: rawValue) ?? FileModeTypeEnum.sdkUnknown(rawValue)
    }
}

extension FileModes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case base
        case destination
        case source
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let base = base {
            try encodeContainer.encode(base.rawValue, forKey: .base)
        }
        if let destination = destination {
            try encodeContainer.encode(destination.rawValue, forKey: .destination)
        }
        if let source = source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(FileModeTypeEnum.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(FileModeTypeEnum.self, forKey: .destination)
        destination = destinationDecoded
        let baseDecoded = try containerValues.decodeIfPresent(FileModeTypeEnum.self, forKey: .base)
        base = baseDecoded
    }
}

extension FileModes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileModes(base: \(String(describing: base)), destination: \(String(describing: destination)), source: \(String(describing: source)))"}
}

/// <p>Information about file modes in a merge or pull request.</p>
public struct FileModes: Equatable {
    /// <p>The file mode of a file in the base of a merge or pull request.</p>
    public let base: FileModeTypeEnum?
    /// <p>The file mode of a file in the destination of a merge or pull request.</p>
    public let destination: FileModeTypeEnum?
    /// <p>The file mode of a file in the source of a merge or pull request.</p>
    public let source: FileModeTypeEnum?

    public init (
        base: FileModeTypeEnum? = nil,
        destination: FileModeTypeEnum? = nil,
        source: FileModeTypeEnum? = nil
    )
    {
        self.base = base
        self.destination = destination
        self.source = source
    }
}

extension FileNameConflictsWithDirectoryNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileNameConflictsWithDirectoryNameException(message: \(String(describing: message)))"}
}

extension FileNameConflictsWithDirectoryNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FileNameConflictsWithDirectoryNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A file cannot be added to the repository because the specified file name has the same name as a directory in this repository. Either provide
///         another name for the file, or add the file in a directory that does not match the file name.</p>
public struct FileNameConflictsWithDirectoryNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FileNameConflictsWithDirectoryNameExceptionBody: Equatable {
    public let message: String?
}

extension FileNameConflictsWithDirectoryNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FilePathConflictsWithSubmodulePathException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FilePathConflictsWithSubmodulePathException(message: \(String(describing: message)))"}
}

extension FilePathConflictsWithSubmodulePathException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FilePathConflictsWithSubmodulePathExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The commit cannot be created because a specified file path points to a submodule. Verify that the destination files
///         have valid file paths that do not point to a submodule.</p>
public struct FilePathConflictsWithSubmodulePathException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FilePathConflictsWithSubmodulePathExceptionBody: Equatable {
    public let message: String?
}

extension FilePathConflictsWithSubmodulePathExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileSizes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case base
        case destination
        case source
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if base != 0 {
            try encodeContainer.encode(base, forKey: .base)
        }
        if destination != 0 {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if source != 0 {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decode(Int.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decode(Int.self, forKey: .destination)
        destination = destinationDecoded
        let baseDecoded = try containerValues.decode(Int.self, forKey: .base)
        base = baseDecoded
    }
}

extension FileSizes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileSizes(base: \(String(describing: base)), destination: \(String(describing: destination)), source: \(String(describing: source)))"}
}

/// <p>Information about the size of files in a merge or pull request.</p>
public struct FileSizes: Equatable {
    /// <p>The size of a file in the base of a merge or pull request.</p>
    public let base: Int
    /// <p>The size of a file in the destination of a merge or pull request.</p>
    public let destination: Int
    /// <p>The  size of a file in the source of a merge or pull request.</p>
    public let source: Int

    public init (
        base: Int = 0,
        destination: Int = 0,
        source: Int = 0
    )
    {
        self.base = base
        self.destination = destination
        self.source = source
    }
}

extension FileTooLargeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileTooLargeException(message: \(String(describing: message)))"}
}

extension FileTooLargeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FileTooLargeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified file exceeds the file size limit for AWS CodeCommit. For more information about limits in AWS CodeCommit, see
///             <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
public struct FileTooLargeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FileTooLargeExceptionBody: Equatable {
    public let message: String?
}

extension FileTooLargeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Folder: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case absolutePath
        case relativePath
        case treeId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absolutePath = absolutePath {
            try encodeContainer.encode(absolutePath, forKey: .absolutePath)
        }
        if let relativePath = relativePath {
            try encodeContainer.encode(relativePath, forKey: .relativePath)
        }
        if let treeId = treeId {
            try encodeContainer.encode(treeId, forKey: .treeId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let treeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treeId)
        treeId = treeIdDecoded
        let absolutePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .absolutePath)
        absolutePath = absolutePathDecoded
        let relativePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .relativePath)
        relativePath = relativePathDecoded
    }
}

extension Folder: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Folder(absolutePath: \(String(describing: absolutePath)), relativePath: \(String(describing: relativePath)), treeId: \(String(describing: treeId)))"}
}

/// <p>Returns information about a folder in a repository.</p>
public struct Folder: Equatable {
    /// <p>The fully qualified path of the folder in the repository.</p>
    public let absolutePath: String?
    /// <p>The relative path of the specified folder from the folder where the query originated.</p>
    public let relativePath: String?
    /// <p>The full SHA-1 pointer of the tree information for the commit that contains the folder.</p>
    public let treeId: String?

    public init (
        absolutePath: String? = nil,
        relativePath: String? = nil,
        treeId: String? = nil
    )
    {
        self.absolutePath = absolutePath
        self.relativePath = relativePath
        self.treeId = treeId
    }
}

extension FolderContentSizeLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FolderContentSizeLimitExceededException(message: \(String(describing: message)))"}
}

extension FolderContentSizeLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FolderContentSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The commit cannot be created because at least one of the overall changes in the commit results in a
///             folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes,
///         or split the changes across multiple folders.</p>
public struct FolderContentSizeLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FolderContentSizeLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension FolderContentSizeLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FolderDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FolderDoesNotExistException(message: \(String(describing: message)))"}
}

extension FolderDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: FolderDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified folder does not exist. Either the folder name is not correct, or you did
///             not enter the full path to the folder.</p>
public struct FolderDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FolderDoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension FolderDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetApprovalRuleTemplateInputBodyMiddleware: Middleware {
    public let id: String = "GetApprovalRuleTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApprovalRuleTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApprovalRuleTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApprovalRuleTemplateInput>
    public typealias MOutput = OperationOutput<GetApprovalRuleTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApprovalRuleTemplateOutputError>
}

extension GetApprovalRuleTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApprovalRuleTemplateInput(approvalRuleTemplateName: \(String(describing: approvalRuleTemplateName)))"}
}

extension GetApprovalRuleTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
    }
}

public struct GetApprovalRuleTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetApprovalRuleTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApprovalRuleTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApprovalRuleTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApprovalRuleTemplateInput>
    public typealias MOutput = OperationOutput<GetApprovalRuleTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApprovalRuleTemplateOutputError>
}

public struct GetApprovalRuleTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetApprovalRuleTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApprovalRuleTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApprovalRuleTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApprovalRuleTemplateInput>
    public typealias MOutput = OperationOutput<GetApprovalRuleTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApprovalRuleTemplateOutputError>
}

public struct GetApprovalRuleTemplateInput: Equatable {
    /// <p>The name of the approval rule template for which you want to get information.</p>
    public let approvalRuleTemplateName: String?

    public init (
        approvalRuleTemplateName: String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
    }
}

struct GetApprovalRuleTemplateInputBody: Equatable {
    public let approvalRuleTemplateName: String?
}

extension GetApprovalRuleTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
    }
}

extension GetApprovalRuleTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApprovalRuleTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateDoesNotExistException" : self = .approvalRuleTemplateDoesNotExistException(try ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApprovalRuleTemplateOutputError: Equatable {
    case approvalRuleTemplateDoesNotExistException(ApprovalRuleTemplateDoesNotExistException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApprovalRuleTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApprovalRuleTemplateOutputResponse(approvalRuleTemplate: \(String(describing: approvalRuleTemplate)))"}
}

extension GetApprovalRuleTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetApprovalRuleTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.approvalRuleTemplate = output.approvalRuleTemplate
        } else {
            self.approvalRuleTemplate = nil
        }
    }
}

public struct GetApprovalRuleTemplateOutputResponse: Equatable {
    /// <p>The content and structure of the approval rule template.</p>
    public let approvalRuleTemplate: ApprovalRuleTemplate?

    public init (
        approvalRuleTemplate: ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

struct GetApprovalRuleTemplateOutputResponseBody: Equatable {
    public let approvalRuleTemplate: ApprovalRuleTemplate?
}

extension GetApprovalRuleTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateDecoded = try containerValues.decodeIfPresent(ApprovalRuleTemplate.self, forKey: .approvalRuleTemplate)
        approvalRuleTemplate = approvalRuleTemplateDecoded
    }
}

public struct GetBlobInputBodyMiddleware: Middleware {
    public let id: String = "GetBlobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBlobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBlobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBlobInput>
    public typealias MOutput = OperationOutput<GetBlobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBlobOutputError>
}

extension GetBlobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBlobInput(blobId: \(String(describing: blobId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension GetBlobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blobId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blobId = blobId {
            try encodeContainer.encode(blobId, forKey: .blobId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetBlobInputHeadersMiddleware: Middleware {
    public let id: String = "GetBlobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBlobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBlobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBlobInput>
    public typealias MOutput = OperationOutput<GetBlobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBlobOutputError>
}

public struct GetBlobInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBlobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBlobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBlobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBlobInput>
    public typealias MOutput = OperationOutput<GetBlobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBlobOutputError>
}

/// <p>Represents the input of a get blob operation.</p>
public struct GetBlobInput: Equatable {
    /// <p>The ID of the blob, which is its SHA-1 pointer.</p>
    public let blobId: String?
    /// <p>The name of the repository that contains the blob.</p>
    public let repositoryName: String?

    public init (
        blobId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.blobId = blobId
        self.repositoryName = repositoryName
    }
}

struct GetBlobInputBody: Equatable {
    public let repositoryName: String?
    public let blobId: String?
}

extension GetBlobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case blobId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let blobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .blobId)
        blobId = blobIdDecoded
    }
}

extension GetBlobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBlobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BlobIdDoesNotExistException" : self = .blobIdDoesNotExistException(try BlobIdDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BlobIdRequiredException" : self = .blobIdRequiredException(try BlobIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileTooLargeException" : self = .fileTooLargeException(try FileTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBlobIdException" : self = .invalidBlobIdException(try InvalidBlobIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBlobOutputError: Equatable {
    case blobIdDoesNotExistException(BlobIdDoesNotExistException)
    case blobIdRequiredException(BlobIdRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileTooLargeException(FileTooLargeException)
    case invalidBlobIdException(InvalidBlobIdException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBlobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBlobOutputResponse(content: \(String(describing: content)))"}
}

extension GetBlobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBlobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.content = output.content
        } else {
            self.content = nil
        }
    }
}

/// <p>Represents the output of a get blob operation.</p>
public struct GetBlobOutputResponse: Equatable {
    /// <p>The content of the blob, usually a file.</p>
    public let content: Data?

    public init (
        content: Data? = nil
    )
    {
        self.content = content
    }
}

struct GetBlobOutputResponseBody: Equatable {
    public let content: Data?
}

extension GetBlobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case content
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .content)
        content = contentDecoded
    }
}

public struct GetBranchInputBodyMiddleware: Middleware {
    public let id: String = "GetBranchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBranchInput>
    public typealias MOutput = OperationOutput<GetBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBranchOutputError>
}

extension GetBranchInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBranchInput(branchName: \(String(describing: branchName)), repositoryName: \(String(describing: repositoryName)))"}
}

extension GetBranchInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branchName
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetBranchInputHeadersMiddleware: Middleware {
    public let id: String = "GetBranchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBranchInput>
    public typealias MOutput = OperationOutput<GetBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBranchOutputError>
}

public struct GetBranchInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBranchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBranchInput>
    public typealias MOutput = OperationOutput<GetBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBranchOutputError>
}

/// <p>Represents the input of a get branch operation.</p>
public struct GetBranchInput: Equatable {
    /// <p>The name of the branch for which you want to retrieve information.</p>
    public let branchName: String?
    /// <p>The name of the repository that contains the branch for which you want to retrieve information.</p>
    public let repositoryName: String?

    public init (
        branchName: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.branchName = branchName
        self.repositoryName = repositoryName
    }
}

struct GetBranchInputBody: Equatable {
    public let repositoryName: String?
    public let branchName: String?
}

extension GetBranchInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case branchName
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchName)
        branchName = branchNameDecoded
    }
}

extension GetBranchOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBranchOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BranchDoesNotExistException" : self = .branchDoesNotExistException(try BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBranchOutputError: Equatable {
    case branchDoesNotExistException(BranchDoesNotExistException)
    case branchNameRequiredException(BranchNameRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBranchOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBranchOutputResponse(branch: \(String(describing: branch)))"}
}

extension GetBranchOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetBranchOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.branch = output.branch
        } else {
            self.branch = nil
        }
    }
}

/// <p>Represents the output of a get branch operation.</p>
public struct GetBranchOutputResponse: Equatable {
    /// <p>The name of the branch.</p>
    public let branch: BranchInfo?

    public init (
        branch: BranchInfo? = nil
    )
    {
        self.branch = branch
    }
}

struct GetBranchOutputResponseBody: Equatable {
    public let branch: BranchInfo?
}

extension GetBranchOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case branch
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchDecoded = try containerValues.decodeIfPresent(BranchInfo.self, forKey: .branch)
        branch = branchDecoded
    }
}

public struct GetCommentInputBodyMiddleware: Middleware {
    public let id: String = "GetCommentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCommentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCommentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCommentInput>
    public typealias MOutput = OperationOutput<GetCommentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCommentOutputError>
}

extension GetCommentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCommentInput(commentId: \(String(describing: commentId)))"}
}

extension GetCommentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commentId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
    }
}

public struct GetCommentInputHeadersMiddleware: Middleware {
    public let id: String = "GetCommentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCommentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCommentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCommentInput>
    public typealias MOutput = OperationOutput<GetCommentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCommentOutputError>
}

public struct GetCommentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCommentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCommentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCommentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCommentInput>
    public typealias MOutput = OperationOutput<GetCommentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCommentOutputError>
}

public struct GetCommentInput: Equatable {
    /// <p>The unique, system-generated ID of the comment. To get this ID, use  <a>GetCommentsForComparedCommit</a>
    ///             or <a>GetCommentsForPullRequest</a>.</p>
    public let commentId: String?

    public init (
        commentId: String? = nil
    )
    {
        self.commentId = commentId
    }
}

struct GetCommentInputBody: Equatable {
    public let commentId: String?
}

extension GetCommentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commentId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commentId)
        commentId = commentIdDecoded
    }
}

extension GetCommentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCommentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommentDeletedException" : self = .commentDeletedException(try CommentDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentDoesNotExistException" : self = .commentDoesNotExistException(try CommentDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentIdRequiredException" : self = .commentIdRequiredException(try CommentIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommentIdException" : self = .invalidCommentIdException(try InvalidCommentIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCommentOutputError: Equatable {
    case commentDeletedException(CommentDeletedException)
    case commentDoesNotExistException(CommentDoesNotExistException)
    case commentIdRequiredException(CommentIdRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommentIdException(InvalidCommentIdException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCommentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCommentOutputResponse(comment: \(String(describing: comment)))"}
}

extension GetCommentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCommentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.comment = output.comment
        } else {
            self.comment = nil
        }
    }
}

public struct GetCommentOutputResponse: Equatable {
    /// <p>The contents of the comment.</p>
    public let comment: Comment?

    public init (
        comment: Comment? = nil
    )
    {
        self.comment = comment
    }
}

struct GetCommentOutputResponseBody: Equatable {
    public let comment: Comment?
}

extension GetCommentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comment
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

public struct GetCommentReactionsInputBodyMiddleware: Middleware {
    public let id: String = "GetCommentReactionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCommentReactionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCommentReactionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCommentReactionsInput>
    public typealias MOutput = OperationOutput<GetCommentReactionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCommentReactionsOutputError>
}

extension GetCommentReactionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCommentReactionsInput(commentId: \(String(describing: commentId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), reactionUserArn: \(String(describing: reactionUserArn)))"}
}

extension GetCommentReactionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commentId
        case maxResults
        case nextToken
        case reactionUserArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let reactionUserArn = reactionUserArn {
            try encodeContainer.encode(reactionUserArn, forKey: .reactionUserArn)
        }
    }
}

public struct GetCommentReactionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetCommentReactionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCommentReactionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCommentReactionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCommentReactionsInput>
    public typealias MOutput = OperationOutput<GetCommentReactionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCommentReactionsOutputError>
}

public struct GetCommentReactionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCommentReactionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCommentReactionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCommentReactionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCommentReactionsInput>
    public typealias MOutput = OperationOutput<GetCommentReactionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCommentReactionsOutputError>
}

public struct GetCommentReactionsInput: Equatable {
    /// <p>The ID of the comment for which you want to get reactions information.</p>
    public let commentId: String?
    /// <p>A non-zero, non-negative integer used to limit the number of returned results.  The default is the same as the allowed maximum, 1,000.</p>
    public let maxResults: Int?
    /// <p>An enumeration token that, when provided in a request, returns the next batch of the results. </p>
    public let nextToken: String?
    /// <p>Optional. The Amazon Resource Name (ARN) of the user or identity for which you want to get reaction information.</p>
    public let reactionUserArn: String?

    public init (
        commentId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        reactionUserArn: String? = nil
    )
    {
        self.commentId = commentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reactionUserArn = reactionUserArn
    }
}

struct GetCommentReactionsInputBody: Equatable {
    public let commentId: String?
    public let reactionUserArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetCommentReactionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commentId
        case maxResults
        case nextToken
        case reactionUserArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commentId)
        commentId = commentIdDecoded
        let reactionUserArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reactionUserArn)
        reactionUserArn = reactionUserArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetCommentReactionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCommentReactionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommentDeletedException" : self = .commentDeletedException(try CommentDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentDoesNotExistException" : self = .commentDoesNotExistException(try CommentDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentIdRequiredException" : self = .commentIdRequiredException(try CommentIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommentIdException" : self = .invalidCommentIdException(try InvalidCommentIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReactionUserArnException" : self = .invalidReactionUserArnException(try InvalidReactionUserArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCommentReactionsOutputError: Equatable {
    case commentDeletedException(CommentDeletedException)
    case commentDoesNotExistException(CommentDoesNotExistException)
    case commentIdRequiredException(CommentIdRequiredException)
    case invalidCommentIdException(InvalidCommentIdException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidReactionUserArnException(InvalidReactionUserArnException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCommentReactionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCommentReactionsOutputResponse(nextToken: \(String(describing: nextToken)), reactionsForComment: \(String(describing: reactionsForComment)))"}
}

extension GetCommentReactionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCommentReactionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.reactionsForComment = output.reactionsForComment
        } else {
            self.nextToken = nil
            self.reactionsForComment = nil
        }
    }
}

public struct GetCommentReactionsOutputResponse: Equatable {
    /// <p>An enumeration token that can be used in a request to return the next batch of the results.</p>
    public let nextToken: String?
    /// <p>An array of reactions to the specified comment.</p>
    public let reactionsForComment: [ReactionForComment]?

    public init (
        nextToken: String? = nil,
        reactionsForComment: [ReactionForComment]? = nil
    )
    {
        self.nextToken = nextToken
        self.reactionsForComment = reactionsForComment
    }
}

struct GetCommentReactionsOutputResponseBody: Equatable {
    public let reactionsForComment: [ReactionForComment]?
    public let nextToken: String?
}

extension GetCommentReactionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case reactionsForComment
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reactionsForCommentContainer = try containerValues.decodeIfPresent([ReactionForComment?].self, forKey: .reactionsForComment)
        var reactionsForCommentDecoded0:[ReactionForComment]? = nil
        if let reactionsForCommentContainer = reactionsForCommentContainer {
            reactionsForCommentDecoded0 = [ReactionForComment]()
            for structure0 in reactionsForCommentContainer {
                if let structure0 = structure0 {
                    reactionsForCommentDecoded0?.append(structure0)
                }
            }
        }
        reactionsForComment = reactionsForCommentDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetCommentsForComparedCommitInputBodyMiddleware: Middleware {
    public let id: String = "GetCommentsForComparedCommitInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCommentsForComparedCommitInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCommentsForComparedCommitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCommentsForComparedCommitInput>
    public typealias MOutput = OperationOutput<GetCommentsForComparedCommitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCommentsForComparedCommitOutputError>
}

extension GetCommentsForComparedCommitInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCommentsForComparedCommitInput(afterCommitId: \(String(describing: afterCommitId)), beforeCommitId: \(String(describing: beforeCommitId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), repositoryName: \(String(describing: repositoryName)))"}
}

extension GetCommentsForComparedCommitInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case afterCommitId
        case beforeCommitId
        case maxResults
        case nextToken
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterCommitId = afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeCommitId = beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetCommentsForComparedCommitInputHeadersMiddleware: Middleware {
    public let id: String = "GetCommentsForComparedCommitInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCommentsForComparedCommitInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCommentsForComparedCommitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCommentsForComparedCommitInput>
    public typealias MOutput = OperationOutput<GetCommentsForComparedCommitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCommentsForComparedCommitOutputError>
}

public struct GetCommentsForComparedCommitInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCommentsForComparedCommitInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCommentsForComparedCommitInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCommentsForComparedCommitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCommentsForComparedCommitInput>
    public typealias MOutput = OperationOutput<GetCommentsForComparedCommitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCommentsForComparedCommitOutputError>
}

public struct GetCommentsForComparedCommitInput: Equatable {
    /// <p>To establish the directionality of the comparison, the full commit ID of the after
    ///             commit.</p>
    public let afterCommitId: String?
    /// <p>To establish the directionality of the comparison, the full commit ID of the before
    ///             commit.</p>
    public let beforeCommitId: String?
    /// <p>A non-zero, non-negative integer used to limit the number of returned results. The
    ///             default is 100 comments, but you can configure up to 500.</p>
    public let maxResults: Int?
    /// <p>An enumeration token that when provided in a request, returns the next batch of the results. </p>
    public let nextToken: String?
    /// <p>The name of the repository where you want to compare commits.</p>
    public let repositoryName: String?

    public init (
        afterCommitId: String? = nil,
        beforeCommitId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.afterCommitId = afterCommitId
        self.beforeCommitId = beforeCommitId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryName = repositoryName
    }
}

struct GetCommentsForComparedCommitInputBody: Equatable {
    public let repositoryName: String?
    public let beforeCommitId: String?
    public let afterCommitId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetCommentsForComparedCommitInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case afterCommitId
        case beforeCommitId
        case maxResults
        case nextToken
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetCommentsForComparedCommitOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCommentsForComparedCommitOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitIdRequiredException" : self = .commitIdRequiredException(try CommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCommentsForComparedCommitOutputError: Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitIdRequiredException(CommitIdRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCommentsForComparedCommitOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCommentsForComparedCommitOutputResponse(commentsForComparedCommitData: \(String(describing: commentsForComparedCommitData)), nextToken: \(String(describing: nextToken)))"}
}

extension GetCommentsForComparedCommitOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCommentsForComparedCommitOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.commentsForComparedCommitData = output.commentsForComparedCommitData
            self.nextToken = output.nextToken
        } else {
            self.commentsForComparedCommitData = nil
            self.nextToken = nil
        }
    }
}

public struct GetCommentsForComparedCommitOutputResponse: Equatable {
    /// <p>A list of comment objects on the compared commit.</p>
    public let commentsForComparedCommitData: [CommentsForComparedCommit]?
    /// <p>An enumeration token that can be used in a request to return the next batch of the results.</p>
    public let nextToken: String?

    public init (
        commentsForComparedCommitData: [CommentsForComparedCommit]? = nil,
        nextToken: String? = nil
    )
    {
        self.commentsForComparedCommitData = commentsForComparedCommitData
        self.nextToken = nextToken
    }
}

struct GetCommentsForComparedCommitOutputResponseBody: Equatable {
    public let commentsForComparedCommitData: [CommentsForComparedCommit]?
    public let nextToken: String?
}

extension GetCommentsForComparedCommitOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commentsForComparedCommitData
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentsForComparedCommitDataContainer = try containerValues.decodeIfPresent([CommentsForComparedCommit?].self, forKey: .commentsForComparedCommitData)
        var commentsForComparedCommitDataDecoded0:[CommentsForComparedCommit]? = nil
        if let commentsForComparedCommitDataContainer = commentsForComparedCommitDataContainer {
            commentsForComparedCommitDataDecoded0 = [CommentsForComparedCommit]()
            for structure0 in commentsForComparedCommitDataContainer {
                if let structure0 = structure0 {
                    commentsForComparedCommitDataDecoded0?.append(structure0)
                }
            }
        }
        commentsForComparedCommitData = commentsForComparedCommitDataDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetCommentsForPullRequestInputBodyMiddleware: Middleware {
    public let id: String = "GetCommentsForPullRequestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCommentsForPullRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCommentsForPullRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCommentsForPullRequestInput>
    public typealias MOutput = OperationOutput<GetCommentsForPullRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCommentsForPullRequestOutputError>
}

extension GetCommentsForPullRequestInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCommentsForPullRequestInput(afterCommitId: \(String(describing: afterCommitId)), beforeCommitId: \(String(describing: beforeCommitId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), pullRequestId: \(String(describing: pullRequestId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension GetCommentsForPullRequestInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case afterCommitId
        case beforeCommitId
        case maxResults
        case nextToken
        case pullRequestId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterCommitId = afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeCommitId = beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetCommentsForPullRequestInputHeadersMiddleware: Middleware {
    public let id: String = "GetCommentsForPullRequestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCommentsForPullRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCommentsForPullRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCommentsForPullRequestInput>
    public typealias MOutput = OperationOutput<GetCommentsForPullRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCommentsForPullRequestOutputError>
}

public struct GetCommentsForPullRequestInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCommentsForPullRequestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCommentsForPullRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCommentsForPullRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCommentsForPullRequestInput>
    public typealias MOutput = OperationOutput<GetCommentsForPullRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCommentsForPullRequestOutputError>
}

public struct GetCommentsForPullRequestInput: Equatable {
    /// <p>The full commit ID of the commit in the source branch that was the tip of the branch at the time the comment was made.</p>
    public let afterCommitId: String?
    /// <p>The full commit ID of the commit in the destination branch that was the tip of the branch at the time the pull request was created.</p>
    public let beforeCommitId: String?
    /// <p>A non-zero, non-negative integer used to limit the number of returned results. The default is 100 comments.
    ///             You can return up to 500 comments with a single request.</p>
    public let maxResults: Int?
    /// <p>An enumeration token that, when provided in a request, returns the next batch of the
    ///             results.</p>
    public let nextToken: String?
    /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
    public let pullRequestId: String?
    /// <p>The name of the repository that contains the pull request.</p>
    public let repositoryName: String?

    public init (
        afterCommitId: String? = nil,
        beforeCommitId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        pullRequestId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.afterCommitId = afterCommitId
        self.beforeCommitId = beforeCommitId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
    }
}

struct GetCommentsForPullRequestInputBody: Equatable {
    public let pullRequestId: String?
    public let repositoryName: String?
    public let beforeCommitId: String?
    public let afterCommitId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension GetCommentsForPullRequestInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case afterCommitId
        case beforeCommitId
        case maxResults
        case nextToken
        case pullRequestId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetCommentsForPullRequestOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCommentsForPullRequestOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitIdRequiredException" : self = .commitIdRequiredException(try CommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotAssociatedWithPullRequestException" : self = .repositoryNotAssociatedWithPullRequestException(try RepositoryNotAssociatedWithPullRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCommentsForPullRequestOutputError: Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitIdRequiredException(CommitIdRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case repositoryNotAssociatedWithPullRequestException(RepositoryNotAssociatedWithPullRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCommentsForPullRequestOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCommentsForPullRequestOutputResponse(commentsForPullRequestData: \(String(describing: commentsForPullRequestData)), nextToken: \(String(describing: nextToken)))"}
}

extension GetCommentsForPullRequestOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCommentsForPullRequestOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.commentsForPullRequestData = output.commentsForPullRequestData
            self.nextToken = output.nextToken
        } else {
            self.commentsForPullRequestData = nil
            self.nextToken = nil
        }
    }
}

public struct GetCommentsForPullRequestOutputResponse: Equatable {
    /// <p>An array of comment objects on the pull request.</p>
    public let commentsForPullRequestData: [CommentsForPullRequest]?
    /// <p>An enumeration token that can be used in a request to return the next batch of the results.</p>
    public let nextToken: String?

    public init (
        commentsForPullRequestData: [CommentsForPullRequest]? = nil,
        nextToken: String? = nil
    )
    {
        self.commentsForPullRequestData = commentsForPullRequestData
        self.nextToken = nextToken
    }
}

struct GetCommentsForPullRequestOutputResponseBody: Equatable {
    public let commentsForPullRequestData: [CommentsForPullRequest]?
    public let nextToken: String?
}

extension GetCommentsForPullRequestOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commentsForPullRequestData
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentsForPullRequestDataContainer = try containerValues.decodeIfPresent([CommentsForPullRequest?].self, forKey: .commentsForPullRequestData)
        var commentsForPullRequestDataDecoded0:[CommentsForPullRequest]? = nil
        if let commentsForPullRequestDataContainer = commentsForPullRequestDataContainer {
            commentsForPullRequestDataDecoded0 = [CommentsForPullRequest]()
            for structure0 in commentsForPullRequestDataContainer {
                if let structure0 = structure0 {
                    commentsForPullRequestDataDecoded0?.append(structure0)
                }
            }
        }
        commentsForPullRequestData = commentsForPullRequestDataDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetCommitInputBodyMiddleware: Middleware {
    public let id: String = "GetCommitInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCommitInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCommitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCommitInput>
    public typealias MOutput = OperationOutput<GetCommitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCommitOutputError>
}

extension GetCommitInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCommitInput(commitId: \(String(describing: commitId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension GetCommitInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commitId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitId = commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetCommitInputHeadersMiddleware: Middleware {
    public let id: String = "GetCommitInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCommitInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCommitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCommitInput>
    public typealias MOutput = OperationOutput<GetCommitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCommitOutputError>
}

public struct GetCommitInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCommitInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCommitInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCommitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCommitInput>
    public typealias MOutput = OperationOutput<GetCommitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCommitOutputError>
}

/// <p>Represents the input of a get commit operation.</p>
public struct GetCommitInput: Equatable {
    /// <p>The commit ID. Commit IDs are the full SHA ID of the commit.</p>
    public let commitId: String?
    /// <p>The name of the repository to which the commit was made.</p>
    public let repositoryName: String?

    public init (
        commitId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.commitId = commitId
        self.repositoryName = repositoryName
    }
}

struct GetCommitInputBody: Equatable {
    public let repositoryName: String?
    public let commitId: String?
}

extension GetCommitInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commitId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let commitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitId)
        commitId = commitIdDecoded
    }
}

extension GetCommitOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCommitOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommitIdDoesNotExistException" : self = .commitIdDoesNotExistException(try CommitIdDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitIdRequiredException" : self = .commitIdRequiredException(try CommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCommitOutputError: Equatable {
    case commitIdDoesNotExistException(CommitIdDoesNotExistException)
    case commitIdRequiredException(CommitIdRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCommitOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCommitOutputResponse(commit: \(String(describing: commit)))"}
}

extension GetCommitOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCommitOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.commit = output.commit
        } else {
            self.commit = nil
        }
    }
}

/// <p>Represents the output of a get commit operation.</p>
public struct GetCommitOutputResponse: Equatable {
    /// <p>A commit data type object that contains information about the specified commit.</p>
    public let commit: Commit?

    public init (
        commit: Commit? = nil
    )
    {
        self.commit = commit
    }
}

struct GetCommitOutputResponseBody: Equatable {
    public let commit: Commit?
}

extension GetCommitOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commit
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitDecoded = try containerValues.decodeIfPresent(Commit.self, forKey: .commit)
        commit = commitDecoded
    }
}

public struct GetDifferencesInputBodyMiddleware: Middleware {
    public let id: String = "GetDifferencesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDifferencesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDifferencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDifferencesInput>
    public typealias MOutput = OperationOutput<GetDifferencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDifferencesOutputError>
}

extension GetDifferencesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDifferencesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), afterCommitSpecifier: \(String(describing: afterCommitSpecifier)), afterPath: \(String(describing: afterPath)), beforeCommitSpecifier: \(String(describing: beforeCommitSpecifier)), beforePath: \(String(describing: beforePath)), repositoryName: \(String(describing: repositoryName)))"}
}

extension GetDifferencesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case afterCommitSpecifier
        case afterPath
        case beforeCommitSpecifier
        case beforePath
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let afterCommitSpecifier = afterCommitSpecifier {
            try encodeContainer.encode(afterCommitSpecifier, forKey: .afterCommitSpecifier)
        }
        if let afterPath = afterPath {
            try encodeContainer.encode(afterPath, forKey: .afterPath)
        }
        if let beforeCommitSpecifier = beforeCommitSpecifier {
            try encodeContainer.encode(beforeCommitSpecifier, forKey: .beforeCommitSpecifier)
        }
        if let beforePath = beforePath {
            try encodeContainer.encode(beforePath, forKey: .beforePath)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetDifferencesInputHeadersMiddleware: Middleware {
    public let id: String = "GetDifferencesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDifferencesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDifferencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDifferencesInput>
    public typealias MOutput = OperationOutput<GetDifferencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDifferencesOutputError>
}

public struct GetDifferencesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDifferencesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDifferencesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDifferencesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDifferencesInput>
    public typealias MOutput = OperationOutput<GetDifferencesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDifferencesOutputError>
}

public struct GetDifferencesInput: Equatable {
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit.</p>
    public let afterCommitSpecifier: String?
    /// <p>The file path in which to check differences. Limits the results to this path. Can also
    ///             be used to specify the changed name of a directory or folder, if it has changed. If not
    ///             specified, differences are shown for all paths.</p>
    public let afterPath: String?
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, the full commit ID). Optional. If not specified, all changes before the
    ///                 <code>afterCommitSpecifier</code> value are shown. If you do not use
    ///                 <code>beforeCommitSpecifier</code> in your request, consider limiting the results
    ///             with <code>maxResults</code>.</p>
    public let beforeCommitSpecifier: String?
    /// <p>The file path in which to check for differences. Limits the results to this path. Can
    ///             also be used to specify the previous name of a directory or folder. If
    ///                 <code>beforePath</code> and <code>afterPath</code> are not specified, differences
    ///             are shown for all paths.</p>
    public let beforePath: String?
    /// <p>A non-zero, non-negative integer used to limit the number of returned results.</p>
    public let maxResults: Int?
    /// <p>An enumeration token that, when provided in a request, returns the next batch of the
    ///             results.</p>
    public let nextToken: String?
    /// <p>The name of the repository where you want to get differences.</p>
    public let repositoryName: String?

    public init (
        afterCommitSpecifier: String? = nil,
        afterPath: String? = nil,
        beforeCommitSpecifier: String? = nil,
        beforePath: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.afterCommitSpecifier = afterCommitSpecifier
        self.afterPath = afterPath
        self.beforeCommitSpecifier = beforeCommitSpecifier
        self.beforePath = beforePath
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryName = repositoryName
    }
}

struct GetDifferencesInputBody: Equatable {
    public let repositoryName: String?
    public let beforeCommitSpecifier: String?
    public let afterCommitSpecifier: String?
    public let beforePath: String?
    public let afterPath: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension GetDifferencesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case afterCommitSpecifier
        case afterPath
        case beforeCommitSpecifier
        case beforePath
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beforeCommitSpecifier)
        beforeCommitSpecifier = beforeCommitSpecifierDecoded
        let afterCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterCommitSpecifier)
        afterCommitSpecifier = afterCommitSpecifierDecoded
        let beforePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beforePath)
        beforePath = beforePathDecoded
        let afterPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterPath)
        afterPath = afterPathDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDifferencesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDifferencesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathDoesNotExistException" : self = .pathDoesNotExistException(try PathDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDifferencesOutputError: Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitRequiredException(CommitRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommitException(InvalidCommitException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidPathException(InvalidPathException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case pathDoesNotExistException(PathDoesNotExistException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDifferencesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDifferencesOutputResponse(nextToken: \(String(describing: nextToken)), differences: \(String(describing: differences)))"}
}

extension GetDifferencesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDifferencesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.differences = output.differences
            self.nextToken = output.nextToken
        } else {
            self.nextToken = nil
            self.differences = nil
        }
    }
}

public struct GetDifferencesOutputResponse: Equatable {
    /// <p>A data type object that contains information about the differences, including whether
    ///             the difference is added, modified, or deleted (A, D, M).</p>
    public let differences: [Difference]?
    /// <p>An enumeration token that can be used in a request to return the next batch of the results.</p>
    public let nextToken: String?

    public init (
        differences: [Difference]? = nil,
        nextToken: String? = nil
    )
    {
        self.differences = differences
        self.nextToken = nextToken
    }
}

struct GetDifferencesOutputResponseBody: Equatable {
    public let differences: [Difference]?
    public let nextToken: String?
}

extension GetDifferencesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case differences
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let differencesContainer = try containerValues.decodeIfPresent([Difference?].self, forKey: .differences)
        var differencesDecoded0:[Difference]? = nil
        if let differencesContainer = differencesContainer {
            differencesDecoded0 = [Difference]()
            for structure0 in differencesContainer {
                if let structure0 = structure0 {
                    differencesDecoded0?.append(structure0)
                }
            }
        }
        differences = differencesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetFileInputBodyMiddleware: Middleware {
    public let id: String = "GetFileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFileInput>
    public typealias MOutput = OperationOutput<GetFileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFileOutputError>
}

extension GetFileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFileInput(commitSpecifier: \(String(describing: commitSpecifier)), filePath: \(String(describing: filePath)), repositoryName: \(String(describing: repositoryName)))"}
}

extension GetFileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commitSpecifier
        case filePath
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitSpecifier = commitSpecifier {
            try encodeContainer.encode(commitSpecifier, forKey: .commitSpecifier)
        }
        if let filePath = filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetFileInputHeadersMiddleware: Middleware {
    public let id: String = "GetFileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFileInput>
    public typealias MOutput = OperationOutput<GetFileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFileOutputError>
}

public struct GetFileInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFileInput>
    public typealias MOutput = OperationOutput<GetFileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFileOutputError>
}

public struct GetFileInput: Equatable {
    /// <p>The fully quaified reference that identifies the commit that contains the file. For
    ///             example, you can specify a full commit ID, a tag, a branch name, or a reference such as
    ///             refs/heads/master. If none is provided, the head commit is used.</p>
    public let commitSpecifier: String?
    /// <p>The fully qualified path to the file, including the full name and extension of the
    ///             file. For example, /examples/file.md is the fully qualified path to a file named file.md
    ///             in a folder named examples.</p>
    public let filePath: String?
    /// <p>The name of the repository that contains the file.</p>
    public let repositoryName: String?

    public init (
        commitSpecifier: String? = nil,
        filePath: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.commitSpecifier = commitSpecifier
        self.filePath = filePath
        self.repositoryName = repositoryName
    }
}

struct GetFileInputBody: Equatable {
    public let repositoryName: String?
    public let commitSpecifier: String?
    public let filePath: String?
}

extension GetFileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commitSpecifier
        case filePath
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let commitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitSpecifier)
        commitSpecifier = commitSpecifierDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePath)
        filePath = filePathDecoded
    }
}

extension GetFileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileDoesNotExistException" : self = .fileDoesNotExistException(try FileDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileTooLargeException" : self = .fileTooLargeException(try FileTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFileOutputError: Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileDoesNotExistException(FileDoesNotExistException)
    case fileTooLargeException(FileTooLargeException)
    case invalidCommitException(InvalidCommitException)
    case invalidPathException(InvalidPathException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case pathRequiredException(PathRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFileOutputResponse(blobId: \(String(describing: blobId)), commitId: \(String(describing: commitId)), fileContent: \(String(describing: fileContent)), fileMode: \(String(describing: fileMode)), filePath: \(String(describing: filePath)), fileSize: \(String(describing: fileSize)))"}
}

extension GetFileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.blobId = output.blobId
            self.commitId = output.commitId
            self.fileContent = output.fileContent
            self.fileMode = output.fileMode
            self.filePath = output.filePath
            self.fileSize = output.fileSize
        } else {
            self.blobId = nil
            self.commitId = nil
            self.fileContent = nil
            self.fileMode = nil
            self.filePath = nil
            self.fileSize = 0
        }
    }
}

public struct GetFileOutputResponse: Equatable {
    /// <p>The blob ID of the object that represents the file content.</p>
    public let blobId: String?
    /// <p>The full commit ID of the commit that contains the content returned by GetFile.</p>
    public let commitId: String?
    /// <p>The base-64 encoded binary data object that represents the content of the file.</p>
    public let fileContent: Data?
    /// <p>The extrapolated file mode permissions of the blob. Valid values include strings such as EXECUTABLE and not numeric values.</p>
    ///         <note>
    ///             <p>The file mode permissions returned by this API are not the standard file mode
    ///                 permission values, such as 100644, but rather extrapolated values. See the supported
    ///                 return values.</p>
    ///         </note>
    public let fileMode: FileModeTypeEnum?
    /// <p>The fully qualified path to the specified file. Returns the name and extension of the
    ///             file.</p>
    public let filePath: String?
    /// <p>The size of the contents of the file, in bytes.</p>
    public let fileSize: Int

    public init (
        blobId: String? = nil,
        commitId: String? = nil,
        fileContent: Data? = nil,
        fileMode: FileModeTypeEnum? = nil,
        filePath: String? = nil,
        fileSize: Int = 0
    )
    {
        self.blobId = blobId
        self.commitId = commitId
        self.fileContent = fileContent
        self.fileMode = fileMode
        self.filePath = filePath
        self.fileSize = fileSize
    }
}

struct GetFileOutputResponseBody: Equatable {
    public let commitId: String?
    public let blobId: String?
    public let filePath: String?
    public let fileMode: FileModeTypeEnum?
    public let fileSize: Int
    public let fileContent: Data?
}

extension GetFileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case blobId
        case commitId
        case fileContent
        case fileMode
        case filePath
        case fileSize
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let blobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
        let fileSizeDecoded = try containerValues.decode(Int.self, forKey: .fileSize)
        fileSize = fileSizeDecoded
        let fileContentDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .fileContent)
        fileContent = fileContentDecoded
    }
}

public struct GetFolderInputBodyMiddleware: Middleware {
    public let id: String = "GetFolderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFolderInput>
    public typealias MOutput = OperationOutput<GetFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFolderOutputError>
}

extension GetFolderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFolderInput(commitSpecifier: \(String(describing: commitSpecifier)), folderPath: \(String(describing: folderPath)), repositoryName: \(String(describing: repositoryName)))"}
}

extension GetFolderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commitSpecifier
        case folderPath
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitSpecifier = commitSpecifier {
            try encodeContainer.encode(commitSpecifier, forKey: .commitSpecifier)
        }
        if let folderPath = folderPath {
            try encodeContainer.encode(folderPath, forKey: .folderPath)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetFolderInputHeadersMiddleware: Middleware {
    public let id: String = "GetFolderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFolderInput>
    public typealias MOutput = OperationOutput<GetFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFolderOutputError>
}

public struct GetFolderInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFolderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFolderInput>
    public typealias MOutput = OperationOutput<GetFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFolderOutputError>
}

public struct GetFolderInput: Equatable {
    /// <p>A fully qualified reference used to identify a commit that contains the version of the
    ///             folder's content to return. A fully qualified reference can be a commit ID, branch name,
    ///             tag, or reference such as HEAD. If no specifier is provided, the folder content is
    ///             returned as it exists in the HEAD commit.</p>
    public let commitSpecifier: String?
    /// <p>The fully qualified path to the folder whose contents are returned, including the
    ///             folder name. For example, /examples is a fully-qualified path to a folder named examples
    ///             that was created off of the root directory (/) of a repository. </p>
    public let folderPath: String?
    /// <p>The name of the repository.</p>
    public let repositoryName: String?

    public init (
        commitSpecifier: String? = nil,
        folderPath: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.commitSpecifier = commitSpecifier
        self.folderPath = folderPath
        self.repositoryName = repositoryName
    }
}

struct GetFolderInputBody: Equatable {
    public let repositoryName: String?
    public let commitSpecifier: String?
    public let folderPath: String?
}

extension GetFolderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commitSpecifier
        case folderPath
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let commitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitSpecifier)
        commitSpecifier = commitSpecifierDecoded
        let folderPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .folderPath)
        folderPath = folderPathDecoded
    }
}

extension GetFolderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFolderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FolderDoesNotExistException" : self = .folderDoesNotExistException(try FolderDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFolderOutputError: Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case folderDoesNotExistException(FolderDoesNotExistException)
    case invalidCommitException(InvalidCommitException)
    case invalidPathException(InvalidPathException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case pathRequiredException(PathRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFolderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFolderOutputResponse(commitId: \(String(describing: commitId)), files: \(String(describing: files)), folderPath: \(String(describing: folderPath)), subFolders: \(String(describing: subFolders)), subModules: \(String(describing: subModules)), symbolicLinks: \(String(describing: symbolicLinks)), treeId: \(String(describing: treeId)))"}
}

extension GetFolderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFolderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.commitId = output.commitId
            self.files = output.files
            self.folderPath = output.folderPath
            self.subFolders = output.subFolders
            self.subModules = output.subModules
            self.symbolicLinks = output.symbolicLinks
            self.treeId = output.treeId
        } else {
            self.commitId = nil
            self.files = nil
            self.folderPath = nil
            self.subFolders = nil
            self.subModules = nil
            self.symbolicLinks = nil
            self.treeId = nil
        }
    }
}

public struct GetFolderOutputResponse: Equatable {
    /// <p>The full commit ID used as a reference for the returned version of the folder
    ///             content.</p>
    public let commitId: String?
    /// <p>The list of files in the specified folder, if any.</p>
    public let files: [File]?
    /// <p>The fully qualified path of the folder whose contents are returned.</p>
    public let folderPath: String?
    /// <p>The list of folders that exist under the specified folder, if any.</p>
    public let subFolders: [Folder]?
    /// <p>The list of submodules in the specified folder, if any.</p>
    public let subModules: [SubModule]?
    /// <p>The list of symbolic links to other files and folders in the specified folder, if
    ///             any.</p>
    public let symbolicLinks: [SymbolicLink]?
    /// <p>The full SHA-1 pointer of the tree information for the commit that contains the folder.</p>
    public let treeId: String?

    public init (
        commitId: String? = nil,
        files: [File]? = nil,
        folderPath: String? = nil,
        subFolders: [Folder]? = nil,
        subModules: [SubModule]? = nil,
        symbolicLinks: [SymbolicLink]? = nil,
        treeId: String? = nil
    )
    {
        self.commitId = commitId
        self.files = files
        self.folderPath = folderPath
        self.subFolders = subFolders
        self.subModules = subModules
        self.symbolicLinks = symbolicLinks
        self.treeId = treeId
    }
}

struct GetFolderOutputResponseBody: Equatable {
    public let commitId: String?
    public let folderPath: String?
    public let treeId: String?
    public let subFolders: [Folder]?
    public let files: [File]?
    public let symbolicLinks: [SymbolicLink]?
    public let subModules: [SubModule]?
}

extension GetFolderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commitId
        case files
        case folderPath
        case subFolders
        case subModules
        case symbolicLinks
        case treeId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let folderPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .folderPath)
        folderPath = folderPathDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treeId)
        treeId = treeIdDecoded
        let subFoldersContainer = try containerValues.decodeIfPresent([Folder?].self, forKey: .subFolders)
        var subFoldersDecoded0:[Folder]? = nil
        if let subFoldersContainer = subFoldersContainer {
            subFoldersDecoded0 = [Folder]()
            for structure0 in subFoldersContainer {
                if let structure0 = structure0 {
                    subFoldersDecoded0?.append(structure0)
                }
            }
        }
        subFolders = subFoldersDecoded0
        let filesContainer = try containerValues.decodeIfPresent([File?].self, forKey: .files)
        var filesDecoded0:[File]? = nil
        if let filesContainer = filesContainer {
            filesDecoded0 = [File]()
            for structure0 in filesContainer {
                if let structure0 = structure0 {
                    filesDecoded0?.append(structure0)
                }
            }
        }
        files = filesDecoded0
        let symbolicLinksContainer = try containerValues.decodeIfPresent([SymbolicLink?].self, forKey: .symbolicLinks)
        var symbolicLinksDecoded0:[SymbolicLink]? = nil
        if let symbolicLinksContainer = symbolicLinksContainer {
            symbolicLinksDecoded0 = [SymbolicLink]()
            for structure0 in symbolicLinksContainer {
                if let structure0 = structure0 {
                    symbolicLinksDecoded0?.append(structure0)
                }
            }
        }
        symbolicLinks = symbolicLinksDecoded0
        let subModulesContainer = try containerValues.decodeIfPresent([SubModule?].self, forKey: .subModules)
        var subModulesDecoded0:[SubModule]? = nil
        if let subModulesContainer = subModulesContainer {
            subModulesDecoded0 = [SubModule]()
            for structure0 in subModulesContainer {
                if let structure0 = structure0 {
                    subModulesDecoded0?.append(structure0)
                }
            }
        }
        subModules = subModulesDecoded0
    }
}

public struct GetMergeCommitInputBodyMiddleware: Middleware {
    public let id: String = "GetMergeCommitInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMergeCommitInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMergeCommitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMergeCommitInput>
    public typealias MOutput = OperationOutput<GetMergeCommitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMergeCommitOutputError>
}

extension GetMergeCommitInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMergeCommitInput(conflictDetailLevel: \(String(describing: conflictDetailLevel)), conflictResolutionStrategy: \(String(describing: conflictResolutionStrategy)), destinationCommitSpecifier: \(String(describing: destinationCommitSpecifier)), repositoryName: \(String(describing: repositoryName)), sourceCommitSpecifier: \(String(describing: sourceCommitSpecifier)))"}
}

extension GetMergeCommitInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case repositoryName
        case sourceCommitSpecifier
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetailLevel = conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolutionStrategy = conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
    }
}

public struct GetMergeCommitInputHeadersMiddleware: Middleware {
    public let id: String = "GetMergeCommitInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMergeCommitInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMergeCommitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMergeCommitInput>
    public typealias MOutput = OperationOutput<GetMergeCommitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMergeCommitOutputError>
}

public struct GetMergeCommitInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMergeCommitInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMergeCommitInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMergeCommitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMergeCommitInput>
    public typealias MOutput = OperationOutput<GetMergeCommitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMergeCommitOutputError>
}

public struct GetMergeCommitInput: Equatable {
    /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
    ///             which returns a not-mergeable result if the same file has differences in both branches.
    ///             If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
    ///             both branches has differences on the same line.</p>
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
    ///             automatically merging two versions of a file. The default is NONE, which requires any
    ///             conflicts to be resolved manually before the merge operation is successful.</p>
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, a branch name or a full commit ID).</p>
    public let destinationCommitSpecifier: String?
    /// <p>The name of the repository that contains the merge commit about which you want to get information.</p>
    public let repositoryName: String?
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, a branch name or a full commit ID).</p>
    public let sourceCommitSpecifier: String?

    public init (
        conflictDetailLevel: ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: String? = nil,
        repositoryName: String? = nil,
        sourceCommitSpecifier: String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

struct GetMergeCommitInputBody: Equatable {
    public let repositoryName: String?
    public let sourceCommitSpecifier: String?
    public let destinationCommitSpecifier: String?
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
}

extension GetMergeCommitInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case repositoryName
        case sourceCommitSpecifier
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
    }
}

extension GetMergeCommitOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMergeCommitOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMergeCommitOutputError: Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitRequiredException(CommitRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommitException(InvalidCommitException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMergeCommitOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMergeCommitOutputResponse(baseCommitId: \(String(describing: baseCommitId)), destinationCommitId: \(String(describing: destinationCommitId)), mergedCommitId: \(String(describing: mergedCommitId)), sourceCommitId: \(String(describing: sourceCommitId)))"}
}

extension GetMergeCommitOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMergeCommitOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.baseCommitId = output.baseCommitId
            self.destinationCommitId = output.destinationCommitId
            self.mergedCommitId = output.mergedCommitId
            self.sourceCommitId = output.sourceCommitId
        } else {
            self.baseCommitId = nil
            self.destinationCommitId = nil
            self.mergedCommitId = nil
            self.sourceCommitId = nil
        }
    }
}

public struct GetMergeCommitOutputResponse: Equatable {
    /// <p>The commit ID of the merge base.</p>
    public let baseCommitId: String?
    /// <p>The commit ID of the destination commit specifier that was used in the merge evaluation.</p>
    public let destinationCommitId: String?
    /// <p>The commit ID for the merge commit created when the source branch was merged into the
    ///             destination branch. If the fast-forward merge strategy was used, there is no merge
    ///             commit.</p>
    public let mergedCommitId: String?
    /// <p>The commit ID of the source commit specifier that was used in the merge evaluation.</p>
    public let sourceCommitId: String?

    public init (
        baseCommitId: String? = nil,
        destinationCommitId: String? = nil,
        mergedCommitId: String? = nil,
        sourceCommitId: String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.destinationCommitId = destinationCommitId
        self.mergedCommitId = mergedCommitId
        self.sourceCommitId = sourceCommitId
    }
}

struct GetMergeCommitOutputResponseBody: Equatable {
    public let sourceCommitId: String?
    public let destinationCommitId: String?
    public let baseCommitId: String?
    public let mergedCommitId: String?
}

extension GetMergeCommitOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baseCommitId
        case destinationCommitId
        case mergedCommitId
        case sourceCommitId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let destinationCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationCommitId)
        destinationCommitId = destinationCommitIdDecoded
        let baseCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baseCommitId)
        baseCommitId = baseCommitIdDecoded
        let mergedCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mergedCommitId)
        mergedCommitId = mergedCommitIdDecoded
    }
}

public struct GetMergeConflictsInputBodyMiddleware: Middleware {
    public let id: String = "GetMergeConflictsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMergeConflictsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMergeConflictsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMergeConflictsInput>
    public typealias MOutput = OperationOutput<GetMergeConflictsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMergeConflictsOutputError>
}

extension GetMergeConflictsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMergeConflictsInput(conflictDetailLevel: \(String(describing: conflictDetailLevel)), conflictResolutionStrategy: \(String(describing: conflictResolutionStrategy)), destinationCommitSpecifier: \(String(describing: destinationCommitSpecifier)), maxConflictFiles: \(String(describing: maxConflictFiles)), mergeOption: \(String(describing: mergeOption)), nextToken: \(String(describing: nextToken)), repositoryName: \(String(describing: repositoryName)), sourceCommitSpecifier: \(String(describing: sourceCommitSpecifier)))"}
}

extension GetMergeConflictsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case maxConflictFiles
        case mergeOption
        case nextToken
        case repositoryName
        case sourceCommitSpecifier
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetailLevel = conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolutionStrategy = conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let maxConflictFiles = maxConflictFiles {
            try encodeContainer.encode(maxConflictFiles, forKey: .maxConflictFiles)
        }
        if let mergeOption = mergeOption {
            try encodeContainer.encode(mergeOption.rawValue, forKey: .mergeOption)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
    }
}

public struct GetMergeConflictsInputHeadersMiddleware: Middleware {
    public let id: String = "GetMergeConflictsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMergeConflictsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMergeConflictsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMergeConflictsInput>
    public typealias MOutput = OperationOutput<GetMergeConflictsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMergeConflictsOutputError>
}

public struct GetMergeConflictsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMergeConflictsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMergeConflictsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMergeConflictsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMergeConflictsInput>
    public typealias MOutput = OperationOutput<GetMergeConflictsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMergeConflictsOutputError>
}

public struct GetMergeConflictsInput: Equatable {
    /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
    ///             which returns a not-mergeable result if the same file has differences in both branches.
    ///             If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
    ///             both branches has differences on the same line.</p>
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
    ///             automatically merging two versions of a file. The default is NONE, which requires any
    ///             conflicts to be resolved manually before the merge operation is successful.</p>
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, a branch name or a full commit ID).</p>
    public let destinationCommitSpecifier: String?
    /// <p>The maximum number of files to include in the output.</p>
    public let maxConflictFiles: Int?
    /// <p>The merge option or strategy you want to use to merge the code.  </p>
    public let mergeOption: MergeOptionTypeEnum?
    /// <p>An enumeration token that, when provided in a request, returns the next batch of the
    ///             results.</p>
    public let nextToken: String?
    /// <p>The name of the repository where the pull request was created.</p>
    public let repositoryName: String?
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, a branch name or a full commit ID).</p>
    public let sourceCommitSpecifier: String?

    public init (
        conflictDetailLevel: ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: String? = nil,
        maxConflictFiles: Int? = nil,
        mergeOption: MergeOptionTypeEnum? = nil,
        nextToken: String? = nil,
        repositoryName: String? = nil,
        sourceCommitSpecifier: String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.maxConflictFiles = maxConflictFiles
        self.mergeOption = mergeOption
        self.nextToken = nextToken
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

struct GetMergeConflictsInputBody: Equatable {
    public let repositoryName: String?
    public let destinationCommitSpecifier: String?
    public let sourceCommitSpecifier: String?
    public let mergeOption: MergeOptionTypeEnum?
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    public let maxConflictFiles: Int?
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
    public let nextToken: String?
}

extension GetMergeConflictsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case maxConflictFiles
        case mergeOption
        case nextToken
        case repositoryName
        case sourceCommitSpecifier
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let mergeOptionDecoded = try containerValues.decodeIfPresent(MergeOptionTypeEnum.self, forKey: .mergeOption)
        mergeOption = mergeOptionDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let maxConflictFilesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxConflictFiles)
        maxConflictFiles = maxConflictFilesDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetMergeConflictsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMergeConflictsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDestinationCommitSpecifierException" : self = .invalidDestinationCommitSpecifierException(try InvalidDestinationCommitSpecifierException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxConflictFilesException" : self = .invalidMaxConflictFilesException(try InvalidMaxConflictFilesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMergeOptionException" : self = .invalidMergeOptionException(try InvalidMergeOptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSourceCommitSpecifierException" : self = .invalidSourceCommitSpecifierException(try InvalidSourceCommitSpecifierException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileContentToLoadExceededException" : self = .maximumFileContentToLoadExceededException(try MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumItemsToCompareExceededException" : self = .maximumItemsToCompareExceededException(try MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MergeOptionRequiredException" : self = .mergeOptionRequiredException(try MergeOptionRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMergeConflictsOutputError: Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitRequiredException(CommitRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommitException(InvalidCommitException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidDestinationCommitSpecifierException(InvalidDestinationCommitSpecifierException)
    case invalidMaxConflictFilesException(InvalidMaxConflictFilesException)
    case invalidMergeOptionException(InvalidMergeOptionException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidSourceCommitSpecifierException(InvalidSourceCommitSpecifierException)
    case maximumFileContentToLoadExceededException(MaximumFileContentToLoadExceededException)
    case maximumItemsToCompareExceededException(MaximumItemsToCompareExceededException)
    case mergeOptionRequiredException(MergeOptionRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMergeConflictsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMergeConflictsOutputResponse(baseCommitId: \(String(describing: baseCommitId)), conflictMetadataList: \(String(describing: conflictMetadataList)), destinationCommitId: \(String(describing: destinationCommitId)), mergeable: \(String(describing: mergeable)), nextToken: \(String(describing: nextToken)), sourceCommitId: \(String(describing: sourceCommitId)))"}
}

extension GetMergeConflictsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMergeConflictsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.baseCommitId = output.baseCommitId
            self.conflictMetadataList = output.conflictMetadataList
            self.destinationCommitId = output.destinationCommitId
            self.mergeable = output.mergeable
            self.nextToken = output.nextToken
            self.sourceCommitId = output.sourceCommitId
        } else {
            self.baseCommitId = nil
            self.conflictMetadataList = nil
            self.destinationCommitId = nil
            self.mergeable = false
            self.nextToken = nil
            self.sourceCommitId = nil
        }
    }
}

public struct GetMergeConflictsOutputResponse: Equatable {
    /// <p>The commit ID of the merge base.</p>
    public let baseCommitId: String?
    /// <p>A list of metadata for any conflicting files. If the specified merge strategy is
    ///             FAST_FORWARD_MERGE, this list is always empty.</p>
    public let conflictMetadataList: [ConflictMetadata]?
    /// <p>The commit ID of the destination commit specifier that was used in the merge evaluation.</p>
    public let destinationCommitId: String?
    /// <p>A Boolean value that indicates whether the code is mergeable by the specified merge option.</p>
    public let mergeable: Bool
    /// <p>An enumeration token that can be used in a request to return the next batch of the results.</p>
    public let nextToken: String?
    /// <p>The commit ID of the source commit specifier that was used in the merge evaluation.</p>
    public let sourceCommitId: String?

    public init (
        baseCommitId: String? = nil,
        conflictMetadataList: [ConflictMetadata]? = nil,
        destinationCommitId: String? = nil,
        mergeable: Bool = false,
        nextToken: String? = nil,
        sourceCommitId: String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.conflictMetadataList = conflictMetadataList
        self.destinationCommitId = destinationCommitId
        self.mergeable = mergeable
        self.nextToken = nextToken
        self.sourceCommitId = sourceCommitId
    }
}

struct GetMergeConflictsOutputResponseBody: Equatable {
    public let mergeable: Bool
    public let destinationCommitId: String?
    public let sourceCommitId: String?
    public let baseCommitId: String?
    public let conflictMetadataList: [ConflictMetadata]?
    public let nextToken: String?
}

extension GetMergeConflictsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baseCommitId
        case conflictMetadataList
        case destinationCommitId
        case mergeable
        case nextToken
        case sourceCommitId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mergeableDecoded = try containerValues.decode(Bool.self, forKey: .mergeable)
        mergeable = mergeableDecoded
        let destinationCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationCommitId)
        destinationCommitId = destinationCommitIdDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let baseCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baseCommitId)
        baseCommitId = baseCommitIdDecoded
        let conflictMetadataListContainer = try containerValues.decodeIfPresent([ConflictMetadata?].self, forKey: .conflictMetadataList)
        var conflictMetadataListDecoded0:[ConflictMetadata]? = nil
        if let conflictMetadataListContainer = conflictMetadataListContainer {
            conflictMetadataListDecoded0 = [ConflictMetadata]()
            for structure0 in conflictMetadataListContainer {
                if let structure0 = structure0 {
                    conflictMetadataListDecoded0?.append(structure0)
                }
            }
        }
        conflictMetadataList = conflictMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetMergeOptionsInputBodyMiddleware: Middleware {
    public let id: String = "GetMergeOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMergeOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMergeOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMergeOptionsInput>
    public typealias MOutput = OperationOutput<GetMergeOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMergeOptionsOutputError>
}

extension GetMergeOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMergeOptionsInput(conflictDetailLevel: \(String(describing: conflictDetailLevel)), conflictResolutionStrategy: \(String(describing: conflictResolutionStrategy)), destinationCommitSpecifier: \(String(describing: destinationCommitSpecifier)), repositoryName: \(String(describing: repositoryName)), sourceCommitSpecifier: \(String(describing: sourceCommitSpecifier)))"}
}

extension GetMergeOptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case repositoryName
        case sourceCommitSpecifier
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetailLevel = conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolutionStrategy = conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
    }
}

public struct GetMergeOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetMergeOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMergeOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMergeOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMergeOptionsInput>
    public typealias MOutput = OperationOutput<GetMergeOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMergeOptionsOutputError>
}

public struct GetMergeOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMergeOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMergeOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMergeOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMergeOptionsInput>
    public typealias MOutput = OperationOutput<GetMergeOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMergeOptionsOutputError>
}

public struct GetMergeOptionsInput: Equatable {
    /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
    ///             which returns a not-mergeable result if the same file has differences in both branches.
    ///             If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
    ///             both branches has differences on the same line.</p>
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
    ///             automatically merging two versions of a file. The default is NONE, which requires any
    ///             conflicts to be resolved manually before the merge operation is successful.</p>
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, a branch name or a full commit ID).</p>
    public let destinationCommitSpecifier: String?
    /// <p>The name of the repository that contains the commits about which you want to get merge options.</p>
    public let repositoryName: String?
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, a branch name or a full commit ID).</p>
    public let sourceCommitSpecifier: String?

    public init (
        conflictDetailLevel: ConflictDetailLevelTypeEnum? = nil,
        conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: String? = nil,
        repositoryName: String? = nil,
        sourceCommitSpecifier: String? = nil
    )
    {
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
    }
}

struct GetMergeOptionsInputBody: Equatable {
    public let repositoryName: String?
    public let sourceCommitSpecifier: String?
    public let destinationCommitSpecifier: String?
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
}

extension GetMergeOptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conflictDetailLevel
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case repositoryName
        case sourceCommitSpecifier
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
    }
}

extension GetMergeOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMergeOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileContentToLoadExceededException" : self = .maximumFileContentToLoadExceededException(try MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumItemsToCompareExceededException" : self = .maximumItemsToCompareExceededException(try MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMergeOptionsOutputError: Equatable {
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitRequiredException(CommitRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommitException(InvalidCommitException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case maximumFileContentToLoadExceededException(MaximumFileContentToLoadExceededException)
    case maximumItemsToCompareExceededException(MaximumItemsToCompareExceededException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMergeOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMergeOptionsOutputResponse(baseCommitId: \(String(describing: baseCommitId)), destinationCommitId: \(String(describing: destinationCommitId)), mergeOptions: \(String(describing: mergeOptions)), sourceCommitId: \(String(describing: sourceCommitId)))"}
}

extension GetMergeOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMergeOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.baseCommitId = output.baseCommitId
            self.destinationCommitId = output.destinationCommitId
            self.mergeOptions = output.mergeOptions
            self.sourceCommitId = output.sourceCommitId
        } else {
            self.baseCommitId = nil
            self.destinationCommitId = nil
            self.mergeOptions = nil
            self.sourceCommitId = nil
        }
    }
}

public struct GetMergeOptionsOutputResponse: Equatable {
    /// <p>The commit ID of the merge base.</p>
    public let baseCommitId: String?
    /// <p>The commit ID of the destination commit specifier that was used in the merge evaluation.</p>
    public let destinationCommitId: String?
    /// <p>The merge option or strategy used to merge the code.</p>
    public let mergeOptions: [MergeOptionTypeEnum]?
    /// <p>The commit ID of the source commit specifier that was used in the merge evaluation.</p>
    public let sourceCommitId: String?

    public init (
        baseCommitId: String? = nil,
        destinationCommitId: String? = nil,
        mergeOptions: [MergeOptionTypeEnum]? = nil,
        sourceCommitId: String? = nil
    )
    {
        self.baseCommitId = baseCommitId
        self.destinationCommitId = destinationCommitId
        self.mergeOptions = mergeOptions
        self.sourceCommitId = sourceCommitId
    }
}

struct GetMergeOptionsOutputResponseBody: Equatable {
    public let mergeOptions: [MergeOptionTypeEnum]?
    public let sourceCommitId: String?
    public let destinationCommitId: String?
    public let baseCommitId: String?
}

extension GetMergeOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baseCommitId
        case destinationCommitId
        case mergeOptions
        case sourceCommitId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mergeOptionsContainer = try containerValues.decodeIfPresent([MergeOptionTypeEnum?].self, forKey: .mergeOptions)
        var mergeOptionsDecoded0:[MergeOptionTypeEnum]? = nil
        if let mergeOptionsContainer = mergeOptionsContainer {
            mergeOptionsDecoded0 = [MergeOptionTypeEnum]()
            for string0 in mergeOptionsContainer {
                if let string0 = string0 {
                    mergeOptionsDecoded0?.append(string0)
                }
            }
        }
        mergeOptions = mergeOptionsDecoded0
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let destinationCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationCommitId)
        destinationCommitId = destinationCommitIdDecoded
        let baseCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baseCommitId)
        baseCommitId = baseCommitIdDecoded
    }
}

public struct GetPullRequestApprovalStatesInputBodyMiddleware: Middleware {
    public let id: String = "GetPullRequestApprovalStatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPullRequestApprovalStatesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPullRequestApprovalStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPullRequestApprovalStatesInput>
    public typealias MOutput = OperationOutput<GetPullRequestApprovalStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPullRequestApprovalStatesOutputError>
}

extension GetPullRequestApprovalStatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPullRequestApprovalStatesInput(pullRequestId: \(String(describing: pullRequestId)), revisionId: \(String(describing: revisionId)))"}
}

extension GetPullRequestApprovalStatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pullRequestId
        case revisionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

public struct GetPullRequestApprovalStatesInputHeadersMiddleware: Middleware {
    public let id: String = "GetPullRequestApprovalStatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPullRequestApprovalStatesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPullRequestApprovalStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPullRequestApprovalStatesInput>
    public typealias MOutput = OperationOutput<GetPullRequestApprovalStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPullRequestApprovalStatesOutputError>
}

public struct GetPullRequestApprovalStatesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPullRequestApprovalStatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPullRequestApprovalStatesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPullRequestApprovalStatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPullRequestApprovalStatesInput>
    public typealias MOutput = OperationOutput<GetPullRequestApprovalStatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPullRequestApprovalStatesOutputError>
}

public struct GetPullRequestApprovalStatesInput: Equatable {
    /// <p>The system-generated ID for the pull request.</p>
    public let pullRequestId: String?
    /// <p>The system-generated ID for the pull request revision.</p>
    public let revisionId: String?

    public init (
        pullRequestId: String? = nil,
        revisionId: String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

struct GetPullRequestApprovalStatesInputBody: Equatable {
    public let pullRequestId: String?
    public let revisionId: String?
}

extension GetPullRequestApprovalStatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pullRequestId
        case revisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GetPullRequestApprovalStatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPullRequestApprovalStatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRevisionIdException" : self = .invalidRevisionIdException(try InvalidRevisionIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RevisionIdRequiredException" : self = .revisionIdRequiredException(try RevisionIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPullRequestApprovalStatesOutputError: Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidRevisionIdException(InvalidRevisionIdException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case revisionIdRequiredException(RevisionIdRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPullRequestApprovalStatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPullRequestApprovalStatesOutputResponse(approvals: \(String(describing: approvals)))"}
}

extension GetPullRequestApprovalStatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPullRequestApprovalStatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.approvals = output.approvals
        } else {
            self.approvals = nil
        }
    }
}

public struct GetPullRequestApprovalStatesOutputResponse: Equatable {
    /// <p>Information about users who have approved the pull request.</p>
    public let approvals: [Approval]?

    public init (
        approvals: [Approval]? = nil
    )
    {
        self.approvals = approvals
    }
}

struct GetPullRequestApprovalStatesOutputResponseBody: Equatable {
    public let approvals: [Approval]?
}

extension GetPullRequestApprovalStatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvals
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalsContainer = try containerValues.decodeIfPresent([Approval?].self, forKey: .approvals)
        var approvalsDecoded0:[Approval]? = nil
        if let approvalsContainer = approvalsContainer {
            approvalsDecoded0 = [Approval]()
            for structure0 in approvalsContainer {
                if let structure0 = structure0 {
                    approvalsDecoded0?.append(structure0)
                }
            }
        }
        approvals = approvalsDecoded0
    }
}

public struct GetPullRequestInputBodyMiddleware: Middleware {
    public let id: String = "GetPullRequestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPullRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPullRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPullRequestInput>
    public typealias MOutput = OperationOutput<GetPullRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPullRequestOutputError>
}

extension GetPullRequestInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPullRequestInput(pullRequestId: \(String(describing: pullRequestId)))"}
}

extension GetPullRequestInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pullRequestId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
    }
}

public struct GetPullRequestInputHeadersMiddleware: Middleware {
    public let id: String = "GetPullRequestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPullRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPullRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPullRequestInput>
    public typealias MOutput = OperationOutput<GetPullRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPullRequestOutputError>
}

public struct GetPullRequestInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPullRequestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPullRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPullRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPullRequestInput>
    public typealias MOutput = OperationOutput<GetPullRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPullRequestOutputError>
}

public struct GetPullRequestInput: Equatable {
    /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
    public let pullRequestId: String?

    public init (
        pullRequestId: String? = nil
    )
    {
        self.pullRequestId = pullRequestId
    }
}

struct GetPullRequestInputBody: Equatable {
    public let pullRequestId: String?
}

extension GetPullRequestInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pullRequestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
    }
}

extension GetPullRequestOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPullRequestOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPullRequestOutputError: Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPullRequestOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPullRequestOutputResponse(pullRequest: \(String(describing: pullRequest)))"}
}

extension GetPullRequestOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPullRequestOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct GetPullRequestOutputResponse: Equatable {
    /// <p>Information about the specified pull request.</p>
    public let pullRequest: PullRequest?

    public init (
        pullRequest: PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct GetPullRequestOutputResponseBody: Equatable {
    public let pullRequest: PullRequest?
}

extension GetPullRequestOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pullRequest
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

public struct GetPullRequestOverrideStateInputBodyMiddleware: Middleware {
    public let id: String = "GetPullRequestOverrideStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPullRequestOverrideStateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPullRequestOverrideStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPullRequestOverrideStateInput>
    public typealias MOutput = OperationOutput<GetPullRequestOverrideStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPullRequestOverrideStateOutputError>
}

extension GetPullRequestOverrideStateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPullRequestOverrideStateInput(pullRequestId: \(String(describing: pullRequestId)), revisionId: \(String(describing: revisionId)))"}
}

extension GetPullRequestOverrideStateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pullRequestId
        case revisionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

public struct GetPullRequestOverrideStateInputHeadersMiddleware: Middleware {
    public let id: String = "GetPullRequestOverrideStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPullRequestOverrideStateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPullRequestOverrideStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPullRequestOverrideStateInput>
    public typealias MOutput = OperationOutput<GetPullRequestOverrideStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPullRequestOverrideStateOutputError>
}

public struct GetPullRequestOverrideStateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPullRequestOverrideStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPullRequestOverrideStateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPullRequestOverrideStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPullRequestOverrideStateInput>
    public typealias MOutput = OperationOutput<GetPullRequestOverrideStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPullRequestOverrideStateOutputError>
}

public struct GetPullRequestOverrideStateInput: Equatable {
    /// <p>The ID of the pull request for which you want to get information about whether approval rules have been set aside (overridden).</p>
    public let pullRequestId: String?
    /// <p>The system-generated ID of the revision for the pull request. To retrieve the most
    ///             recent revision ID, use
    ///             <a>GetPullRequest</a>.</p>
    public let revisionId: String?

    public init (
        pullRequestId: String? = nil,
        revisionId: String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

struct GetPullRequestOverrideStateInputBody: Equatable {
    public let pullRequestId: String?
    public let revisionId: String?
}

extension GetPullRequestOverrideStateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pullRequestId
        case revisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GetPullRequestOverrideStateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPullRequestOverrideStateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRevisionIdException" : self = .invalidRevisionIdException(try InvalidRevisionIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RevisionIdRequiredException" : self = .revisionIdRequiredException(try RevisionIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPullRequestOverrideStateOutputError: Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidRevisionIdException(InvalidRevisionIdException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case revisionIdRequiredException(RevisionIdRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPullRequestOverrideStateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPullRequestOverrideStateOutputResponse(overridden: \(String(describing: overridden)), overrider: \(String(describing: overrider)))"}
}

extension GetPullRequestOverrideStateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPullRequestOverrideStateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.overridden = output.overridden
            self.overrider = output.overrider
        } else {
            self.overridden = false
            self.overrider = nil
        }
    }
}

public struct GetPullRequestOverrideStateOutputResponse: Equatable {
    /// <p>A Boolean value that indicates whether a pull request has had its rules set aside (TRUE) or whether all approval rules still apply (FALSE).</p>
    public let overridden: Bool
    /// <p>The Amazon Resource Name (ARN) of the user or identity that overrode the rules and their requirements for the pull request.</p>
    public let overrider: String?

    public init (
        overridden: Bool = false,
        overrider: String? = nil
    )
    {
        self.overridden = overridden
        self.overrider = overrider
    }
}

struct GetPullRequestOverrideStateOutputResponseBody: Equatable {
    public let overridden: Bool
    public let overrider: String?
}

extension GetPullRequestOverrideStateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case overridden
        case overrider
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overriddenDecoded = try containerValues.decode(Bool.self, forKey: .overridden)
        overridden = overriddenDecoded
        let overriderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .overrider)
        overrider = overriderDecoded
    }
}

public struct GetRepositoryInputBodyMiddleware: Middleware {
    public let id: String = "GetRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryInput>
    public typealias MOutput = OperationOutput<GetRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryOutputError>
}

extension GetRepositoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRepositoryInput(repositoryName: \(String(describing: repositoryName)))"}
}

extension GetRepositoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetRepositoryInputHeadersMiddleware: Middleware {
    public let id: String = "GetRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryInput>
    public typealias MOutput = OperationOutput<GetRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryOutputError>
}

public struct GetRepositoryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryInput>
    public typealias MOutput = OperationOutput<GetRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryOutputError>
}

/// <p>Represents the input of a get repository operation.</p>
public struct GetRepositoryInput: Equatable {
    /// <p>The name of the repository to get information about.</p>
    public let repositoryName: String?

    public init (
        repositoryName: String? = nil
    )
    {
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryInputBody: Equatable {
    public let repositoryName: String?
}

extension GetRepositoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension GetRepositoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRepositoryOutputError: Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRepositoryOutputResponse(repositoryMetadata: \(String(describing: repositoryMetadata)))"}
}

extension GetRepositoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.repositoryMetadata = output.repositoryMetadata
        } else {
            self.repositoryMetadata = nil
        }
    }
}

/// <p>Represents the output of a get repository operation.</p>
public struct GetRepositoryOutputResponse: Equatable {
    /// <p>Information about the repository.</p>
    public let repositoryMetadata: RepositoryMetadata?

    public init (
        repositoryMetadata: RepositoryMetadata? = nil
    )
    {
        self.repositoryMetadata = repositoryMetadata
    }
}

struct GetRepositoryOutputResponseBody: Equatable {
    public let repositoryMetadata: RepositoryMetadata?
}

extension GetRepositoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repositoryMetadata
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryMetadataDecoded = try containerValues.decodeIfPresent(RepositoryMetadata.self, forKey: .repositoryMetadata)
        repositoryMetadata = repositoryMetadataDecoded
    }
}

public struct GetRepositoryTriggersInputBodyMiddleware: Middleware {
    public let id: String = "GetRepositoryTriggersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryTriggersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryTriggersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryTriggersInput>
    public typealias MOutput = OperationOutput<GetRepositoryTriggersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryTriggersOutputError>
}

extension GetRepositoryTriggersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRepositoryTriggersInput(repositoryName: \(String(describing: repositoryName)))"}
}

extension GetRepositoryTriggersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetRepositoryTriggersInputHeadersMiddleware: Middleware {
    public let id: String = "GetRepositoryTriggersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryTriggersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryTriggersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryTriggersInput>
    public typealias MOutput = OperationOutput<GetRepositoryTriggersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryTriggersOutputError>
}

public struct GetRepositoryTriggersInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRepositoryTriggersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryTriggersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryTriggersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryTriggersInput>
    public typealias MOutput = OperationOutput<GetRepositoryTriggersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryTriggersOutputError>
}

/// <p>Represents the input of a get repository triggers operation.</p>
public struct GetRepositoryTriggersInput: Equatable {
    /// <p>The name of the repository for which the trigger is configured.</p>
    public let repositoryName: String?

    public init (
        repositoryName: String? = nil
    )
    {
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryTriggersInputBody: Equatable {
    public let repositoryName: String?
}

extension GetRepositoryTriggersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension GetRepositoryTriggersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryTriggersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRepositoryTriggersOutputError: Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryTriggersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRepositoryTriggersOutputResponse(configurationId: \(String(describing: configurationId)), triggers: \(String(describing: triggers)))"}
}

extension GetRepositoryTriggersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRepositoryTriggersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationId = output.configurationId
            self.triggers = output.triggers
        } else {
            self.configurationId = nil
            self.triggers = nil
        }
    }
}

/// <p>Represents the output of a get repository triggers operation.</p>
public struct GetRepositoryTriggersOutputResponse: Equatable {
    /// <p>The system-generated unique ID for the trigger.</p>
    public let configurationId: String?
    /// <p>The JSON block of configuration information for each trigger.</p>
    public let triggers: [RepositoryTrigger]?

    public init (
        configurationId: String? = nil,
        triggers: [RepositoryTrigger]? = nil
    )
    {
        self.configurationId = configurationId
        self.triggers = triggers
    }
}

struct GetRepositoryTriggersOutputResponseBody: Equatable {
    public let configurationId: String?
    public let triggers: [RepositoryTrigger]?
}

extension GetRepositoryTriggersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationId
        case triggers
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let triggersContainer = try containerValues.decodeIfPresent([RepositoryTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[RepositoryTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [RepositoryTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
    }
}

extension IdempotencyParameterMismatchException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdempotencyParameterMismatchException(message: \(String(describing: message)))"}
}

extension IdempotencyParameterMismatchException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IdempotencyParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The client request token is not valid. Either the token is not in a valid format, or
///             the token has been used in a previous request and cannot be reused.</p>
public struct IdempotencyParameterMismatchException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotencyParameterMismatchExceptionBody: Equatable {
    public let message: String?
}

extension IdempotencyParameterMismatchExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidActorArnException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidActorArnException(message: \(String(describing: message)))"}
}

extension InvalidActorArnException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidActorArnExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the user who initiated the change for the pull request,
///             and then try again.</p>
public struct InvalidActorArnException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidActorArnExceptionBody: Equatable {
    public let message: String?
}

extension InvalidActorArnExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalRuleContentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidApprovalRuleContentException(message: \(String(describing: message)))"}
}

extension InvalidApprovalRuleContentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidApprovalRuleContentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The content for the approval rule is not valid.</p>
public struct InvalidApprovalRuleContentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidApprovalRuleContentExceptionBody: Equatable {
    public let message: String?
}

extension InvalidApprovalRuleContentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalRuleNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidApprovalRuleNameException(message: \(String(describing: message)))"}
}

extension InvalidApprovalRuleNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidApprovalRuleNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The name for the approval rule is not valid.</p>
public struct InvalidApprovalRuleNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidApprovalRuleNameExceptionBody: Equatable {
    public let message: String?
}

extension InvalidApprovalRuleNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalRuleTemplateContentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidApprovalRuleTemplateContentException(message: \(String(describing: message)))"}
}

extension InvalidApprovalRuleTemplateContentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidApprovalRuleTemplateContentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The content of the approval rule template is not valid.</p>
public struct InvalidApprovalRuleTemplateContentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidApprovalRuleTemplateContentExceptionBody: Equatable {
    public let message: String?
}

extension InvalidApprovalRuleTemplateContentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalRuleTemplateDescriptionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidApprovalRuleTemplateDescriptionException(message: \(String(describing: message)))"}
}

extension InvalidApprovalRuleTemplateDescriptionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidApprovalRuleTemplateDescriptionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The description for the approval rule template is not valid because it exceeds the
///             maximum characters allowed for a description. For more information about limits in AWS
///             CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User
///             Guide</a>.</p>
public struct InvalidApprovalRuleTemplateDescriptionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidApprovalRuleTemplateDescriptionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidApprovalRuleTemplateDescriptionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalRuleTemplateNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidApprovalRuleTemplateNameException(message: \(String(describing: message)))"}
}

extension InvalidApprovalRuleTemplateNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidApprovalRuleTemplateNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The name of the approval rule template is not valid. Template names must be between 1
///             and 100 valid characters in length. For more information about limits in AWS CodeCommit,
///             see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS
///                 CodeCommit User Guide</a>.</p>
public struct InvalidApprovalRuleTemplateNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidApprovalRuleTemplateNameExceptionBody: Equatable {
    public let message: String?
}

extension InvalidApprovalRuleTemplateNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidApprovalStateException(message: \(String(describing: message)))"}
}

extension InvalidApprovalStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidApprovalStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The state for the approval is not valid. Valid values include APPROVE and REVOKE. </p>
public struct InvalidApprovalStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidApprovalStateExceptionBody: Equatable {
    public let message: String?
}

extension InvalidApprovalStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAuthorArnException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidAuthorArnException(message: \(String(describing: message)))"}
}

extension InvalidAuthorArnException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidAuthorArnExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the author of the pull request, and then try again.</p>
public struct InvalidAuthorArnException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAuthorArnExceptionBody: Equatable {
    public let message: String?
}

extension InvalidAuthorArnExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidBlobIdException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidBlobIdException(message: \(String(describing: message)))"}
}

extension InvalidBlobIdException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidBlobIdExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified blob is not valid.</p>
public struct InvalidBlobIdException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidBlobIdExceptionBody: Equatable {
    public let message: String?
}

extension InvalidBlobIdExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidBranchNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidBranchNameException(message: \(String(describing: message)))"}
}

extension InvalidBranchNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidBranchNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified reference name is not valid.</p>
public struct InvalidBranchNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidBranchNameExceptionBody: Equatable {
    public let message: String?
}

extension InvalidBranchNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClientRequestTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidClientRequestTokenException(message: \(String(describing: message)))"}
}

extension InvalidClientRequestTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidClientRequestTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The client request token is not valid.</p>
public struct InvalidClientRequestTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClientRequestTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidClientRequestTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCommentIdException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidCommentIdException(message: \(String(describing: message)))"}
}

extension InvalidCommentIdException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidCommentIdExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The comment ID is not in a valid format. Make sure that you have provided the full comment ID.</p>
public struct InvalidCommentIdException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCommentIdExceptionBody: Equatable {
    public let message: String?
}

extension InvalidCommentIdExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCommitException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidCommitException(message: \(String(describing: message)))"}
}

extension InvalidCommitException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidCommitExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified commit is not valid.</p>
public struct InvalidCommitException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCommitExceptionBody: Equatable {
    public let message: String?
}

extension InvalidCommitExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCommitIdException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidCommitIdException(message: \(String(describing: message)))"}
}

extension InvalidCommitIdException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidCommitIdExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified commit ID is not valid.</p>
public struct InvalidCommitIdException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCommitIdExceptionBody: Equatable {
    public let message: String?
}

extension InvalidCommitIdExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidConflictDetailLevelException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidConflictDetailLevelException(message: \(String(describing: message)))"}
}

extension InvalidConflictDetailLevelException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidConflictDetailLevelExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified conflict detail level is not valid.</p>
public struct InvalidConflictDetailLevelException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidConflictDetailLevelExceptionBody: Equatable {
    public let message: String?
}

extension InvalidConflictDetailLevelExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidConflictResolutionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidConflictResolutionException(message: \(String(describing: message)))"}
}

extension InvalidConflictResolutionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidConflictResolutionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified conflict resolution list is not valid.</p>
public struct InvalidConflictResolutionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidConflictResolutionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidConflictResolutionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidConflictResolutionStrategyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidConflictResolutionStrategyException(message: \(String(describing: message)))"}
}

extension InvalidConflictResolutionStrategyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidConflictResolutionStrategyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified conflict resolution strategy is not valid.</p>
public struct InvalidConflictResolutionStrategyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidConflictResolutionStrategyExceptionBody: Equatable {
    public let message: String?
}

extension InvalidConflictResolutionStrategyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidContinuationTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidContinuationTokenException(message: \(String(describing: message)))"}
}

extension InvalidContinuationTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidContinuationTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified continuation token is not valid.</p>
public struct InvalidContinuationTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidContinuationTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidContinuationTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDeletionParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDeletionParameterException(message: \(String(describing: message)))"}
}

extension InvalidDeletionParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidDeletionParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified deletion parameter is not valid.</p>
public struct InvalidDeletionParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDeletionParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidDeletionParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDescriptionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDescriptionException(message: \(String(describing: message)))"}
}

extension InvalidDescriptionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidDescriptionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pull request description is not valid. Descriptions cannot be more than 1,000
///             characters.</p>
public struct InvalidDescriptionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDescriptionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidDescriptionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDestinationCommitSpecifierException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDestinationCommitSpecifierException(message: \(String(describing: message)))"}
}

extension InvalidDestinationCommitSpecifierException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidDestinationCommitSpecifierExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The destination commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID. </p>
public struct InvalidDestinationCommitSpecifierException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDestinationCommitSpecifierExceptionBody: Equatable {
    public let message: String?
}

extension InvalidDestinationCommitSpecifierExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEmailException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidEmailException(message: \(String(describing: message)))"}
}

extension InvalidEmailException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidEmailExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters
///         allowed for an email address.</p>
public struct InvalidEmailException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEmailExceptionBody: Equatable {
    public let message: String?
}

extension InvalidEmailExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFileLocationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidFileLocationException(message: \(String(describing: message)))"}
}

extension InvalidFileLocationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidFileLocationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The location of the file is not valid. Make sure that you include the file name and
///             extension.</p>
public struct InvalidFileLocationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFileLocationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidFileLocationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFileModeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidFileModeException(message: \(String(describing: message)))"}
}

extension InvalidFileModeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidFileModeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <a>PutFile</a>. </p>
public struct InvalidFileModeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFileModeExceptionBody: Equatable {
    public let message: String?
}

extension InvalidFileModeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFilePositionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidFilePositionException(message: \(String(describing: message)))"}
}

extension InvalidFilePositionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidFilePositionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The position is not valid. Make sure that the line number exists in the version of the file you want to comment on.</p>
public struct InvalidFilePositionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFilePositionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidFilePositionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMaxConflictFilesException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidMaxConflictFilesException(message: \(String(describing: message)))"}
}

extension InvalidMaxConflictFilesException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidMaxConflictFilesExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified value for the number of conflict files to return is not valid.</p>
public struct InvalidMaxConflictFilesException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMaxConflictFilesExceptionBody: Equatable {
    public let message: String?
}

extension InvalidMaxConflictFilesExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMaxMergeHunksException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidMaxMergeHunksException(message: \(String(describing: message)))"}
}

extension InvalidMaxMergeHunksException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidMaxMergeHunksExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified value for the number of merge hunks to return is not valid.</p>
public struct InvalidMaxMergeHunksException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMaxMergeHunksExceptionBody: Equatable {
    public let message: String?
}

extension InvalidMaxMergeHunksExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMaxResultsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidMaxResultsException(message: \(String(describing: message)))"}
}

extension InvalidMaxResultsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidMaxResultsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified number of maximum results is not valid.</p>
public struct InvalidMaxResultsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMaxResultsExceptionBody: Equatable {
    public let message: String?
}

extension InvalidMaxResultsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMergeOptionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidMergeOptionException(message: \(String(describing: message)))"}
}

extension InvalidMergeOptionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidMergeOptionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified merge option is not valid for this operation. Not all merge strategies are supported for all operations.</p>
public struct InvalidMergeOptionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMergeOptionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidMergeOptionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOrderException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidOrderException(message: \(String(describing: message)))"}
}

extension InvalidOrderException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidOrderExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified sort order is not valid.</p>
public struct InvalidOrderException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOrderExceptionBody: Equatable {
    public let message: String?
}

extension InvalidOrderExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOverrideStatusException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidOverrideStatusException(message: \(String(describing: message)))"}
}

extension InvalidOverrideStatusException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidOverrideStatusExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The override status is not valid. Valid statuses are OVERRIDE and REVOKE.</p>
public struct InvalidOverrideStatusException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOverrideStatusExceptionBody: Equatable {
    public let message: String?
}

extension InvalidOverrideStatusExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParentCommitIdException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParentCommitIdException(message: \(String(describing: message)))"}
}

extension InvalidParentCommitIdException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParentCommitIdExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The parent commit ID is not valid. The commit ID cannot be empty, and must match the head commit ID for the branch of the repository where you
///         want to add or update a file.</p>
public struct InvalidParentCommitIdException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParentCommitIdExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParentCommitIdExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPathException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPathException(message: \(String(describing: message)))"}
}

extension InvalidPathException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPathExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified path is not valid.</p>
public struct InvalidPathException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPathExceptionBody: Equatable {
    public let message: String?
}

extension InvalidPathExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPullRequestEventTypeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPullRequestEventTypeException(message: \(String(describing: message)))"}
}

extension InvalidPullRequestEventTypeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPullRequestEventTypeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pull request event type is not valid. </p>
public struct InvalidPullRequestEventTypeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPullRequestEventTypeExceptionBody: Equatable {
    public let message: String?
}

extension InvalidPullRequestEventTypeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPullRequestIdException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPullRequestIdException(message: \(String(describing: message)))"}
}

extension InvalidPullRequestIdException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPullRequestIdExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
public struct InvalidPullRequestIdException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPullRequestIdExceptionBody: Equatable {
    public let message: String?
}

extension InvalidPullRequestIdExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPullRequestStatusException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPullRequestStatusException(message: \(String(describing: message)))"}
}

extension InvalidPullRequestStatusException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPullRequestStatusExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pull request status is not valid. The only valid values are <code>OPEN</code> and <code>CLOSED</code>.</p>
public struct InvalidPullRequestStatusException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPullRequestStatusExceptionBody: Equatable {
    public let message: String?
}

extension InvalidPullRequestStatusExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPullRequestStatusUpdateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPullRequestStatusUpdateException(message: \(String(describing: message)))"}
}

extension InvalidPullRequestStatusUpdateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPullRequestStatusUpdateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pull request status update is not valid. The only valid update is from <code>OPEN</code> to <code>CLOSED</code>.</p>
public struct InvalidPullRequestStatusUpdateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPullRequestStatusUpdateExceptionBody: Equatable {
    public let message: String?
}

extension InvalidPullRequestStatusUpdateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidReactionUserArnException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidReactionUserArnException(message: \(String(describing: message)))"}
}

extension InvalidReactionUserArnException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidReactionUserArnExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Amazon Resource Name (ARN) of the user or identity is not valid.</p>
public struct InvalidReactionUserArnException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidReactionUserArnExceptionBody: Equatable {
    public let message: String?
}

extension InvalidReactionUserArnExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidReactionValueException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidReactionValueException(message: \(String(describing: message)))"}
}

extension InvalidReactionValueException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidReactionValueExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value of the reaction is not valid. For more information, see the <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">AWS CodeCommit User Guide</a>.</p>
public struct InvalidReactionValueException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidReactionValueExceptionBody: Equatable {
    public let message: String?
}

extension InvalidReactionValueExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidReferenceNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidReferenceNameException(message: \(String(describing: message)))"}
}

extension InvalidReferenceNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidReferenceNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified reference name format is not valid. Reference names must conform to the
///             Git references format (for example, refs/heads/master). For more information, see <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-References">Git Internals -
///                 Git References</a> or consult your Git documentation.</p>
public struct InvalidReferenceNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidReferenceNameExceptionBody: Equatable {
    public let message: String?
}

extension InvalidReferenceNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRelativeFileVersionEnumException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRelativeFileVersionEnumException(message: \(String(describing: message)))"}
}

extension InvalidRelativeFileVersionEnumException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRelativeFileVersionEnumExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Either the enum is not in a valid format, or the specified file version enum is not valid in respect to the current file version.</p>
public struct InvalidRelativeFileVersionEnumException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRelativeFileVersionEnumExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRelativeFileVersionEnumExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidReplacementContentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidReplacementContentException(message: \(String(describing: message)))"}
}

extension InvalidReplacementContentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidReplacementContentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing. </p>
public struct InvalidReplacementContentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidReplacementContentExceptionBody: Equatable {
    public let message: String?
}

extension InvalidReplacementContentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidReplacementTypeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidReplacementTypeException(message: \(String(describing: message)))"}
}

extension InvalidReplacementTypeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidReplacementTypeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Automerge was specified for resolving the conflict, but the specified replacement type is not valid.</p>
public struct InvalidReplacementTypeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidReplacementTypeExceptionBody: Equatable {
    public let message: String?
}

extension InvalidReplacementTypeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryDescriptionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRepositoryDescriptionException(message: \(String(describing: message)))"}
}

extension InvalidRepositoryDescriptionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRepositoryDescriptionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified repository description is not valid.</p>
public struct InvalidRepositoryDescriptionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRepositoryDescriptionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRepositoryDescriptionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRepositoryNameException(message: \(String(describing: message)))"}
}

extension InvalidRepositoryNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRepositoryNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A specified repository name is not valid.</p>
///
///         <note>
///             <p>This exception occurs only when a specified repository name is not valid. Other
///                 exceptions occur when a required repository parameter is missing, or when a
///                 specified repository does not exist.</p>
///          </note>
public struct InvalidRepositoryNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRepositoryNameExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRepositoryNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryTriggerBranchNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRepositoryTriggerBranchNameException(message: \(String(describing: message)))"}
}

extension InvalidRepositoryTriggerBranchNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRepositoryTriggerBranchNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more branch names specified for the trigger is not valid.</p>
public struct InvalidRepositoryTriggerBranchNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRepositoryTriggerBranchNameExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRepositoryTriggerBranchNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryTriggerCustomDataException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRepositoryTriggerCustomDataException(message: \(String(describing: message)))"}
}

extension InvalidRepositoryTriggerCustomDataException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRepositoryTriggerCustomDataExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The custom data provided for the trigger is not valid.</p>
public struct InvalidRepositoryTriggerCustomDataException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRepositoryTriggerCustomDataExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRepositoryTriggerCustomDataExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryTriggerDestinationArnException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRepositoryTriggerDestinationArnException(message: \(String(describing: message)))"}
}

extension InvalidRepositoryTriggerDestinationArnException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRepositoryTriggerDestinationArnExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Amazon Resource Name (ARN) for the trigger is not valid for the specified destination. The most common reason for this error is that the ARN does not meet the requirements for the service type.</p>
public struct InvalidRepositoryTriggerDestinationArnException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRepositoryTriggerDestinationArnExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRepositoryTriggerDestinationArnExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryTriggerEventsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRepositoryTriggerEventsException(message: \(String(describing: message)))"}
}

extension InvalidRepositoryTriggerEventsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRepositoryTriggerEventsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more events specified for the trigger is not valid. Check to make sure that all events specified match the requirements for allowed events.</p>
public struct InvalidRepositoryTriggerEventsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRepositoryTriggerEventsExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRepositoryTriggerEventsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryTriggerNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRepositoryTriggerNameException(message: \(String(describing: message)))"}
}

extension InvalidRepositoryTriggerNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRepositoryTriggerNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The name of the trigger is not valid.</p>
public struct InvalidRepositoryTriggerNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRepositoryTriggerNameExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRepositoryTriggerNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRepositoryTriggerRegionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRepositoryTriggerRegionException(message: \(String(describing: message)))"}
}

extension InvalidRepositoryTriggerRegionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRepositoryTriggerRegionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The AWS Region for the trigger target does not match the AWS Region for the
///             repository. Triggers must be created in the same Region as the target for the
///             trigger.</p>
public struct InvalidRepositoryTriggerRegionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRepositoryTriggerRegionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRepositoryTriggerRegionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceArnException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidResourceArnException(message: \(String(describing: message)))"}
}

extension InvalidResourceArnException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidResourceArnExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value for the resource ARN is not valid. For more information about resources in AWS CodeCommit, see
///             <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a>
///             in the AWS CodeCommit User Guide.</p>
public struct InvalidResourceArnException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceArnExceptionBody: Equatable {
    public let message: String?
}

extension InvalidResourceArnExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRevisionIdException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRevisionIdException(message: \(String(describing: message)))"}
}

extension InvalidRevisionIdException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRevisionIdExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The revision ID is not valid. Use GetPullRequest to determine the value.</p>
public struct InvalidRevisionIdException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRevisionIdExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRevisionIdExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRuleContentSha256Exception: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRuleContentSha256Exception(message: \(String(describing: message)))"}
}

extension InvalidRuleContentSha256Exception: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRuleContentSha256ExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The SHA-256 hash signature for the rule content is not valid.</p>
public struct InvalidRuleContentSha256Exception: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRuleContentSha256ExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRuleContentSha256ExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSortByException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSortByException(message: \(String(describing: message)))"}
}

extension InvalidSortByException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidSortByExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified sort by value is not valid.</p>
public struct InvalidSortByException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSortByExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSortByExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSourceCommitSpecifierException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSourceCommitSpecifierException(message: \(String(describing: message)))"}
}

extension InvalidSourceCommitSpecifierException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidSourceCommitSpecifierExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The source commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID.</p>
public struct InvalidSourceCommitSpecifierException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSourceCommitSpecifierExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSourceCommitSpecifierExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSystemTagUsageException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSystemTagUsageException(message: \(String(describing: message)))"}
}

extension InvalidSystemTagUsageException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidSystemTagUsageExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified tag is not valid. Key names cannot be prefixed with aws:.</p>
public struct InvalidSystemTagUsageException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSystemTagUsageExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSystemTagUsageExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagKeysListException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTagKeysListException(message: \(String(describing: message)))"}
}

extension InvalidTagKeysListException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTagKeysListExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The list of tags is not valid.</p>
public struct InvalidTagKeysListException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagKeysListExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTagKeysListExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagsMapException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTagsMapException(message: \(String(describing: message)))"}
}

extension InvalidTagsMapException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTagsMapExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The map of tags is not valid.</p>
public struct InvalidTagsMapException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagsMapExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTagsMapExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTargetBranchException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTargetBranchException(message: \(String(describing: message)))"}
}

extension InvalidTargetBranchException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTargetBranchExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified target branch is not valid.</p>
public struct InvalidTargetBranchException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTargetBranchExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTargetBranchExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTargetException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTargetException(message: \(String(describing: message)))"}
}

extension InvalidTargetException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTargetExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The target for the pull request is not valid. A target must contain the full values for the repository name, source branch, and destination branch for the pull request.</p>
public struct InvalidTargetException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTargetExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTargetExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTargetsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTargetsException(message: \(String(describing: message)))"}
}

extension InvalidTargetsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTargetsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The targets for the pull request is not valid or not in a valid format. Targets are a list of target objects. Each target object must contain the full values for
///             the repository name, source branch, and destination branch for a pull request.</p>
public struct InvalidTargetsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTargetsExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTargetsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTitleException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTitleException(message: \(String(describing: message)))"}
}

extension InvalidTitleException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTitleExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The title of the pull request is not valid. Pull request titles cannot exceed 100 characters in length.</p>
public struct InvalidTitleException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTitleExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTitleExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IsBinaryFile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case base
        case destination
        case source
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let base = base {
            try encodeContainer.encode(base, forKey: .base)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .destination)
        destination = destinationDecoded
        let baseDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .base)
        base = baseDecoded
    }
}

extension IsBinaryFile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IsBinaryFile(base: \(String(describing: base)), destination: \(String(describing: destination)), source: \(String(describing: source)))"}
}

/// <p>Information about whether a file is binary or textual in a merge or pull request operation.</p>
public struct IsBinaryFile: Equatable {
    /// <p>The binary or non-binary status of a file in the base of a merge or pull request.</p>
    public let base: Bool?
    /// <p>The binary or non-binary status of a file in the destination of a merge or pull request.</p>
    public let destination: Bool?
    /// <p>The binary or non-binary status of file in the source of a merge or pull request.</p>
    public let source: Bool?

    public init (
        base: Bool? = nil,
        destination: Bool? = nil,
        source: Bool? = nil
    )
    {
        self.base = base
        self.destination = destination
        self.source = source
    }
}

public struct ListApprovalRuleTemplatesInputBodyMiddleware: Middleware {
    public let id: String = "ListApprovalRuleTemplatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApprovalRuleTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApprovalRuleTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApprovalRuleTemplatesInput>
    public typealias MOutput = OperationOutput<ListApprovalRuleTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApprovalRuleTemplatesOutputError>
}

extension ListApprovalRuleTemplatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApprovalRuleTemplatesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApprovalRuleTemplatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListApprovalRuleTemplatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListApprovalRuleTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApprovalRuleTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApprovalRuleTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApprovalRuleTemplatesInput>
    public typealias MOutput = OperationOutput<ListApprovalRuleTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApprovalRuleTemplatesOutputError>
}

public struct ListApprovalRuleTemplatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListApprovalRuleTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApprovalRuleTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApprovalRuleTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApprovalRuleTemplatesInput>
    public typealias MOutput = OperationOutput<ListApprovalRuleTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApprovalRuleTemplatesOutputError>
}

public struct ListApprovalRuleTemplatesInput: Equatable {
    /// <p>A non-zero, non-negative integer used to limit the number of returned results.</p>
    public let maxResults: Int?
    /// <p>An enumeration token that, when provided in a request, returns the next batch of the
    ///             results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApprovalRuleTemplatesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListApprovalRuleTemplatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListApprovalRuleTemplatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApprovalRuleTemplatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApprovalRuleTemplatesOutputError: Equatable {
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApprovalRuleTemplatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApprovalRuleTemplatesOutputResponse(approvalRuleTemplateNames: \(String(describing: approvalRuleTemplateNames)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApprovalRuleTemplatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListApprovalRuleTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.approvalRuleTemplateNames = output.approvalRuleTemplateNames
            self.nextToken = output.nextToken
        } else {
            self.approvalRuleTemplateNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListApprovalRuleTemplatesOutputResponse: Equatable {
    /// <p>The names of all the approval rule templates found in the AWS Region for your AWS account.</p>
    public let approvalRuleTemplateNames: [String]?
    /// <p>An enumeration token that allows the operation to batch the next results of the operation.</p>
    public let nextToken: String?

    public init (
        approvalRuleTemplateNames: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.approvalRuleTemplateNames = approvalRuleTemplateNames
        self.nextToken = nextToken
    }
}

struct ListApprovalRuleTemplatesOutputResponseBody: Equatable {
    public let approvalRuleTemplateNames: [String]?
    public let nextToken: String?
}

extension ListApprovalRuleTemplatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateNames
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .approvalRuleTemplateNames)
        var approvalRuleTemplateNamesDecoded0:[String]? = nil
        if let approvalRuleTemplateNamesContainer = approvalRuleTemplateNamesContainer {
            approvalRuleTemplateNamesDecoded0 = [String]()
            for string0 in approvalRuleTemplateNamesContainer {
                if let string0 = string0 {
                    approvalRuleTemplateNamesDecoded0?.append(string0)
                }
            }
        }
        approvalRuleTemplateNames = approvalRuleTemplateNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAssociatedApprovalRuleTemplatesForRepositoryInputBodyMiddleware: Middleware {
    public let id: String = "ListAssociatedApprovalRuleTemplatesForRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociatedApprovalRuleTemplatesForRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociatedApprovalRuleTemplatesForRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociatedApprovalRuleTemplatesForRepositoryInput>
    public typealias MOutput = OperationOutput<ListAssociatedApprovalRuleTemplatesForRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociatedApprovalRuleTemplatesForRepositoryOutputError>
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssociatedApprovalRuleTemplatesForRepositoryInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), repositoryName: \(String(describing: repositoryName)))"}
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct ListAssociatedApprovalRuleTemplatesForRepositoryInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssociatedApprovalRuleTemplatesForRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociatedApprovalRuleTemplatesForRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociatedApprovalRuleTemplatesForRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociatedApprovalRuleTemplatesForRepositoryInput>
    public typealias MOutput = OperationOutput<ListAssociatedApprovalRuleTemplatesForRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociatedApprovalRuleTemplatesForRepositoryOutputError>
}

public struct ListAssociatedApprovalRuleTemplatesForRepositoryInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssociatedApprovalRuleTemplatesForRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssociatedApprovalRuleTemplatesForRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssociatedApprovalRuleTemplatesForRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssociatedApprovalRuleTemplatesForRepositoryInput>
    public typealias MOutput = OperationOutput<ListAssociatedApprovalRuleTemplatesForRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssociatedApprovalRuleTemplatesForRepositoryOutputError>
}

public struct ListAssociatedApprovalRuleTemplatesForRepositoryInput: Equatable {
    /// <p>A non-zero, non-negative integer used to limit the number of returned results.</p>
    public let maxResults: Int?
    /// <p>An enumeration token that, when provided in a request, returns the next batch of the
    ///             results.</p>
    public let nextToken: String?
    /// <p>The name of the repository for which you want to list all associated approval rule templates.</p>
    public let repositoryName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryName = repositoryName
    }
}

struct ListAssociatedApprovalRuleTemplatesForRepositoryInputBody: Equatable {
    public let repositoryName: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociatedApprovalRuleTemplatesForRepositoryOutputError: Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssociatedApprovalRuleTemplatesForRepositoryOutputResponse(approvalRuleTemplateNames: \(String(describing: approvalRuleTemplateNames)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssociatedApprovalRuleTemplatesForRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.approvalRuleTemplateNames = output.approvalRuleTemplateNames
            self.nextToken = output.nextToken
        } else {
            self.approvalRuleTemplateNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociatedApprovalRuleTemplatesForRepositoryOutputResponse: Equatable {
    /// <p>The names of all approval rule templates associated with the repository.</p>
    public let approvalRuleTemplateNames: [String]?
    /// <p>An enumeration token that allows the operation to batch the next results of the operation.</p>
    public let nextToken: String?

    public init (
        approvalRuleTemplateNames: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.approvalRuleTemplateNames = approvalRuleTemplateNames
        self.nextToken = nextToken
    }
}

struct ListAssociatedApprovalRuleTemplatesForRepositoryOutputResponseBody: Equatable {
    public let approvalRuleTemplateNames: [String]?
    public let nextToken: String?
}

extension ListAssociatedApprovalRuleTemplatesForRepositoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateNames
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .approvalRuleTemplateNames)
        var approvalRuleTemplateNamesDecoded0:[String]? = nil
        if let approvalRuleTemplateNamesContainer = approvalRuleTemplateNamesContainer {
            approvalRuleTemplateNamesDecoded0 = [String]()
            for string0 in approvalRuleTemplateNamesContainer {
                if let string0 = string0 {
                    approvalRuleTemplateNamesDecoded0?.append(string0)
                }
            }
        }
        approvalRuleTemplateNames = approvalRuleTemplateNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListBranchesInputBodyMiddleware: Middleware {
    public let id: String = "ListBranchesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBranchesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBranchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBranchesInput>
    public typealias MOutput = OperationOutput<ListBranchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBranchesOutputError>
}

extension ListBranchesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBranchesInput(nextToken: \(String(describing: nextToken)), repositoryName: \(String(describing: repositoryName)))"}
}

extension ListBranchesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct ListBranchesInputHeadersMiddleware: Middleware {
    public let id: String = "ListBranchesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBranchesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBranchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBranchesInput>
    public typealias MOutput = OperationOutput<ListBranchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBranchesOutputError>
}

public struct ListBranchesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBranchesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBranchesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBranchesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBranchesInput>
    public typealias MOutput = OperationOutput<ListBranchesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBranchesOutputError>
}

/// <p>Represents the input of a list branches operation.</p>
public struct ListBranchesInput: Equatable {
    /// <p>An enumeration token that allows the operation to batch the results.</p>
    public let nextToken: String?
    /// <p>The name of the repository that contains the branches.</p>
    public let repositoryName: String?

    public init (
        nextToken: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.nextToken = nextToken
        self.repositoryName = repositoryName
    }
}

struct ListBranchesInputBody: Equatable {
    public let repositoryName: String?
    public let nextToken: String?
}

extension ListBranchesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListBranchesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBranchesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBranchesOutputError: Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBranchesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBranchesOutputResponse(branches: \(String(describing: branches)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBranchesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBranchesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.branches = output.branches
            self.nextToken = output.nextToken
        } else {
            self.branches = nil
            self.nextToken = nil
        }
    }
}

/// <p>Represents the output of a list branches operation.</p>
public struct ListBranchesOutputResponse: Equatable {
    /// <p>The list of branch names.</p>
    public let branches: [String]?
    /// <p>An enumeration token that returns the batch of the results.</p>
    public let nextToken: String?

    public init (
        branches: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.branches = branches
        self.nextToken = nextToken
    }
}

struct ListBranchesOutputResponseBody: Equatable {
    public let branches: [String]?
    public let nextToken: String?
}

extension ListBranchesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case branches
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .branches)
        var branchesDecoded0:[String]? = nil
        if let branchesContainer = branchesContainer {
            branchesDecoded0 = [String]()
            for string0 in branchesContainer {
                if let string0 = string0 {
                    branchesDecoded0?.append(string0)
                }
            }
        }
        branches = branchesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPullRequestsInputBodyMiddleware: Middleware {
    public let id: String = "ListPullRequestsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPullRequestsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPullRequestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPullRequestsInput>
    public typealias MOutput = OperationOutput<ListPullRequestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPullRequestsOutputError>
}

extension ListPullRequestsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPullRequestsInput(authorArn: \(String(describing: authorArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), pullRequestStatus: \(String(describing: pullRequestStatus)), repositoryName: \(String(describing: repositoryName)))"}
}

extension ListPullRequestsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorArn
        case maxResults
        case nextToken
        case pullRequestStatus
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorArn = authorArn {
            try encodeContainer.encode(authorArn, forKey: .authorArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pullRequestStatus = pullRequestStatus {
            try encodeContainer.encode(pullRequestStatus.rawValue, forKey: .pullRequestStatus)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct ListPullRequestsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPullRequestsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPullRequestsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPullRequestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPullRequestsInput>
    public typealias MOutput = OperationOutput<ListPullRequestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPullRequestsOutputError>
}

public struct ListPullRequestsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPullRequestsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPullRequestsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPullRequestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPullRequestsInput>
    public typealias MOutput = OperationOutput<ListPullRequestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPullRequestsOutputError>
}

public struct ListPullRequestsInput: Equatable {
    /// <p>Optional. The Amazon Resource Name (ARN) of the user who created the pull request. If used, this filters the results
    ///         to pull requests created by that user.</p>
    public let authorArn: String?
    /// <p>A non-zero, non-negative integer used to limit the number of returned results.</p>
    public let maxResults: Int?
    /// <p>An enumeration token that, when provided in a request, returns the next batch of the
    ///             results.</p>
    public let nextToken: String?
    /// <p>Optional. The status of the pull request. If used, this refines the results to the pull requests that match the specified status.</p>
    public let pullRequestStatus: PullRequestStatusEnum?
    /// <p>The name of the repository for which you want to list pull requests.</p>
    public let repositoryName: String?

    public init (
        authorArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        pullRequestStatus: PullRequestStatusEnum? = nil,
        repositoryName: String? = nil
    )
    {
        self.authorArn = authorArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pullRequestStatus = pullRequestStatus
        self.repositoryName = repositoryName
    }
}

struct ListPullRequestsInputBody: Equatable {
    public let repositoryName: String?
    public let authorArn: String?
    public let pullRequestStatus: PullRequestStatusEnum?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListPullRequestsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorArn
        case maxResults
        case nextToken
        case pullRequestStatus
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let authorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorArn)
        authorArn = authorArnDecoded
        let pullRequestStatusDecoded = try containerValues.decodeIfPresent(PullRequestStatusEnum.self, forKey: .pullRequestStatus)
        pullRequestStatus = pullRequestStatusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPullRequestsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPullRequestsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthorDoesNotExistException" : self = .authorDoesNotExistException(try AuthorDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAuthorArnException" : self = .invalidAuthorArnException(try InvalidAuthorArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestStatusException" : self = .invalidPullRequestStatusException(try InvalidPullRequestStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPullRequestsOutputError: Equatable {
    case authorDoesNotExistException(AuthorDoesNotExistException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidAuthorArnException(InvalidAuthorArnException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidPullRequestStatusException(InvalidPullRequestStatusException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPullRequestsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPullRequestsOutputResponse(nextToken: \(String(describing: nextToken)), pullRequestIds: \(String(describing: pullRequestIds)))"}
}

extension ListPullRequestsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPullRequestsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.pullRequestIds = output.pullRequestIds
        } else {
            self.nextToken = nil
            self.pullRequestIds = nil
        }
    }
}

public struct ListPullRequestsOutputResponse: Equatable {
    /// <p>An enumeration token that allows the operation to batch the next results of the operation.</p>
    public let nextToken: String?
    /// <p>The system-generated IDs of the pull requests.</p>
    public let pullRequestIds: [String]?

    public init (
        nextToken: String? = nil,
        pullRequestIds: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.pullRequestIds = pullRequestIds
    }
}

struct ListPullRequestsOutputResponseBody: Equatable {
    public let pullRequestIds: [String]?
    public let nextToken: String?
}

extension ListPullRequestsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case pullRequestIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .pullRequestIds)
        var pullRequestIdsDecoded0:[String]? = nil
        if let pullRequestIdsContainer = pullRequestIdsContainer {
            pullRequestIdsDecoded0 = [String]()
            for string0 in pullRequestIdsContainer {
                if let string0 = string0 {
                    pullRequestIdsDecoded0?.append(string0)
                }
            }
        }
        pullRequestIds = pullRequestIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRepositoriesForApprovalRuleTemplateInputBodyMiddleware: Middleware {
    public let id: String = "ListRepositoriesForApprovalRuleTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRepositoriesForApprovalRuleTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRepositoriesForApprovalRuleTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRepositoriesForApprovalRuleTemplateInput>
    public typealias MOutput = OperationOutput<ListRepositoriesForApprovalRuleTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRepositoriesForApprovalRuleTemplateOutputError>
}

extension ListRepositoriesForApprovalRuleTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRepositoriesForApprovalRuleTemplateInput(approvalRuleTemplateName: \(String(describing: approvalRuleTemplateName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRepositoriesForApprovalRuleTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateName
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRepositoriesForApprovalRuleTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "ListRepositoriesForApprovalRuleTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRepositoriesForApprovalRuleTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRepositoriesForApprovalRuleTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRepositoriesForApprovalRuleTemplateInput>
    public typealias MOutput = OperationOutput<ListRepositoriesForApprovalRuleTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRepositoriesForApprovalRuleTemplateOutputError>
}

public struct ListRepositoriesForApprovalRuleTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRepositoriesForApprovalRuleTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRepositoriesForApprovalRuleTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRepositoriesForApprovalRuleTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRepositoriesForApprovalRuleTemplateInput>
    public typealias MOutput = OperationOutput<ListRepositoriesForApprovalRuleTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRepositoriesForApprovalRuleTemplateOutputError>
}

public struct ListRepositoriesForApprovalRuleTemplateInput: Equatable {
    /// <p>The name of the approval rule template for which you want to list repositories that are associated with that template.</p>
    public let approvalRuleTemplateName: String?
    /// <p>A non-zero, non-negative integer used to limit the number of returned results.</p>
    public let maxResults: Int?
    /// <p>An enumeration token that, when provided in a request, returns the next batch of the
    ///             results.</p>
    public let nextToken: String?

    public init (
        approvalRuleTemplateName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRepositoriesForApprovalRuleTemplateInputBody: Equatable {
    public let approvalRuleTemplateName: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListRepositoriesForApprovalRuleTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateName
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRepositoriesForApprovalRuleTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRepositoriesForApprovalRuleTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateDoesNotExistException" : self = .approvalRuleTemplateDoesNotExistException(try ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRepositoriesForApprovalRuleTemplateOutputError: Equatable {
    case approvalRuleTemplateDoesNotExistException(ApprovalRuleTemplateDoesNotExistException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRepositoriesForApprovalRuleTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRepositoriesForApprovalRuleTemplateOutputResponse(nextToken: \(String(describing: nextToken)), repositoryNames: \(String(describing: repositoryNames)))"}
}

extension ListRepositoriesForApprovalRuleTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRepositoriesForApprovalRuleTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.repositoryNames = output.repositoryNames
        } else {
            self.nextToken = nil
            self.repositoryNames = nil
        }
    }
}

public struct ListRepositoriesForApprovalRuleTemplateOutputResponse: Equatable {
    /// <p>An enumeration token that allows the operation to batch the next results of the operation.</p>
    public let nextToken: String?
    /// <p>A list of repository names that are associated with the specified approval rule template.</p>
    public let repositoryNames: [String]?

    public init (
        nextToken: String? = nil,
        repositoryNames: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositoryNames = repositoryNames
    }
}

struct ListRepositoriesForApprovalRuleTemplateOutputResponseBody: Equatable {
    public let repositoryNames: [String]?
    public let nextToken: String?
}

extension ListRepositoriesForApprovalRuleTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case repositoryNames
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRepositoriesInputBodyMiddleware: Middleware {
    public let id: String = "ListRepositoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRepositoriesInput>
    public typealias MOutput = OperationOutput<ListRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRepositoriesOutputError>
}

extension ListRepositoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRepositoriesInput(nextToken: \(String(describing: nextToken)), order: \(String(describing: order)), sortBy: \(String(describing: sortBy)))"}
}

extension ListRepositoriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case order
        case sortBy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let order = order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
    }
}

public struct ListRepositoriesInputHeadersMiddleware: Middleware {
    public let id: String = "ListRepositoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRepositoriesInput>
    public typealias MOutput = OperationOutput<ListRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRepositoriesOutputError>
}

public struct ListRepositoriesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRepositoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRepositoriesInput>
    public typealias MOutput = OperationOutput<ListRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRepositoriesOutputError>
}

/// <p>Represents the input of a list repositories operation.</p>
public struct ListRepositoriesInput: Equatable {
    /// <p>An enumeration token that allows the operation to batch the results of the operation.
    ///             Batch sizes are 1,000 for list repository operations. When the client sends the token back to AWS CodeCommit,
    ///             another page of 1,000 records is retrieved.</p>
    public let nextToken: String?
    /// <p>The order in which to sort the results of a list repositories operation.</p>
    public let order: OrderEnum?
    /// <p>The criteria used to sort the results of a list repositories operation.</p>
    public let sortBy: SortByEnum?

    public init (
        nextToken: String? = nil,
        order: OrderEnum? = nil,
        sortBy: SortByEnum? = nil
    )
    {
        self.nextToken = nextToken
        self.order = order
        self.sortBy = sortBy
    }
}

struct ListRepositoriesInputBody: Equatable {
    public let nextToken: String?
    public let sortBy: SortByEnum?
    public let order: OrderEnum?
}

extension ListRepositoriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case order
        case sortBy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(SortByEnum.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let orderDecoded = try containerValues.decodeIfPresent(OrderEnum.self, forKey: .order)
        order = orderDecoded
    }
}

extension ListRepositoriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRepositoriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidContinuationTokenException" : self = .invalidContinuationTokenException(try InvalidContinuationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOrderException" : self = .invalidOrderException(try InvalidOrderException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSortByException" : self = .invalidSortByException(try InvalidSortByException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRepositoriesOutputError: Equatable {
    case invalidContinuationTokenException(InvalidContinuationTokenException)
    case invalidOrderException(InvalidOrderException)
    case invalidSortByException(InvalidSortByException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRepositoriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRepositoriesOutputResponse(nextToken: \(String(describing: nextToken)), repositories: \(String(describing: repositories)))"}
}

extension ListRepositoriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRepositoriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

/// <p>Represents the output of a list repositories operation.</p>
public struct ListRepositoriesOutputResponse: Equatable {
    /// <p>An enumeration token that allows the operation to batch the results of the operation.
    ///             Batch sizes are 1,000 for list repository operations. When the client sends the token back to AWS CodeCommit,
    ///             another page of 1,000 records is retrieved.</p>
    public let nextToken: String?
    /// <p>Lists the repositories called by the list repositories operation.</p>
    public let repositories: [RepositoryNameIdPair]?

    public init (
        nextToken: String? = nil,
        repositories: [RepositoryNameIdPair]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct ListRepositoriesOutputResponseBody: Equatable {
    public let repositories: [RepositoryNameIdPair]?
    public let nextToken: String?
}

extension ListRepositoriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case repositories
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([RepositoryNameIdPair?].self, forKey: .repositories)
        var repositoriesDecoded0:[RepositoryNameIdPair]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [RepositoryNameIdPair]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case resourceArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>An enumeration token that, when provided in a request, returns the next batch of the
    ///             results.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the resource for which you want to get information
    ///             about tags, if any.</p>
    public let resourceArn: String?

    public init (
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
    public let nextToken: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceArnException" : self = .invalidResourceArnException(try InvalidResourceArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceArnRequiredException" : self = .resourceArnRequiredException(try ResourceArnRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidResourceArnException(InvalidResourceArnException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case resourceArnRequiredException(ResourceArnRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>An enumeration token that allows the operation to batch the next results of the operation.</p>
    public let nextToken: String?
    /// <p>A list of tag key and value pairs associated with the specified resource.</p>
    public let tags: [String:String]?

    public init (
        nextToken: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
    public let nextToken: String?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filePath
        case filePosition
        case relativeFileVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filePath = filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let filePosition = filePosition {
            try encodeContainer.encode(filePosition, forKey: .filePosition)
        }
        if let relativeFileVersion = relativeFileVersion {
            try encodeContainer.encode(relativeFileVersion.rawValue, forKey: .relativeFileVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePath)
        filePath = filePathDecoded
        let filePositionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .filePosition)
        filePosition = filePositionDecoded
        let relativeFileVersionDecoded = try containerValues.decodeIfPresent(RelativeFileVersionEnum.self, forKey: .relativeFileVersion)
        relativeFileVersion = relativeFileVersionDecoded
    }
}

extension Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Location(filePath: \(String(describing: filePath)), filePosition: \(String(describing: filePosition)), relativeFileVersion: \(String(describing: relativeFileVersion)))"}
}

/// <p>Returns information about the location of a change or comment in the comparison between two commits or a pull request.</p>
public struct Location: Equatable {
    /// <p>The name of the file being compared, including its extension and subdirectory, if any.</p>
    public let filePath: String?
    /// <p>The position of a change in a compared file, in line number format.</p>
    public let filePosition: Int?
    /// <p>In a comparison of commits or a pull request, whether the change is in the before or
    ///             after of that comparison.</p>
    public let relativeFileVersion: RelativeFileVersionEnum?

    public init (
        filePath: String? = nil,
        filePosition: Int? = nil,
        relativeFileVersion: RelativeFileVersionEnum? = nil
    )
    {
        self.filePath = filePath
        self.filePosition = filePosition
        self.relativeFileVersion = relativeFileVersion
    }
}

extension ManualMergeRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ManualMergeRequiredException(message: \(String(describing: message)))"}
}

extension ManualMergeRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ManualMergeRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
public struct ManualMergeRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ManualMergeRequiredExceptionBody: Equatable {
    public let message: String?
}

extension ManualMergeRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumBranchesExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaximumBranchesExceededException(message: \(String(describing: message)))"}
}

extension MaximumBranchesExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaximumBranchesExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of branches for the trigger was exceeded.</p>
public struct MaximumBranchesExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumBranchesExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaximumBranchesExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumConflictResolutionEntriesExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaximumConflictResolutionEntriesExceededException(message: \(String(describing: message)))"}
}

extension MaximumConflictResolutionEntriesExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaximumConflictResolutionEntriesExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of allowed conflict resolution entries was exceeded.</p>
public struct MaximumConflictResolutionEntriesExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumConflictResolutionEntriesExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaximumConflictResolutionEntriesExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumFileContentToLoadExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaximumFileContentToLoadExceededException(message: \(String(describing: message)))"}
}

extension MaximumFileContentToLoadExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaximumFileContentToLoadExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of files to load exceeds the allowed limit.</p>
public struct MaximumFileContentToLoadExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumFileContentToLoadExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaximumFileContentToLoadExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumFileEntriesExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaximumFileEntriesExceededException(message: \(String(describing: message)))"}
}

extension MaximumFileEntriesExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaximumFileEntriesExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of specified files to change as part of this commit exceeds the maximum number of files
///         that can be changed in a single commit. Consider using a Git client for these changes.</p>
public struct MaximumFileEntriesExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumFileEntriesExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaximumFileEntriesExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumItemsToCompareExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaximumItemsToCompareExceededException(message: \(String(describing: message)))"}
}

extension MaximumItemsToCompareExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaximumItemsToCompareExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
public struct MaximumItemsToCompareExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumItemsToCompareExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaximumItemsToCompareExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumNumberOfApprovalsExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaximumNumberOfApprovalsExceededException(message: \(String(describing: message)))"}
}

extension MaximumNumberOfApprovalsExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaximumNumberOfApprovalsExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of approvals required for the approval rule exceeds the maximum number allowed.</p>
public struct MaximumNumberOfApprovalsExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumNumberOfApprovalsExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaximumNumberOfApprovalsExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumOpenPullRequestsExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaximumOpenPullRequestsExceededException(message: \(String(describing: message)))"}
}

extension MaximumOpenPullRequestsExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaximumOpenPullRequestsExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You cannot create the pull request because the repository has too many open pull requests.
///             The maximum number of open pull requests for a repository is 1,000. Close one or more open pull requests, and then try again.</p>
public struct MaximumOpenPullRequestsExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumOpenPullRequestsExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaximumOpenPullRequestsExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumRepositoryNamesExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaximumRepositoryNamesExceededException(message: \(String(describing: message)))"}
}

extension MaximumRepositoryNamesExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaximumRepositoryNamesExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of allowed repository names was exceeded. Currently, this number is 100.</p>
public struct MaximumRepositoryNamesExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumRepositoryNamesExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaximumRepositoryNamesExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumRepositoryTriggersExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaximumRepositoryTriggersExceededException(message: \(String(describing: message)))"}
}

extension MaximumRepositoryTriggersExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaximumRepositoryTriggersExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of triggers allowed for the repository was exceeded.</p>
public struct MaximumRepositoryTriggersExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumRepositoryTriggersExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaximumRepositoryTriggersExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MaximumRuleTemplatesAssociatedWithRepositoryException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaximumRuleTemplatesAssociatedWithRepositoryException(message: \(String(describing: message)))"}
}

extension MaximumRuleTemplatesAssociatedWithRepositoryException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaximumRuleTemplatesAssociatedWithRepositoryExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of approval rule templates for a repository has been exceeded. You cannot associate more than 25
///         approval rule templates with a repository.</p>
public struct MaximumRuleTemplatesAssociatedWithRepositoryException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumRuleTemplatesAssociatedWithRepositoryExceptionBody: Equatable {
    public let message: String?
}

extension MaximumRuleTemplatesAssociatedWithRepositoryExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct MergeBranchesByFastForwardInputBodyMiddleware: Middleware {
    public let id: String = "MergeBranchesByFastForwardInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergeBranchesByFastForwardInput>,
                  next: H) -> Swift.Result<OperationOutput<MergeBranchesByFastForwardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergeBranchesByFastForwardInput>
    public typealias MOutput = OperationOutput<MergeBranchesByFastForwardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergeBranchesByFastForwardOutputError>
}

extension MergeBranchesByFastForwardInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergeBranchesByFastForwardInput(destinationCommitSpecifier: \(String(describing: destinationCommitSpecifier)), repositoryName: \(String(describing: repositoryName)), sourceCommitSpecifier: \(String(describing: sourceCommitSpecifier)), targetBranch: \(String(describing: targetBranch)))"}
}

extension MergeBranchesByFastForwardInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationCommitSpecifier
        case repositoryName
        case sourceCommitSpecifier
        case targetBranch
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationCommitSpecifier = destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
        if let targetBranch = targetBranch {
            try encodeContainer.encode(targetBranch, forKey: .targetBranch)
        }
    }
}

public struct MergeBranchesByFastForwardInputHeadersMiddleware: Middleware {
    public let id: String = "MergeBranchesByFastForwardInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergeBranchesByFastForwardInput>,
                  next: H) -> Swift.Result<OperationOutput<MergeBranchesByFastForwardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergeBranchesByFastForwardInput>
    public typealias MOutput = OperationOutput<MergeBranchesByFastForwardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergeBranchesByFastForwardOutputError>
}

public struct MergeBranchesByFastForwardInputQueryItemMiddleware: Middleware {
    public let id: String = "MergeBranchesByFastForwardInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergeBranchesByFastForwardInput>,
                  next: H) -> Swift.Result<OperationOutput<MergeBranchesByFastForwardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergeBranchesByFastForwardInput>
    public typealias MOutput = OperationOutput<MergeBranchesByFastForwardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergeBranchesByFastForwardOutputError>
}

public struct MergeBranchesByFastForwardInput: Equatable {
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, a branch name or a full commit ID).</p>
    public let destinationCommitSpecifier: String?
    /// <p>The name of the repository where you want to merge two branches.</p>
    public let repositoryName: String?
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, a branch name or a full commit ID).</p>
    public let sourceCommitSpecifier: String?
    /// <p>The branch where the merge is applied.</p>
    public let targetBranch: String?

    public init (
        destinationCommitSpecifier: String? = nil,
        repositoryName: String? = nil,
        sourceCommitSpecifier: String? = nil,
        targetBranch: String? = nil
    )
    {
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
        self.targetBranch = targetBranch
    }
}

struct MergeBranchesByFastForwardInputBody: Equatable {
    public let repositoryName: String?
    public let sourceCommitSpecifier: String?
    public let destinationCommitSpecifier: String?
    public let targetBranch: String?
}

extension MergeBranchesByFastForwardInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationCommitSpecifier
        case repositoryName
        case sourceCommitSpecifier
        case targetBranch
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let targetBranchDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetBranch)
        targetBranch = targetBranchDecoded
    }
}

extension MergeBranchesByFastForwardOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MergeBranchesByFastForwardOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BranchDoesNotExistException" : self = .branchDoesNotExistException(try BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameIsTagNameException" : self = .branchNameIsTagNameException(try BranchNameIsTagNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentReferenceUpdateException" : self = .concurrentReferenceUpdateException(try ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTargetBranchException" : self = .invalidTargetBranchException(try InvalidTargetBranchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManualMergeRequiredException" : self = .manualMergeRequiredException(try ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MergeBranchesByFastForwardOutputError: Equatable {
    case branchDoesNotExistException(BranchDoesNotExistException)
    case branchNameIsTagNameException(BranchNameIsTagNameException)
    case branchNameRequiredException(BranchNameRequiredException)
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitRequiredException(CommitRequiredException)
    case concurrentReferenceUpdateException(ConcurrentReferenceUpdateException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidCommitException(InvalidCommitException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidTargetBranchException(InvalidTargetBranchException)
    case manualMergeRequiredException(ManualMergeRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MergeBranchesByFastForwardOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergeBranchesByFastForwardOutputResponse(commitId: \(String(describing: commitId)), treeId: \(String(describing: treeId)))"}
}

extension MergeBranchesByFastForwardOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MergeBranchesByFastForwardOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.commitId = output.commitId
            self.treeId = output.treeId
        } else {
            self.commitId = nil
            self.treeId = nil
        }
    }
}

public struct MergeBranchesByFastForwardOutputResponse: Equatable {
    /// <p>The commit ID of the merge in the destination or target branch.</p>
    public let commitId: String?
    /// <p>The tree ID of the merge in the destination or target branch.</p>
    public let treeId: String?

    public init (
        commitId: String? = nil,
        treeId: String? = nil
    )
    {
        self.commitId = commitId
        self.treeId = treeId
    }
}

struct MergeBranchesByFastForwardOutputResponseBody: Equatable {
    public let commitId: String?
    public let treeId: String?
}

extension MergeBranchesByFastForwardOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commitId
        case treeId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treeId)
        treeId = treeIdDecoded
    }
}

public struct MergeBranchesBySquashInputBodyMiddleware: Middleware {
    public let id: String = "MergeBranchesBySquashInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergeBranchesBySquashInput>,
                  next: H) -> Swift.Result<OperationOutput<MergeBranchesBySquashOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergeBranchesBySquashInput>
    public typealias MOutput = OperationOutput<MergeBranchesBySquashOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergeBranchesBySquashOutputError>
}

extension MergeBranchesBySquashInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergeBranchesBySquashInput(authorName: \(String(describing: authorName)), commitMessage: \(String(describing: commitMessage)), conflictDetailLevel: \(String(describing: conflictDetailLevel)), conflictResolution: \(String(describing: conflictResolution)), conflictResolutionStrategy: \(String(describing: conflictResolutionStrategy)), destinationCommitSpecifier: \(String(describing: destinationCommitSpecifier)), email: \(String(describing: email)), keepEmptyFolders: \(String(describing: keepEmptyFolders)), repositoryName: \(String(describing: repositoryName)), sourceCommitSpecifier: \(String(describing: sourceCommitSpecifier)), targetBranch: \(String(describing: targetBranch)))"}
}

extension MergeBranchesBySquashInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case email
        case keepEmptyFolders
        case repositoryName
        case sourceCommitSpecifier
        case targetBranch
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let commitMessage = commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let conflictDetailLevel = conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolution = conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let conflictResolutionStrategy = conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if keepEmptyFolders != false {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
        if let targetBranch = targetBranch {
            try encodeContainer.encode(targetBranch, forKey: .targetBranch)
        }
    }
}

public struct MergeBranchesBySquashInputHeadersMiddleware: Middleware {
    public let id: String = "MergeBranchesBySquashInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergeBranchesBySquashInput>,
                  next: H) -> Swift.Result<OperationOutput<MergeBranchesBySquashOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergeBranchesBySquashInput>
    public typealias MOutput = OperationOutput<MergeBranchesBySquashOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergeBranchesBySquashOutputError>
}

public struct MergeBranchesBySquashInputQueryItemMiddleware: Middleware {
    public let id: String = "MergeBranchesBySquashInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergeBranchesBySquashInput>,
                  next: H) -> Swift.Result<OperationOutput<MergeBranchesBySquashOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergeBranchesBySquashInput>
    public typealias MOutput = OperationOutput<MergeBranchesBySquashOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergeBranchesBySquashOutputError>
}

public struct MergeBranchesBySquashInput: Equatable {
    /// <p>The name of the author who created the commit. This information is used as both the
    ///             author and committer for the commit.</p>
    public let authorName: String?
    /// <p>The commit message for the merge.</p>
    public let commitMessage: String?
    /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
    ///             which returns a not-mergeable result if the same file has differences in both branches.
    ///             If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
    ///             both branches has differences on the same line.</p>
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    /// <p>If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when
    ///             resolving conflicts during a merge.</p>
    public let conflictResolution: ConflictResolution?
    /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
    ///             automatically merging two versions of a file. The default is NONE, which requires any
    ///             conflicts to be resolved manually before the merge operation is successful.</p>
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, a branch name or a full commit ID).</p>
    public let destinationCommitSpecifier: String?
    /// <p>The email address of the person merging the branches. This information is used in the
    ///             commit information for the merge.</p>
    public let email: String?
    /// <p>If the commit contains deletions, whether to keep a folder or folder structure if the
    ///             changes leave the folders empty. If this is specified as true, a .gitkeep file is
    ///             created for empty folders. The default is false.</p>
    public let keepEmptyFolders: Bool
    /// <p>The name of the repository where you want to merge two branches.</p>
    public let repositoryName: String?
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, a branch name or a full commit ID).</p>
    public let sourceCommitSpecifier: String?
    /// <p>The branch where the merge is applied. </p>
    public let targetBranch: String?

    public init (
        authorName: String? = nil,
        commitMessage: String? = nil,
        conflictDetailLevel: ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: ConflictResolution? = nil,
        conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: String? = nil,
        email: String? = nil,
        keepEmptyFolders: Bool = false,
        repositoryName: String? = nil,
        sourceCommitSpecifier: String? = nil,
        targetBranch: String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
        self.targetBranch = targetBranch
    }
}

struct MergeBranchesBySquashInputBody: Equatable {
    public let repositoryName: String?
    public let sourceCommitSpecifier: String?
    public let destinationCommitSpecifier: String?
    public let targetBranch: String?
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
    public let authorName: String?
    public let email: String?
    public let commitMessage: String?
    public let keepEmptyFolders: Bool
    public let conflictResolution: ConflictResolution?
}

extension MergeBranchesBySquashInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case email
        case keepEmptyFolders
        case repositoryName
        case sourceCommitSpecifier
        case targetBranch
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let targetBranchDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetBranch)
        targetBranch = targetBranchDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let authorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let keepEmptyFoldersDecoded = try containerValues.decode(Bool.self, forKey: .keepEmptyFolders)
        keepEmptyFolders = keepEmptyFoldersDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
    }
}

extension MergeBranchesBySquashOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MergeBranchesBySquashOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BranchDoesNotExistException" : self = .branchDoesNotExistException(try BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameIsTagNameException" : self = .branchNameIsTagNameException(try BranchNameIsTagNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitMessageLengthExceededException" : self = .commitMessageLengthExceededException(try CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentReferenceUpdateException" : self = .concurrentReferenceUpdateException(try ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileContentSizeLimitExceededException" : self = .fileContentSizeLimitExceededException(try FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileModeRequiredException" : self = .fileModeRequiredException(try FileModeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FolderContentSizeLimitExceededException" : self = .folderContentSizeLimitExceededException(try FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionException" : self = .invalidConflictResolutionException(try InvalidConflictResolutionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailException" : self = .invalidEmailException(try InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFileModeException" : self = .invalidFileModeException(try InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementContentException" : self = .invalidReplacementContentException(try InvalidReplacementContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementTypeException" : self = .invalidReplacementTypeException(try InvalidReplacementTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTargetBranchException" : self = .invalidTargetBranchException(try InvalidTargetBranchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManualMergeRequiredException" : self = .manualMergeRequiredException(try ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumConflictResolutionEntriesExceededException" : self = .maximumConflictResolutionEntriesExceededException(try MaximumConflictResolutionEntriesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileContentToLoadExceededException" : self = .maximumFileContentToLoadExceededException(try MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumItemsToCompareExceededException" : self = .maximumItemsToCompareExceededException(try MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MultipleConflictResolutionEntriesException" : self = .multipleConflictResolutionEntriesException(try MultipleConflictResolutionEntriesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameLengthExceededException" : self = .nameLengthExceededException(try NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementContentRequiredException" : self = .replacementContentRequiredException(try ReplacementContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementTypeRequiredException" : self = .replacementTypeRequiredException(try ReplacementTypeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MergeBranchesBySquashOutputError: Equatable {
    case branchDoesNotExistException(BranchDoesNotExistException)
    case branchNameIsTagNameException(BranchNameIsTagNameException)
    case branchNameRequiredException(BranchNameRequiredException)
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitMessageLengthExceededException(CommitMessageLengthExceededException)
    case commitRequiredException(CommitRequiredException)
    case concurrentReferenceUpdateException(ConcurrentReferenceUpdateException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileContentSizeLimitExceededException(FileContentSizeLimitExceededException)
    case fileModeRequiredException(FileModeRequiredException)
    case folderContentSizeLimitExceededException(FolderContentSizeLimitExceededException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidCommitException(InvalidCommitException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionException(InvalidConflictResolutionException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidEmailException(InvalidEmailException)
    case invalidFileModeException(InvalidFileModeException)
    case invalidPathException(InvalidPathException)
    case invalidReplacementContentException(InvalidReplacementContentException)
    case invalidReplacementTypeException(InvalidReplacementTypeException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidTargetBranchException(InvalidTargetBranchException)
    case manualMergeRequiredException(ManualMergeRequiredException)
    case maximumConflictResolutionEntriesExceededException(MaximumConflictResolutionEntriesExceededException)
    case maximumFileContentToLoadExceededException(MaximumFileContentToLoadExceededException)
    case maximumItemsToCompareExceededException(MaximumItemsToCompareExceededException)
    case multipleConflictResolutionEntriesException(MultipleConflictResolutionEntriesException)
    case nameLengthExceededException(NameLengthExceededException)
    case pathRequiredException(PathRequiredException)
    case replacementContentRequiredException(ReplacementContentRequiredException)
    case replacementTypeRequiredException(ReplacementTypeRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MergeBranchesBySquashOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergeBranchesBySquashOutputResponse(commitId: \(String(describing: commitId)), treeId: \(String(describing: treeId)))"}
}

extension MergeBranchesBySquashOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MergeBranchesBySquashOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.commitId = output.commitId
            self.treeId = output.treeId
        } else {
            self.commitId = nil
            self.treeId = nil
        }
    }
}

public struct MergeBranchesBySquashOutputResponse: Equatable {
    /// <p>The commit ID of the merge in the destination or target branch.</p>
    public let commitId: String?
    /// <p>The tree ID of the merge in the destination or target branch.</p>
    public let treeId: String?

    public init (
        commitId: String? = nil,
        treeId: String? = nil
    )
    {
        self.commitId = commitId
        self.treeId = treeId
    }
}

struct MergeBranchesBySquashOutputResponseBody: Equatable {
    public let commitId: String?
    public let treeId: String?
}

extension MergeBranchesBySquashOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commitId
        case treeId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treeId)
        treeId = treeIdDecoded
    }
}

public struct MergeBranchesByThreeWayInputBodyMiddleware: Middleware {
    public let id: String = "MergeBranchesByThreeWayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergeBranchesByThreeWayInput>,
                  next: H) -> Swift.Result<OperationOutput<MergeBranchesByThreeWayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergeBranchesByThreeWayInput>
    public typealias MOutput = OperationOutput<MergeBranchesByThreeWayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergeBranchesByThreeWayOutputError>
}

extension MergeBranchesByThreeWayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergeBranchesByThreeWayInput(authorName: \(String(describing: authorName)), commitMessage: \(String(describing: commitMessage)), conflictDetailLevel: \(String(describing: conflictDetailLevel)), conflictResolution: \(String(describing: conflictResolution)), conflictResolutionStrategy: \(String(describing: conflictResolutionStrategy)), destinationCommitSpecifier: \(String(describing: destinationCommitSpecifier)), email: \(String(describing: email)), keepEmptyFolders: \(String(describing: keepEmptyFolders)), repositoryName: \(String(describing: repositoryName)), sourceCommitSpecifier: \(String(describing: sourceCommitSpecifier)), targetBranch: \(String(describing: targetBranch)))"}
}

extension MergeBranchesByThreeWayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case email
        case keepEmptyFolders
        case repositoryName
        case sourceCommitSpecifier
        case targetBranch
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let commitMessage = commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let conflictDetailLevel = conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolution = conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let conflictResolutionStrategy = conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let destinationCommitSpecifier = destinationCommitSpecifier {
            try encodeContainer.encode(destinationCommitSpecifier, forKey: .destinationCommitSpecifier)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if keepEmptyFolders != false {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitSpecifier = sourceCommitSpecifier {
            try encodeContainer.encode(sourceCommitSpecifier, forKey: .sourceCommitSpecifier)
        }
        if let targetBranch = targetBranch {
            try encodeContainer.encode(targetBranch, forKey: .targetBranch)
        }
    }
}

public struct MergeBranchesByThreeWayInputHeadersMiddleware: Middleware {
    public let id: String = "MergeBranchesByThreeWayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergeBranchesByThreeWayInput>,
                  next: H) -> Swift.Result<OperationOutput<MergeBranchesByThreeWayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergeBranchesByThreeWayInput>
    public typealias MOutput = OperationOutput<MergeBranchesByThreeWayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergeBranchesByThreeWayOutputError>
}

public struct MergeBranchesByThreeWayInputQueryItemMiddleware: Middleware {
    public let id: String = "MergeBranchesByThreeWayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergeBranchesByThreeWayInput>,
                  next: H) -> Swift.Result<OperationOutput<MergeBranchesByThreeWayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergeBranchesByThreeWayInput>
    public typealias MOutput = OperationOutput<MergeBranchesByThreeWayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergeBranchesByThreeWayOutputError>
}

public struct MergeBranchesByThreeWayInput: Equatable {
    /// <p>The name of the author who created the commit. This information is used as both the
    ///             author and committer for the commit.</p>
    public let authorName: String?
    /// <p>The commit message to include in the commit information for the merge.</p>
    public let commitMessage: String?
    /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
    ///             which returns a not-mergeable result if the same file has differences in both branches.
    ///             If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
    ///             both branches has differences on the same line.</p>
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    /// <p>If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when
    ///             resolving conflicts during a merge.</p>
    public let conflictResolution: ConflictResolution?
    /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
    ///             automatically merging two versions of a file. The default is NONE, which requires any
    ///             conflicts to be resolved manually before the merge operation is successful.</p>
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, a branch name or a full commit ID).</p>
    public let destinationCommitSpecifier: String?
    /// <p>The email address of the person merging the branches. This information is used in the
    ///             commit information for the merge.</p>
    public let email: String?
    /// <p>If the commit contains deletions, whether to keep a folder or folder structure if the
    ///             changes leave the folders empty. If true, a .gitkeep file is created for empty folders.
    ///             The default is false.</p>
    public let keepEmptyFolders: Bool
    /// <p>The name of the repository where you want to merge two branches.</p>
    public let repositoryName: String?
    /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
    ///             (for example, a branch name or a full commit ID).</p>
    public let sourceCommitSpecifier: String?
    /// <p>The branch where the merge is applied. </p>
    public let targetBranch: String?

    public init (
        authorName: String? = nil,
        commitMessage: String? = nil,
        conflictDetailLevel: ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: ConflictResolution? = nil,
        conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum? = nil,
        destinationCommitSpecifier: String? = nil,
        email: String? = nil,
        keepEmptyFolders: Bool = false,
        repositoryName: String? = nil,
        sourceCommitSpecifier: String? = nil,
        targetBranch: String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.destinationCommitSpecifier = destinationCommitSpecifier
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.repositoryName = repositoryName
        self.sourceCommitSpecifier = sourceCommitSpecifier
        self.targetBranch = targetBranch
    }
}

struct MergeBranchesByThreeWayInputBody: Equatable {
    public let repositoryName: String?
    public let sourceCommitSpecifier: String?
    public let destinationCommitSpecifier: String?
    public let targetBranch: String?
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
    public let authorName: String?
    public let email: String?
    public let commitMessage: String?
    public let keepEmptyFolders: Bool
    public let conflictResolution: ConflictResolution?
}

extension MergeBranchesByThreeWayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case destinationCommitSpecifier
        case email
        case keepEmptyFolders
        case repositoryName
        case sourceCommitSpecifier
        case targetBranch
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommitSpecifier)
        sourceCommitSpecifier = sourceCommitSpecifierDecoded
        let destinationCommitSpecifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationCommitSpecifier)
        destinationCommitSpecifier = destinationCommitSpecifierDecoded
        let targetBranchDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetBranch)
        targetBranch = targetBranchDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let authorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let keepEmptyFoldersDecoded = try containerValues.decode(Bool.self, forKey: .keepEmptyFolders)
        keepEmptyFolders = keepEmptyFoldersDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
    }
}

extension MergeBranchesByThreeWayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MergeBranchesByThreeWayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BranchDoesNotExistException" : self = .branchDoesNotExistException(try BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameIsTagNameException" : self = .branchNameIsTagNameException(try BranchNameIsTagNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitMessageLengthExceededException" : self = .commitMessageLengthExceededException(try CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitRequiredException" : self = .commitRequiredException(try CommitRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentReferenceUpdateException" : self = .concurrentReferenceUpdateException(try ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileContentSizeLimitExceededException" : self = .fileContentSizeLimitExceededException(try FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileModeRequiredException" : self = .fileModeRequiredException(try FileModeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FolderContentSizeLimitExceededException" : self = .folderContentSizeLimitExceededException(try FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitException" : self = .invalidCommitException(try InvalidCommitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionException" : self = .invalidConflictResolutionException(try InvalidConflictResolutionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailException" : self = .invalidEmailException(try InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFileModeException" : self = .invalidFileModeException(try InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementContentException" : self = .invalidReplacementContentException(try InvalidReplacementContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementTypeException" : self = .invalidReplacementTypeException(try InvalidReplacementTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTargetBranchException" : self = .invalidTargetBranchException(try InvalidTargetBranchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManualMergeRequiredException" : self = .manualMergeRequiredException(try ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumConflictResolutionEntriesExceededException" : self = .maximumConflictResolutionEntriesExceededException(try MaximumConflictResolutionEntriesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileContentToLoadExceededException" : self = .maximumFileContentToLoadExceededException(try MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumItemsToCompareExceededException" : self = .maximumItemsToCompareExceededException(try MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MultipleConflictResolutionEntriesException" : self = .multipleConflictResolutionEntriesException(try MultipleConflictResolutionEntriesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameLengthExceededException" : self = .nameLengthExceededException(try NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementContentRequiredException" : self = .replacementContentRequiredException(try ReplacementContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementTypeRequiredException" : self = .replacementTypeRequiredException(try ReplacementTypeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MergeBranchesByThreeWayOutputError: Equatable {
    case branchDoesNotExistException(BranchDoesNotExistException)
    case branchNameIsTagNameException(BranchNameIsTagNameException)
    case branchNameRequiredException(BranchNameRequiredException)
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitMessageLengthExceededException(CommitMessageLengthExceededException)
    case commitRequiredException(CommitRequiredException)
    case concurrentReferenceUpdateException(ConcurrentReferenceUpdateException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileContentSizeLimitExceededException(FileContentSizeLimitExceededException)
    case fileModeRequiredException(FileModeRequiredException)
    case folderContentSizeLimitExceededException(FolderContentSizeLimitExceededException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidCommitException(InvalidCommitException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionException(InvalidConflictResolutionException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidEmailException(InvalidEmailException)
    case invalidFileModeException(InvalidFileModeException)
    case invalidPathException(InvalidPathException)
    case invalidReplacementContentException(InvalidReplacementContentException)
    case invalidReplacementTypeException(InvalidReplacementTypeException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidTargetBranchException(InvalidTargetBranchException)
    case manualMergeRequiredException(ManualMergeRequiredException)
    case maximumConflictResolutionEntriesExceededException(MaximumConflictResolutionEntriesExceededException)
    case maximumFileContentToLoadExceededException(MaximumFileContentToLoadExceededException)
    case maximumItemsToCompareExceededException(MaximumItemsToCompareExceededException)
    case multipleConflictResolutionEntriesException(MultipleConflictResolutionEntriesException)
    case nameLengthExceededException(NameLengthExceededException)
    case pathRequiredException(PathRequiredException)
    case replacementContentRequiredException(ReplacementContentRequiredException)
    case replacementTypeRequiredException(ReplacementTypeRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MergeBranchesByThreeWayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergeBranchesByThreeWayOutputResponse(commitId: \(String(describing: commitId)), treeId: \(String(describing: treeId)))"}
}

extension MergeBranchesByThreeWayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MergeBranchesByThreeWayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.commitId = output.commitId
            self.treeId = output.treeId
        } else {
            self.commitId = nil
            self.treeId = nil
        }
    }
}

public struct MergeBranchesByThreeWayOutputResponse: Equatable {
    /// <p>The commit ID of the merge in the destination or target branch.</p>
    public let commitId: String?
    /// <p>The tree ID of the merge in the destination or target branch.</p>
    public let treeId: String?

    public init (
        commitId: String? = nil,
        treeId: String? = nil
    )
    {
        self.commitId = commitId
        self.treeId = treeId
    }
}

struct MergeBranchesByThreeWayOutputResponseBody: Equatable {
    public let commitId: String?
    public let treeId: String?
}

extension MergeBranchesByThreeWayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commitId
        case treeId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treeId)
        treeId = treeIdDecoded
    }
}

extension MergeHunk: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case base
        case destination
        case isConflict
        case source
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let base = base {
            try encodeContainer.encode(base, forKey: .base)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if isConflict != false {
            try encodeContainer.encode(isConflict, forKey: .isConflict)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isConflictDecoded = try containerValues.decode(Bool.self, forKey: .isConflict)
        isConflict = isConflictDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(MergeHunkDetail.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(MergeHunkDetail.self, forKey: .destination)
        destination = destinationDecoded
        let baseDecoded = try containerValues.decodeIfPresent(MergeHunkDetail.self, forKey: .base)
        base = baseDecoded
    }
}

extension MergeHunk: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergeHunk(base: \(String(describing: base)), destination: \(String(describing: destination)), isConflict: \(String(describing: isConflict)), source: \(String(describing: source)))"}
}

/// <p>Information about merge hunks in a merge or pull request operation.</p>
public struct MergeHunk: Equatable {
    /// <p>Information about the merge hunk in the base of a merge or pull request.</p>
    public let base: MergeHunkDetail?
    /// <p>Information about the merge hunk in the destination of a merge or pull request.</p>
    public let destination: MergeHunkDetail?
    /// <p>A Boolean value indicating whether a combination of hunks contains a conflict.
    ///             Conflicts occur when the same file or the same lines in a file were modified in both the
    ///             source and destination of a merge or pull request. Valid values include true, false, and
    ///             null. True when the hunk represents a conflict and one or more files contains a line
    ///             conflict. File mode conflicts in a merge do not set this to true.</p>
    public let isConflict: Bool
    /// <p>Information about the merge hunk in the source of a merge or pull request.</p>
    public let source: MergeHunkDetail?

    public init (
        base: MergeHunkDetail? = nil,
        destination: MergeHunkDetail? = nil,
        isConflict: Bool = false,
        source: MergeHunkDetail? = nil
    )
    {
        self.base = base
        self.destination = destination
        self.isConflict = isConflict
        self.source = source
    }
}

extension MergeHunkDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endLine
        case hunkContent
        case startLine
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endLine = endLine {
            try encodeContainer.encode(endLine, forKey: .endLine)
        }
        if let hunkContent = hunkContent {
            try encodeContainer.encode(hunkContent, forKey: .hunkContent)
        }
        if let startLine = startLine {
            try encodeContainer.encode(startLine, forKey: .startLine)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startLineDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .startLine)
        startLine = startLineDecoded
        let endLineDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .endLine)
        endLine = endLineDecoded
        let hunkContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hunkContent)
        hunkContent = hunkContentDecoded
    }
}

extension MergeHunkDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergeHunkDetail(endLine: \(String(describing: endLine)), hunkContent: \(String(describing: hunkContent)), startLine: \(String(describing: startLine)))"}
}

/// <p>Information about the details of a merge hunk that contains a conflict in a merge or pull request operation.</p>
public struct MergeHunkDetail: Equatable {
    /// <p>The end position of the hunk in the merge result.</p>
    public let endLine: Int?
    /// <p>The base-64 encoded content of the hunk merged region that might contain a
    ///             conflict.</p>
    public let hunkContent: String?
    /// <p>The start position of the hunk in the merge result.</p>
    public let startLine: Int?

    public init (
        endLine: Int? = nil,
        hunkContent: String? = nil,
        startLine: Int? = nil
    )
    {
        self.endLine = endLine
        self.hunkContent = hunkContent
        self.startLine = startLine
    }
}

extension MergeMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isMerged
        case mergeCommitId
        case mergeOption
        case mergedBy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isMerged != false {
            try encodeContainer.encode(isMerged, forKey: .isMerged)
        }
        if let mergeCommitId = mergeCommitId {
            try encodeContainer.encode(mergeCommitId, forKey: .mergeCommitId)
        }
        if let mergeOption = mergeOption {
            try encodeContainer.encode(mergeOption.rawValue, forKey: .mergeOption)
        }
        if let mergedBy = mergedBy {
            try encodeContainer.encode(mergedBy, forKey: .mergedBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isMergedDecoded = try containerValues.decode(Bool.self, forKey: .isMerged)
        isMerged = isMergedDecoded
        let mergedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mergedBy)
        mergedBy = mergedByDecoded
        let mergeCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mergeCommitId)
        mergeCommitId = mergeCommitIdDecoded
        let mergeOptionDecoded = try containerValues.decodeIfPresent(MergeOptionTypeEnum.self, forKey: .mergeOption)
        mergeOption = mergeOptionDecoded
    }
}

extension MergeMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergeMetadata(isMerged: \(String(describing: isMerged)), mergeCommitId: \(String(describing: mergeCommitId)), mergeOption: \(String(describing: mergeOption)), mergedBy: \(String(describing: mergedBy)))"}
}

/// <p>Returns information about a merge or potential merge between a source reference and a destination reference in a pull request.</p>
public struct MergeMetadata: Equatable {
    /// <p>A Boolean value indicating whether the merge has been made.</p>
    public let isMerged: Bool
    /// <p>The commit ID for the merge commit, if any.</p>
    public let mergeCommitId: String?
    /// <p>The merge strategy used in the merge.</p>
    public let mergeOption: MergeOptionTypeEnum?
    /// <p>The Amazon Resource Name (ARN) of the user who merged the branches.</p>
    public let mergedBy: String?

    public init (
        isMerged: Bool = false,
        mergeCommitId: String? = nil,
        mergeOption: MergeOptionTypeEnum? = nil,
        mergedBy: String? = nil
    )
    {
        self.isMerged = isMerged
        self.mergeCommitId = mergeCommitId
        self.mergeOption = mergeOption
        self.mergedBy = mergedBy
    }
}

extension MergeOperations: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination
        case source
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination.rawValue, forKey: .destination)
        }
        if let source = source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(ChangeTypeEnum.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ChangeTypeEnum.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension MergeOperations: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergeOperations(destination: \(String(describing: destination)), source: \(String(describing: source)))"}
}

/// <p>Information about the file operation conflicts in a merge operation.</p>
public struct MergeOperations: Equatable {
    /// <p>The operation on a file in the destination of a merge or pull request.</p>
    public let destination: ChangeTypeEnum?
    /// <p>The operation (add, modify, or delete) on a file in the source of a merge or pull
    ///             request.</p>
    public let source: ChangeTypeEnum?

    public init (
        destination: ChangeTypeEnum? = nil,
        source: ChangeTypeEnum? = nil
    )
    {
        self.destination = destination
        self.source = source
    }
}

extension MergeOptionRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergeOptionRequiredException(message: \(String(describing: message)))"}
}

extension MergeOptionRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MergeOptionRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A merge option or stategy is required, and none was provided.</p>
public struct MergeOptionRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MergeOptionRequiredExceptionBody: Equatable {
    public let message: String?
}

extension MergeOptionRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum MergeOptionTypeEnum {
    case fastForwardMerge
    case squashMerge
    case threeWayMerge
    case sdkUnknown(String)
}

extension MergeOptionTypeEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MergeOptionTypeEnum] {
        return [
            .fastForwardMerge,
            .squashMerge,
            .threeWayMerge,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fastForwardMerge: return "FAST_FORWARD_MERGE"
        case .squashMerge: return "SQUASH_MERGE"
        case .threeWayMerge: return "THREE_WAY_MERGE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MergeOptionTypeEnum(rawValue: rawValue) ?? MergeOptionTypeEnum.sdkUnknown(rawValue)
    }
}

public struct MergePullRequestByFastForwardInputBodyMiddleware: Middleware {
    public let id: String = "MergePullRequestByFastForwardInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergePullRequestByFastForwardInput>,
                  next: H) -> Swift.Result<OperationOutput<MergePullRequestByFastForwardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergePullRequestByFastForwardInput>
    public typealias MOutput = OperationOutput<MergePullRequestByFastForwardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergePullRequestByFastForwardOutputError>
}

extension MergePullRequestByFastForwardInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergePullRequestByFastForwardInput(pullRequestId: \(String(describing: pullRequestId)), repositoryName: \(String(describing: repositoryName)), sourceCommitId: \(String(describing: sourceCommitId)))"}
}

extension MergePullRequestByFastForwardInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pullRequestId
        case repositoryName
        case sourceCommitId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitId = sourceCommitId {
            try encodeContainer.encode(sourceCommitId, forKey: .sourceCommitId)
        }
    }
}

public struct MergePullRequestByFastForwardInputHeadersMiddleware: Middleware {
    public let id: String = "MergePullRequestByFastForwardInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergePullRequestByFastForwardInput>,
                  next: H) -> Swift.Result<OperationOutput<MergePullRequestByFastForwardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergePullRequestByFastForwardInput>
    public typealias MOutput = OperationOutput<MergePullRequestByFastForwardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergePullRequestByFastForwardOutputError>
}

public struct MergePullRequestByFastForwardInputQueryItemMiddleware: Middleware {
    public let id: String = "MergePullRequestByFastForwardInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergePullRequestByFastForwardInput>,
                  next: H) -> Swift.Result<OperationOutput<MergePullRequestByFastForwardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergePullRequestByFastForwardInput>
    public typealias MOutput = OperationOutput<MergePullRequestByFastForwardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergePullRequestByFastForwardOutputError>
}

public struct MergePullRequestByFastForwardInput: Equatable {
    /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
    public let pullRequestId: String?
    /// <p>The name of the repository where the pull request was created.</p>
    public let repositoryName: String?
    /// <p>The full commit ID of the original or updated commit in the pull request source branch. Pass this value if you want an
    ///         exception thrown if the current commit ID of the tip of the source branch does not match this commit ID.</p>
    public let sourceCommitId: String?

    public init (
        pullRequestId: String? = nil,
        repositoryName: String? = nil,
        sourceCommitId: String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
        self.sourceCommitId = sourceCommitId
    }
}

struct MergePullRequestByFastForwardInputBody: Equatable {
    public let pullRequestId: String?
    public let repositoryName: String?
    public let sourceCommitId: String?
}

extension MergePullRequestByFastForwardInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pullRequestId
        case repositoryName
        case sourceCommitId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
    }
}

extension MergePullRequestByFastForwardOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MergePullRequestByFastForwardOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentReferenceUpdateException" : self = .concurrentReferenceUpdateException(try ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManualMergeRequiredException" : self = .manualMergeRequiredException(try ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestApprovalRulesNotSatisfiedException" : self = .pullRequestApprovalRulesNotSatisfiedException(try PullRequestApprovalRulesNotSatisfiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReferenceDoesNotExistException" : self = .referenceDoesNotExistException(try ReferenceDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotAssociatedWithPullRequestException" : self = .repositoryNotAssociatedWithPullRequestException(try RepositoryNotAssociatedWithPullRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipOfSourceReferenceIsDifferentException" : self = .tipOfSourceReferenceIsDifferentException(try TipOfSourceReferenceIsDifferentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MergePullRequestByFastForwardOutputError: Equatable {
    case concurrentReferenceUpdateException(ConcurrentReferenceUpdateException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case manualMergeRequiredException(ManualMergeRequiredException)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestApprovalRulesNotSatisfiedException(PullRequestApprovalRulesNotSatisfiedException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case referenceDoesNotExistException(ReferenceDoesNotExistException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case repositoryNotAssociatedWithPullRequestException(RepositoryNotAssociatedWithPullRequestException)
    case tipOfSourceReferenceIsDifferentException(TipOfSourceReferenceIsDifferentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MergePullRequestByFastForwardOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergePullRequestByFastForwardOutputResponse(pullRequest: \(String(describing: pullRequest)))"}
}

extension MergePullRequestByFastForwardOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MergePullRequestByFastForwardOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct MergePullRequestByFastForwardOutputResponse: Equatable {
    /// <p>Information about the specified pull request, including the merge.</p>
    public let pullRequest: PullRequest?

    public init (
        pullRequest: PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct MergePullRequestByFastForwardOutputResponseBody: Equatable {
    public let pullRequest: PullRequest?
}

extension MergePullRequestByFastForwardOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pullRequest
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

public struct MergePullRequestBySquashInputBodyMiddleware: Middleware {
    public let id: String = "MergePullRequestBySquashInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergePullRequestBySquashInput>,
                  next: H) -> Swift.Result<OperationOutput<MergePullRequestBySquashOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergePullRequestBySquashInput>
    public typealias MOutput = OperationOutput<MergePullRequestBySquashOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergePullRequestBySquashOutputError>
}

extension MergePullRequestBySquashInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergePullRequestBySquashInput(authorName: \(String(describing: authorName)), commitMessage: \(String(describing: commitMessage)), conflictDetailLevel: \(String(describing: conflictDetailLevel)), conflictResolution: \(String(describing: conflictResolution)), conflictResolutionStrategy: \(String(describing: conflictResolutionStrategy)), email: \(String(describing: email)), keepEmptyFolders: \(String(describing: keepEmptyFolders)), pullRequestId: \(String(describing: pullRequestId)), repositoryName: \(String(describing: repositoryName)), sourceCommitId: \(String(describing: sourceCommitId)))"}
}

extension MergePullRequestBySquashInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case email
        case keepEmptyFolders
        case pullRequestId
        case repositoryName
        case sourceCommitId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let commitMessage = commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let conflictDetailLevel = conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolution = conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let conflictResolutionStrategy = conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if keepEmptyFolders != false {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitId = sourceCommitId {
            try encodeContainer.encode(sourceCommitId, forKey: .sourceCommitId)
        }
    }
}

public struct MergePullRequestBySquashInputHeadersMiddleware: Middleware {
    public let id: String = "MergePullRequestBySquashInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergePullRequestBySquashInput>,
                  next: H) -> Swift.Result<OperationOutput<MergePullRequestBySquashOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergePullRequestBySquashInput>
    public typealias MOutput = OperationOutput<MergePullRequestBySquashOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergePullRequestBySquashOutputError>
}

public struct MergePullRequestBySquashInputQueryItemMiddleware: Middleware {
    public let id: String = "MergePullRequestBySquashInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergePullRequestBySquashInput>,
                  next: H) -> Swift.Result<OperationOutput<MergePullRequestBySquashOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergePullRequestBySquashInput>
    public typealias MOutput = OperationOutput<MergePullRequestBySquashOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergePullRequestBySquashOutputError>
}

public struct MergePullRequestBySquashInput: Equatable {
    /// <p>The name of the author who created the commit. This information is used as both the
    ///             author and committer for the commit.</p>
    public let authorName: String?
    /// <p>The commit message to include in the commit information for the merge.</p>
    public let commitMessage: String?
    /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
    ///             which returns a not-mergeable result if the same file has differences in both branches.
    ///             If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
    ///             both branches has differences on the same line.</p>
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    /// <p>If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when
    ///             resolving conflicts during a merge.</p>
    public let conflictResolution: ConflictResolution?
    /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
    ///             automatically merging two versions of a file. The default is NONE, which requires any
    ///             conflicts to be resolved manually before the merge operation is successful.</p>
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
    /// <p>The email address of the person merging the branches. This information is used in the
    ///             commit information for the merge.</p>
    public let email: String?
    /// <p>If the commit contains deletions, whether to keep a folder or folder structure if the
    ///             changes leave the folders empty. If true, a .gitkeep file is created for empty folders.
    ///             The default is false.</p>
    public let keepEmptyFolders: Bool
    /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
    public let pullRequestId: String?
    /// <p>The name of the repository where the pull request was created.</p>
    public let repositoryName: String?
    /// <p>The full commit ID of the original or updated commit in the pull request source branch. Pass this value if you want an
    ///             exception thrown if the current commit ID of the tip of the source branch does not match this commit ID.</p>
    public let sourceCommitId: String?

    public init (
        authorName: String? = nil,
        commitMessage: String? = nil,
        conflictDetailLevel: ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: ConflictResolution? = nil,
        conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum? = nil,
        email: String? = nil,
        keepEmptyFolders: Bool = false,
        pullRequestId: String? = nil,
        repositoryName: String? = nil,
        sourceCommitId: String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
        self.sourceCommitId = sourceCommitId
    }
}

struct MergePullRequestBySquashInputBody: Equatable {
    public let pullRequestId: String?
    public let repositoryName: String?
    public let sourceCommitId: String?
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
    public let commitMessage: String?
    public let authorName: String?
    public let email: String?
    public let keepEmptyFolders: Bool
    public let conflictResolution: ConflictResolution?
}

extension MergePullRequestBySquashInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case email
        case keepEmptyFolders
        case pullRequestId
        case repositoryName
        case sourceCommitId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let authorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let keepEmptyFoldersDecoded = try containerValues.decode(Bool.self, forKey: .keepEmptyFolders)
        keepEmptyFolders = keepEmptyFoldersDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
    }
}

extension MergePullRequestBySquashOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MergePullRequestBySquashOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommitMessageLengthExceededException" : self = .commitMessageLengthExceededException(try CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentReferenceUpdateException" : self = .concurrentReferenceUpdateException(try ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileContentSizeLimitExceededException" : self = .fileContentSizeLimitExceededException(try FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FolderContentSizeLimitExceededException" : self = .folderContentSizeLimitExceededException(try FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionException" : self = .invalidConflictResolutionException(try InvalidConflictResolutionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailException" : self = .invalidEmailException(try InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFileModeException" : self = .invalidFileModeException(try InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementContentException" : self = .invalidReplacementContentException(try InvalidReplacementContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementTypeException" : self = .invalidReplacementTypeException(try InvalidReplacementTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManualMergeRequiredException" : self = .manualMergeRequiredException(try ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumConflictResolutionEntriesExceededException" : self = .maximumConflictResolutionEntriesExceededException(try MaximumConflictResolutionEntriesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileContentToLoadExceededException" : self = .maximumFileContentToLoadExceededException(try MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumItemsToCompareExceededException" : self = .maximumItemsToCompareExceededException(try MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MultipleConflictResolutionEntriesException" : self = .multipleConflictResolutionEntriesException(try MultipleConflictResolutionEntriesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameLengthExceededException" : self = .nameLengthExceededException(try NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestApprovalRulesNotSatisfiedException" : self = .pullRequestApprovalRulesNotSatisfiedException(try PullRequestApprovalRulesNotSatisfiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementContentRequiredException" : self = .replacementContentRequiredException(try ReplacementContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementTypeRequiredException" : self = .replacementTypeRequiredException(try ReplacementTypeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotAssociatedWithPullRequestException" : self = .repositoryNotAssociatedWithPullRequestException(try RepositoryNotAssociatedWithPullRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipOfSourceReferenceIsDifferentException" : self = .tipOfSourceReferenceIsDifferentException(try TipOfSourceReferenceIsDifferentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MergePullRequestBySquashOutputError: Equatable {
    case commitMessageLengthExceededException(CommitMessageLengthExceededException)
    case concurrentReferenceUpdateException(ConcurrentReferenceUpdateException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileContentSizeLimitExceededException(FileContentSizeLimitExceededException)
    case folderContentSizeLimitExceededException(FolderContentSizeLimitExceededException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionException(InvalidConflictResolutionException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidEmailException(InvalidEmailException)
    case invalidFileModeException(InvalidFileModeException)
    case invalidPathException(InvalidPathException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidReplacementContentException(InvalidReplacementContentException)
    case invalidReplacementTypeException(InvalidReplacementTypeException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case manualMergeRequiredException(ManualMergeRequiredException)
    case maximumConflictResolutionEntriesExceededException(MaximumConflictResolutionEntriesExceededException)
    case maximumFileContentToLoadExceededException(MaximumFileContentToLoadExceededException)
    case maximumItemsToCompareExceededException(MaximumItemsToCompareExceededException)
    case multipleConflictResolutionEntriesException(MultipleConflictResolutionEntriesException)
    case nameLengthExceededException(NameLengthExceededException)
    case pathRequiredException(PathRequiredException)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestApprovalRulesNotSatisfiedException(PullRequestApprovalRulesNotSatisfiedException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case replacementContentRequiredException(ReplacementContentRequiredException)
    case replacementTypeRequiredException(ReplacementTypeRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case repositoryNotAssociatedWithPullRequestException(RepositoryNotAssociatedWithPullRequestException)
    case tipOfSourceReferenceIsDifferentException(TipOfSourceReferenceIsDifferentException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MergePullRequestBySquashOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergePullRequestBySquashOutputResponse(pullRequest: \(String(describing: pullRequest)))"}
}

extension MergePullRequestBySquashOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MergePullRequestBySquashOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct MergePullRequestBySquashOutputResponse: Equatable {
    /// <p>Returns information about a pull request.</p>
    public let pullRequest: PullRequest?

    public init (
        pullRequest: PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct MergePullRequestBySquashOutputResponseBody: Equatable {
    public let pullRequest: PullRequest?
}

extension MergePullRequestBySquashOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pullRequest
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

public struct MergePullRequestByThreeWayInputBodyMiddleware: Middleware {
    public let id: String = "MergePullRequestByThreeWayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergePullRequestByThreeWayInput>,
                  next: H) -> Swift.Result<OperationOutput<MergePullRequestByThreeWayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergePullRequestByThreeWayInput>
    public typealias MOutput = OperationOutput<MergePullRequestByThreeWayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergePullRequestByThreeWayOutputError>
}

extension MergePullRequestByThreeWayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergePullRequestByThreeWayInput(authorName: \(String(describing: authorName)), commitMessage: \(String(describing: commitMessage)), conflictDetailLevel: \(String(describing: conflictDetailLevel)), conflictResolution: \(String(describing: conflictResolution)), conflictResolutionStrategy: \(String(describing: conflictResolutionStrategy)), email: \(String(describing: email)), keepEmptyFolders: \(String(describing: keepEmptyFolders)), pullRequestId: \(String(describing: pullRequestId)), repositoryName: \(String(describing: repositoryName)), sourceCommitId: \(String(describing: sourceCommitId)))"}
}

extension MergePullRequestByThreeWayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case email
        case keepEmptyFolders
        case pullRequestId
        case repositoryName
        case sourceCommitId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let commitMessage = commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let conflictDetailLevel = conflictDetailLevel {
            try encodeContainer.encode(conflictDetailLevel.rawValue, forKey: .conflictDetailLevel)
        }
        if let conflictResolution = conflictResolution {
            try encodeContainer.encode(conflictResolution, forKey: .conflictResolution)
        }
        if let conflictResolutionStrategy = conflictResolutionStrategy {
            try encodeContainer.encode(conflictResolutionStrategy.rawValue, forKey: .conflictResolutionStrategy)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if keepEmptyFolders != false {
            try encodeContainer.encode(keepEmptyFolders, forKey: .keepEmptyFolders)
        }
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitId = sourceCommitId {
            try encodeContainer.encode(sourceCommitId, forKey: .sourceCommitId)
        }
    }
}

public struct MergePullRequestByThreeWayInputHeadersMiddleware: Middleware {
    public let id: String = "MergePullRequestByThreeWayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergePullRequestByThreeWayInput>,
                  next: H) -> Swift.Result<OperationOutput<MergePullRequestByThreeWayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergePullRequestByThreeWayInput>
    public typealias MOutput = OperationOutput<MergePullRequestByThreeWayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergePullRequestByThreeWayOutputError>
}

public struct MergePullRequestByThreeWayInputQueryItemMiddleware: Middleware {
    public let id: String = "MergePullRequestByThreeWayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergePullRequestByThreeWayInput>,
                  next: H) -> Swift.Result<OperationOutput<MergePullRequestByThreeWayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergePullRequestByThreeWayInput>
    public typealias MOutput = OperationOutput<MergePullRequestByThreeWayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergePullRequestByThreeWayOutputError>
}

public struct MergePullRequestByThreeWayInput: Equatable {
    /// <p>The name of the author who created the commit. This information is used as both the
    ///             author and committer for the commit.</p>
    public let authorName: String?
    /// <p>The commit message to include in the commit information for the merge.</p>
    public let commitMessage: String?
    /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
    ///             which returns a not-mergeable result if the same file has differences in both branches.
    ///             If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
    ///             both branches has differences on the same line.</p>
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    /// <p>If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when
    ///             resolving conflicts during a merge.</p>
    public let conflictResolution: ConflictResolution?
    /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
    ///             automatically merging two versions of a file. The default is NONE, which requires any
    ///             conflicts to be resolved manually before the merge operation is successful.</p>
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
    /// <p>The email address of the person merging the branches. This information is used in the
    ///             commit information for the merge.</p>
    public let email: String?
    /// <p>If the commit contains deletions, whether to keep a folder or folder structure if the
    ///             changes leave the folders empty. If true, a .gitkeep file is created for empty folders.
    ///             The default is false.</p>
    public let keepEmptyFolders: Bool
    /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
    public let pullRequestId: String?
    /// <p>The name of the repository where the pull request was created.</p>
    public let repositoryName: String?
    /// <p>The full commit ID of the original or updated commit in the pull request source branch. Pass this value if you want an
    ///             exception thrown if the current commit ID of the tip of the source branch does not match this commit ID.</p>
    public let sourceCommitId: String?

    public init (
        authorName: String? = nil,
        commitMessage: String? = nil,
        conflictDetailLevel: ConflictDetailLevelTypeEnum? = nil,
        conflictResolution: ConflictResolution? = nil,
        conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum? = nil,
        email: String? = nil,
        keepEmptyFolders: Bool = false,
        pullRequestId: String? = nil,
        repositoryName: String? = nil,
        sourceCommitId: String? = nil
    )
    {
        self.authorName = authorName
        self.commitMessage = commitMessage
        self.conflictDetailLevel = conflictDetailLevel
        self.conflictResolution = conflictResolution
        self.conflictResolutionStrategy = conflictResolutionStrategy
        self.email = email
        self.keepEmptyFolders = keepEmptyFolders
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
        self.sourceCommitId = sourceCommitId
    }
}

struct MergePullRequestByThreeWayInputBody: Equatable {
    public let pullRequestId: String?
    public let repositoryName: String?
    public let sourceCommitId: String?
    public let conflictDetailLevel: ConflictDetailLevelTypeEnum?
    public let conflictResolutionStrategy: ConflictResolutionStrategyTypeEnum?
    public let commitMessage: String?
    public let authorName: String?
    public let email: String?
    public let keepEmptyFolders: Bool
    public let conflictResolution: ConflictResolution?
}

extension MergePullRequestByThreeWayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorName
        case commitMessage
        case conflictDetailLevel
        case conflictResolution
        case conflictResolutionStrategy
        case email
        case keepEmptyFolders
        case pullRequestId
        case repositoryName
        case sourceCommitId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let conflictDetailLevelDecoded = try containerValues.decodeIfPresent(ConflictDetailLevelTypeEnum.self, forKey: .conflictDetailLevel)
        conflictDetailLevel = conflictDetailLevelDecoded
        let conflictResolutionStrategyDecoded = try containerValues.decodeIfPresent(ConflictResolutionStrategyTypeEnum.self, forKey: .conflictResolutionStrategy)
        conflictResolutionStrategy = conflictResolutionStrategyDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let authorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let keepEmptyFoldersDecoded = try containerValues.decode(Bool.self, forKey: .keepEmptyFolders)
        keepEmptyFolders = keepEmptyFoldersDecoded
        let conflictResolutionDecoded = try containerValues.decodeIfPresent(ConflictResolution.self, forKey: .conflictResolution)
        conflictResolution = conflictResolutionDecoded
    }
}

extension MergePullRequestByThreeWayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MergePullRequestByThreeWayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommitMessageLengthExceededException" : self = .commitMessageLengthExceededException(try CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentReferenceUpdateException" : self = .concurrentReferenceUpdateException(try ConcurrentReferenceUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileContentSizeLimitExceededException" : self = .fileContentSizeLimitExceededException(try FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FolderContentSizeLimitExceededException" : self = .folderContentSizeLimitExceededException(try FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictDetailLevelException" : self = .invalidConflictDetailLevelException(try InvalidConflictDetailLevelException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionException" : self = .invalidConflictResolutionException(try InvalidConflictResolutionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConflictResolutionStrategyException" : self = .invalidConflictResolutionStrategyException(try InvalidConflictResolutionStrategyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailException" : self = .invalidEmailException(try InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFileModeException" : self = .invalidFileModeException(try InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementContentException" : self = .invalidReplacementContentException(try InvalidReplacementContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReplacementTypeException" : self = .invalidReplacementTypeException(try InvalidReplacementTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManualMergeRequiredException" : self = .manualMergeRequiredException(try ManualMergeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumConflictResolutionEntriesExceededException" : self = .maximumConflictResolutionEntriesExceededException(try MaximumConflictResolutionEntriesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumFileContentToLoadExceededException" : self = .maximumFileContentToLoadExceededException(try MaximumFileContentToLoadExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumItemsToCompareExceededException" : self = .maximumItemsToCompareExceededException(try MaximumItemsToCompareExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MultipleConflictResolutionEntriesException" : self = .multipleConflictResolutionEntriesException(try MultipleConflictResolutionEntriesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameLengthExceededException" : self = .nameLengthExceededException(try NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestApprovalRulesNotSatisfiedException" : self = .pullRequestApprovalRulesNotSatisfiedException(try PullRequestApprovalRulesNotSatisfiedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementContentRequiredException" : self = .replacementContentRequiredException(try ReplacementContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReplacementTypeRequiredException" : self = .replacementTypeRequiredException(try ReplacementTypeRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotAssociatedWithPullRequestException" : self = .repositoryNotAssociatedWithPullRequestException(try RepositoryNotAssociatedWithPullRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipOfSourceReferenceIsDifferentException" : self = .tipOfSourceReferenceIsDifferentException(try TipOfSourceReferenceIsDifferentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TipsDivergenceExceededException" : self = .tipsDivergenceExceededException(try TipsDivergenceExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MergePullRequestByThreeWayOutputError: Equatable {
    case commitMessageLengthExceededException(CommitMessageLengthExceededException)
    case concurrentReferenceUpdateException(ConcurrentReferenceUpdateException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileContentSizeLimitExceededException(FileContentSizeLimitExceededException)
    case folderContentSizeLimitExceededException(FolderContentSizeLimitExceededException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidConflictDetailLevelException(InvalidConflictDetailLevelException)
    case invalidConflictResolutionException(InvalidConflictResolutionException)
    case invalidConflictResolutionStrategyException(InvalidConflictResolutionStrategyException)
    case invalidEmailException(InvalidEmailException)
    case invalidFileModeException(InvalidFileModeException)
    case invalidPathException(InvalidPathException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidReplacementContentException(InvalidReplacementContentException)
    case invalidReplacementTypeException(InvalidReplacementTypeException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case manualMergeRequiredException(ManualMergeRequiredException)
    case maximumConflictResolutionEntriesExceededException(MaximumConflictResolutionEntriesExceededException)
    case maximumFileContentToLoadExceededException(MaximumFileContentToLoadExceededException)
    case maximumItemsToCompareExceededException(MaximumItemsToCompareExceededException)
    case multipleConflictResolutionEntriesException(MultipleConflictResolutionEntriesException)
    case nameLengthExceededException(NameLengthExceededException)
    case pathRequiredException(PathRequiredException)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestApprovalRulesNotSatisfiedException(PullRequestApprovalRulesNotSatisfiedException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case replacementContentRequiredException(ReplacementContentRequiredException)
    case replacementTypeRequiredException(ReplacementTypeRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case repositoryNotAssociatedWithPullRequestException(RepositoryNotAssociatedWithPullRequestException)
    case tipOfSourceReferenceIsDifferentException(TipOfSourceReferenceIsDifferentException)
    case tipsDivergenceExceededException(TipsDivergenceExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MergePullRequestByThreeWayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergePullRequestByThreeWayOutputResponse(pullRequest: \(String(describing: pullRequest)))"}
}

extension MergePullRequestByThreeWayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MergePullRequestByThreeWayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct MergePullRequestByThreeWayOutputResponse: Equatable {
    /// <p>Returns information about a pull request.</p>
    public let pullRequest: PullRequest?

    public init (
        pullRequest: PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct MergePullRequestByThreeWayOutputResponseBody: Equatable {
    public let pullRequest: PullRequest?
}

extension MergePullRequestByThreeWayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pullRequest
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

extension MultipleConflictResolutionEntriesException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MultipleConflictResolutionEntriesException(message: \(String(describing: message)))"}
}

extension MultipleConflictResolutionEntriesException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MultipleConflictResolutionEntriesExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.</p>
public struct MultipleConflictResolutionEntriesException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MultipleConflictResolutionEntriesExceptionBody: Equatable {
    public let message: String?
}

extension MultipleConflictResolutionEntriesExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MultipleRepositoriesInPullRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MultipleRepositoriesInPullRequestException(message: \(String(describing: message)))"}
}

extension MultipleRepositoriesInPullRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MultipleRepositoriesInPullRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You cannot include more than one repository in a pull request. Make sure you have specified only one repository name in your request, and then try again.</p>
public struct MultipleRepositoriesInPullRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MultipleRepositoriesInPullRequestExceptionBody: Equatable {
    public let message: String?
}

extension MultipleRepositoriesInPullRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NameLengthExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NameLengthExceededException(message: \(String(describing: message)))"}
}

extension NameLengthExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NameLengthExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
public struct NameLengthExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NameLengthExceededExceptionBody: Equatable {
    public let message: String?
}

extension NameLengthExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoChangeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoChangeException(message: \(String(describing: message)))"}
}

extension NoChangeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoChangeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The commit cannot be created because no changes will be made to the repository as a result of this commit. A commit must contain at least one change.</p>
public struct NoChangeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoChangeExceptionBody: Equatable {
    public let message: String?
}

extension NoChangeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NumberOfRuleTemplatesExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NumberOfRuleTemplatesExceededException(message: \(String(describing: message)))"}
}

extension NumberOfRuleTemplatesExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NumberOfRuleTemplatesExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of approval rule templates has been exceeded for this AWS Region. </p>
public struct NumberOfRuleTemplatesExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NumberOfRuleTemplatesExceededExceptionBody: Equatable {
    public let message: String?
}

extension NumberOfRuleTemplatesExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NumberOfRulesExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NumberOfRulesExceededException(message: \(String(describing: message)))"}
}

extension NumberOfRulesExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NumberOfRulesExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The approval rule cannot be added. The pull request has the maximum number of approval rules associated with it.</p>
public struct NumberOfRulesExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NumberOfRulesExceededExceptionBody: Equatable {
    public let message: String?
}

extension NumberOfRulesExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ObjectTypeEnum {
    case directory
    case file
    case gitLink
    case symbolicLink
    case sdkUnknown(String)
}

extension ObjectTypeEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ObjectTypeEnum] {
        return [
            .directory,
            .file,
            .gitLink,
            .symbolicLink,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .directory: return "DIRECTORY"
        case .file: return "FILE"
        case .gitLink: return "GIT_LINK"
        case .symbolicLink: return "SYMBOLIC_LINK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ObjectTypeEnum(rawValue: rawValue) ?? ObjectTypeEnum.sdkUnknown(rawValue)
    }
}

extension ObjectTypes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case base
        case destination
        case source
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let base = base {
            try encodeContainer.encode(base.rawValue, forKey: .base)
        }
        if let destination = destination {
            try encodeContainer.encode(destination.rawValue, forKey: .destination)
        }
        if let source = source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(ObjectTypeEnum.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ObjectTypeEnum.self, forKey: .destination)
        destination = destinationDecoded
        let baseDecoded = try containerValues.decodeIfPresent(ObjectTypeEnum.self, forKey: .base)
        base = baseDecoded
    }
}

extension ObjectTypes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ObjectTypes(base: \(String(describing: base)), destination: \(String(describing: destination)), source: \(String(describing: source)))"}
}

/// <p>Information about the type of an object in a merge operation.</p>
public struct ObjectTypes: Equatable {
    /// <p>The type of the object in the base commit of the merge.</p>
    public let base: ObjectTypeEnum?
    /// <p>The type of the object in the destination branch.</p>
    public let destination: ObjectTypeEnum?
    /// <p>The type of the object in the source branch.</p>
    public let source: ObjectTypeEnum?

    public init (
        base: ObjectTypeEnum? = nil,
        destination: ObjectTypeEnum? = nil,
        source: ObjectTypeEnum? = nil
    )
    {
        self.base = base
        self.destination = destination
        self.source = source
    }
}

public enum OrderEnum {
    case ascending
    case descending
    case sdkUnknown(String)
}

extension OrderEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OrderEnum] {
        return [
            .ascending,
            .descending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascending: return "ascending"
        case .descending: return "descending"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OrderEnum(rawValue: rawValue) ?? OrderEnum.sdkUnknown(rawValue)
    }
}

extension OriginApprovalRuleTemplate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateId
        case approvalRuleTemplateName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateId = approvalRuleTemplateId {
            try encodeContainer.encode(approvalRuleTemplateId, forKey: .approvalRuleTemplateId)
        }
        if let approvalRuleTemplateName = approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateId)
        approvalRuleTemplateId = approvalRuleTemplateIdDecoded
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
    }
}

extension OriginApprovalRuleTemplate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginApprovalRuleTemplate(approvalRuleTemplateId: \(String(describing: approvalRuleTemplateId)), approvalRuleTemplateName: \(String(describing: approvalRuleTemplateName)))"}
}

/// <p>Returns information about the template that created the approval rule for a pull request.</p>
public struct OriginApprovalRuleTemplate: Equatable {
    /// <p>The ID of the template that created the approval rule.</p>
    public let approvalRuleTemplateId: String?
    /// <p>The name of the template that created the approval rule.</p>
    public let approvalRuleTemplateName: String?

    public init (
        approvalRuleTemplateId: String? = nil,
        approvalRuleTemplateName: String? = nil
    )
    {
        self.approvalRuleTemplateId = approvalRuleTemplateId
        self.approvalRuleTemplateName = approvalRuleTemplateName
    }
}

extension OverrideAlreadySetException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OverrideAlreadySetException(message: \(String(describing: message)))"}
}

extension OverrideAlreadySetException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OverrideAlreadySetExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pull request has already had its approval rules set to override.</p>
public struct OverrideAlreadySetException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OverrideAlreadySetExceptionBody: Equatable {
    public let message: String?
}

extension OverrideAlreadySetExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct OverridePullRequestApprovalRulesInputBodyMiddleware: Middleware {
    public let id: String = "OverridePullRequestApprovalRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<OverridePullRequestApprovalRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<OverridePullRequestApprovalRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<OverridePullRequestApprovalRulesInput>
    public typealias MOutput = OperationOutput<OverridePullRequestApprovalRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<OverridePullRequestApprovalRulesOutputError>
}

extension OverridePullRequestApprovalRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OverridePullRequestApprovalRulesInput(overrideStatus: \(String(describing: overrideStatus)), pullRequestId: \(String(describing: pullRequestId)), revisionId: \(String(describing: revisionId)))"}
}

extension OverridePullRequestApprovalRulesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case overrideStatus
        case pullRequestId
        case revisionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrideStatus = overrideStatus {
            try encodeContainer.encode(overrideStatus.rawValue, forKey: .overrideStatus)
        }
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

public struct OverridePullRequestApprovalRulesInputHeadersMiddleware: Middleware {
    public let id: String = "OverridePullRequestApprovalRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<OverridePullRequestApprovalRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<OverridePullRequestApprovalRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<OverridePullRequestApprovalRulesInput>
    public typealias MOutput = OperationOutput<OverridePullRequestApprovalRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<OverridePullRequestApprovalRulesOutputError>
}

public struct OverridePullRequestApprovalRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "OverridePullRequestApprovalRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<OverridePullRequestApprovalRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<OverridePullRequestApprovalRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<OverridePullRequestApprovalRulesInput>
    public typealias MOutput = OperationOutput<OverridePullRequestApprovalRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<OverridePullRequestApprovalRulesOutputError>
}

public struct OverridePullRequestApprovalRulesInput: Equatable {
    /// <p>Whether you want to set aside approval rule requirements for the pull request (OVERRIDE) or revoke a previous override and apply
    ///         approval rule requirements (REVOKE). REVOKE status is not stored.</p>
    public let overrideStatus: OverrideStatus?
    /// <p>The system-generated ID of the pull request for which you want to override all
    ///             approval rule requirements. To get this information, use
    ///             <a>GetPullRequest</a>.</p>
    public let pullRequestId: String?
    /// <p>The system-generated ID of the most recent revision of the pull request. You cannot override approval rules for anything but the most recent revision of a pull request.
    ///             To get the revision ID, use GetPullRequest.</p>
    public let revisionId: String?

    public init (
        overrideStatus: OverrideStatus? = nil,
        pullRequestId: String? = nil,
        revisionId: String? = nil
    )
    {
        self.overrideStatus = overrideStatus
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

struct OverridePullRequestApprovalRulesInputBody: Equatable {
    public let pullRequestId: String?
    public let revisionId: String?
    public let overrideStatus: OverrideStatus?
}

extension OverridePullRequestApprovalRulesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case overrideStatus
        case pullRequestId
        case revisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let overrideStatusDecoded = try containerValues.decodeIfPresent(OverrideStatus.self, forKey: .overrideStatus)
        overrideStatus = overrideStatusDecoded
    }
}

extension OverridePullRequestApprovalRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension OverridePullRequestApprovalRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOverrideStatusException" : self = .invalidOverrideStatusException(try InvalidOverrideStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRevisionIdException" : self = .invalidRevisionIdException(try InvalidRevisionIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OverrideAlreadySetException" : self = .overrideAlreadySetException(try OverrideAlreadySetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OverrideStatusRequiredException" : self = .overrideStatusRequiredException(try OverrideStatusRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RevisionIdRequiredException" : self = .revisionIdRequiredException(try RevisionIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RevisionNotCurrentException" : self = .revisionNotCurrentException(try RevisionNotCurrentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum OverridePullRequestApprovalRulesOutputError: Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidOverrideStatusException(InvalidOverrideStatusException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidRevisionIdException(InvalidRevisionIdException)
    case overrideAlreadySetException(OverrideAlreadySetException)
    case overrideStatusRequiredException(OverrideStatusRequiredException)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case revisionIdRequiredException(RevisionIdRequiredException)
    case revisionNotCurrentException(RevisionNotCurrentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension OverridePullRequestApprovalRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OverridePullRequestApprovalRulesOutputResponse()"}
}

extension OverridePullRequestApprovalRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct OverridePullRequestApprovalRulesOutputResponse: Equatable {

    public init() {}
}

struct OverridePullRequestApprovalRulesOutputResponseBody: Equatable {
}

extension OverridePullRequestApprovalRulesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum OverrideStatus {
    case `override`
    case revoke
    case sdkUnknown(String)
}

extension OverrideStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OverrideStatus] {
        return [
            .override,
            .revoke,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .override: return "OVERRIDE"
        case .revoke: return "REVOKE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OverrideStatus(rawValue: rawValue) ?? OverrideStatus.sdkUnknown(rawValue)
    }
}

extension OverrideStatusRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OverrideStatusRequiredException(message: \(String(describing: message)))"}
}

extension OverrideStatusRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OverrideStatusRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An override status is required, but no value was provided. Valid values include OVERRIDE and REVOKE.</p>
public struct OverrideStatusRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OverrideStatusRequiredExceptionBody: Equatable {
    public let message: String?
}

extension OverrideStatusRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParentCommitDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParentCommitDoesNotExistException(message: \(String(describing: message)))"}
}

extension ParentCommitDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ParentCommitDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The parent commit ID is not valid because it does not exist. The specified parent commit ID does not exist in the specified branch of the repository.</p>
public struct ParentCommitDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ParentCommitDoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension ParentCommitDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParentCommitIdOutdatedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParentCommitIdOutdatedException(message: \(String(describing: message)))"}
}

extension ParentCommitIdOutdatedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ParentCommitIdOutdatedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The file could not be added because the provided parent commit ID is not the current tip of the specified branch. To view the full commit ID of the current head
///         of the branch, use <a>GetBranch</a>.</p>
public struct ParentCommitIdOutdatedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ParentCommitIdOutdatedExceptionBody: Equatable {
    public let message: String?
}

extension ParentCommitIdOutdatedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParentCommitIdRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParentCommitIdRequiredException(message: \(String(describing: message)))"}
}

extension ParentCommitIdRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ParentCommitIdRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A parent commit ID is required. To view the full commit ID of a branch in a repository, use <a>GetBranch</a> or a Git command
///         (for example, git pull or git log).</p>
public struct ParentCommitIdRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ParentCommitIdRequiredExceptionBody: Equatable {
    public let message: String?
}

extension ParentCommitIdRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PathDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PathDoesNotExistException(message: \(String(describing: message)))"}
}

extension PathDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PathDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified path does not exist.</p>
public struct PathDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PathDoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension PathDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PathRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PathRequiredException(message: \(String(describing: message)))"}
}

extension PathRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PathRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The folderPath for a location cannot be null.</p>
public struct PathRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PathRequiredExceptionBody: Equatable {
    public let message: String?
}

extension PathRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PostCommentForComparedCommitInputBodyMiddleware: Middleware {
    public let id: String = "PostCommentForComparedCommitInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PostCommentForComparedCommitInput>,
                  next: H) -> Swift.Result<OperationOutput<PostCommentForComparedCommitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PostCommentForComparedCommitInput>
    public typealias MOutput = OperationOutput<PostCommentForComparedCommitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PostCommentForComparedCommitOutputError>
}

extension PostCommentForComparedCommitInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PostCommentForComparedCommitInput(afterCommitId: \(String(describing: afterCommitId)), beforeCommitId: \(String(describing: beforeCommitId)), clientRequestToken: \(String(describing: clientRequestToken)), content: \(String(describing: content)), location: \(String(describing: location)), repositoryName: \(String(describing: repositoryName)))"}
}

extension PostCommentForComparedCommitInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case afterCommitId
        case beforeCommitId
        case clientRequestToken
        case content
        case location
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterCommitId = afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeCommitId = beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct PostCommentForComparedCommitInputHeadersMiddleware: Middleware {
    public let id: String = "PostCommentForComparedCommitInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PostCommentForComparedCommitInput>,
                  next: H) -> Swift.Result<OperationOutput<PostCommentForComparedCommitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PostCommentForComparedCommitInput>
    public typealias MOutput = OperationOutput<PostCommentForComparedCommitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PostCommentForComparedCommitOutputError>
}

public struct PostCommentForComparedCommitInputQueryItemMiddleware: Middleware {
    public let id: String = "PostCommentForComparedCommitInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PostCommentForComparedCommitInput>,
                  next: H) -> Swift.Result<OperationOutput<PostCommentForComparedCommitOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PostCommentForComparedCommitInput>
    public typealias MOutput = OperationOutput<PostCommentForComparedCommitOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PostCommentForComparedCommitOutputError>
}

public struct PostCommentForComparedCommitInput: Equatable {
    /// <p>To establish the directionality of the comparison, the full commit ID of the after
    ///             commit.</p>
    public let afterCommitId: String?
    /// <p>To establish the directionality of the comparison, the full commit ID of the before
    ///             commit. Required for commenting on any commit unless that commit is the initial
    ///             commit.</p>
    public let beforeCommitId: String?
    /// <p>A unique, client-generated idempotency token that, when provided in a request, ensures
    ///             the request cannot be repeated with a changed parameter. If a request is received with
    ///             the same parameters and a token is included, the request returns information about the
    ///             initial request that used that token.</p>
    public var clientRequestToken: String?
    /// <p>The content of the comment you want to make.</p>
    public let content: String?
    /// <p>The location of the comparison where you want to comment.</p>
    public let location: Location?
    /// <p>The name of the repository where you want to post a comment on the comparison between commits.</p>
    public let repositoryName: String?

    public init (
        afterCommitId: String? = nil,
        beforeCommitId: String? = nil,
        clientRequestToken: String? = nil,
        content: String? = nil,
        location: Location? = nil,
        repositoryName: String? = nil
    )
    {
        self.afterCommitId = afterCommitId
        self.beforeCommitId = beforeCommitId
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.location = location
        self.repositoryName = repositoryName
    }
}

struct PostCommentForComparedCommitInputBody: Equatable {
    public let repositoryName: String?
    public let beforeCommitId: String?
    public let afterCommitId: String?
    public let location: Location?
    public let content: String?
    public let clientRequestToken: String?
}

extension PostCommentForComparedCommitInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case afterCommitId
        case beforeCommitId
        case clientRequestToken
        case content
        case location
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Location.self, forKey: .location)
        location = locationDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension PostCommentForComparedCommitOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PostCommentForComparedCommitOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BeforeCommitIdAndAfterCommitIdAreSameException" : self = .beforeCommitIdAndAfterCommitIdAreSameException(try BeforeCommitIdAndAfterCommitIdAreSameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientRequestTokenRequiredException" : self = .clientRequestTokenRequiredException(try ClientRequestTokenRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentContentRequiredException" : self = .commentContentRequiredException(try CommentContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentContentSizeLimitExceededException" : self = .commentContentSizeLimitExceededException(try CommentContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitIdRequiredException" : self = .commitIdRequiredException(try CommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotencyParameterMismatchException" : self = .idempotencyParameterMismatchException(try IdempotencyParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientRequestTokenException" : self = .invalidClientRequestTokenException(try InvalidClientRequestTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFileLocationException" : self = .invalidFileLocationException(try InvalidFileLocationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilePositionException" : self = .invalidFilePositionException(try InvalidFilePositionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRelativeFileVersionEnumException" : self = .invalidRelativeFileVersionEnumException(try InvalidRelativeFileVersionEnumException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathDoesNotExistException" : self = .pathDoesNotExistException(try PathDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PostCommentForComparedCommitOutputError: Equatable {
    case beforeCommitIdAndAfterCommitIdAreSameException(BeforeCommitIdAndAfterCommitIdAreSameException)
    case clientRequestTokenRequiredException(ClientRequestTokenRequiredException)
    case commentContentRequiredException(CommentContentRequiredException)
    case commentContentSizeLimitExceededException(CommentContentSizeLimitExceededException)
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitIdRequiredException(CommitIdRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case idempotencyParameterMismatchException(IdempotencyParameterMismatchException)
    case invalidClientRequestTokenException(InvalidClientRequestTokenException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidFileLocationException(InvalidFileLocationException)
    case invalidFilePositionException(InvalidFilePositionException)
    case invalidPathException(InvalidPathException)
    case invalidRelativeFileVersionEnumException(InvalidRelativeFileVersionEnumException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case pathDoesNotExistException(PathDoesNotExistException)
    case pathRequiredException(PathRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PostCommentForComparedCommitOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PostCommentForComparedCommitOutputResponse(afterBlobId: \(String(describing: afterBlobId)), afterCommitId: \(String(describing: afterCommitId)), beforeBlobId: \(String(describing: beforeBlobId)), beforeCommitId: \(String(describing: beforeCommitId)), comment: \(String(describing: comment)), location: \(String(describing: location)), repositoryName: \(String(describing: repositoryName)))"}
}

extension PostCommentForComparedCommitOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PostCommentForComparedCommitOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.afterBlobId = output.afterBlobId
            self.afterCommitId = output.afterCommitId
            self.beforeBlobId = output.beforeBlobId
            self.beforeCommitId = output.beforeCommitId
            self.comment = output.comment
            self.location = output.location
            self.repositoryName = output.repositoryName
        } else {
            self.afterBlobId = nil
            self.afterCommitId = nil
            self.beforeBlobId = nil
            self.beforeCommitId = nil
            self.comment = nil
            self.location = nil
            self.repositoryName = nil
        }
    }
}

public struct PostCommentForComparedCommitOutputResponse: Equatable {
    /// <p>In the directionality you established, the blob ID of the after blob.</p>
    public let afterBlobId: String?
    /// <p>In the directionality you established, the full commit ID of the after commit.</p>
    public let afterCommitId: String?
    /// <p>In the directionality you established, the blob ID of the before blob.</p>
    public let beforeBlobId: String?
    /// <p>In the directionality you established, the full commit ID of the before commit.</p>
    public let beforeCommitId: String?
    /// <p>The content of the comment you posted.</p>
    public let comment: Comment?
    /// <p>The location of the comment in the comparison between the two commits.</p>
    public let location: Location?
    /// <p>The name of the repository where you posted a comment on the comparison between commits.</p>
    public let repositoryName: String?

    public init (
        afterBlobId: String? = nil,
        afterCommitId: String? = nil,
        beforeBlobId: String? = nil,
        beforeCommitId: String? = nil,
        comment: Comment? = nil,
        location: Location? = nil,
        repositoryName: String? = nil
    )
    {
        self.afterBlobId = afterBlobId
        self.afterCommitId = afterCommitId
        self.beforeBlobId = beforeBlobId
        self.beforeCommitId = beforeCommitId
        self.comment = comment
        self.location = location
        self.repositoryName = repositoryName
    }
}

struct PostCommentForComparedCommitOutputResponseBody: Equatable {
    public let repositoryName: String?
    public let beforeCommitId: String?
    public let afterCommitId: String?
    public let beforeBlobId: String?
    public let afterBlobId: String?
    public let location: Location?
    public let comment: Comment?
}

extension PostCommentForComparedCommitOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case afterBlobId
        case afterCommitId
        case beforeBlobId
        case beforeCommitId
        case comment
        case location
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let beforeBlobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beforeBlobId)
        beforeBlobId = beforeBlobIdDecoded
        let afterBlobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterBlobId)
        afterBlobId = afterBlobIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Location.self, forKey: .location)
        location = locationDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

public struct PostCommentForPullRequestInputBodyMiddleware: Middleware {
    public let id: String = "PostCommentForPullRequestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PostCommentForPullRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<PostCommentForPullRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PostCommentForPullRequestInput>
    public typealias MOutput = OperationOutput<PostCommentForPullRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PostCommentForPullRequestOutputError>
}

extension PostCommentForPullRequestInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PostCommentForPullRequestInput(afterCommitId: \(String(describing: afterCommitId)), beforeCommitId: \(String(describing: beforeCommitId)), clientRequestToken: \(String(describing: clientRequestToken)), content: \(String(describing: content)), location: \(String(describing: location)), pullRequestId: \(String(describing: pullRequestId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension PostCommentForPullRequestInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case afterCommitId
        case beforeCommitId
        case clientRequestToken
        case content
        case location
        case pullRequestId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterCommitId = afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeCommitId = beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct PostCommentForPullRequestInputHeadersMiddleware: Middleware {
    public let id: String = "PostCommentForPullRequestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PostCommentForPullRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<PostCommentForPullRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PostCommentForPullRequestInput>
    public typealias MOutput = OperationOutput<PostCommentForPullRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PostCommentForPullRequestOutputError>
}

public struct PostCommentForPullRequestInputQueryItemMiddleware: Middleware {
    public let id: String = "PostCommentForPullRequestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PostCommentForPullRequestInput>,
                  next: H) -> Swift.Result<OperationOutput<PostCommentForPullRequestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PostCommentForPullRequestInput>
    public typealias MOutput = OperationOutput<PostCommentForPullRequestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PostCommentForPullRequestOutputError>
}

public struct PostCommentForPullRequestInput: Equatable {
    /// <p>The full commit ID of the commit in the source branch that is the current tip of the branch for the pull request when you post the comment.</p>
    public let afterCommitId: String?
    /// <p>The full commit ID of the commit in the destination branch that was the tip of the branch at the time the pull request was created.</p>
    public let beforeCommitId: String?
    /// <p>A unique, client-generated idempotency token that, when provided in a request, ensures
    ///             the request cannot be repeated with a changed parameter. If a request is received with
    ///             the same parameters and a token is included, the request returns information about the
    ///             initial request that used that token.</p>
    public var clientRequestToken: String?
    /// <p>The content of your comment on the change.</p>
    public let content: String?
    /// <p>The location of the change where you want to post your comment. If no location is
    ///             provided, the comment is posted as a general comment on the pull request difference
    ///             between the before commit ID and the after commit ID.</p>
    public let location: Location?
    /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
    public let pullRequestId: String?
    /// <p>The name of the repository where you want to post a comment on a pull request.</p>
    public let repositoryName: String?

    public init (
        afterCommitId: String? = nil,
        beforeCommitId: String? = nil,
        clientRequestToken: String? = nil,
        content: String? = nil,
        location: Location? = nil,
        pullRequestId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.afterCommitId = afterCommitId
        self.beforeCommitId = beforeCommitId
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.location = location
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
    }
}

struct PostCommentForPullRequestInputBody: Equatable {
    public let pullRequestId: String?
    public let repositoryName: String?
    public let beforeCommitId: String?
    public let afterCommitId: String?
    public let location: Location?
    public let content: String?
    public let clientRequestToken: String?
}

extension PostCommentForPullRequestInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case afterCommitId
        case beforeCommitId
        case clientRequestToken
        case content
        case location
        case pullRequestId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Location.self, forKey: .location)
        location = locationDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension PostCommentForPullRequestOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PostCommentForPullRequestOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BeforeCommitIdAndAfterCommitIdAreSameException" : self = .beforeCommitIdAndAfterCommitIdAreSameException(try BeforeCommitIdAndAfterCommitIdAreSameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientRequestTokenRequiredException" : self = .clientRequestTokenRequiredException(try ClientRequestTokenRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentContentRequiredException" : self = .commentContentRequiredException(try CommentContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentContentSizeLimitExceededException" : self = .commentContentSizeLimitExceededException(try CommentContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitDoesNotExistException" : self = .commitDoesNotExistException(try CommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitIdRequiredException" : self = .commitIdRequiredException(try CommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotencyParameterMismatchException" : self = .idempotencyParameterMismatchException(try IdempotencyParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientRequestTokenException" : self = .invalidClientRequestTokenException(try InvalidClientRequestTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommitIdException" : self = .invalidCommitIdException(try InvalidCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFileLocationException" : self = .invalidFileLocationException(try InvalidFileLocationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFilePositionException" : self = .invalidFilePositionException(try InvalidFilePositionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRelativeFileVersionEnumException" : self = .invalidRelativeFileVersionEnumException(try InvalidRelativeFileVersionEnumException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathDoesNotExistException" : self = .pathDoesNotExistException(try PathDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotAssociatedWithPullRequestException" : self = .repositoryNotAssociatedWithPullRequestException(try RepositoryNotAssociatedWithPullRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PostCommentForPullRequestOutputError: Equatable {
    case beforeCommitIdAndAfterCommitIdAreSameException(BeforeCommitIdAndAfterCommitIdAreSameException)
    case clientRequestTokenRequiredException(ClientRequestTokenRequiredException)
    case commentContentRequiredException(CommentContentRequiredException)
    case commentContentSizeLimitExceededException(CommentContentSizeLimitExceededException)
    case commitDoesNotExistException(CommitDoesNotExistException)
    case commitIdRequiredException(CommitIdRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case idempotencyParameterMismatchException(IdempotencyParameterMismatchException)
    case invalidClientRequestTokenException(InvalidClientRequestTokenException)
    case invalidCommitIdException(InvalidCommitIdException)
    case invalidFileLocationException(InvalidFileLocationException)
    case invalidFilePositionException(InvalidFilePositionException)
    case invalidPathException(InvalidPathException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidRelativeFileVersionEnumException(InvalidRelativeFileVersionEnumException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case pathDoesNotExistException(PathDoesNotExistException)
    case pathRequiredException(PathRequiredException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case repositoryNotAssociatedWithPullRequestException(RepositoryNotAssociatedWithPullRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PostCommentForPullRequestOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PostCommentForPullRequestOutputResponse(afterBlobId: \(String(describing: afterBlobId)), afterCommitId: \(String(describing: afterCommitId)), beforeBlobId: \(String(describing: beforeBlobId)), beforeCommitId: \(String(describing: beforeCommitId)), comment: \(String(describing: comment)), location: \(String(describing: location)), pullRequestId: \(String(describing: pullRequestId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension PostCommentForPullRequestOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PostCommentForPullRequestOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.afterBlobId = output.afterBlobId
            self.afterCommitId = output.afterCommitId
            self.beforeBlobId = output.beforeBlobId
            self.beforeCommitId = output.beforeCommitId
            self.comment = output.comment
            self.location = output.location
            self.pullRequestId = output.pullRequestId
            self.repositoryName = output.repositoryName
        } else {
            self.afterBlobId = nil
            self.afterCommitId = nil
            self.beforeBlobId = nil
            self.beforeCommitId = nil
            self.comment = nil
            self.location = nil
            self.pullRequestId = nil
            self.repositoryName = nil
        }
    }
}

public struct PostCommentForPullRequestOutputResponse: Equatable {
    /// <p>In the directionality of the pull request, the blob ID of the after blob.</p>
    public let afterBlobId: String?
    /// <p>The full commit ID of the commit in the destination branch where the pull request is
    ///             merged.</p>
    public let afterCommitId: String?
    /// <p>In the directionality of the pull request, the blob ID of the before blob.</p>
    public let beforeBlobId: String?
    /// <p>The full commit ID of the commit in the source branch used to create the pull request,
    ///             or in the case of an updated pull request, the full commit ID of the commit used to update the pull request.</p>
    public let beforeCommitId: String?
    /// <p>The content of the comment you posted.</p>
    public let comment: Comment?
    /// <p>The location of the change where you posted your comment.</p>
    public let location: Location?
    /// <p>The system-generated ID of the pull request. </p>
    public let pullRequestId: String?
    /// <p>The name of the repository where you posted a comment on a pull request.</p>
    public let repositoryName: String?

    public init (
        afterBlobId: String? = nil,
        afterCommitId: String? = nil,
        beforeBlobId: String? = nil,
        beforeCommitId: String? = nil,
        comment: Comment? = nil,
        location: Location? = nil,
        pullRequestId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.afterBlobId = afterBlobId
        self.afterCommitId = afterCommitId
        self.beforeBlobId = beforeBlobId
        self.beforeCommitId = beforeCommitId
        self.comment = comment
        self.location = location
        self.pullRequestId = pullRequestId
        self.repositoryName = repositoryName
    }
}

struct PostCommentForPullRequestOutputResponseBody: Equatable {
    public let repositoryName: String?
    public let pullRequestId: String?
    public let beforeCommitId: String?
    public let afterCommitId: String?
    public let beforeBlobId: String?
    public let afterBlobId: String?
    public let location: Location?
    public let comment: Comment?
}

extension PostCommentForPullRequestOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case afterBlobId
        case afterCommitId
        case beforeBlobId
        case beforeCommitId
        case comment
        case location
        case pullRequestId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let beforeBlobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beforeBlobId)
        beforeBlobId = beforeBlobIdDecoded
        let afterBlobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterBlobId)
        afterBlobId = afterBlobIdDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Location.self, forKey: .location)
        location = locationDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

public struct PostCommentReplyInputBodyMiddleware: Middleware {
    public let id: String = "PostCommentReplyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PostCommentReplyInput>,
                  next: H) -> Swift.Result<OperationOutput<PostCommentReplyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PostCommentReplyInput>
    public typealias MOutput = OperationOutput<PostCommentReplyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PostCommentReplyOutputError>
}

extension PostCommentReplyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PostCommentReplyInput(clientRequestToken: \(String(describing: clientRequestToken)), content: \(String(describing: content)), inReplyTo: \(String(describing: inReplyTo)))"}
}

extension PostCommentReplyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case content
        case inReplyTo
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let inReplyTo = inReplyTo {
            try encodeContainer.encode(inReplyTo, forKey: .inReplyTo)
        }
    }
}

public struct PostCommentReplyInputHeadersMiddleware: Middleware {
    public let id: String = "PostCommentReplyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PostCommentReplyInput>,
                  next: H) -> Swift.Result<OperationOutput<PostCommentReplyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PostCommentReplyInput>
    public typealias MOutput = OperationOutput<PostCommentReplyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PostCommentReplyOutputError>
}

public struct PostCommentReplyInputQueryItemMiddleware: Middleware {
    public let id: String = "PostCommentReplyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PostCommentReplyInput>,
                  next: H) -> Swift.Result<OperationOutput<PostCommentReplyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PostCommentReplyInput>
    public typealias MOutput = OperationOutput<PostCommentReplyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PostCommentReplyOutputError>
}

public struct PostCommentReplyInput: Equatable {
    /// <p>A unique, client-generated idempotency token that, when provided in a request, ensures
    ///             the request cannot be repeated with a changed parameter. If a request is received with
    ///             the same parameters and a token is included, the request returns information about the
    ///             initial request that used that token.</p>
    public var clientRequestToken: String?
    /// <p>The contents of your reply to a comment.</p>
    public let content: String?
    /// <p>The system-generated ID of the comment to which you want to reply. To get this ID, use <a>GetCommentsForComparedCommit</a>
    ///         or <a>GetCommentsForPullRequest</a>.</p>
    public let inReplyTo: String?

    public init (
        clientRequestToken: String? = nil,
        content: String? = nil,
        inReplyTo: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.inReplyTo = inReplyTo
    }
}

struct PostCommentReplyInputBody: Equatable {
    public let inReplyTo: String?
    public let clientRequestToken: String?
    public let content: String?
}

extension PostCommentReplyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case content
        case inReplyTo
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inReplyToDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inReplyTo)
        inReplyTo = inReplyToDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
    }
}

extension PostCommentReplyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PostCommentReplyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClientRequestTokenRequiredException" : self = .clientRequestTokenRequiredException(try ClientRequestTokenRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentContentRequiredException" : self = .commentContentRequiredException(try CommentContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentContentSizeLimitExceededException" : self = .commentContentSizeLimitExceededException(try CommentContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentDoesNotExistException" : self = .commentDoesNotExistException(try CommentDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentIdRequiredException" : self = .commentIdRequiredException(try CommentIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotencyParameterMismatchException" : self = .idempotencyParameterMismatchException(try IdempotencyParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientRequestTokenException" : self = .invalidClientRequestTokenException(try InvalidClientRequestTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommentIdException" : self = .invalidCommentIdException(try InvalidCommentIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PostCommentReplyOutputError: Equatable {
    case clientRequestTokenRequiredException(ClientRequestTokenRequiredException)
    case commentContentRequiredException(CommentContentRequiredException)
    case commentContentSizeLimitExceededException(CommentContentSizeLimitExceededException)
    case commentDoesNotExistException(CommentDoesNotExistException)
    case commentIdRequiredException(CommentIdRequiredException)
    case idempotencyParameterMismatchException(IdempotencyParameterMismatchException)
    case invalidClientRequestTokenException(InvalidClientRequestTokenException)
    case invalidCommentIdException(InvalidCommentIdException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PostCommentReplyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PostCommentReplyOutputResponse(comment: \(String(describing: comment)))"}
}

extension PostCommentReplyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PostCommentReplyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.comment = output.comment
        } else {
            self.comment = nil
        }
    }
}

public struct PostCommentReplyOutputResponse: Equatable {
    /// <p>Information about the reply to a comment.</p>
    public let comment: Comment?

    public init (
        comment: Comment? = nil
    )
    {
        self.comment = comment
    }
}

struct PostCommentReplyOutputResponseBody: Equatable {
    public let comment: Comment?
}

extension PostCommentReplyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comment
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension PullRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRules
        case authorArn
        case clientRequestToken
        case creationDate
        case description
        case lastActivityDate
        case pullRequestId
        case pullRequestStatus
        case pullRequestTargets
        case revisionId
        case title
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRules = approvalRules {
            var approvalRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvalRules)
            for approvalruleslist0 in approvalRules {
                try approvalRulesContainer.encode(approvalruleslist0)
            }
        }
        if let authorArn = authorArn {
            try encodeContainer.encode(authorArn, forKey: .authorArn)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastActivityDate = lastActivityDate {
            try encodeContainer.encode(lastActivityDate.timeIntervalSince1970, forKey: .lastActivityDate)
        }
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let pullRequestStatus = pullRequestStatus {
            try encodeContainer.encode(pullRequestStatus.rawValue, forKey: .pullRequestStatus)
        }
        if let pullRequestTargets = pullRequestTargets {
            var pullRequestTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pullRequestTargets)
            for pullrequesttargetlist0 in pullRequestTargets {
                try pullRequestTargetsContainer.encode(pullrequesttargetlist0)
            }
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let lastActivityDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastActivityDate)
        lastActivityDate = lastActivityDateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let pullRequestStatusDecoded = try containerValues.decodeIfPresent(PullRequestStatusEnum.self, forKey: .pullRequestStatus)
        pullRequestStatus = pullRequestStatusDecoded
        let authorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorArn)
        authorArn = authorArnDecoded
        let pullRequestTargetsContainer = try containerValues.decodeIfPresent([PullRequestTarget?].self, forKey: .pullRequestTargets)
        var pullRequestTargetsDecoded0:[PullRequestTarget]? = nil
        if let pullRequestTargetsContainer = pullRequestTargetsContainer {
            pullRequestTargetsDecoded0 = [PullRequestTarget]()
            for structure0 in pullRequestTargetsContainer {
                if let structure0 = structure0 {
                    pullRequestTargetsDecoded0?.append(structure0)
                }
            }
        }
        pullRequestTargets = pullRequestTargetsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let approvalRulesContainer = try containerValues.decodeIfPresent([ApprovalRule?].self, forKey: .approvalRules)
        var approvalRulesDecoded0:[ApprovalRule]? = nil
        if let approvalRulesContainer = approvalRulesContainer {
            approvalRulesDecoded0 = [ApprovalRule]()
            for structure0 in approvalRulesContainer {
                if let structure0 = structure0 {
                    approvalRulesDecoded0?.append(structure0)
                }
            }
        }
        approvalRules = approvalRulesDecoded0
    }
}

extension PullRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PullRequest(approvalRules: \(String(describing: approvalRules)), authorArn: \(String(describing: authorArn)), clientRequestToken: \(String(describing: clientRequestToken)), creationDate: \(String(describing: creationDate)), description: \(String(describing: description)), lastActivityDate: \(String(describing: lastActivityDate)), pullRequestId: \(String(describing: pullRequestId)), pullRequestStatus: \(String(describing: pullRequestStatus)), pullRequestTargets: \(String(describing: pullRequestTargets)), revisionId: \(String(describing: revisionId)), title: \(String(describing: title)))"}
}

/// <p>Returns information about a pull request.</p>
public struct PullRequest: Equatable {
    /// <p>The approval rules applied to the pull request.</p>
    public let approvalRules: [ApprovalRule]?
    /// <p>The Amazon Resource Name (ARN) of the user who created the pull request.</p>
    public let authorArn: String?
    /// <p>A unique, client-generated idempotency token that, when provided in a request, ensures
    ///             the request cannot be repeated with a changed parameter. If a request is received with
    ///             the same parameters and a token is included, the request returns information about the
    ///             initial request that used that token.</p>
    public let clientRequestToken: String?
    /// <p>The date and time the pull request was originally created, in timestamp format.</p>
    public let creationDate: Date?
    /// <p>The user-defined description of the pull request. This description can be used to clarify what should be reviewed and other details of the request.</p>
    public let description: String?
    /// <p>The day and time of the last user or system activity on the pull request, in timestamp format.</p>
    public let lastActivityDate: Date?
    /// <p>The system-generated ID of the pull request. </p>
    public let pullRequestId: String?
    /// <p>The status of the pull request. Pull request status can only change from <code>OPEN</code> to <code>CLOSED</code>.</p>
    public let pullRequestStatus: PullRequestStatusEnum?
    /// <p>The targets of the pull request, including the source branch and destination branch for the pull request.</p>
    public let pullRequestTargets: [PullRequestTarget]?
    /// <p>The system-generated revision ID for the pull request.</p>
    public let revisionId: String?
    /// <p>The user-defined title of the pull request. This title is displayed in the list of
    ///             pull requests to other repository users.</p>
    public let title: String?

    public init (
        approvalRules: [ApprovalRule]? = nil,
        authorArn: String? = nil,
        clientRequestToken: String? = nil,
        creationDate: Date? = nil,
        description: String? = nil,
        lastActivityDate: Date? = nil,
        pullRequestId: String? = nil,
        pullRequestStatus: PullRequestStatusEnum? = nil,
        pullRequestTargets: [PullRequestTarget]? = nil,
        revisionId: String? = nil,
        title: String? = nil
    )
    {
        self.approvalRules = approvalRules
        self.authorArn = authorArn
        self.clientRequestToken = clientRequestToken
        self.creationDate = creationDate
        self.description = description
        self.lastActivityDate = lastActivityDate
        self.pullRequestId = pullRequestId
        self.pullRequestStatus = pullRequestStatus
        self.pullRequestTargets = pullRequestTargets
        self.revisionId = revisionId
        self.title = title
    }
}

extension PullRequestAlreadyClosedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PullRequestAlreadyClosedException(message: \(String(describing: message)))"}
}

extension PullRequestAlreadyClosedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PullRequestAlreadyClosedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pull request status cannot be updated because it is already closed.</p>
public struct PullRequestAlreadyClosedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PullRequestAlreadyClosedExceptionBody: Equatable {
    public let message: String?
}

extension PullRequestAlreadyClosedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PullRequestApprovalRulesNotSatisfiedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PullRequestApprovalRulesNotSatisfiedException(message: \(String(describing: message)))"}
}

extension PullRequestApprovalRulesNotSatisfiedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PullRequestApprovalRulesNotSatisfiedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pull request cannot be merged because one or more approval rules applied to the pull request have conditions that have not been met.</p>
public struct PullRequestApprovalRulesNotSatisfiedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PullRequestApprovalRulesNotSatisfiedExceptionBody: Equatable {
    public let message: String?
}

extension PullRequestApprovalRulesNotSatisfiedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PullRequestCannotBeApprovedByAuthorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PullRequestCannotBeApprovedByAuthorException(message: \(String(describing: message)))"}
}

extension PullRequestCannotBeApprovedByAuthorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PullRequestCannotBeApprovedByAuthorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The approval cannot be applied because the user approving the pull request matches the user who created the pull request. You cannot approve a pull
///         request that you created.</p>
public struct PullRequestCannotBeApprovedByAuthorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PullRequestCannotBeApprovedByAuthorExceptionBody: Equatable {
    public let message: String?
}

extension PullRequestCannotBeApprovedByAuthorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PullRequestCreatedEventMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationCommitId
        case mergeBase
        case repositoryName
        case sourceCommitId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationCommitId = destinationCommitId {
            try encodeContainer.encode(destinationCommitId, forKey: .destinationCommitId)
        }
        if let mergeBase = mergeBase {
            try encodeContainer.encode(mergeBase, forKey: .mergeBase)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommitId = sourceCommitId {
            try encodeContainer.encode(sourceCommitId, forKey: .sourceCommitId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommitId)
        sourceCommitId = sourceCommitIdDecoded
        let destinationCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationCommitId)
        destinationCommitId = destinationCommitIdDecoded
        let mergeBaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mergeBase)
        mergeBase = mergeBaseDecoded
    }
}

extension PullRequestCreatedEventMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PullRequestCreatedEventMetadata(destinationCommitId: \(String(describing: destinationCommitId)), mergeBase: \(String(describing: mergeBase)), repositoryName: \(String(describing: repositoryName)), sourceCommitId: \(String(describing: sourceCommitId)))"}
}

/// <p>Metadata about the pull request that is used when comparing the pull request source with its destination.</p>
public struct PullRequestCreatedEventMetadata: Equatable {
    /// <p>The commit ID of the tip of the branch specified as the destination branch when the pull request was created.</p>
    public let destinationCommitId: String?
    /// <p>The commit ID of the most recent commit that the source branch and the destination branch have in common.</p>
    public let mergeBase: String?
    /// <p>The name of the repository where the pull request was created.</p>
    public let repositoryName: String?
    /// <p>The commit ID on the source branch used when the pull request was created.</p>
    public let sourceCommitId: String?

    public init (
        destinationCommitId: String? = nil,
        mergeBase: String? = nil,
        repositoryName: String? = nil,
        sourceCommitId: String? = nil
    )
    {
        self.destinationCommitId = destinationCommitId
        self.mergeBase = mergeBase
        self.repositoryName = repositoryName
        self.sourceCommitId = sourceCommitId
    }
}

extension PullRequestDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PullRequestDoesNotExistException(message: \(String(describing: message)))"}
}

extension PullRequestDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PullRequestDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
public struct PullRequestDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PullRequestDoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension PullRequestDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PullRequestEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actorArn
        case approvalRuleEventMetadata
        case approvalRuleOverriddenEventMetadata
        case approvalStateChangedEventMetadata
        case eventDate
        case pullRequestCreatedEventMetadata
        case pullRequestEventType
        case pullRequestId
        case pullRequestMergedStateChangedEventMetadata
        case pullRequestSourceReferenceUpdatedEventMetadata
        case pullRequestStatusChangedEventMetadata
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actorArn = actorArn {
            try encodeContainer.encode(actorArn, forKey: .actorArn)
        }
        if let approvalRuleEventMetadata = approvalRuleEventMetadata {
            try encodeContainer.encode(approvalRuleEventMetadata, forKey: .approvalRuleEventMetadata)
        }
        if let approvalRuleOverriddenEventMetadata = approvalRuleOverriddenEventMetadata {
            try encodeContainer.encode(approvalRuleOverriddenEventMetadata, forKey: .approvalRuleOverriddenEventMetadata)
        }
        if let approvalStateChangedEventMetadata = approvalStateChangedEventMetadata {
            try encodeContainer.encode(approvalStateChangedEventMetadata, forKey: .approvalStateChangedEventMetadata)
        }
        if let eventDate = eventDate {
            try encodeContainer.encode(eventDate.timeIntervalSince1970, forKey: .eventDate)
        }
        if let pullRequestCreatedEventMetadata = pullRequestCreatedEventMetadata {
            try encodeContainer.encode(pullRequestCreatedEventMetadata, forKey: .pullRequestCreatedEventMetadata)
        }
        if let pullRequestEventType = pullRequestEventType {
            try encodeContainer.encode(pullRequestEventType.rawValue, forKey: .pullRequestEventType)
        }
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let pullRequestMergedStateChangedEventMetadata = pullRequestMergedStateChangedEventMetadata {
            try encodeContainer.encode(pullRequestMergedStateChangedEventMetadata, forKey: .pullRequestMergedStateChangedEventMetadata)
        }
        if let pullRequestSourceReferenceUpdatedEventMetadata = pullRequestSourceReferenceUpdatedEventMetadata {
            try encodeContainer.encode(pullRequestSourceReferenceUpdatedEventMetadata, forKey: .pullRequestSourceReferenceUpdatedEventMetadata)
        }
        if let pullRequestStatusChangedEventMetadata = pullRequestStatusChangedEventMetadata {
            try encodeContainer.encode(pullRequestStatusChangedEventMetadata, forKey: .pullRequestStatusChangedEventMetadata)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let eventDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventDate)
        eventDate = eventDateDecoded
        let pullRequestEventTypeDecoded = try containerValues.decodeIfPresent(PullRequestEventType.self, forKey: .pullRequestEventType)
        pullRequestEventType = pullRequestEventTypeDecoded
        let actorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actorArn)
        actorArn = actorArnDecoded
        let pullRequestCreatedEventMetadataDecoded = try containerValues.decodeIfPresent(PullRequestCreatedEventMetadata.self, forKey: .pullRequestCreatedEventMetadata)
        pullRequestCreatedEventMetadata = pullRequestCreatedEventMetadataDecoded
        let pullRequestStatusChangedEventMetadataDecoded = try containerValues.decodeIfPresent(PullRequestStatusChangedEventMetadata.self, forKey: .pullRequestStatusChangedEventMetadata)
        pullRequestStatusChangedEventMetadata = pullRequestStatusChangedEventMetadataDecoded
        let pullRequestSourceReferenceUpdatedEventMetadataDecoded = try containerValues.decodeIfPresent(PullRequestSourceReferenceUpdatedEventMetadata.self, forKey: .pullRequestSourceReferenceUpdatedEventMetadata)
        pullRequestSourceReferenceUpdatedEventMetadata = pullRequestSourceReferenceUpdatedEventMetadataDecoded
        let pullRequestMergedStateChangedEventMetadataDecoded = try containerValues.decodeIfPresent(PullRequestMergedStateChangedEventMetadata.self, forKey: .pullRequestMergedStateChangedEventMetadata)
        pullRequestMergedStateChangedEventMetadata = pullRequestMergedStateChangedEventMetadataDecoded
        let approvalRuleEventMetadataDecoded = try containerValues.decodeIfPresent(ApprovalRuleEventMetadata.self, forKey: .approvalRuleEventMetadata)
        approvalRuleEventMetadata = approvalRuleEventMetadataDecoded
        let approvalStateChangedEventMetadataDecoded = try containerValues.decodeIfPresent(ApprovalStateChangedEventMetadata.self, forKey: .approvalStateChangedEventMetadata)
        approvalStateChangedEventMetadata = approvalStateChangedEventMetadataDecoded
        let approvalRuleOverriddenEventMetadataDecoded = try containerValues.decodeIfPresent(ApprovalRuleOverriddenEventMetadata.self, forKey: .approvalRuleOverriddenEventMetadata)
        approvalRuleOverriddenEventMetadata = approvalRuleOverriddenEventMetadataDecoded
    }
}

extension PullRequestEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PullRequestEvent(actorArn: \(String(describing: actorArn)), approvalRuleEventMetadata: \(String(describing: approvalRuleEventMetadata)), approvalRuleOverriddenEventMetadata: \(String(describing: approvalRuleOverriddenEventMetadata)), approvalStateChangedEventMetadata: \(String(describing: approvalStateChangedEventMetadata)), eventDate: \(String(describing: eventDate)), pullRequestCreatedEventMetadata: \(String(describing: pullRequestCreatedEventMetadata)), pullRequestEventType: \(String(describing: pullRequestEventType)), pullRequestId: \(String(describing: pullRequestId)), pullRequestMergedStateChangedEventMetadata: \(String(describing: pullRequestMergedStateChangedEventMetadata)), pullRequestSourceReferenceUpdatedEventMetadata: \(String(describing: pullRequestSourceReferenceUpdatedEventMetadata)), pullRequestStatusChangedEventMetadata: \(String(describing: pullRequestStatusChangedEventMetadata)))"}
}

/// <p>Returns information about a pull request event.</p>
public struct PullRequestEvent: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the user whose actions resulted in the event.
    ///             Examples include updating the pull request with more commits or changing the status of a
    ///             pull request.</p>
    public let actorArn: String?
    /// <p>Information about a pull request event.</p>
    public let approvalRuleEventMetadata: ApprovalRuleEventMetadata?
    /// <p>Information about an approval rule override event for a pull request.</p>
    public let approvalRuleOverriddenEventMetadata: ApprovalRuleOverriddenEventMetadata?
    /// <p>Information about an approval state change for a pull request.</p>
    public let approvalStateChangedEventMetadata: ApprovalStateChangedEventMetadata?
    /// <p>The day and time of the pull request event, in timestamp format.</p>
    public let eventDate: Date?
    /// <p>Information about the source and destination branches for the pull request.</p>
    public let pullRequestCreatedEventMetadata: PullRequestCreatedEventMetadata?
    /// <p>The type of the pull request event (for example, a status change event
    ///             (PULL_REQUEST_STATUS_CHANGED) or update event
    ///             (PULL_REQUEST_SOURCE_REFERENCE_UPDATED)).</p>
    public let pullRequestEventType: PullRequestEventType?
    /// <p>The system-generated ID of the pull request.</p>
    public let pullRequestId: String?
    /// <p>Information about the change in mergability state for the pull request event.</p>
    public let pullRequestMergedStateChangedEventMetadata: PullRequestMergedStateChangedEventMetadata?
    /// <p>Information about the updated source branch for the pull request event. </p>
    public let pullRequestSourceReferenceUpdatedEventMetadata: PullRequestSourceReferenceUpdatedEventMetadata?
    /// <p>Information about the change in status for the pull request event.</p>
    public let pullRequestStatusChangedEventMetadata: PullRequestStatusChangedEventMetadata?

    public init (
        actorArn: String? = nil,
        approvalRuleEventMetadata: ApprovalRuleEventMetadata? = nil,
        approvalRuleOverriddenEventMetadata: ApprovalRuleOverriddenEventMetadata? = nil,
        approvalStateChangedEventMetadata: ApprovalStateChangedEventMetadata? = nil,
        eventDate: Date? = nil,
        pullRequestCreatedEventMetadata: PullRequestCreatedEventMetadata? = nil,
        pullRequestEventType: PullRequestEventType? = nil,
        pullRequestId: String? = nil,
        pullRequestMergedStateChangedEventMetadata: PullRequestMergedStateChangedEventMetadata? = nil,
        pullRequestSourceReferenceUpdatedEventMetadata: PullRequestSourceReferenceUpdatedEventMetadata? = nil,
        pullRequestStatusChangedEventMetadata: PullRequestStatusChangedEventMetadata? = nil
    )
    {
        self.actorArn = actorArn
        self.approvalRuleEventMetadata = approvalRuleEventMetadata
        self.approvalRuleOverriddenEventMetadata = approvalRuleOverriddenEventMetadata
        self.approvalStateChangedEventMetadata = approvalStateChangedEventMetadata
        self.eventDate = eventDate
        self.pullRequestCreatedEventMetadata = pullRequestCreatedEventMetadata
        self.pullRequestEventType = pullRequestEventType
        self.pullRequestId = pullRequestId
        self.pullRequestMergedStateChangedEventMetadata = pullRequestMergedStateChangedEventMetadata
        self.pullRequestSourceReferenceUpdatedEventMetadata = pullRequestSourceReferenceUpdatedEventMetadata
        self.pullRequestStatusChangedEventMetadata = pullRequestStatusChangedEventMetadata
    }
}

public enum PullRequestEventType {
    case pullRequestApprovalRuleCreated
    case pullRequestApprovalRuleDeleted
    case pullRequestApprovalRuleOverridden
    case pullRequestApprovalRuleUpdated
    case pullRequestApprovalStateChanged
    case pullRequestCreated
    case pullRequestMergeStateChanged
    case pullRequestSourceReferenceUpdated
    case pullRequestStatusChanged
    case sdkUnknown(String)
}

extension PullRequestEventType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PullRequestEventType] {
        return [
            .pullRequestApprovalRuleCreated,
            .pullRequestApprovalRuleDeleted,
            .pullRequestApprovalRuleOverridden,
            .pullRequestApprovalRuleUpdated,
            .pullRequestApprovalStateChanged,
            .pullRequestCreated,
            .pullRequestMergeStateChanged,
            .pullRequestSourceReferenceUpdated,
            .pullRequestStatusChanged,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .pullRequestApprovalRuleCreated: return "PULL_REQUEST_APPROVAL_RULE_CREATED"
        case .pullRequestApprovalRuleDeleted: return "PULL_REQUEST_APPROVAL_RULE_DELETED"
        case .pullRequestApprovalRuleOverridden: return "PULL_REQUEST_APPROVAL_RULE_OVERRIDDEN"
        case .pullRequestApprovalRuleUpdated: return "PULL_REQUEST_APPROVAL_RULE_UPDATED"
        case .pullRequestApprovalStateChanged: return "PULL_REQUEST_APPROVAL_STATE_CHANGED"
        case .pullRequestCreated: return "PULL_REQUEST_CREATED"
        case .pullRequestMergeStateChanged: return "PULL_REQUEST_MERGE_STATE_CHANGED"
        case .pullRequestSourceReferenceUpdated: return "PULL_REQUEST_SOURCE_REFERENCE_UPDATED"
        case .pullRequestStatusChanged: return "PULL_REQUEST_STATUS_CHANGED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PullRequestEventType(rawValue: rawValue) ?? PullRequestEventType.sdkUnknown(rawValue)
    }
}

extension PullRequestIdRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PullRequestIdRequiredException(message: \(String(describing: message)))"}
}

extension PullRequestIdRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PullRequestIdRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A pull request ID is required, but none was provided.</p>
public struct PullRequestIdRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PullRequestIdRequiredExceptionBody: Equatable {
    public let message: String?
}

extension PullRequestIdRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PullRequestMergedStateChangedEventMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationReference
        case mergeMetadata
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationReference = destinationReference {
            try encodeContainer.encode(destinationReference, forKey: .destinationReference)
        }
        if let mergeMetadata = mergeMetadata {
            try encodeContainer.encode(mergeMetadata, forKey: .mergeMetadata)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let destinationReferenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationReference)
        destinationReference = destinationReferenceDecoded
        let mergeMetadataDecoded = try containerValues.decodeIfPresent(MergeMetadata.self, forKey: .mergeMetadata)
        mergeMetadata = mergeMetadataDecoded
    }
}

extension PullRequestMergedStateChangedEventMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PullRequestMergedStateChangedEventMetadata(destinationReference: \(String(describing: destinationReference)), mergeMetadata: \(String(describing: mergeMetadata)), repositoryName: \(String(describing: repositoryName)))"}
}

/// <p>Returns information about the change in the merge state for a pull request event. </p>
public struct PullRequestMergedStateChangedEventMetadata: Equatable {
    /// <p>The name of the branch that the pull request is merged into.</p>
    public let destinationReference: String?
    /// <p>Information about the merge state change event.</p>
    public let mergeMetadata: MergeMetadata?
    /// <p>The name of the repository where the pull request was created.</p>
    public let repositoryName: String?

    public init (
        destinationReference: String? = nil,
        mergeMetadata: MergeMetadata? = nil,
        repositoryName: String? = nil
    )
    {
        self.destinationReference = destinationReference
        self.mergeMetadata = mergeMetadata
        self.repositoryName = repositoryName
    }
}

extension PullRequestSourceReferenceUpdatedEventMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case afterCommitId
        case beforeCommitId
        case mergeBase
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterCommitId = afterCommitId {
            try encodeContainer.encode(afterCommitId, forKey: .afterCommitId)
        }
        if let beforeCommitId = beforeCommitId {
            try encodeContainer.encode(beforeCommitId, forKey: .beforeCommitId)
        }
        if let mergeBase = mergeBase {
            try encodeContainer.encode(mergeBase, forKey: .mergeBase)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let beforeCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beforeCommitId)
        beforeCommitId = beforeCommitIdDecoded
        let afterCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .afterCommitId)
        afterCommitId = afterCommitIdDecoded
        let mergeBaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mergeBase)
        mergeBase = mergeBaseDecoded
    }
}

extension PullRequestSourceReferenceUpdatedEventMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PullRequestSourceReferenceUpdatedEventMetadata(afterCommitId: \(String(describing: afterCommitId)), beforeCommitId: \(String(describing: beforeCommitId)), mergeBase: \(String(describing: mergeBase)), repositoryName: \(String(describing: repositoryName)))"}
}

/// <p>Information about an update to the source branch of a pull request.</p>
public struct PullRequestSourceReferenceUpdatedEventMetadata: Equatable {
    /// <p>The full commit ID of the commit in the source branch that was the tip of the branch at the time the pull request was updated.</p>
    public let afterCommitId: String?
    /// <p>The full commit ID of the commit in the destination branch that was the tip of the branch at the time the pull request was updated.</p>
    public let beforeCommitId: String?
    /// <p>The commit ID of the most recent commit that the source branch and the destination branch have in common.</p>
    public let mergeBase: String?
    /// <p>The name of the repository where the pull request was updated.</p>
    public let repositoryName: String?

    public init (
        afterCommitId: String? = nil,
        beforeCommitId: String? = nil,
        mergeBase: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.afterCommitId = afterCommitId
        self.beforeCommitId = beforeCommitId
        self.mergeBase = mergeBase
        self.repositoryName = repositoryName
    }
}

extension PullRequestStatusChangedEventMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pullRequestStatus
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestStatus = pullRequestStatus {
            try encodeContainer.encode(pullRequestStatus.rawValue, forKey: .pullRequestStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestStatusDecoded = try containerValues.decodeIfPresent(PullRequestStatusEnum.self, forKey: .pullRequestStatus)
        pullRequestStatus = pullRequestStatusDecoded
    }
}

extension PullRequestStatusChangedEventMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PullRequestStatusChangedEventMetadata(pullRequestStatus: \(String(describing: pullRequestStatus)))"}
}

/// <p>Information about a change to the status of a pull request.</p>
public struct PullRequestStatusChangedEventMetadata: Equatable {
    /// <p>The changed status of the pull request.</p>
    public let pullRequestStatus: PullRequestStatusEnum?

    public init (
        pullRequestStatus: PullRequestStatusEnum? = nil
    )
    {
        self.pullRequestStatus = pullRequestStatus
    }
}

public enum PullRequestStatusEnum {
    case closed
    case `open`
    case sdkUnknown(String)
}

extension PullRequestStatusEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PullRequestStatusEnum] {
        return [
            .closed,
            .open,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .closed: return "CLOSED"
        case .open: return "OPEN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PullRequestStatusEnum(rawValue: rawValue) ?? PullRequestStatusEnum.sdkUnknown(rawValue)
    }
}

extension PullRequestStatusRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PullRequestStatusRequiredException(message: \(String(describing: message)))"}
}

extension PullRequestStatusRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PullRequestStatusRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A pull request status is required, but none was provided.</p>
public struct PullRequestStatusRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PullRequestStatusRequiredExceptionBody: Equatable {
    public let message: String?
}

extension PullRequestStatusRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PullRequestTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationCommit
        case destinationReference
        case mergeBase
        case mergeMetadata
        case repositoryName
        case sourceCommit
        case sourceReference
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationCommit = destinationCommit {
            try encodeContainer.encode(destinationCommit, forKey: .destinationCommit)
        }
        if let destinationReference = destinationReference {
            try encodeContainer.encode(destinationReference, forKey: .destinationReference)
        }
        if let mergeBase = mergeBase {
            try encodeContainer.encode(mergeBase, forKey: .mergeBase)
        }
        if let mergeMetadata = mergeMetadata {
            try encodeContainer.encode(mergeMetadata, forKey: .mergeMetadata)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceCommit = sourceCommit {
            try encodeContainer.encode(sourceCommit, forKey: .sourceCommit)
        }
        if let sourceReference = sourceReference {
            try encodeContainer.encode(sourceReference, forKey: .sourceReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceReferenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceReference)
        sourceReference = sourceReferenceDecoded
        let destinationReferenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationReference)
        destinationReference = destinationReferenceDecoded
        let destinationCommitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationCommit)
        destinationCommit = destinationCommitDecoded
        let sourceCommitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceCommit)
        sourceCommit = sourceCommitDecoded
        let mergeBaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mergeBase)
        mergeBase = mergeBaseDecoded
        let mergeMetadataDecoded = try containerValues.decodeIfPresent(MergeMetadata.self, forKey: .mergeMetadata)
        mergeMetadata = mergeMetadataDecoded
    }
}

extension PullRequestTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PullRequestTarget(destinationCommit: \(String(describing: destinationCommit)), destinationReference: \(String(describing: destinationReference)), mergeBase: \(String(describing: mergeBase)), mergeMetadata: \(String(describing: mergeMetadata)), repositoryName: \(String(describing: repositoryName)), sourceCommit: \(String(describing: sourceCommit)), sourceReference: \(String(describing: sourceReference)))"}
}

/// <p>Returns information about a pull request target.</p>
public struct PullRequestTarget: Equatable {
    /// <p>The full commit ID that is the tip of the destination branch. This is the commit where the pull request was or will be merged.</p>
    public let destinationCommit: String?
    /// <p>The branch of the repository where the pull request changes are merged. Also known as
    ///             the destination branch. </p>
    public let destinationReference: String?
    /// <p>The commit ID of the most recent commit that the source branch and the destination branch have in common.</p>
    public let mergeBase: String?
    /// <p>Returns metadata about the state of the merge, including whether the merge has been made.</p>
    public let mergeMetadata: MergeMetadata?
    /// <p>The name of the repository that contains the pull request source and destination branches.</p>
    public let repositoryName: String?
    /// <p>The full commit ID of the tip of the source branch used to create the pull request. If
    ///             the pull request branch is updated by a push while the pull request is open, the commit
    ///             ID changes to reflect the new tip of the branch.</p>
    public let sourceCommit: String?
    /// <p>The branch of the repository that contains the changes for the pull request. Also known as the source branch.</p>
    public let sourceReference: String?

    public init (
        destinationCommit: String? = nil,
        destinationReference: String? = nil,
        mergeBase: String? = nil,
        mergeMetadata: MergeMetadata? = nil,
        repositoryName: String? = nil,
        sourceCommit: String? = nil,
        sourceReference: String? = nil
    )
    {
        self.destinationCommit = destinationCommit
        self.destinationReference = destinationReference
        self.mergeBase = mergeBase
        self.mergeMetadata = mergeMetadata
        self.repositoryName = repositoryName
        self.sourceCommit = sourceCommit
        self.sourceReference = sourceReference
    }
}

public struct PutCommentReactionInputBodyMiddleware: Middleware {
    public let id: String = "PutCommentReactionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutCommentReactionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutCommentReactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutCommentReactionInput>
    public typealias MOutput = OperationOutput<PutCommentReactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutCommentReactionOutputError>
}

extension PutCommentReactionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutCommentReactionInput(commentId: \(String(describing: commentId)), reactionValue: \(String(describing: reactionValue)))"}
}

extension PutCommentReactionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commentId
        case reactionValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
        if let reactionValue = reactionValue {
            try encodeContainer.encode(reactionValue, forKey: .reactionValue)
        }
    }
}

public struct PutCommentReactionInputHeadersMiddleware: Middleware {
    public let id: String = "PutCommentReactionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutCommentReactionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutCommentReactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutCommentReactionInput>
    public typealias MOutput = OperationOutput<PutCommentReactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutCommentReactionOutputError>
}

public struct PutCommentReactionInputQueryItemMiddleware: Middleware {
    public let id: String = "PutCommentReactionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutCommentReactionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutCommentReactionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutCommentReactionInput>
    public typealias MOutput = OperationOutput<PutCommentReactionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutCommentReactionOutputError>
}

public struct PutCommentReactionInput: Equatable {
    /// <p>The ID of the comment to which you want to add or update a reaction.</p>
    public let commentId: String?
    /// <p>The emoji reaction you want to add or update. To remove a reaction, provide a value of blank or null. You can also provide the value of none.
    ///             For information about emoji reaction values supported in AWS CodeCommit, see the <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/how-to-commit-comment.html#emoji-reaction-table">AWS CodeCommit User Guide</a>.</p>
    public let reactionValue: String?

    public init (
        commentId: String? = nil,
        reactionValue: String? = nil
    )
    {
        self.commentId = commentId
        self.reactionValue = reactionValue
    }
}

struct PutCommentReactionInputBody: Equatable {
    public let commentId: String?
    public let reactionValue: String?
}

extension PutCommentReactionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commentId
        case reactionValue
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commentId)
        commentId = commentIdDecoded
        let reactionValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reactionValue)
        reactionValue = reactionValueDecoded
    }
}

extension PutCommentReactionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutCommentReactionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommentDeletedException" : self = .commentDeletedException(try CommentDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentDoesNotExistException" : self = .commentDoesNotExistException(try CommentDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentIdRequiredException" : self = .commentIdRequiredException(try CommentIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommentIdException" : self = .invalidCommentIdException(try InvalidCommentIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidReactionValueException" : self = .invalidReactionValueException(try InvalidReactionValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReactionLimitExceededException" : self = .reactionLimitExceededException(try ReactionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReactionValueRequiredException" : self = .reactionValueRequiredException(try ReactionValueRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutCommentReactionOutputError: Equatable {
    case commentDeletedException(CommentDeletedException)
    case commentDoesNotExistException(CommentDoesNotExistException)
    case commentIdRequiredException(CommentIdRequiredException)
    case invalidCommentIdException(InvalidCommentIdException)
    case invalidReactionValueException(InvalidReactionValueException)
    case reactionLimitExceededException(ReactionLimitExceededException)
    case reactionValueRequiredException(ReactionValueRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutCommentReactionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutCommentReactionOutputResponse()"}
}

extension PutCommentReactionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutCommentReactionOutputResponse: Equatable {

    public init() {}
}

struct PutCommentReactionOutputResponseBody: Equatable {
}

extension PutCommentReactionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension PutFileEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileContent
        case fileMode
        case filePath
        case sourceFile
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileContent = fileContent {
            try encodeContainer.encode(fileContent.base64EncodedString(), forKey: .fileContent)
        }
        if let fileMode = fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
        if let filePath = filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let sourceFile = sourceFile {
            try encodeContainer.encode(sourceFile, forKey: .sourceFile)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
        let fileContentDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .fileContent)
        fileContent = fileContentDecoded
        let sourceFileDecoded = try containerValues.decodeIfPresent(SourceFileSpecifier.self, forKey: .sourceFile)
        sourceFile = sourceFileDecoded
    }
}

extension PutFileEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFileEntry(fileContent: \(String(describing: fileContent)), fileMode: \(String(describing: fileMode)), filePath: \(String(describing: filePath)), sourceFile: \(String(describing: sourceFile)))"}
}

/// <p>Information about a file added or updated as part of a commit.</p>
public struct PutFileEntry: Equatable {
    /// <p>The content of the file, if a source file is not specified.</p>
    public let fileContent: Data?
    /// <p>The extrapolated file mode permissions for the file. Valid values include EXECUTABLE and NORMAL.</p>
    public let fileMode: FileModeTypeEnum?
    /// <p>The full path to the file in the repository, including the name of the file.</p>
    public let filePath: String?
    /// <p>The name and full path of the file that contains the changes you want to make as part of the commit,
    ///         if you are not providing the file content directly.</p>
    public let sourceFile: SourceFileSpecifier?

    public init (
        fileContent: Data? = nil,
        fileMode: FileModeTypeEnum? = nil,
        filePath: String? = nil,
        sourceFile: SourceFileSpecifier? = nil
    )
    {
        self.fileContent = fileContent
        self.fileMode = fileMode
        self.filePath = filePath
        self.sourceFile = sourceFile
    }
}

extension PutFileEntryConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFileEntryConflictException(message: \(String(describing: message)))"}
}

extension PutFileEntryConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutFileEntryConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The commit cannot be created because one or more files specified in the commit reference both a file and a folder.</p>
public struct PutFileEntryConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PutFileEntryConflictExceptionBody: Equatable {
    public let message: String?
}

extension PutFileEntryConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutFileInputBodyMiddleware: Middleware {
    public let id: String = "PutFileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFileInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFileInput>
    public typealias MOutput = OperationOutput<PutFileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFileOutputError>
}

extension PutFileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFileInput(branchName: \(String(describing: branchName)), commitMessage: \(String(describing: commitMessage)), email: \(String(describing: email)), fileContent: \(String(describing: fileContent)), fileMode: \(String(describing: fileMode)), filePath: \(String(describing: filePath)), name: \(String(describing: name)), parentCommitId: \(String(describing: parentCommitId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension PutFileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branchName
        case commitMessage
        case email
        case fileContent
        case fileMode
        case filePath
        case name
        case parentCommitId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branchName = branchName {
            try encodeContainer.encode(branchName, forKey: .branchName)
        }
        if let commitMessage = commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let fileContent = fileContent {
            try encodeContainer.encode(fileContent.base64EncodedString(), forKey: .fileContent)
        }
        if let fileMode = fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
        if let filePath = filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentCommitId = parentCommitId {
            try encodeContainer.encode(parentCommitId, forKey: .parentCommitId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct PutFileInputHeadersMiddleware: Middleware {
    public let id: String = "PutFileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFileInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFileInput>
    public typealias MOutput = OperationOutput<PutFileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFileOutputError>
}

public struct PutFileInputQueryItemMiddleware: Middleware {
    public let id: String = "PutFileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFileInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFileInput>
    public typealias MOutput = OperationOutput<PutFileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFileOutputError>
}

public struct PutFileInput: Equatable {
    /// <p>The name of the branch where you want to add or update the file. If this is an empty
    ///             repository, this branch is created.</p>
    public let branchName: String?
    /// <p>A message about why this file was added or updated. Although it is optional, a message
    ///             makes the commit history for your repository more useful.</p>
    public let commitMessage: String?
    /// <p>An email address for the person adding or updating the file.</p>
    public let email: String?
    /// <p>The content of the file, in binary object format. </p>
    public let fileContent: Data?
    /// <p>The file mode permissions of the blob. Valid file mode permissions are listed
    ///             here.</p>
    public let fileMode: FileModeTypeEnum?
    /// <p>The name of the file you want to add or update, including the relative path to the file in the repository.</p>
    ///         <note>
    ///             <p>If the path does not currently exist in the repository, the path is created as part of adding
    ///                 the file.</p>
    ///          </note>
    public let filePath: String?
    /// <p>The name of the person adding or updating the file. Although it is optional, a name
    ///             makes the commit history for your repository more useful.</p>
    public let name: String?
    /// <p>The full commit ID of the head commit in the branch where you want to add or update the file. If this is an empty repository,
    ///             no commit ID is required. If this is not an empty repository, a commit ID is required. </p>
    ///         <p>The commit ID must match the ID of the head commit at the time of the operation.
    ///             Otherwise, an error occurs, and the file is not added or updated.</p>
    public let parentCommitId: String?
    /// <p>The name of the repository where you want to add or update the file.</p>
    public let repositoryName: String?

    public init (
        branchName: String? = nil,
        commitMessage: String? = nil,
        email: String? = nil,
        fileContent: Data? = nil,
        fileMode: FileModeTypeEnum? = nil,
        filePath: String? = nil,
        name: String? = nil,
        parentCommitId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.branchName = branchName
        self.commitMessage = commitMessage
        self.email = email
        self.fileContent = fileContent
        self.fileMode = fileMode
        self.filePath = filePath
        self.name = name
        self.parentCommitId = parentCommitId
        self.repositoryName = repositoryName
    }
}

struct PutFileInputBody: Equatable {
    public let repositoryName: String?
    public let branchName: String?
    public let fileContent: Data?
    public let filePath: String?
    public let fileMode: FileModeTypeEnum?
    public let parentCommitId: String?
    public let commitMessage: String?
    public let name: String?
    public let email: String?
}

extension PutFileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case branchName
        case commitMessage
        case email
        case fileContent
        case fileMode
        case filePath
        case name
        case parentCommitId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let branchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .branchName)
        branchName = branchNameDecoded
        let fileContentDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .fileContent)
        fileContent = fileContentDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
        let parentCommitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentCommitId)
        parentCommitId = parentCommitIdDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
    }
}

extension PutFileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BranchDoesNotExistException" : self = .branchDoesNotExistException(try BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameIsTagNameException" : self = .branchNameIsTagNameException(try BranchNameIsTagNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommitMessageLengthExceededException" : self = .commitMessageLengthExceededException(try CommitMessageLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryNameConflictsWithFileNameException" : self = .directoryNameConflictsWithFileNameException(try DirectoryNameConflictsWithFileNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileContentRequiredException" : self = .fileContentRequiredException(try FileContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileContentSizeLimitExceededException" : self = .fileContentSizeLimitExceededException(try FileContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FileNameConflictsWithDirectoryNameException" : self = .fileNameConflictsWithDirectoryNameException(try FileNameConflictsWithDirectoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FilePathConflictsWithSubmodulePathException" : self = .filePathConflictsWithSubmodulePathException(try FilePathConflictsWithSubmodulePathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FolderContentSizeLimitExceededException" : self = .folderContentSizeLimitExceededException(try FolderContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDeletionParameterException" : self = .invalidDeletionParameterException(try InvalidDeletionParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEmailException" : self = .invalidEmailException(try InvalidEmailException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFileModeException" : self = .invalidFileModeException(try InvalidFileModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParentCommitIdException" : self = .invalidParentCommitIdException(try InvalidParentCommitIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPathException" : self = .invalidPathException(try InvalidPathException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameLengthExceededException" : self = .nameLengthExceededException(try NameLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParentCommitDoesNotExistException" : self = .parentCommitDoesNotExistException(try ParentCommitDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParentCommitIdOutdatedException" : self = .parentCommitIdOutdatedException(try ParentCommitIdOutdatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParentCommitIdRequiredException" : self = .parentCommitIdRequiredException(try ParentCommitIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PathRequiredException" : self = .pathRequiredException(try PathRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SameFileContentException" : self = .sameFileContentException(try SameFileContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFileOutputError: Equatable {
    case branchDoesNotExistException(BranchDoesNotExistException)
    case branchNameIsTagNameException(BranchNameIsTagNameException)
    case branchNameRequiredException(BranchNameRequiredException)
    case commitMessageLengthExceededException(CommitMessageLengthExceededException)
    case directoryNameConflictsWithFileNameException(DirectoryNameConflictsWithFileNameException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case fileContentRequiredException(FileContentRequiredException)
    case fileContentSizeLimitExceededException(FileContentSizeLimitExceededException)
    case fileNameConflictsWithDirectoryNameException(FileNameConflictsWithDirectoryNameException)
    case filePathConflictsWithSubmodulePathException(FilePathConflictsWithSubmodulePathException)
    case folderContentSizeLimitExceededException(FolderContentSizeLimitExceededException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidDeletionParameterException(InvalidDeletionParameterException)
    case invalidEmailException(InvalidEmailException)
    case invalidFileModeException(InvalidFileModeException)
    case invalidParentCommitIdException(InvalidParentCommitIdException)
    case invalidPathException(InvalidPathException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case nameLengthExceededException(NameLengthExceededException)
    case parentCommitDoesNotExistException(ParentCommitDoesNotExistException)
    case parentCommitIdOutdatedException(ParentCommitIdOutdatedException)
    case parentCommitIdRequiredException(ParentCommitIdRequiredException)
    case pathRequiredException(PathRequiredException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case sameFileContentException(SameFileContentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFileOutputResponse(blobId: \(String(describing: blobId)), commitId: \(String(describing: commitId)), treeId: \(String(describing: treeId)))"}
}

extension PutFileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutFileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.blobId = output.blobId
            self.commitId = output.commitId
            self.treeId = output.treeId
        } else {
            self.blobId = nil
            self.commitId = nil
            self.treeId = nil
        }
    }
}

public struct PutFileOutputResponse: Equatable {
    /// <p>The ID of the blob, which is its SHA-1 pointer.</p>
    public let blobId: String?
    /// <p>The full SHA ID of the commit that contains this file change.</p>
    public let commitId: String?
    /// <p>The full SHA-1 pointer of the tree information for the commit that contains this file change.</p>
    public let treeId: String?

    public init (
        blobId: String? = nil,
        commitId: String? = nil,
        treeId: String? = nil
    )
    {
        self.blobId = blobId
        self.commitId = commitId
        self.treeId = treeId
    }
}

struct PutFileOutputResponseBody: Equatable {
    public let commitId: String?
    public let blobId: String?
    public let treeId: String?
}

extension PutFileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case blobId
        case commitId
        case treeId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let blobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let treeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treeId)
        treeId = treeIdDecoded
    }
}

public struct PutRepositoryTriggersInputBodyMiddleware: Middleware {
    public let id: String = "PutRepositoryTriggersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRepositoryTriggersInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRepositoryTriggersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRepositoryTriggersInput>
    public typealias MOutput = OperationOutput<PutRepositoryTriggersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRepositoryTriggersOutputError>
}

extension PutRepositoryTriggersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRepositoryTriggersInput(repositoryName: \(String(describing: repositoryName)), triggers: \(String(describing: triggers)))"}
}

extension PutRepositoryTriggersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case repositoryName
        case triggers
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let triggers = triggers {
            var triggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .triggers)
            for repositorytriggerslist0 in triggers {
                try triggersContainer.encode(repositorytriggerslist0)
            }
        }
    }
}

public struct PutRepositoryTriggersInputHeadersMiddleware: Middleware {
    public let id: String = "PutRepositoryTriggersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRepositoryTriggersInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRepositoryTriggersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRepositoryTriggersInput>
    public typealias MOutput = OperationOutput<PutRepositoryTriggersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRepositoryTriggersOutputError>
}

public struct PutRepositoryTriggersInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRepositoryTriggersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRepositoryTriggersInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRepositoryTriggersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRepositoryTriggersInput>
    public typealias MOutput = OperationOutput<PutRepositoryTriggersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRepositoryTriggersOutputError>
}

/// <p>Represents the input of a put repository triggers operation.</p>
public struct PutRepositoryTriggersInput: Equatable {
    /// <p>The name of the repository where you want to create or update the trigger.</p>
    public let repositoryName: String?
    /// <p>The JSON block of configuration information for each trigger.</p>
    public let triggers: [RepositoryTrigger]?

    public init (
        repositoryName: String? = nil,
        triggers: [RepositoryTrigger]? = nil
    )
    {
        self.repositoryName = repositoryName
        self.triggers = triggers
    }
}

struct PutRepositoryTriggersInputBody: Equatable {
    public let repositoryName: String?
    public let triggers: [RepositoryTrigger]?
}

extension PutRepositoryTriggersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repositoryName
        case triggers
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let triggersContainer = try containerValues.decodeIfPresent([RepositoryTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[RepositoryTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [RepositoryTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
    }
}

extension PutRepositoryTriggersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRepositoryTriggersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerBranchNameException" : self = .invalidRepositoryTriggerBranchNameException(try InvalidRepositoryTriggerBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerCustomDataException" : self = .invalidRepositoryTriggerCustomDataException(try InvalidRepositoryTriggerCustomDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerDestinationArnException" : self = .invalidRepositoryTriggerDestinationArnException(try InvalidRepositoryTriggerDestinationArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerEventsException" : self = .invalidRepositoryTriggerEventsException(try InvalidRepositoryTriggerEventsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerNameException" : self = .invalidRepositoryTriggerNameException(try InvalidRepositoryTriggerNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerRegionException" : self = .invalidRepositoryTriggerRegionException(try InvalidRepositoryTriggerRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumBranchesExceededException" : self = .maximumBranchesExceededException(try MaximumBranchesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumRepositoryTriggersExceededException" : self = .maximumRepositoryTriggersExceededException(try MaximumRepositoryTriggersExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggerBranchNameListRequiredException" : self = .repositoryTriggerBranchNameListRequiredException(try RepositoryTriggerBranchNameListRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggerDestinationArnRequiredException" : self = .repositoryTriggerDestinationArnRequiredException(try RepositoryTriggerDestinationArnRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggerEventsListRequiredException" : self = .repositoryTriggerEventsListRequiredException(try RepositoryTriggerEventsListRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggerNameRequiredException" : self = .repositoryTriggerNameRequiredException(try RepositoryTriggerNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggersListRequiredException" : self = .repositoryTriggersListRequiredException(try RepositoryTriggersListRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRepositoryTriggersOutputError: Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidRepositoryTriggerBranchNameException(InvalidRepositoryTriggerBranchNameException)
    case invalidRepositoryTriggerCustomDataException(InvalidRepositoryTriggerCustomDataException)
    case invalidRepositoryTriggerDestinationArnException(InvalidRepositoryTriggerDestinationArnException)
    case invalidRepositoryTriggerEventsException(InvalidRepositoryTriggerEventsException)
    case invalidRepositoryTriggerNameException(InvalidRepositoryTriggerNameException)
    case invalidRepositoryTriggerRegionException(InvalidRepositoryTriggerRegionException)
    case maximumBranchesExceededException(MaximumBranchesExceededException)
    case maximumRepositoryTriggersExceededException(MaximumRepositoryTriggersExceededException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case repositoryTriggerBranchNameListRequiredException(RepositoryTriggerBranchNameListRequiredException)
    case repositoryTriggerDestinationArnRequiredException(RepositoryTriggerDestinationArnRequiredException)
    case repositoryTriggerEventsListRequiredException(RepositoryTriggerEventsListRequiredException)
    case repositoryTriggerNameRequiredException(RepositoryTriggerNameRequiredException)
    case repositoryTriggersListRequiredException(RepositoryTriggersListRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRepositoryTriggersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRepositoryTriggersOutputResponse(configurationId: \(String(describing: configurationId)))"}
}

extension PutRepositoryTriggersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutRepositoryTriggersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationId = output.configurationId
        } else {
            self.configurationId = nil
        }
    }
}

/// <p>Represents the output of a put repository triggers operation.</p>
public struct PutRepositoryTriggersOutputResponse: Equatable {
    /// <p>The system-generated unique ID for the create or update operation.</p>
    public let configurationId: String?

    public init (
        configurationId: String? = nil
    )
    {
        self.configurationId = configurationId
    }
}

struct PutRepositoryTriggersOutputResponseBody: Equatable {
    public let configurationId: String?
}

extension PutRepositoryTriggersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
    }
}

extension ReactionForComment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reaction
        case reactionUsers
        case reactionsFromDeletedUsersCount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reaction = reaction {
            try encodeContainer.encode(reaction, forKey: .reaction)
        }
        if let reactionUsers = reactionUsers {
            var reactionUsersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reactionUsers)
            for reactionuserslist0 in reactionUsers {
                try reactionUsersContainer.encode(reactionuserslist0)
            }
        }
        if let reactionsFromDeletedUsersCount = reactionsFromDeletedUsersCount {
            try encodeContainer.encode(reactionsFromDeletedUsersCount, forKey: .reactionsFromDeletedUsersCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reactionDecoded = try containerValues.decodeIfPresent(ReactionValueFormats.self, forKey: .reaction)
        reaction = reactionDecoded
        let reactionUsersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .reactionUsers)
        var reactionUsersDecoded0:[String]? = nil
        if let reactionUsersContainer = reactionUsersContainer {
            reactionUsersDecoded0 = [String]()
            for string0 in reactionUsersContainer {
                if let string0 = string0 {
                    reactionUsersDecoded0?.append(string0)
                }
            }
        }
        reactionUsers = reactionUsersDecoded0
        let reactionsFromDeletedUsersCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .reactionsFromDeletedUsersCount)
        reactionsFromDeletedUsersCount = reactionsFromDeletedUsersCountDecoded
    }
}

extension ReactionForComment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReactionForComment(reaction: \(String(describing: reaction)), reactionUsers: \(String(describing: reactionUsers)), reactionsFromDeletedUsersCount: \(String(describing: reactionsFromDeletedUsersCount)))"}
}

/// <p>Information about the reaction values provided by users on a comment.</p>
public struct ReactionForComment: Equatable {
    /// <p>The reaction for a specified comment.</p>
    public let reaction: ReactionValueFormats?
    /// <p>The Amazon Resource Names (ARNs) of users who have provided reactions to the comment.</p>
    public let reactionUsers: [String]?
    /// <p>A numerical count of users who reacted with the specified emoji whose identities have been subsequently deleted
    ///             from IAM. While these IAM users or roles no longer exist, the reactions might still appear in total reaction counts.</p>
    public let reactionsFromDeletedUsersCount: Int?

    public init (
        reaction: ReactionValueFormats? = nil,
        reactionUsers: [String]? = nil,
        reactionsFromDeletedUsersCount: Int? = nil
    )
    {
        self.reaction = reaction
        self.reactionUsers = reactionUsers
        self.reactionsFromDeletedUsersCount = reactionsFromDeletedUsersCount
    }
}

extension ReactionLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReactionLimitExceededException(message: \(String(describing: message)))"}
}

extension ReactionLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReactionLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of reactions has been exceeded. Reactions are limited to one reaction per user for each individual comment ID.</p>
public struct ReactionLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReactionLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ReactionLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReactionValueFormats: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emoji
        case shortCode
        case unicode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emoji = emoji {
            try encodeContainer.encode(emoji, forKey: .emoji)
        }
        if let shortCode = shortCode {
            try encodeContainer.encode(shortCode, forKey: .shortCode)
        }
        if let unicode = unicode {
            try encodeContainer.encode(unicode, forKey: .unicode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emojiDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emoji)
        emoji = emojiDecoded
        let shortCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shortCode)
        shortCode = shortCodeDecoded
        let unicodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unicode)
        unicode = unicodeDecoded
    }
}

extension ReactionValueFormats: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReactionValueFormats(emoji: \(String(describing: emoji)), shortCode: \(String(describing: shortCode)), unicode: \(String(describing: unicode)))"}
}

/// <p>Information about the values for reactions to a comment. AWS CodeCommit supports a limited set of reactions.</p>
public struct ReactionValueFormats: Equatable {
    /// <p>The Emoji Version 1.0 graphic of the reaction. These graphics are interpreted slightly differently on different operating systems.</p>
    public let emoji: String?
    /// <p>The emoji short code for the reaction. Short codes are interpreted slightly differently on different operating systems. </p>
    public let shortCode: String?
    /// <p>The Unicode codepoint for the reaction.</p>
    public let unicode: String?

    public init (
        emoji: String? = nil,
        shortCode: String? = nil,
        unicode: String? = nil
    )
    {
        self.emoji = emoji
        self.shortCode = shortCode
        self.unicode = unicode
    }
}

extension ReactionValueRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReactionValueRequiredException(message: \(String(describing: message)))"}
}

extension ReactionValueRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReactionValueRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A reaction value is required. </p>
public struct ReactionValueRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReactionValueRequiredExceptionBody: Equatable {
    public let message: String?
}

extension ReactionValueRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReferenceDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReferenceDoesNotExistException(message: \(String(describing: message)))"}
}

extension ReferenceDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReferenceDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified reference does not exist. You must provide a full commit ID.</p>
public struct ReferenceDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReferenceDoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension ReferenceDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReferenceNameRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReferenceNameRequiredException(message: \(String(describing: message)))"}
}

extension ReferenceNameRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReferenceNameRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A reference name is required, but none was provided.</p>
public struct ReferenceNameRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReferenceNameRequiredExceptionBody: Equatable {
    public let message: String?
}

extension ReferenceNameRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReferenceTypeNotSupportedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReferenceTypeNotSupportedException(message: \(String(describing: message)))"}
}

extension ReferenceTypeNotSupportedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReferenceTypeNotSupportedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified reference is not a supported type. </p>
public struct ReferenceTypeNotSupportedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReferenceTypeNotSupportedExceptionBody: Equatable {
    public let message: String?
}

extension ReferenceTypeNotSupportedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum RelativeFileVersionEnum {
    case after
    case before
    case sdkUnknown(String)
}

extension RelativeFileVersionEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RelativeFileVersionEnum] {
        return [
            .after,
            .before,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .after: return "AFTER"
        case .before: return "BEFORE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RelativeFileVersionEnum(rawValue: rawValue) ?? RelativeFileVersionEnum.sdkUnknown(rawValue)
    }
}

extension ReplaceContentEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case content
        case fileMode
        case filePath
        case replacementType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content.base64EncodedString(), forKey: .content)
        }
        if let fileMode = fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
        if let filePath = filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let replacementType = replacementType {
            try encodeContainer.encode(replacementType.rawValue, forKey: .replacementType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePath)
        filePath = filePathDecoded
        let replacementTypeDecoded = try containerValues.decodeIfPresent(ReplacementTypeEnum.self, forKey: .replacementType)
        replacementType = replacementTypeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .content)
        content = contentDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
    }
}

extension ReplaceContentEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplaceContentEntry(content: \(String(describing: content)), fileMode: \(String(describing: fileMode)), filePath: \(String(describing: filePath)), replacementType: \(String(describing: replacementType)))"}
}

/// <p>Information about a replacement content entry in the conflict of a merge or pull request operation.</p>
public struct ReplaceContentEntry: Equatable {
    /// <p>The base-64 encoded content to use when the replacement type is USE_NEW_CONTENT.</p>
    public let content: Data?
    /// <p>The file mode to apply during conflict resoltion.</p>
    public let fileMode: FileModeTypeEnum?
    /// <p>The path of the conflicting file.</p>
    public let filePath: String?
    /// <p>The replacement type to use when determining how to resolve the conflict.</p>
    public let replacementType: ReplacementTypeEnum?

    public init (
        content: Data? = nil,
        fileMode: FileModeTypeEnum? = nil,
        filePath: String? = nil,
        replacementType: ReplacementTypeEnum? = nil
    )
    {
        self.content = content
        self.fileMode = fileMode
        self.filePath = filePath
        self.replacementType = replacementType
    }
}

extension ReplacementContentRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplacementContentRequiredException(message: \(String(describing: message)))"}
}

extension ReplacementContentRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReplacementContentRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>USE_NEW_CONTENT was specified, but no replacement content has been provided.</p>
public struct ReplacementContentRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReplacementContentRequiredExceptionBody: Equatable {
    public let message: String?
}

extension ReplacementContentRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ReplacementTypeEnum {
    case keepBase
    case keepDestination
    case keepSource
    case useNewContent
    case sdkUnknown(String)
}

extension ReplacementTypeEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReplacementTypeEnum] {
        return [
            .keepBase,
            .keepDestination,
            .keepSource,
            .useNewContent,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .keepBase: return "KEEP_BASE"
        case .keepDestination: return "KEEP_DESTINATION"
        case .keepSource: return "KEEP_SOURCE"
        case .useNewContent: return "USE_NEW_CONTENT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReplacementTypeEnum(rawValue: rawValue) ?? ReplacementTypeEnum.sdkUnknown(rawValue)
    }
}

extension ReplacementTypeRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplacementTypeRequiredException(message: \(String(describing: message)))"}
}

extension ReplacementTypeRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReplacementTypeRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A replacement type is required.</p>
public struct ReplacementTypeRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReplacementTypeRequiredExceptionBody: Equatable {
    public let message: String?
}

extension ReplacementTypeRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryDoesNotExistException(message: \(String(describing: message)))"}
}

extension RepositoryDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified repository does not exist.</p>
public struct RepositoryDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryDoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryLimitExceededException(message: \(String(describing: message)))"}
}

extension RepositoryLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A repository resource limit was exceeded.</p>
public struct RepositoryLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case accountId
        case cloneUrlHttp
        case cloneUrlSsh
        case creationDate
        case defaultBranch
        case lastModifiedDate
        case repositoryDescription
        case repositoryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let cloneUrlHttp = cloneUrlHttp {
            try encodeContainer.encode(cloneUrlHttp, forKey: .cloneUrlHttp)
        }
        if let cloneUrlSsh = cloneUrlSsh {
            try encodeContainer.encode(cloneUrlSsh, forKey: .cloneUrlSsh)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let defaultBranch = defaultBranch {
            try encodeContainer.encode(defaultBranch, forKey: .defaultBranch)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let repositoryDescription = repositoryDescription {
            try encodeContainer.encode(repositoryDescription, forKey: .repositoryDescription)
        }
        if let repositoryId = repositoryId {
            try encodeContainer.encode(repositoryId, forKey: .repositoryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let repositoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryId)
        repositoryId = repositoryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryDescription)
        repositoryDescription = repositoryDescriptionDecoded
        let defaultBranchDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultBranch)
        defaultBranch = defaultBranchDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let cloneUrlHttpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloneUrlHttp)
        cloneUrlHttp = cloneUrlHttpDecoded
        let cloneUrlSshDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloneUrlSsh)
        cloneUrlSsh = cloneUrlSshDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension RepositoryMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryMetadata(arn: \(String(describing: arn)), accountId: \(String(describing: accountId)), cloneUrlHttp: \(String(describing: cloneUrlHttp)), cloneUrlSsh: \(String(describing: cloneUrlSsh)), creationDate: \(String(describing: creationDate)), defaultBranch: \(String(describing: defaultBranch)), lastModifiedDate: \(String(describing: lastModifiedDate)), repositoryDescription: \(String(describing: repositoryDescription)), repositoryId: \(String(describing: repositoryId)), repositoryName: \(String(describing: repositoryName)))"}
}

/// <p>Information about a repository.</p>
public struct RepositoryMetadata: Equatable {
    /// <p>The ID of the AWS account associated with the repository.</p>
    public let accountId: String?
    /// <p>The Amazon Resource Name (ARN) of the repository.</p>
    public let arn: String?
    /// <p>The URL to use for cloning the repository over HTTPS.</p>
    public let cloneUrlHttp: String?
    /// <p>The URL to use for cloning the repository over SSH.</p>
    public let cloneUrlSsh: String?
    /// <p>The date and time the repository was created, in timestamp format.</p>
    public let creationDate: Date?
    /// <p>The repository's default branch name.</p>
    public let defaultBranch: String?
    /// <p>The date and time the repository was last modified, in timestamp format.</p>
    public let lastModifiedDate: Date?
    /// <p>A comment or description about the repository.</p>
    public let repositoryDescription: String?
    /// <p>The ID of the repository.</p>
    public let repositoryId: String?
    /// <p>The repository's name.</p>
    public let repositoryName: String?

    public init (
        accountId: String? = nil,
        arn: String? = nil,
        cloneUrlHttp: String? = nil,
        cloneUrlSsh: String? = nil,
        creationDate: Date? = nil,
        defaultBranch: String? = nil,
        lastModifiedDate: Date? = nil,
        repositoryDescription: String? = nil,
        repositoryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.accountId = accountId
        self.arn = arn
        self.cloneUrlHttp = cloneUrlHttp
        self.cloneUrlSsh = cloneUrlSsh
        self.creationDate = creationDate
        self.defaultBranch = defaultBranch
        self.lastModifiedDate = lastModifiedDate
        self.repositoryDescription = repositoryDescription
        self.repositoryId = repositoryId
        self.repositoryName = repositoryName
    }
}

extension RepositoryNameExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryNameExistsException(message: \(String(describing: message)))"}
}

extension RepositoryNameExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryNameExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified repository name already exists.</p>
public struct RepositoryNameExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryNameExistsExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryNameExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryNameIdPair: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case repositoryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryId = repositoryId {
            try encodeContainer.encode(repositoryId, forKey: .repositoryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryId)
        repositoryId = repositoryIdDecoded
    }
}

extension RepositoryNameIdPair: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryNameIdPair(repositoryId: \(String(describing: repositoryId)), repositoryName: \(String(describing: repositoryName)))"}
}

/// <p>Information about a repository name and ID.</p>
public struct RepositoryNameIdPair: Equatable {
    /// <p>The ID associated with the repository.</p>
    public let repositoryId: String?
    /// <p>The name associated with the repository.</p>
    public let repositoryName: String?

    public init (
        repositoryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.repositoryId = repositoryId
        self.repositoryName = repositoryName
    }
}

extension RepositoryNameRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryNameRequiredException(message: \(String(describing: message)))"}
}

extension RepositoryNameRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryNameRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A repository name is required, but was not specified.</p>
public struct RepositoryNameRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryNameRequiredExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryNameRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryNamesRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryNamesRequiredException(message: \(String(describing: message)))"}
}

extension RepositoryNamesRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryNamesRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>At least one repository name object is required, but was not specified.</p>
public struct RepositoryNamesRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryNamesRequiredExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryNamesRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryNotAssociatedWithPullRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryNotAssociatedWithPullRequestException(message: \(String(describing: message)))"}
}

extension RepositoryNotAssociatedWithPullRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryNotAssociatedWithPullRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.</p>
public struct RepositoryNotAssociatedWithPullRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryNotAssociatedWithPullRequestExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryNotAssociatedWithPullRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryTrigger: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branches
        case customData
        case destinationArn
        case events
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branches = branches {
            var branchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .branches)
            for branchnamelist0 in branches {
                try branchesContainer.encode(branchnamelist0)
            }
        }
        if let customData = customData {
            try encodeContainer.encode(customData, forKey: .customData)
        }
        if let destinationArn = destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for repositorytriggereventlist0 in events {
                try eventsContainer.encode(repositorytriggereventlist0.rawValue)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let customDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customData)
        customData = customDataDecoded
        let branchesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .branches)
        var branchesDecoded0:[String]? = nil
        if let branchesContainer = branchesContainer {
            branchesDecoded0 = [String]()
            for string0 in branchesContainer {
                if let string0 = string0 {
                    branchesDecoded0?.append(string0)
                }
            }
        }
        branches = branchesDecoded0
        let eventsContainer = try containerValues.decodeIfPresent([RepositoryTriggerEventEnum?].self, forKey: .events)
        var eventsDecoded0:[RepositoryTriggerEventEnum]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [RepositoryTriggerEventEnum]()
            for string0 in eventsContainer {
                if let string0 = string0 {
                    eventsDecoded0?.append(string0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension RepositoryTrigger: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryTrigger(branches: \(String(describing: branches)), customData: \(String(describing: customData)), destinationArn: \(String(describing: destinationArn)), events: \(String(describing: events)), name: \(String(describing: name)))"}
}

/// <p>Information about a trigger for a repository.</p>
public struct RepositoryTrigger: Equatable {
    /// <p>The branches to be included in the trigger configuration. If you specify an empty
    ///             array, the trigger applies to all branches.</p>
    ///         <note>
    ///             <p>Although no content is required in the array, you must include the array itself.</p>
    ///         </note>
    public let branches: [String]?
    /// <p>Any custom data associated with the trigger to be included in the information sent to
    ///             the target of the trigger.</p>
    public let customData: String?
    /// <p>The ARN of the resource that is the target for a trigger (for example, the ARN of a
    ///             topic in Amazon SNS).</p>
    public let destinationArn: String?
    /// <p>The repository events that cause the trigger to run actions in another service, such
    ///             as sending a notification through Amazon SNS.
    ///
    ///         </p>
    ///          <note>
    ///             <p>The valid value "all" cannot be used with any other values.</p>
    ///          </note>
    public let events: [RepositoryTriggerEventEnum]?
    /// <p>The name of the trigger.</p>
    public let name: String?

    public init (
        branches: [String]? = nil,
        customData: String? = nil,
        destinationArn: String? = nil,
        events: [RepositoryTriggerEventEnum]? = nil,
        name: String? = nil
    )
    {
        self.branches = branches
        self.customData = customData
        self.destinationArn = destinationArn
        self.events = events
        self.name = name
    }
}

extension RepositoryTriggerBranchNameListRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryTriggerBranchNameListRequiredException(message: \(String(describing: message)))"}
}

extension RepositoryTriggerBranchNameListRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryTriggerBranchNameListRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>At least one branch name is required, but was not specified in the trigger
///             configuration.</p>
public struct RepositoryTriggerBranchNameListRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryTriggerBranchNameListRequiredExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryTriggerBranchNameListRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryTriggerDestinationArnRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryTriggerDestinationArnRequiredException(message: \(String(describing: message)))"}
}

extension RepositoryTriggerDestinationArnRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryTriggerDestinationArnRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A destination ARN for the target service for the trigger is required, but was not
///             specified.</p>
public struct RepositoryTriggerDestinationArnRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryTriggerDestinationArnRequiredExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryTriggerDestinationArnRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum RepositoryTriggerEventEnum {
    case all
    case createReference
    case deleteReference
    case updateReference
    case sdkUnknown(String)
}

extension RepositoryTriggerEventEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RepositoryTriggerEventEnum] {
        return [
            .all,
            .createReference,
            .deleteReference,
            .updateReference,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "all"
        case .createReference: return "createReference"
        case .deleteReference: return "deleteReference"
        case .updateReference: return "updateReference"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RepositoryTriggerEventEnum(rawValue: rawValue) ?? RepositoryTriggerEventEnum.sdkUnknown(rawValue)
    }
}

extension RepositoryTriggerEventsListRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryTriggerEventsListRequiredException(message: \(String(describing: message)))"}
}

extension RepositoryTriggerEventsListRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryTriggerEventsListRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>At least one event for the trigger is required, but was not specified.</p>
public struct RepositoryTriggerEventsListRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryTriggerEventsListRequiredExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryTriggerEventsListRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryTriggerExecutionFailure: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureMessage
        case trigger
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureMessage = failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let trigger = trigger {
            try encodeContainer.encode(trigger, forKey: .trigger)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trigger)
        trigger = triggerDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
    }
}

extension RepositoryTriggerExecutionFailure: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryTriggerExecutionFailure(failureMessage: \(String(describing: failureMessage)), trigger: \(String(describing: trigger)))"}
}

/// <p>A trigger failed to run.</p>
public struct RepositoryTriggerExecutionFailure: Equatable {
    /// <p>Message information about the trigger that did not run.</p>
    public let failureMessage: String?
    /// <p>The name of the trigger that did not run.</p>
    public let trigger: String?

    public init (
        failureMessage: String? = nil,
        trigger: String? = nil
    )
    {
        self.failureMessage = failureMessage
        self.trigger = trigger
    }
}

extension RepositoryTriggerNameRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryTriggerNameRequiredException(message: \(String(describing: message)))"}
}

extension RepositoryTriggerNameRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryTriggerNameRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A name for the trigger is required, but was not specified.</p>
public struct RepositoryTriggerNameRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryTriggerNameRequiredExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryTriggerNameRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryTriggersListRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryTriggersListRequiredException(message: \(String(describing: message)))"}
}

extension RepositoryTriggersListRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryTriggersListRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The list of triggers for the repository is required, but was not specified.</p>
public struct RepositoryTriggersListRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryTriggersListRequiredExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryTriggersListRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceArnRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceArnRequiredException(message: \(String(describing: message)))"}
}

extension ResourceArnRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceArnRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A valid Amazon Resource Name (ARN) for an AWS CodeCommit resource is required. For a list of valid resources in AWS CodeCommit, see
///             <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a>
///             in the AWS CodeCommit User Guide.</p>
public struct ResourceArnRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceArnRequiredExceptionBody: Equatable {
    public let message: String?
}

extension ResourceArnRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RestrictedSourceFileException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestrictedSourceFileException(message: \(String(describing: message)))"}
}

extension RestrictedSourceFileException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RestrictedSourceFileExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The commit cannot be created because one of the changes specifies copying or moving a .gitkeep file.</p>
public struct RestrictedSourceFileException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RestrictedSourceFileExceptionBody: Equatable {
    public let message: String?
}

extension RestrictedSourceFileExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RevisionIdRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevisionIdRequiredException(message: \(String(describing: message)))"}
}

extension RevisionIdRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RevisionIdRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A revision ID is required, but was not provided.</p>
public struct RevisionIdRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RevisionIdRequiredExceptionBody: Equatable {
    public let message: String?
}

extension RevisionIdRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RevisionNotCurrentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevisionNotCurrentException(message: \(String(describing: message)))"}
}

extension RevisionNotCurrentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RevisionNotCurrentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The revision ID provided in the request does not match the current revision ID. Use GetPullRequest to retrieve the current revision ID.</p>
public struct RevisionNotCurrentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RevisionNotCurrentExceptionBody: Equatable {
    public let message: String?
}

extension RevisionNotCurrentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SameFileContentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SameFileContentException(message: \(String(describing: message)))"}
}

extension SameFileContentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SameFileContentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The file was not added or updated because the content of the file is exactly the same as the content of that file in the repository and branch
///         that you specified.</p>
public struct SameFileContentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SameFileContentExceptionBody: Equatable {
    public let message: String?
}

extension SameFileContentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SamePathRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SamePathRequestException(message: \(String(describing: message)))"}
}

extension SamePathRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SamePathRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The commit cannot be created because one or more changes in this commit duplicate actions in the same file path. For example,
///         you cannot make the same delete request to the same file in the same file path twice, or make a delete request and a move request to the same
///         file as part of the same commit.</p>
public struct SamePathRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SamePathRequestExceptionBody: Equatable {
    public let message: String?
}

extension SamePathRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SetFileModeEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fileMode
        case filePath
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileMode = fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
        if let filePath = filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
    }
}

extension SetFileModeEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetFileModeEntry(fileMode: \(String(describing: fileMode)), filePath: \(String(describing: filePath)))"}
}

/// <p>Information about the file mode changes.</p>
public struct SetFileModeEntry: Equatable {
    /// <p>The file mode for the file.</p>
    public let fileMode: FileModeTypeEnum?
    /// <p>The full path to the file, including the name of the file.</p>
    public let filePath: String?

    public init (
        fileMode: FileModeTypeEnum? = nil,
        filePath: String? = nil
    )
    {
        self.fileMode = fileMode
        self.filePath = filePath
    }
}

public enum SortByEnum {
    case modifiedDate
    case repositoryName
    case sdkUnknown(String)
}

extension SortByEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SortByEnum] {
        return [
            .modifiedDate,
            .repositoryName,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .modifiedDate: return "lastModifiedDate"
        case .repositoryName: return "repositoryName"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SortByEnum(rawValue: rawValue) ?? SortByEnum.sdkUnknown(rawValue)
    }
}

extension SourceAndDestinationAreSameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceAndDestinationAreSameException(message: \(String(describing: message)))"}
}

extension SourceAndDestinationAreSameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SourceAndDestinationAreSameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The source branch and destination branch for the pull request are the same. You must
///             specify different branches for the source and destination.</p>
public struct SourceAndDestinationAreSameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SourceAndDestinationAreSameExceptionBody: Equatable {
    public let message: String?
}

extension SourceAndDestinationAreSameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SourceFileOrContentRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceFileOrContentRequiredException(message: \(String(describing: message)))"}
}

extension SourceFileOrContentRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SourceFileOrContentRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The commit cannot be created because no source files or file content have been specified for the commit.</p>
public struct SourceFileOrContentRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SourceFileOrContentRequiredExceptionBody: Equatable {
    public let message: String?
}

extension SourceFileOrContentRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SourceFileSpecifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filePath
        case isMove
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filePath = filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if isMove != false {
            try encodeContainer.encode(isMove, forKey: .isMove)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filePath)
        filePath = filePathDecoded
        let isMoveDecoded = try containerValues.decode(Bool.self, forKey: .isMove)
        isMove = isMoveDecoded
    }
}

extension SourceFileSpecifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceFileSpecifier(filePath: \(String(describing: filePath)), isMove: \(String(describing: isMove)))"}
}

/// <p>Information about a source file that is part of changes made in a commit.</p>
public struct SourceFileSpecifier: Equatable {
    /// <p>The full path to the file, including the name of the file.</p>
    public let filePath: String?
    /// <p>Whether to remove the source file from the parent commit.</p>
    public let isMove: Bool

    public init (
        filePath: String? = nil,
        isMove: Bool = false
    )
    {
        self.filePath = filePath
        self.isMove = isMove
    }
}

extension SubModule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case absolutePath
        case commitId
        case relativePath
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absolutePath = absolutePath {
            try encodeContainer.encode(absolutePath, forKey: .absolutePath)
        }
        if let commitId = commitId {
            try encodeContainer.encode(commitId, forKey: .commitId)
        }
        if let relativePath = relativePath {
            try encodeContainer.encode(relativePath, forKey: .relativePath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commitIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commitId)
        commitId = commitIdDecoded
        let absolutePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .absolutePath)
        absolutePath = absolutePathDecoded
        let relativePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .relativePath)
        relativePath = relativePathDecoded
    }
}

extension SubModule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubModule(absolutePath: \(String(describing: absolutePath)), commitId: \(String(describing: commitId)), relativePath: \(String(describing: relativePath)))"}
}

/// <p>Returns information about a submodule reference in a repository folder.</p>
public struct SubModule: Equatable {
    /// <p>The fully qualified path to the folder that contains the reference to the submodule.</p>
    public let absolutePath: String?
    /// <p>The commit ID that contains the reference to the submodule.</p>
    public let commitId: String?
    /// <p>The relative path of the submodule from the folder where the query originated.</p>
    public let relativePath: String?

    public init (
        absolutePath: String? = nil,
        commitId: String? = nil,
        relativePath: String? = nil
    )
    {
        self.absolutePath = absolutePath
        self.commitId = commitId
        self.relativePath = relativePath
    }
}

extension SymbolicLink: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case absolutePath
        case blobId
        case fileMode
        case relativePath
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absolutePath = absolutePath {
            try encodeContainer.encode(absolutePath, forKey: .absolutePath)
        }
        if let blobId = blobId {
            try encodeContainer.encode(blobId, forKey: .blobId)
        }
        if let fileMode = fileMode {
            try encodeContainer.encode(fileMode.rawValue, forKey: .fileMode)
        }
        if let relativePath = relativePath {
            try encodeContainer.encode(relativePath, forKey: .relativePath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .blobId)
        blobId = blobIdDecoded
        let absolutePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .absolutePath)
        absolutePath = absolutePathDecoded
        let relativePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .relativePath)
        relativePath = relativePathDecoded
        let fileModeDecoded = try containerValues.decodeIfPresent(FileModeTypeEnum.self, forKey: .fileMode)
        fileMode = fileModeDecoded
    }
}

extension SymbolicLink: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SymbolicLink(absolutePath: \(String(describing: absolutePath)), blobId: \(String(describing: blobId)), fileMode: \(String(describing: fileMode)), relativePath: \(String(describing: relativePath)))"}
}

/// <p>Returns information about a symbolic link in a repository folder.</p>
public struct SymbolicLink: Equatable {
    /// <p>The fully qualified path to the folder that contains the symbolic link.</p>
    public let absolutePath: String?
    /// <p>The blob ID that contains the information about the symbolic link.</p>
    public let blobId: String?
    /// <p>The file mode permissions of the blob that cotains information about the symbolic link.</p>
    public let fileMode: FileModeTypeEnum?
    /// <p>The relative path of the symbolic link from the folder where the query originated.</p>
    public let relativePath: String?

    public init (
        absolutePath: String? = nil,
        blobId: String? = nil,
        fileMode: FileModeTypeEnum? = nil,
        relativePath: String? = nil
    )
    {
        self.absolutePath = absolutePath
        self.blobId = blobId
        self.fileMode = fileMode
        self.relativePath = relativePath
    }
}

extension TagKeysListRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagKeysListRequiredException(message: \(String(describing: message)))"}
}

extension TagKeysListRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagKeysListRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A list of tag keys is required. The list cannot be empty or null.</p>
public struct TagKeysListRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TagKeysListRequiredExceptionBody: Equatable {
    public let message: String?
}

extension TagKeysListRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagPolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagPolicyException(message: \(String(describing: message)))"}
}

extension TagPolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagPolicyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The tag policy is not valid.</p>
public struct TagPolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TagPolicyExceptionBody: Equatable {
    public let message: String?
}

extension TagPolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource to which you want to add or update tags.</p>
    public let resourceArn: String?
    /// <p>The key-value pair to use when tagging this repository.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceArnException" : self = .invalidResourceArnException(try InvalidResourceArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSystemTagUsageException" : self = .invalidSystemTagUsageException(try InvalidSystemTagUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagsMapException" : self = .invalidTagsMapException(try InvalidTagsMapException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceArnRequiredException" : self = .resourceArnRequiredException(try ResourceArnRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsMapRequiredException" : self = .tagsMapRequiredException(try TagsMapRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidResourceArnException(InvalidResourceArnException)
    case invalidSystemTagUsageException(InvalidSystemTagUsageException)
    case invalidTagsMapException(InvalidTagsMapException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case resourceArnRequiredException(ResourceArnRequiredException)
    case tagPolicyException(TagPolicyException)
    case tagsMapRequiredException(TagsMapRequiredException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TagsMapRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagsMapRequiredException(message: \(String(describing: message)))"}
}

extension TagsMapRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagsMapRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A map of tags is required.</p>
public struct TagsMapRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TagsMapRequiredExceptionBody: Equatable {
    public let message: String?
}

extension TagsMapRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Target: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationReference
        case repositoryName
        case sourceReference
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationReference = destinationReference {
            try encodeContainer.encode(destinationReference, forKey: .destinationReference)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let sourceReference = sourceReference {
            try encodeContainer.encode(sourceReference, forKey: .sourceReference)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let sourceReferenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceReference)
        sourceReference = sourceReferenceDecoded
        let destinationReferenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationReference)
        destinationReference = destinationReferenceDecoded
    }
}

extension Target: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Target(destinationReference: \(String(describing: destinationReference)), repositoryName: \(String(describing: repositoryName)), sourceReference: \(String(describing: sourceReference)))"}
}

/// <p>Returns information about a target for a pull request.</p>
public struct Target: Equatable {
    /// <p>The branch of the repository where the pull request changes are merged. Also known as
    ///             the destination branch.</p>
    public let destinationReference: String?
    /// <p>The name of the repository that contains the pull request.</p>
    public let repositoryName: String?
    /// <p>The branch of the repository that contains the changes for the pull request. Also known as the source branch.</p>
    public let sourceReference: String?

    public init (
        destinationReference: String? = nil,
        repositoryName: String? = nil,
        sourceReference: String? = nil
    )
    {
        self.destinationReference = destinationReference
        self.repositoryName = repositoryName
        self.sourceReference = sourceReference
    }
}

extension TargetRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetRequiredException(message: \(String(describing: message)))"}
}

extension TargetRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TargetRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A pull request target is required. It cannot be empty or null. A pull request target must contain the full values for the repository name, source branch, and destination branch for the pull request.</p>
public struct TargetRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TargetRequiredExceptionBody: Equatable {
    public let message: String?
}

extension TargetRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TargetsRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetsRequiredException(message: \(String(describing: message)))"}
}

extension TargetsRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TargetsRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An array of target objects is required. It cannot be empty or null.</p>
public struct TargetsRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TargetsRequiredExceptionBody: Equatable {
    public let message: String?
}

extension TargetsRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TestRepositoryTriggersInputBodyMiddleware: Middleware {
    public let id: String = "TestRepositoryTriggersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestRepositoryTriggersInput>,
                  next: H) -> Swift.Result<OperationOutput<TestRepositoryTriggersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestRepositoryTriggersInput>
    public typealias MOutput = OperationOutput<TestRepositoryTriggersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestRepositoryTriggersOutputError>
}

extension TestRepositoryTriggersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestRepositoryTriggersInput(repositoryName: \(String(describing: repositoryName)), triggers: \(String(describing: triggers)))"}
}

extension TestRepositoryTriggersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case repositoryName
        case triggers
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let triggers = triggers {
            var triggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .triggers)
            for repositorytriggerslist0 in triggers {
                try triggersContainer.encode(repositorytriggerslist0)
            }
        }
    }
}

public struct TestRepositoryTriggersInputHeadersMiddleware: Middleware {
    public let id: String = "TestRepositoryTriggersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestRepositoryTriggersInput>,
                  next: H) -> Swift.Result<OperationOutput<TestRepositoryTriggersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestRepositoryTriggersInput>
    public typealias MOutput = OperationOutput<TestRepositoryTriggersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestRepositoryTriggersOutputError>
}

public struct TestRepositoryTriggersInputQueryItemMiddleware: Middleware {
    public let id: String = "TestRepositoryTriggersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestRepositoryTriggersInput>,
                  next: H) -> Swift.Result<OperationOutput<TestRepositoryTriggersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestRepositoryTriggersInput>
    public typealias MOutput = OperationOutput<TestRepositoryTriggersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestRepositoryTriggersOutputError>
}

/// <p>Represents the input of a test repository triggers operation.</p>
public struct TestRepositoryTriggersInput: Equatable {
    /// <p>The name of the repository in which to test the triggers.</p>
    public let repositoryName: String?
    /// <p>The list of triggers to test.</p>
    public let triggers: [RepositoryTrigger]?

    public init (
        repositoryName: String? = nil,
        triggers: [RepositoryTrigger]? = nil
    )
    {
        self.repositoryName = repositoryName
        self.triggers = triggers
    }
}

struct TestRepositoryTriggersInputBody: Equatable {
    public let repositoryName: String?
    public let triggers: [RepositoryTrigger]?
}

extension TestRepositoryTriggersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repositoryName
        case triggers
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let triggersContainer = try containerValues.decodeIfPresent([RepositoryTrigger?].self, forKey: .triggers)
        var triggersDecoded0:[RepositoryTrigger]? = nil
        if let triggersContainer = triggersContainer {
            triggersDecoded0 = [RepositoryTrigger]()
            for structure0 in triggersContainer {
                if let structure0 = structure0 {
                    triggersDecoded0?.append(structure0)
                }
            }
        }
        triggers = triggersDecoded0
    }
}

extension TestRepositoryTriggersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestRepositoryTriggersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerBranchNameException" : self = .invalidRepositoryTriggerBranchNameException(try InvalidRepositoryTriggerBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerCustomDataException" : self = .invalidRepositoryTriggerCustomDataException(try InvalidRepositoryTriggerCustomDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerDestinationArnException" : self = .invalidRepositoryTriggerDestinationArnException(try InvalidRepositoryTriggerDestinationArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerEventsException" : self = .invalidRepositoryTriggerEventsException(try InvalidRepositoryTriggerEventsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerNameException" : self = .invalidRepositoryTriggerNameException(try InvalidRepositoryTriggerNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryTriggerRegionException" : self = .invalidRepositoryTriggerRegionException(try InvalidRepositoryTriggerRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumBranchesExceededException" : self = .maximumBranchesExceededException(try MaximumBranchesExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumRepositoryTriggersExceededException" : self = .maximumRepositoryTriggersExceededException(try MaximumRepositoryTriggersExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggerBranchNameListRequiredException" : self = .repositoryTriggerBranchNameListRequiredException(try RepositoryTriggerBranchNameListRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggerDestinationArnRequiredException" : self = .repositoryTriggerDestinationArnRequiredException(try RepositoryTriggerDestinationArnRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggerEventsListRequiredException" : self = .repositoryTriggerEventsListRequiredException(try RepositoryTriggerEventsListRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggerNameRequiredException" : self = .repositoryTriggerNameRequiredException(try RepositoryTriggerNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryTriggersListRequiredException" : self = .repositoryTriggersListRequiredException(try RepositoryTriggersListRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestRepositoryTriggersOutputError: Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidRepositoryTriggerBranchNameException(InvalidRepositoryTriggerBranchNameException)
    case invalidRepositoryTriggerCustomDataException(InvalidRepositoryTriggerCustomDataException)
    case invalidRepositoryTriggerDestinationArnException(InvalidRepositoryTriggerDestinationArnException)
    case invalidRepositoryTriggerEventsException(InvalidRepositoryTriggerEventsException)
    case invalidRepositoryTriggerNameException(InvalidRepositoryTriggerNameException)
    case invalidRepositoryTriggerRegionException(InvalidRepositoryTriggerRegionException)
    case maximumBranchesExceededException(MaximumBranchesExceededException)
    case maximumRepositoryTriggersExceededException(MaximumRepositoryTriggersExceededException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case repositoryTriggerBranchNameListRequiredException(RepositoryTriggerBranchNameListRequiredException)
    case repositoryTriggerDestinationArnRequiredException(RepositoryTriggerDestinationArnRequiredException)
    case repositoryTriggerEventsListRequiredException(RepositoryTriggerEventsListRequiredException)
    case repositoryTriggerNameRequiredException(RepositoryTriggerNameRequiredException)
    case repositoryTriggersListRequiredException(RepositoryTriggersListRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestRepositoryTriggersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestRepositoryTriggersOutputResponse(failedExecutions: \(String(describing: failedExecutions)), successfulExecutions: \(String(describing: successfulExecutions)))"}
}

extension TestRepositoryTriggersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TestRepositoryTriggersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedExecutions = output.failedExecutions
            self.successfulExecutions = output.successfulExecutions
        } else {
            self.failedExecutions = nil
            self.successfulExecutions = nil
        }
    }
}

/// <p>Represents the output of a test repository triggers operation.</p>
public struct TestRepositoryTriggersOutputResponse: Equatable {
    /// <p>The list of triggers that were not tested. This list provides the names of the
    ///             triggers that could not be tested, separated by commas.</p>
    public let failedExecutions: [RepositoryTriggerExecutionFailure]?
    /// <p>The list of triggers that were successfully tested. This list provides the names of the triggers that were successfully tested, separated by commas.</p>
    public let successfulExecutions: [String]?

    public init (
        failedExecutions: [RepositoryTriggerExecutionFailure]? = nil,
        successfulExecutions: [String]? = nil
    )
    {
        self.failedExecutions = failedExecutions
        self.successfulExecutions = successfulExecutions
    }
}

struct TestRepositoryTriggersOutputResponseBody: Equatable {
    public let successfulExecutions: [String]?
    public let failedExecutions: [RepositoryTriggerExecutionFailure]?
}

extension TestRepositoryTriggersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedExecutions
        case successfulExecutions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulExecutionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .successfulExecutions)
        var successfulExecutionsDecoded0:[String]? = nil
        if let successfulExecutionsContainer = successfulExecutionsContainer {
            successfulExecutionsDecoded0 = [String]()
            for string0 in successfulExecutionsContainer {
                if let string0 = string0 {
                    successfulExecutionsDecoded0?.append(string0)
                }
            }
        }
        successfulExecutions = successfulExecutionsDecoded0
        let failedExecutionsContainer = try containerValues.decodeIfPresent([RepositoryTriggerExecutionFailure?].self, forKey: .failedExecutions)
        var failedExecutionsDecoded0:[RepositoryTriggerExecutionFailure]? = nil
        if let failedExecutionsContainer = failedExecutionsContainer {
            failedExecutionsDecoded0 = [RepositoryTriggerExecutionFailure]()
            for structure0 in failedExecutionsContainer {
                if let structure0 = structure0 {
                    failedExecutionsDecoded0?.append(structure0)
                }
            }
        }
        failedExecutions = failedExecutionsDecoded0
    }
}

extension TipOfSourceReferenceIsDifferentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TipOfSourceReferenceIsDifferentException(message: \(String(describing: message)))"}
}

extension TipOfSourceReferenceIsDifferentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TipOfSourceReferenceIsDifferentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The tip of the source branch in the destination repository does not match the tip of the source branch specified in your request.
///             The pull request might have been updated. Make sure that you have the latest changes.</p>
public struct TipOfSourceReferenceIsDifferentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TipOfSourceReferenceIsDifferentExceptionBody: Equatable {
    public let message: String?
}

extension TipOfSourceReferenceIsDifferentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TipsDivergenceExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TipsDivergenceExceededException(message: \(String(describing: message)))"}
}

extension TipsDivergenceExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TipsDivergenceExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be
///             any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
public struct TipsDivergenceExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TipsDivergenceExceededExceptionBody: Equatable {
    public let message: String?
}

extension TipsDivergenceExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TitleRequiredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TitleRequiredException(message: \(String(describing: message)))"}
}

extension TitleRequiredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TitleRequiredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A pull request title is required. It cannot be empty or null.</p>
public struct TitleRequiredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TitleRequiredExceptionBody: Equatable {
    public let message: String?
}

extension TitleRequiredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of tags for an AWS CodeCommit resource has been exceeded.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Any message associated with the exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeyslist0 in tagKeys {
                try tagKeysContainer.encode(tagkeyslist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource to which you want to remove tags.</p>
    public let resourceArn: String?
    /// <p>The tag key for each tag that you want to remove from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceArnException" : self = .invalidResourceArnException(try InvalidResourceArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSystemTagUsageException" : self = .invalidSystemTagUsageException(try InvalidSystemTagUsageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagKeysListException" : self = .invalidTagKeysListException(try InvalidTagKeysListException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceArnRequiredException" : self = .resourceArnRequiredException(try ResourceArnRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagKeysListRequiredException" : self = .tagKeysListRequiredException(try TagKeysListRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyException" : self = .tagPolicyException(try TagPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case invalidResourceArnException(InvalidResourceArnException)
    case invalidSystemTagUsageException(InvalidSystemTagUsageException)
    case invalidTagKeysListException(InvalidTagKeysListException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case resourceArnRequiredException(ResourceArnRequiredException)
    case tagKeysListRequiredException(TagKeysListRequiredException)
    case tagPolicyException(TagPolicyException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateApprovalRuleTemplateContentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApprovalRuleTemplateContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApprovalRuleTemplateContentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApprovalRuleTemplateContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApprovalRuleTemplateContentInput>
    public typealias MOutput = OperationOutput<UpdateApprovalRuleTemplateContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApprovalRuleTemplateContentOutputError>
}

extension UpdateApprovalRuleTemplateContentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApprovalRuleTemplateContentInput(approvalRuleTemplateName: \(String(describing: approvalRuleTemplateName)), existingRuleContentSha256: \(String(describing: existingRuleContentSha256)), newRuleContent: \(String(describing: newRuleContent)))"}
}

extension UpdateApprovalRuleTemplateContentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateName
        case existingRuleContentSha256
        case newRuleContent
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateName = approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
        if let existingRuleContentSha256 = existingRuleContentSha256 {
            try encodeContainer.encode(existingRuleContentSha256, forKey: .existingRuleContentSha256)
        }
        if let newRuleContent = newRuleContent {
            try encodeContainer.encode(newRuleContent, forKey: .newRuleContent)
        }
    }
}

public struct UpdateApprovalRuleTemplateContentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApprovalRuleTemplateContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApprovalRuleTemplateContentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApprovalRuleTemplateContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApprovalRuleTemplateContentInput>
    public typealias MOutput = OperationOutput<UpdateApprovalRuleTemplateContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApprovalRuleTemplateContentOutputError>
}

public struct UpdateApprovalRuleTemplateContentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApprovalRuleTemplateContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApprovalRuleTemplateContentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApprovalRuleTemplateContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApprovalRuleTemplateContentInput>
    public typealias MOutput = OperationOutput<UpdateApprovalRuleTemplateContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApprovalRuleTemplateContentOutputError>
}

public struct UpdateApprovalRuleTemplateContentInput: Equatable {
    /// <p>The name of the approval rule template where you want to update the content of the rule. </p>
    public let approvalRuleTemplateName: String?
    /// <p>The SHA-256 hash signature for the content of the approval rule. You can retrieve this
    ///             information by using
    ///             <a>GetPullRequest</a>.</p>
    public let existingRuleContentSha256: String?
    /// <p>The content that replaces the existing content of the rule. Content statements must be
    ///             complete. You cannot provide only the changes.</p>
    public let newRuleContent: String?

    public init (
        approvalRuleTemplateName: String? = nil,
        existingRuleContentSha256: String? = nil,
        newRuleContent: String? = nil
    )
    {
        self.approvalRuleTemplateName = approvalRuleTemplateName
        self.existingRuleContentSha256 = existingRuleContentSha256
        self.newRuleContent = newRuleContent
    }
}

struct UpdateApprovalRuleTemplateContentInputBody: Equatable {
    public let approvalRuleTemplateName: String?
    public let newRuleContent: String?
    public let existingRuleContentSha256: String?
}

extension UpdateApprovalRuleTemplateContentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateName
        case existingRuleContentSha256
        case newRuleContent
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let newRuleContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .newRuleContent)
        newRuleContent = newRuleContentDecoded
        let existingRuleContentSha256Decoded = try containerValues.decodeIfPresent(String.self, forKey: .existingRuleContentSha256)
        existingRuleContentSha256 = existingRuleContentSha256Decoded
    }
}

extension UpdateApprovalRuleTemplateContentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApprovalRuleTemplateContentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateContentRequiredException" : self = .approvalRuleTemplateContentRequiredException(try ApprovalRuleTemplateContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateDoesNotExistException" : self = .approvalRuleTemplateDoesNotExistException(try ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateContentException" : self = .invalidApprovalRuleTemplateContentException(try InvalidApprovalRuleTemplateContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuleContentSha256Exception" : self = .invalidRuleContentSha256Exception(try InvalidRuleContentSha256Exception(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApprovalRuleTemplateContentOutputError: Equatable {
    case approvalRuleTemplateContentRequiredException(ApprovalRuleTemplateContentRequiredException)
    case approvalRuleTemplateDoesNotExistException(ApprovalRuleTemplateDoesNotExistException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case invalidApprovalRuleTemplateContentException(InvalidApprovalRuleTemplateContentException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case invalidRuleContentSha256Exception(InvalidRuleContentSha256Exception)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApprovalRuleTemplateContentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApprovalRuleTemplateContentOutputResponse(approvalRuleTemplate: \(String(describing: approvalRuleTemplate)))"}
}

extension UpdateApprovalRuleTemplateContentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateApprovalRuleTemplateContentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.approvalRuleTemplate = output.approvalRuleTemplate
        } else {
            self.approvalRuleTemplate = nil
        }
    }
}

public struct UpdateApprovalRuleTemplateContentOutputResponse: Equatable {
    /// <p>Returns information about an approval rule template.</p>
    public let approvalRuleTemplate: ApprovalRuleTemplate?

    public init (
        approvalRuleTemplate: ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

struct UpdateApprovalRuleTemplateContentOutputResponseBody: Equatable {
    public let approvalRuleTemplate: ApprovalRuleTemplate?
}

extension UpdateApprovalRuleTemplateContentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateDecoded = try containerValues.decodeIfPresent(ApprovalRuleTemplate.self, forKey: .approvalRuleTemplate)
        approvalRuleTemplate = approvalRuleTemplateDecoded
    }
}

public struct UpdateApprovalRuleTemplateDescriptionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApprovalRuleTemplateDescriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApprovalRuleTemplateDescriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApprovalRuleTemplateDescriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApprovalRuleTemplateDescriptionInput>
    public typealias MOutput = OperationOutput<UpdateApprovalRuleTemplateDescriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApprovalRuleTemplateDescriptionOutputError>
}

extension UpdateApprovalRuleTemplateDescriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApprovalRuleTemplateDescriptionInput(approvalRuleTemplateDescription: \(String(describing: approvalRuleTemplateDescription)), approvalRuleTemplateName: \(String(describing: approvalRuleTemplateName)))"}
}

extension UpdateApprovalRuleTemplateDescriptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateDescription
        case approvalRuleTemplateName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleTemplateDescription = approvalRuleTemplateDescription {
            try encodeContainer.encode(approvalRuleTemplateDescription, forKey: .approvalRuleTemplateDescription)
        }
        if let approvalRuleTemplateName = approvalRuleTemplateName {
            try encodeContainer.encode(approvalRuleTemplateName, forKey: .approvalRuleTemplateName)
        }
    }
}

public struct UpdateApprovalRuleTemplateDescriptionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApprovalRuleTemplateDescriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApprovalRuleTemplateDescriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApprovalRuleTemplateDescriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApprovalRuleTemplateDescriptionInput>
    public typealias MOutput = OperationOutput<UpdateApprovalRuleTemplateDescriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApprovalRuleTemplateDescriptionOutputError>
}

public struct UpdateApprovalRuleTemplateDescriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApprovalRuleTemplateDescriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApprovalRuleTemplateDescriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApprovalRuleTemplateDescriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApprovalRuleTemplateDescriptionInput>
    public typealias MOutput = OperationOutput<UpdateApprovalRuleTemplateDescriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApprovalRuleTemplateDescriptionOutputError>
}

public struct UpdateApprovalRuleTemplateDescriptionInput: Equatable {
    /// <p>The updated description of the approval rule template.</p>
    public let approvalRuleTemplateDescription: String?
    /// <p>The name of the template for which you want to update the description.</p>
    public let approvalRuleTemplateName: String?

    public init (
        approvalRuleTemplateDescription: String? = nil,
        approvalRuleTemplateName: String? = nil
    )
    {
        self.approvalRuleTemplateDescription = approvalRuleTemplateDescription
        self.approvalRuleTemplateName = approvalRuleTemplateName
    }
}

struct UpdateApprovalRuleTemplateDescriptionInputBody: Equatable {
    public let approvalRuleTemplateName: String?
    public let approvalRuleTemplateDescription: String?
}

extension UpdateApprovalRuleTemplateDescriptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplateDescription
        case approvalRuleTemplateName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateName)
        approvalRuleTemplateName = approvalRuleTemplateNameDecoded
        let approvalRuleTemplateDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleTemplateDescription)
        approvalRuleTemplateDescription = approvalRuleTemplateDescriptionDecoded
    }
}

extension UpdateApprovalRuleTemplateDescriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApprovalRuleTemplateDescriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateDoesNotExistException" : self = .approvalRuleTemplateDoesNotExistException(try ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateDescriptionException" : self = .invalidApprovalRuleTemplateDescriptionException(try InvalidApprovalRuleTemplateDescriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApprovalRuleTemplateDescriptionOutputError: Equatable {
    case approvalRuleTemplateDoesNotExistException(ApprovalRuleTemplateDoesNotExistException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case invalidApprovalRuleTemplateDescriptionException(InvalidApprovalRuleTemplateDescriptionException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApprovalRuleTemplateDescriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApprovalRuleTemplateDescriptionOutputResponse(approvalRuleTemplate: \(String(describing: approvalRuleTemplate)))"}
}

extension UpdateApprovalRuleTemplateDescriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateApprovalRuleTemplateDescriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.approvalRuleTemplate = output.approvalRuleTemplate
        } else {
            self.approvalRuleTemplate = nil
        }
    }
}

public struct UpdateApprovalRuleTemplateDescriptionOutputResponse: Equatable {
    /// <p>The structure and content of the updated approval rule template.</p>
    public let approvalRuleTemplate: ApprovalRuleTemplate?

    public init (
        approvalRuleTemplate: ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

struct UpdateApprovalRuleTemplateDescriptionOutputResponseBody: Equatable {
    public let approvalRuleTemplate: ApprovalRuleTemplate?
}

extension UpdateApprovalRuleTemplateDescriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateDecoded = try containerValues.decodeIfPresent(ApprovalRuleTemplate.self, forKey: .approvalRuleTemplate)
        approvalRuleTemplate = approvalRuleTemplateDecoded
    }
}

public struct UpdateApprovalRuleTemplateNameInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApprovalRuleTemplateNameInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApprovalRuleTemplateNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApprovalRuleTemplateNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApprovalRuleTemplateNameInput>
    public typealias MOutput = OperationOutput<UpdateApprovalRuleTemplateNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApprovalRuleTemplateNameOutputError>
}

extension UpdateApprovalRuleTemplateNameInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApprovalRuleTemplateNameInput(newApprovalRuleTemplateName: \(String(describing: newApprovalRuleTemplateName)), oldApprovalRuleTemplateName: \(String(describing: oldApprovalRuleTemplateName)))"}
}

extension UpdateApprovalRuleTemplateNameInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case newApprovalRuleTemplateName
        case oldApprovalRuleTemplateName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let newApprovalRuleTemplateName = newApprovalRuleTemplateName {
            try encodeContainer.encode(newApprovalRuleTemplateName, forKey: .newApprovalRuleTemplateName)
        }
        if let oldApprovalRuleTemplateName = oldApprovalRuleTemplateName {
            try encodeContainer.encode(oldApprovalRuleTemplateName, forKey: .oldApprovalRuleTemplateName)
        }
    }
}

public struct UpdateApprovalRuleTemplateNameInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApprovalRuleTemplateNameInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApprovalRuleTemplateNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApprovalRuleTemplateNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApprovalRuleTemplateNameInput>
    public typealias MOutput = OperationOutput<UpdateApprovalRuleTemplateNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApprovalRuleTemplateNameOutputError>
}

public struct UpdateApprovalRuleTemplateNameInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApprovalRuleTemplateNameInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApprovalRuleTemplateNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApprovalRuleTemplateNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApprovalRuleTemplateNameInput>
    public typealias MOutput = OperationOutput<UpdateApprovalRuleTemplateNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApprovalRuleTemplateNameOutputError>
}

public struct UpdateApprovalRuleTemplateNameInput: Equatable {
    /// <p>The new name you want to apply to the approval rule template.</p>
    public let newApprovalRuleTemplateName: String?
    /// <p>The current name of the approval rule template.</p>
    public let oldApprovalRuleTemplateName: String?

    public init (
        newApprovalRuleTemplateName: String? = nil,
        oldApprovalRuleTemplateName: String? = nil
    )
    {
        self.newApprovalRuleTemplateName = newApprovalRuleTemplateName
        self.oldApprovalRuleTemplateName = oldApprovalRuleTemplateName
    }
}

struct UpdateApprovalRuleTemplateNameInputBody: Equatable {
    public let oldApprovalRuleTemplateName: String?
    public let newApprovalRuleTemplateName: String?
}

extension UpdateApprovalRuleTemplateNameInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case newApprovalRuleTemplateName
        case oldApprovalRuleTemplateName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oldApprovalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .oldApprovalRuleTemplateName)
        oldApprovalRuleTemplateName = oldApprovalRuleTemplateNameDecoded
        let newApprovalRuleTemplateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .newApprovalRuleTemplateName)
        newApprovalRuleTemplateName = newApprovalRuleTemplateNameDecoded
    }
}

extension UpdateApprovalRuleTemplateNameOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApprovalRuleTemplateNameOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ApprovalRuleTemplateDoesNotExistException" : self = .approvalRuleTemplateDoesNotExistException(try ApprovalRuleTemplateDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameAlreadyExistsException" : self = .approvalRuleTemplateNameAlreadyExistsException(try ApprovalRuleTemplateNameAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleTemplateNameRequiredException" : self = .approvalRuleTemplateNameRequiredException(try ApprovalRuleTemplateNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleTemplateNameException" : self = .invalidApprovalRuleTemplateNameException(try InvalidApprovalRuleTemplateNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApprovalRuleTemplateNameOutputError: Equatable {
    case approvalRuleTemplateDoesNotExistException(ApprovalRuleTemplateDoesNotExistException)
    case approvalRuleTemplateNameAlreadyExistsException(ApprovalRuleTemplateNameAlreadyExistsException)
    case approvalRuleTemplateNameRequiredException(ApprovalRuleTemplateNameRequiredException)
    case invalidApprovalRuleTemplateNameException(InvalidApprovalRuleTemplateNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApprovalRuleTemplateNameOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApprovalRuleTemplateNameOutputResponse(approvalRuleTemplate: \(String(describing: approvalRuleTemplate)))"}
}

extension UpdateApprovalRuleTemplateNameOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateApprovalRuleTemplateNameOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.approvalRuleTemplate = output.approvalRuleTemplate
        } else {
            self.approvalRuleTemplate = nil
        }
    }
}

public struct UpdateApprovalRuleTemplateNameOutputResponse: Equatable {
    /// <p>The structure and content of the updated approval rule template.</p>
    public let approvalRuleTemplate: ApprovalRuleTemplate?

    public init (
        approvalRuleTemplate: ApprovalRuleTemplate? = nil
    )
    {
        self.approvalRuleTemplate = approvalRuleTemplate
    }
}

struct UpdateApprovalRuleTemplateNameOutputResponseBody: Equatable {
    public let approvalRuleTemplate: ApprovalRuleTemplate?
}

extension UpdateApprovalRuleTemplateNameOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleTemplate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleTemplateDecoded = try containerValues.decodeIfPresent(ApprovalRuleTemplate.self, forKey: .approvalRuleTemplate)
        approvalRuleTemplate = approvalRuleTemplateDecoded
    }
}

public struct UpdateCommentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCommentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCommentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCommentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCommentInput>
    public typealias MOutput = OperationOutput<UpdateCommentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCommentOutputError>
}

extension UpdateCommentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCommentInput(commentId: \(String(describing: commentId)), content: \(String(describing: content)))"}
}

extension UpdateCommentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commentId
        case content
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
    }
}

public struct UpdateCommentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCommentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCommentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCommentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCommentInput>
    public typealias MOutput = OperationOutput<UpdateCommentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCommentOutputError>
}

public struct UpdateCommentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCommentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCommentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCommentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCommentInput>
    public typealias MOutput = OperationOutput<UpdateCommentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCommentOutputError>
}

public struct UpdateCommentInput: Equatable {
    /// <p>The system-generated ID of the comment you want to update. To get this ID, use <a>GetCommentsForComparedCommit</a>
    ///             or <a>GetCommentsForPullRequest</a>.</p>
    public let commentId: String?
    /// <p>The updated content to replace the existing content of the comment.</p>
    public let content: String?

    public init (
        commentId: String? = nil,
        content: String? = nil
    )
    {
        self.commentId = commentId
        self.content = content
    }
}

struct UpdateCommentInputBody: Equatable {
    public let commentId: String?
    public let content: String?
}

extension UpdateCommentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commentId
        case content
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commentId)
        commentId = commentIdDecoded
        let contentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .content)
        content = contentDecoded
    }
}

extension UpdateCommentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCommentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CommentContentRequiredException" : self = .commentContentRequiredException(try CommentContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentContentSizeLimitExceededException" : self = .commentContentSizeLimitExceededException(try CommentContentSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentDeletedException" : self = .commentDeletedException(try CommentDeletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentDoesNotExistException" : self = .commentDoesNotExistException(try CommentDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentIdRequiredException" : self = .commentIdRequiredException(try CommentIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CommentNotCreatedByCallerException" : self = .commentNotCreatedByCallerException(try CommentNotCreatedByCallerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommentIdException" : self = .invalidCommentIdException(try InvalidCommentIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCommentOutputError: Equatable {
    case commentContentRequiredException(CommentContentRequiredException)
    case commentContentSizeLimitExceededException(CommentContentSizeLimitExceededException)
    case commentDeletedException(CommentDeletedException)
    case commentDoesNotExistException(CommentDoesNotExistException)
    case commentIdRequiredException(CommentIdRequiredException)
    case commentNotCreatedByCallerException(CommentNotCreatedByCallerException)
    case invalidCommentIdException(InvalidCommentIdException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCommentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCommentOutputResponse(comment: \(String(describing: comment)))"}
}

extension UpdateCommentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateCommentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.comment = output.comment
        } else {
            self.comment = nil
        }
    }
}

public struct UpdateCommentOutputResponse: Equatable {
    /// <p>Information about the updated comment.</p>
    public let comment: Comment?

    public init (
        comment: Comment? = nil
    )
    {
        self.comment = comment
    }
}

struct UpdateCommentOutputResponseBody: Equatable {
    public let comment: Comment?
}

extension UpdateCommentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comment
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

public struct UpdateDefaultBranchInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDefaultBranchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDefaultBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDefaultBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDefaultBranchInput>
    public typealias MOutput = OperationOutput<UpdateDefaultBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDefaultBranchOutputError>
}

extension UpdateDefaultBranchInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDefaultBranchInput(defaultBranchName: \(String(describing: defaultBranchName)), repositoryName: \(String(describing: repositoryName)))"}
}

extension UpdateDefaultBranchInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultBranchName
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultBranchName = defaultBranchName {
            try encodeContainer.encode(defaultBranchName, forKey: .defaultBranchName)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct UpdateDefaultBranchInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDefaultBranchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDefaultBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDefaultBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDefaultBranchInput>
    public typealias MOutput = OperationOutput<UpdateDefaultBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDefaultBranchOutputError>
}

public struct UpdateDefaultBranchInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDefaultBranchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDefaultBranchInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDefaultBranchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDefaultBranchInput>
    public typealias MOutput = OperationOutput<UpdateDefaultBranchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDefaultBranchOutputError>
}

/// <p>Represents the input of an update default branch operation.</p>
public struct UpdateDefaultBranchInput: Equatable {
    /// <p>The name of the branch to set as the default.</p>
    public let defaultBranchName: String?
    /// <p>The name of the repository to set or change the default branch for.</p>
    public let repositoryName: String?

    public init (
        defaultBranchName: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.defaultBranchName = defaultBranchName
        self.repositoryName = repositoryName
    }
}

struct UpdateDefaultBranchInputBody: Equatable {
    public let repositoryName: String?
    public let defaultBranchName: String?
}

extension UpdateDefaultBranchInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultBranchName
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let defaultBranchNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultBranchName)
        defaultBranchName = defaultBranchNameDecoded
    }
}

extension UpdateDefaultBranchOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDefaultBranchOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BranchDoesNotExistException" : self = .branchDoesNotExistException(try BranchDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BranchNameRequiredException" : self = .branchNameRequiredException(try BranchNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBranchNameException" : self = .invalidBranchNameException(try InvalidBranchNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDefaultBranchOutputError: Equatable {
    case branchDoesNotExistException(BranchDoesNotExistException)
    case branchNameRequiredException(BranchNameRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidBranchNameException(InvalidBranchNameException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDefaultBranchOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDefaultBranchOutputResponse()"}
}

extension UpdateDefaultBranchOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDefaultBranchOutputResponse: Equatable {

    public init() {}
}

struct UpdateDefaultBranchOutputResponseBody: Equatable {
}

extension UpdateDefaultBranchOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdatePullRequestApprovalRuleContentInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePullRequestApprovalRuleContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePullRequestApprovalRuleContentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePullRequestApprovalRuleContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePullRequestApprovalRuleContentInput>
    public typealias MOutput = OperationOutput<UpdatePullRequestApprovalRuleContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePullRequestApprovalRuleContentOutputError>
}

extension UpdatePullRequestApprovalRuleContentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePullRequestApprovalRuleContentInput(approvalRuleName: \(String(describing: approvalRuleName)), existingRuleContentSha256: \(String(describing: existingRuleContentSha256)), newRuleContent: \(String(describing: newRuleContent)), pullRequestId: \(String(describing: pullRequestId)))"}
}

extension UpdatePullRequestApprovalRuleContentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalRuleName
        case existingRuleContentSha256
        case newRuleContent
        case pullRequestId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRuleName = approvalRuleName {
            try encodeContainer.encode(approvalRuleName, forKey: .approvalRuleName)
        }
        if let existingRuleContentSha256 = existingRuleContentSha256 {
            try encodeContainer.encode(existingRuleContentSha256, forKey: .existingRuleContentSha256)
        }
        if let newRuleContent = newRuleContent {
            try encodeContainer.encode(newRuleContent, forKey: .newRuleContent)
        }
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
    }
}

public struct UpdatePullRequestApprovalRuleContentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePullRequestApprovalRuleContentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePullRequestApprovalRuleContentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePullRequestApprovalRuleContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePullRequestApprovalRuleContentInput>
    public typealias MOutput = OperationOutput<UpdatePullRequestApprovalRuleContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePullRequestApprovalRuleContentOutputError>
}

public struct UpdatePullRequestApprovalRuleContentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePullRequestApprovalRuleContentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePullRequestApprovalRuleContentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePullRequestApprovalRuleContentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePullRequestApprovalRuleContentInput>
    public typealias MOutput = OperationOutput<UpdatePullRequestApprovalRuleContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePullRequestApprovalRuleContentOutputError>
}

public struct UpdatePullRequestApprovalRuleContentInput: Equatable {
    /// <p>The name of the approval rule you want to update.</p>
    public let approvalRuleName: String?
    /// <p>The SHA-256 hash signature for the content of the approval rule. You can retrieve this
    ///             information by using
    ///             <a>GetPullRequest</a>.</p>
    public let existingRuleContentSha256: String?
    /// <p>The updated content for the approval rule.</p>
    ///         <note>
    ///             <p>When you update the content of the approval rule, you can specify approvers in an
    ///                 approval pool in one of two ways:</p>
    ///             <ul>
    ///                <li>
    ///                     <p>
    ///                      <b>CodeCommitApprovers</b>: This option only
    ///                         requires an AWS account and a resource. It can be used for both IAM users
    ///                         and federated access users whose name matches the provided resource name.
    ///                         This is a very powerful option that offers a great deal of flexibility. For
    ///                         example, if you specify the AWS account <i>123456789012</i>
    ///                         and <i>Mary_Major</i>, all of the following are counted as
    ///                         approvals coming from that user:</p>
    ///                     <ul>
    ///                      <li>
    ///                             <p>An IAM user in the account
    ///                                 (arn:aws:iam::<i>123456789012</i>:user/<i>Mary_Major</i>)</p>
    ///                         </li>
    ///                      <li>
    ///                             <p>A federated user identified in IAM as Mary_Major
    ///                                 (arn:aws:sts::<i>123456789012</i>:federated-user/<i>Mary_Major</i>)</p>
    ///                         </li>
    ///                   </ul>
    ///                     <p>This option does not recognize an active session of someone assuming the
    ///                         role of CodeCommitReview with a role session name of
    ///                             <i>Mary_Major</i>
    ///                             (arn:aws:sts::<i>123456789012</i>:assumed-role/CodeCommitReview/<i>Mary_Major</i>)
    ///                         unless you include a wildcard (*Mary_Major).</p>
    ///                 </li>
    ///                <li>
    ///                     <p>
    ///                      <b>Fully qualified ARN</b>: This option allows
    ///                         you to specify the fully qualified Amazon Resource Name (ARN) of the IAM
    ///                         user or role. </p>
    ///                 </li>
    ///             </ul>
    ///             <p>For more information about IAM ARNs, wildcards, and formats, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM
    ///                     Identifiers</a> in the <i>IAM User Guide</i>.</p>
    ///
    ///         </note>
    public let newRuleContent: String?
    /// <p>The system-generated ID of the pull request.</p>
    public let pullRequestId: String?

    public init (
        approvalRuleName: String? = nil,
        existingRuleContentSha256: String? = nil,
        newRuleContent: String? = nil,
        pullRequestId: String? = nil
    )
    {
        self.approvalRuleName = approvalRuleName
        self.existingRuleContentSha256 = existingRuleContentSha256
        self.newRuleContent = newRuleContent
        self.pullRequestId = pullRequestId
    }
}

struct UpdatePullRequestApprovalRuleContentInputBody: Equatable {
    public let pullRequestId: String?
    public let approvalRuleName: String?
    public let existingRuleContentSha256: String?
    public let newRuleContent: String?
}

extension UpdatePullRequestApprovalRuleContentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRuleName
        case existingRuleContentSha256
        case newRuleContent
        case pullRequestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let approvalRuleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .approvalRuleName)
        approvalRuleName = approvalRuleNameDecoded
        let existingRuleContentSha256Decoded = try containerValues.decodeIfPresent(String.self, forKey: .existingRuleContentSha256)
        existingRuleContentSha256 = existingRuleContentSha256Decoded
        let newRuleContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .newRuleContent)
        newRuleContent = newRuleContentDecoded
    }
}

extension UpdatePullRequestApprovalRuleContentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePullRequestApprovalRuleContentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ApprovalRuleContentRequiredException" : self = .approvalRuleContentRequiredException(try ApprovalRuleContentRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleDoesNotExistException" : self = .approvalRuleDoesNotExistException(try ApprovalRuleDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalRuleNameRequiredException" : self = .approvalRuleNameRequiredException(try ApprovalRuleNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CannotModifyApprovalRuleFromTemplateException" : self = .cannotModifyApprovalRuleFromTemplateException(try CannotModifyApprovalRuleFromTemplateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleContentException" : self = .invalidApprovalRuleContentException(try InvalidApprovalRuleContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalRuleNameException" : self = .invalidApprovalRuleNameException(try InvalidApprovalRuleNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuleContentSha256Exception" : self = .invalidRuleContentSha256Exception(try InvalidRuleContentSha256Exception(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePullRequestApprovalRuleContentOutputError: Equatable {
    case approvalRuleContentRequiredException(ApprovalRuleContentRequiredException)
    case approvalRuleDoesNotExistException(ApprovalRuleDoesNotExistException)
    case approvalRuleNameRequiredException(ApprovalRuleNameRequiredException)
    case cannotModifyApprovalRuleFromTemplateException(CannotModifyApprovalRuleFromTemplateException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidApprovalRuleContentException(InvalidApprovalRuleContentException)
    case invalidApprovalRuleNameException(InvalidApprovalRuleNameException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidRuleContentSha256Exception(InvalidRuleContentSha256Exception)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePullRequestApprovalRuleContentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePullRequestApprovalRuleContentOutputResponse(approvalRule: \(String(describing: approvalRule)))"}
}

extension UpdatePullRequestApprovalRuleContentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdatePullRequestApprovalRuleContentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.approvalRule = output.approvalRule
        } else {
            self.approvalRule = nil
        }
    }
}

public struct UpdatePullRequestApprovalRuleContentOutputResponse: Equatable {
    /// <p>Information about the updated approval rule.</p>
    public let approvalRule: ApprovalRule?

    public init (
        approvalRule: ApprovalRule? = nil
    )
    {
        self.approvalRule = approvalRule
    }
}

struct UpdatePullRequestApprovalRuleContentOutputResponseBody: Equatable {
    public let approvalRule: ApprovalRule?
}

extension UpdatePullRequestApprovalRuleContentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalRule
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvalRuleDecoded = try containerValues.decodeIfPresent(ApprovalRule.self, forKey: .approvalRule)
        approvalRule = approvalRuleDecoded
    }
}

public struct UpdatePullRequestApprovalStateInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePullRequestApprovalStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePullRequestApprovalStateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePullRequestApprovalStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePullRequestApprovalStateInput>
    public typealias MOutput = OperationOutput<UpdatePullRequestApprovalStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePullRequestApprovalStateOutputError>
}

extension UpdatePullRequestApprovalStateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePullRequestApprovalStateInput(approvalState: \(String(describing: approvalState)), pullRequestId: \(String(describing: pullRequestId)), revisionId: \(String(describing: revisionId)))"}
}

extension UpdatePullRequestApprovalStateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case approvalState
        case pullRequestId
        case revisionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalState = approvalState {
            try encodeContainer.encode(approvalState.rawValue, forKey: .approvalState)
        }
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

public struct UpdatePullRequestApprovalStateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePullRequestApprovalStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePullRequestApprovalStateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePullRequestApprovalStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePullRequestApprovalStateInput>
    public typealias MOutput = OperationOutput<UpdatePullRequestApprovalStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePullRequestApprovalStateOutputError>
}

public struct UpdatePullRequestApprovalStateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePullRequestApprovalStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePullRequestApprovalStateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePullRequestApprovalStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePullRequestApprovalStateInput>
    public typealias MOutput = OperationOutput<UpdatePullRequestApprovalStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePullRequestApprovalStateOutputError>
}

public struct UpdatePullRequestApprovalStateInput: Equatable {
    /// <p>The approval state to associate with the user on the pull request.</p>
    public let approvalState: ApprovalState?
    /// <p>The system-generated ID of the pull request.</p>
    public let pullRequestId: String?
    /// <p>The system-generated ID of the revision.</p>
    public let revisionId: String?

    public init (
        approvalState: ApprovalState? = nil,
        pullRequestId: String? = nil,
        revisionId: String? = nil
    )
    {
        self.approvalState = approvalState
        self.pullRequestId = pullRequestId
        self.revisionId = revisionId
    }
}

struct UpdatePullRequestApprovalStateInputBody: Equatable {
    public let pullRequestId: String?
    public let revisionId: String?
    public let approvalState: ApprovalState?
}

extension UpdatePullRequestApprovalStateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvalState
        case pullRequestId
        case revisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let approvalStateDecoded = try containerValues.decodeIfPresent(ApprovalState.self, forKey: .approvalState)
        approvalState = approvalStateDecoded
    }
}

extension UpdatePullRequestApprovalStateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePullRequestApprovalStateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ApprovalStateRequiredException" : self = .approvalStateRequiredException(try ApprovalStateRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalStateException" : self = .invalidApprovalStateException(try InvalidApprovalStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRevisionIdException" : self = .invalidRevisionIdException(try InvalidRevisionIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumNumberOfApprovalsExceededException" : self = .maximumNumberOfApprovalsExceededException(try MaximumNumberOfApprovalsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestCannotBeApprovedByAuthorException" : self = .pullRequestCannotBeApprovedByAuthorException(try PullRequestCannotBeApprovedByAuthorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RevisionIdRequiredException" : self = .revisionIdRequiredException(try RevisionIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RevisionNotCurrentException" : self = .revisionNotCurrentException(try RevisionNotCurrentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePullRequestApprovalStateOutputError: Equatable {
    case approvalStateRequiredException(ApprovalStateRequiredException)
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidApprovalStateException(InvalidApprovalStateException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidRevisionIdException(InvalidRevisionIdException)
    case maximumNumberOfApprovalsExceededException(MaximumNumberOfApprovalsExceededException)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestCannotBeApprovedByAuthorException(PullRequestCannotBeApprovedByAuthorException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case revisionIdRequiredException(RevisionIdRequiredException)
    case revisionNotCurrentException(RevisionNotCurrentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePullRequestApprovalStateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePullRequestApprovalStateOutputResponse()"}
}

extension UpdatePullRequestApprovalStateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePullRequestApprovalStateOutputResponse: Equatable {

    public init() {}
}

struct UpdatePullRequestApprovalStateOutputResponseBody: Equatable {
}

extension UpdatePullRequestApprovalStateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdatePullRequestDescriptionInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePullRequestDescriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePullRequestDescriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePullRequestDescriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePullRequestDescriptionInput>
    public typealias MOutput = OperationOutput<UpdatePullRequestDescriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePullRequestDescriptionOutputError>
}

extension UpdatePullRequestDescriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePullRequestDescriptionInput(description: \(String(describing: description)), pullRequestId: \(String(describing: pullRequestId)))"}
}

extension UpdatePullRequestDescriptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case pullRequestId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
    }
}

public struct UpdatePullRequestDescriptionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePullRequestDescriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePullRequestDescriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePullRequestDescriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePullRequestDescriptionInput>
    public typealias MOutput = OperationOutput<UpdatePullRequestDescriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePullRequestDescriptionOutputError>
}

public struct UpdatePullRequestDescriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePullRequestDescriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePullRequestDescriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePullRequestDescriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePullRequestDescriptionInput>
    public typealias MOutput = OperationOutput<UpdatePullRequestDescriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePullRequestDescriptionOutputError>
}

public struct UpdatePullRequestDescriptionInput: Equatable {
    /// <p>The updated content of the description for the pull request. This content replaces the
    ///             existing description.</p>
    public let description: String?
    /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
    public let pullRequestId: String?

    public init (
        description: String? = nil,
        pullRequestId: String? = nil
    )
    {
        self.description = description
        self.pullRequestId = pullRequestId
    }
}

struct UpdatePullRequestDescriptionInputBody: Equatable {
    public let pullRequestId: String?
    public let description: String?
}

extension UpdatePullRequestDescriptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case pullRequestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdatePullRequestDescriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePullRequestDescriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidDescriptionException" : self = .invalidDescriptionException(try InvalidDescriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePullRequestDescriptionOutputError: Equatable {
    case invalidDescriptionException(InvalidDescriptionException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePullRequestDescriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePullRequestDescriptionOutputResponse(pullRequest: \(String(describing: pullRequest)))"}
}

extension UpdatePullRequestDescriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdatePullRequestDescriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct UpdatePullRequestDescriptionOutputResponse: Equatable {
    /// <p>Information about the updated pull request.</p>
    public let pullRequest: PullRequest?

    public init (
        pullRequest: PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct UpdatePullRequestDescriptionOutputResponseBody: Equatable {
    public let pullRequest: PullRequest?
}

extension UpdatePullRequestDescriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pullRequest
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

public struct UpdatePullRequestStatusInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePullRequestStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePullRequestStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePullRequestStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePullRequestStatusInput>
    public typealias MOutput = OperationOutput<UpdatePullRequestStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePullRequestStatusOutputError>
}

extension UpdatePullRequestStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePullRequestStatusInput(pullRequestId: \(String(describing: pullRequestId)), pullRequestStatus: \(String(describing: pullRequestStatus)))"}
}

extension UpdatePullRequestStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pullRequestId
        case pullRequestStatus
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let pullRequestStatus = pullRequestStatus {
            try encodeContainer.encode(pullRequestStatus.rawValue, forKey: .pullRequestStatus)
        }
    }
}

public struct UpdatePullRequestStatusInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePullRequestStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePullRequestStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePullRequestStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePullRequestStatusInput>
    public typealias MOutput = OperationOutput<UpdatePullRequestStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePullRequestStatusOutputError>
}

public struct UpdatePullRequestStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePullRequestStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePullRequestStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePullRequestStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePullRequestStatusInput>
    public typealias MOutput = OperationOutput<UpdatePullRequestStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePullRequestStatusOutputError>
}

public struct UpdatePullRequestStatusInput: Equatable {
    /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
    public let pullRequestId: String?
    /// <p>The status of the pull request. The only valid operations are to update the status
    ///             from <code>OPEN</code> to <code>OPEN</code>, <code>OPEN</code> to <code>CLOSED</code> or
    ///             from <code>CLOSED</code> to <code>CLOSED</code>.</p>
    public let pullRequestStatus: PullRequestStatusEnum?

    public init (
        pullRequestId: String? = nil,
        pullRequestStatus: PullRequestStatusEnum? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.pullRequestStatus = pullRequestStatus
    }
}

struct UpdatePullRequestStatusInputBody: Equatable {
    public let pullRequestId: String?
    public let pullRequestStatus: PullRequestStatusEnum?
}

extension UpdatePullRequestStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pullRequestId
        case pullRequestStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let pullRequestStatusDecoded = try containerValues.decodeIfPresent(PullRequestStatusEnum.self, forKey: .pullRequestStatus)
        pullRequestStatus = pullRequestStatusDecoded
    }
}

extension UpdatePullRequestStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePullRequestStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestStatusException" : self = .invalidPullRequestStatusException(try InvalidPullRequestStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPullRequestStatusUpdateException" : self = .invalidPullRequestStatusUpdateException(try InvalidPullRequestStatusUpdateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestStatusRequiredException" : self = .pullRequestStatusRequiredException(try PullRequestStatusRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePullRequestStatusOutputError: Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidPullRequestStatusException(InvalidPullRequestStatusException)
    case invalidPullRequestStatusUpdateException(InvalidPullRequestStatusUpdateException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case pullRequestStatusRequiredException(PullRequestStatusRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePullRequestStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePullRequestStatusOutputResponse(pullRequest: \(String(describing: pullRequest)))"}
}

extension UpdatePullRequestStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdatePullRequestStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct UpdatePullRequestStatusOutputResponse: Equatable {
    /// <p>Information about the pull request.</p>
    public let pullRequest: PullRequest?

    public init (
        pullRequest: PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct UpdatePullRequestStatusOutputResponseBody: Equatable {
    public let pullRequest: PullRequest?
}

extension UpdatePullRequestStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pullRequest
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

public struct UpdatePullRequestTitleInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePullRequestTitleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePullRequestTitleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePullRequestTitleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePullRequestTitleInput>
    public typealias MOutput = OperationOutput<UpdatePullRequestTitleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePullRequestTitleOutputError>
}

extension UpdatePullRequestTitleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePullRequestTitleInput(pullRequestId: \(String(describing: pullRequestId)), title: \(String(describing: title)))"}
}

extension UpdatePullRequestTitleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pullRequestId
        case title
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pullRequestId = pullRequestId {
            try encodeContainer.encode(pullRequestId, forKey: .pullRequestId)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

public struct UpdatePullRequestTitleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePullRequestTitleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePullRequestTitleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePullRequestTitleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePullRequestTitleInput>
    public typealias MOutput = OperationOutput<UpdatePullRequestTitleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePullRequestTitleOutputError>
}

public struct UpdatePullRequestTitleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePullRequestTitleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePullRequestTitleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePullRequestTitleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePullRequestTitleInput>
    public typealias MOutput = OperationOutput<UpdatePullRequestTitleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePullRequestTitleOutputError>
}

public struct UpdatePullRequestTitleInput: Equatable {
    /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
    public let pullRequestId: String?
    /// <p>The updated title of the pull request. This replaces the existing title.</p>
    public let title: String?

    public init (
        pullRequestId: String? = nil,
        title: String? = nil
    )
    {
        self.pullRequestId = pullRequestId
        self.title = title
    }
}

struct UpdatePullRequestTitleInputBody: Equatable {
    public let pullRequestId: String?
    public let title: String?
}

extension UpdatePullRequestTitleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pullRequestId
        case title
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pullRequestId)
        pullRequestId = pullRequestIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
    }
}

extension UpdatePullRequestTitleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePullRequestTitleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidPullRequestIdException" : self = .invalidPullRequestIdException(try InvalidPullRequestIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTitleException" : self = .invalidTitleException(try InvalidTitleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestAlreadyClosedException" : self = .pullRequestAlreadyClosedException(try PullRequestAlreadyClosedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestDoesNotExistException" : self = .pullRequestDoesNotExistException(try PullRequestDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PullRequestIdRequiredException" : self = .pullRequestIdRequiredException(try PullRequestIdRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TitleRequiredException" : self = .titleRequiredException(try TitleRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePullRequestTitleOutputError: Equatable {
    case invalidPullRequestIdException(InvalidPullRequestIdException)
    case invalidTitleException(InvalidTitleException)
    case pullRequestAlreadyClosedException(PullRequestAlreadyClosedException)
    case pullRequestDoesNotExistException(PullRequestDoesNotExistException)
    case pullRequestIdRequiredException(PullRequestIdRequiredException)
    case titleRequiredException(TitleRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePullRequestTitleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePullRequestTitleOutputResponse(pullRequest: \(String(describing: pullRequest)))"}
}

extension UpdatePullRequestTitleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdatePullRequestTitleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.pullRequest = output.pullRequest
        } else {
            self.pullRequest = nil
        }
    }
}

public struct UpdatePullRequestTitleOutputResponse: Equatable {
    /// <p>Information about the updated pull request.</p>
    public let pullRequest: PullRequest?

    public init (
        pullRequest: PullRequest? = nil
    )
    {
        self.pullRequest = pullRequest
    }
}

struct UpdatePullRequestTitleOutputResponseBody: Equatable {
    public let pullRequest: PullRequest?
}

extension UpdatePullRequestTitleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pullRequest
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullRequestDecoded = try containerValues.decodeIfPresent(PullRequest.self, forKey: .pullRequest)
        pullRequest = pullRequestDecoded
    }
}

public struct UpdateRepositoryDescriptionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRepositoryDescriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRepositoryDescriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRepositoryDescriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRepositoryDescriptionInput>
    public typealias MOutput = OperationOutput<UpdateRepositoryDescriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRepositoryDescriptionOutputError>
}

extension UpdateRepositoryDescriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRepositoryDescriptionInput(repositoryDescription: \(String(describing: repositoryDescription)), repositoryName: \(String(describing: repositoryName)))"}
}

extension UpdateRepositoryDescriptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case repositoryDescription
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryDescription = repositoryDescription {
            try encodeContainer.encode(repositoryDescription, forKey: .repositoryDescription)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct UpdateRepositoryDescriptionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRepositoryDescriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRepositoryDescriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRepositoryDescriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRepositoryDescriptionInput>
    public typealias MOutput = OperationOutput<UpdateRepositoryDescriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRepositoryDescriptionOutputError>
}

public struct UpdateRepositoryDescriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRepositoryDescriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRepositoryDescriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRepositoryDescriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRepositoryDescriptionInput>
    public typealias MOutput = OperationOutput<UpdateRepositoryDescriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRepositoryDescriptionOutputError>
}

/// <p>Represents the input of an update repository description operation.</p>
public struct UpdateRepositoryDescriptionInput: Equatable {
    /// <p>The new comment or description for the specified repository. Repository descriptions are limited to 1,000 characters.</p>
    public let repositoryDescription: String?
    /// <p>The name of the repository to set or change the comment or description for.</p>
    public let repositoryName: String?

    public init (
        repositoryDescription: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.repositoryDescription = repositoryDescription
        self.repositoryName = repositoryName
    }
}

struct UpdateRepositoryDescriptionInputBody: Equatable {
    public let repositoryName: String?
    public let repositoryDescription: String?
}

extension UpdateRepositoryDescriptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repositoryDescription
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryDescription)
        repositoryDescription = repositoryDescriptionDecoded
    }
}

extension UpdateRepositoryDescriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRepositoryDescriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EncryptionIntegrityChecksFailedException" : self = .encryptionIntegrityChecksFailedException(try EncryptionIntegrityChecksFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyAccessDeniedException" : self = .encryptionKeyAccessDeniedException(try EncryptionKeyAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyDisabledException" : self = .encryptionKeyDisabledException(try EncryptionKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyNotFoundException" : self = .encryptionKeyNotFoundException(try EncryptionKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EncryptionKeyUnavailableException" : self = .encryptionKeyUnavailableException(try EncryptionKeyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryDescriptionException" : self = .invalidRepositoryDescriptionException(try InvalidRepositoryDescriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRepositoryDescriptionOutputError: Equatable {
    case encryptionIntegrityChecksFailedException(EncryptionIntegrityChecksFailedException)
    case encryptionKeyAccessDeniedException(EncryptionKeyAccessDeniedException)
    case encryptionKeyDisabledException(EncryptionKeyDisabledException)
    case encryptionKeyNotFoundException(EncryptionKeyNotFoundException)
    case encryptionKeyUnavailableException(EncryptionKeyUnavailableException)
    case invalidRepositoryDescriptionException(InvalidRepositoryDescriptionException)
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRepositoryDescriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRepositoryDescriptionOutputResponse()"}
}

extension UpdateRepositoryDescriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRepositoryDescriptionOutputResponse: Equatable {

    public init() {}
}

struct UpdateRepositoryDescriptionOutputResponseBody: Equatable {
}

extension UpdateRepositoryDescriptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateRepositoryNameInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRepositoryNameInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRepositoryNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRepositoryNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRepositoryNameInput>
    public typealias MOutput = OperationOutput<UpdateRepositoryNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRepositoryNameOutputError>
}

extension UpdateRepositoryNameInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRepositoryNameInput(newName: \(String(describing: newName)), oldName: \(String(describing: oldName)))"}
}

extension UpdateRepositoryNameInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case newName
        case oldName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let newName = newName {
            try encodeContainer.encode(newName, forKey: .newName)
        }
        if let oldName = oldName {
            try encodeContainer.encode(oldName, forKey: .oldName)
        }
    }
}

public struct UpdateRepositoryNameInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRepositoryNameInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRepositoryNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRepositoryNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRepositoryNameInput>
    public typealias MOutput = OperationOutput<UpdateRepositoryNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRepositoryNameOutputError>
}

public struct UpdateRepositoryNameInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRepositoryNameInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRepositoryNameInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRepositoryNameOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRepositoryNameInput>
    public typealias MOutput = OperationOutput<UpdateRepositoryNameOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRepositoryNameOutputError>
}

/// <p>Represents the input of an update repository description operation.</p>
public struct UpdateRepositoryNameInput: Equatable {
    /// <p>The new name for the repository.</p>
    public let newName: String?
    /// <p>The current name of the repository.</p>
    public let oldName: String?

    public init (
        newName: String? = nil,
        oldName: String? = nil
    )
    {
        self.newName = newName
        self.oldName = oldName
    }
}

struct UpdateRepositoryNameInputBody: Equatable {
    public let oldName: String?
    public let newName: String?
}

extension UpdateRepositoryNameInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case newName
        case oldName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .oldName)
        oldName = oldNameDecoded
        let newNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .newName)
        newName = newNameDecoded
    }
}

extension UpdateRepositoryNameOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRepositoryNameOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRepositoryNameException" : self = .invalidRepositoryNameException(try InvalidRepositoryNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryDoesNotExistException" : self = .repositoryDoesNotExistException(try RepositoryDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameExistsException" : self = .repositoryNameExistsException(try RepositoryNameExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNameRequiredException" : self = .repositoryNameRequiredException(try RepositoryNameRequiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRepositoryNameOutputError: Equatable {
    case invalidRepositoryNameException(InvalidRepositoryNameException)
    case repositoryDoesNotExistException(RepositoryDoesNotExistException)
    case repositoryNameExistsException(RepositoryNameExistsException)
    case repositoryNameRequiredException(RepositoryNameRequiredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRepositoryNameOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRepositoryNameOutputResponse()"}
}

extension UpdateRepositoryNameOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRepositoryNameOutputResponse: Equatable {

    public init() {}
}

struct UpdateRepositoryNameOutputResponseBody: Equatable {
}

extension UpdateRepositoryNameOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UserInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case date
        case email
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let date = date {
            try encodeContainer.encode(date, forKey: .date)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let dateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .date)
        date = dateDecoded
    }
}

extension UserInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserInfo(date: \(String(describing: date)), email: \(String(describing: email)), name: \(String(describing: name)))"}
}

/// <p>Information about the user who made a specified commit.</p>
public struct UserInfo: Equatable {
    /// <p>The date when the specified commit was commited, in timestamp format with GMT offset.</p>
    public let date: String?
    /// <p>The email address associated with the user who made the commit, if any.</p>
    public let email: String?
    /// <p>The name of the user who made the specified commit.</p>
    public let name: String?

    public init (
        date: String? = nil,
        email: String? = nil,
        name: String? = nil
    )
    {
        self.date = date
        self.email = email
        self.name = name
    }
}
