// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AssociateDomainInputBodyMiddleware: Middleware {
    public let id: String = "AssociateDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDomainInput>
    public typealias MOutput = OperationOutput<AssociateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDomainOutputError>
}

extension AssociateDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateDomainInput(acmCertificateArn: \(String(describing: acmCertificateArn)), displayName: \(String(describing: displayName)), domainName: \(String(describing: domainName)), fleetArn: \(String(describing: fleetArn)))"}
}

extension AssociateDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acmCertificateArn = "AcmCertificateArn"
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acmCertificateArn = acmCertificateArn {
            try encodeContainer.encode(acmCertificateArn, forKey: .acmCertificateArn)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct AssociateDomainInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDomainInput>
    public typealias MOutput = OperationOutput<AssociateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDomainOutputError>
}

public struct AssociateDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDomainInput>
    public typealias MOutput = OperationOutput<AssociateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDomainOutputError>
}

public struct AssociateDomainInput: Equatable {
    /// <p>The ARN of an issued ACM certificate that is valid for the domain being associated.</p>
    public let acmCertificateArn: String?
    /// <p>The name to display.</p>
    public let displayName: String?
    /// <p>The fully qualified domain name (FQDN).</p>
    public let domainName: String?
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let fleetArn: String?

    public init (
        acmCertificateArn: String? = nil,
        displayName: String? = nil,
        domainName: String? = nil,
        fleetArn: String? = nil
    )
    {
        self.acmCertificateArn = acmCertificateArn
        self.displayName = displayName
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct AssociateDomainInputBody: Equatable {
    public let fleetArn: String?
    public let domainName: String?
    public let displayName: String?
    public let acmCertificateArn: String?
}

extension AssociateDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acmCertificateArn = "AcmCertificateArn"
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let acmCertificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acmCertificateArn)
        acmCertificateArn = acmCertificateArnDecoded
    }
}

extension AssociateDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateDomainOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateDomainOutputResponse()"}
}

extension AssociateDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDomainOutputResponse: Equatable {

    public init() {}
}

struct AssociateDomainOutputResponseBody: Equatable {
}

extension AssociateDomainOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateWebsiteAuthorizationProviderInputBodyMiddleware: Middleware {
    public let id: String = "AssociateWebsiteAuthorizationProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateWebsiteAuthorizationProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateWebsiteAuthorizationProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateWebsiteAuthorizationProviderInput>
    public typealias MOutput = OperationOutput<AssociateWebsiteAuthorizationProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateWebsiteAuthorizationProviderOutputError>
}

extension AssociateWebsiteAuthorizationProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateWebsiteAuthorizationProviderInput(authorizationProviderType: \(String(describing: authorizationProviderType)), domainName: \(String(describing: domainName)), fleetArn: \(String(describing: fleetArn)))"}
}

extension AssociateWebsiteAuthorizationProviderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizationProviderType = "AuthorizationProviderType"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationProviderType = authorizationProviderType {
            try encodeContainer.encode(authorizationProviderType.rawValue, forKey: .authorizationProviderType)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct AssociateWebsiteAuthorizationProviderInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateWebsiteAuthorizationProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateWebsiteAuthorizationProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateWebsiteAuthorizationProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateWebsiteAuthorizationProviderInput>
    public typealias MOutput = OperationOutput<AssociateWebsiteAuthorizationProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateWebsiteAuthorizationProviderOutputError>
}

public struct AssociateWebsiteAuthorizationProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateWebsiteAuthorizationProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateWebsiteAuthorizationProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateWebsiteAuthorizationProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateWebsiteAuthorizationProviderInput>
    public typealias MOutput = OperationOutput<AssociateWebsiteAuthorizationProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateWebsiteAuthorizationProviderOutputError>
}

public struct AssociateWebsiteAuthorizationProviderInput: Equatable {
    /// <p>The authorization provider type.</p>
    public let authorizationProviderType: AuthorizationProviderType?
    /// <p>The domain name of the authorization provider. This applies only to SAML-based
    ///             authorization providers.</p>
    public let domainName: String?
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?

    public init (
        authorizationProviderType: AuthorizationProviderType? = nil,
        domainName: String? = nil,
        fleetArn: String? = nil
    )
    {
        self.authorizationProviderType = authorizationProviderType
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct AssociateWebsiteAuthorizationProviderInputBody: Equatable {
    public let fleetArn: String?
    public let authorizationProviderType: AuthorizationProviderType?
    public let domainName: String?
}

extension AssociateWebsiteAuthorizationProviderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizationProviderType = "AuthorizationProviderType"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let authorizationProviderTypeDecoded = try containerValues.decodeIfPresent(AuthorizationProviderType.self, forKey: .authorizationProviderType)
        authorizationProviderType = authorizationProviderTypeDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension AssociateWebsiteAuthorizationProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWebsiteAuthorizationProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateWebsiteAuthorizationProviderOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWebsiteAuthorizationProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateWebsiteAuthorizationProviderOutputResponse(authorizationProviderId: \(String(describing: authorizationProviderId)))"}
}

extension AssociateWebsiteAuthorizationProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateWebsiteAuthorizationProviderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authorizationProviderId = output.authorizationProviderId
        } else {
            self.authorizationProviderId = nil
        }
    }
}

public struct AssociateWebsiteAuthorizationProviderOutputResponse: Equatable {
    /// <p>A unique identifier for the authorization provider.</p>
    public let authorizationProviderId: String?

    public init (
        authorizationProviderId: String? = nil
    )
    {
        self.authorizationProviderId = authorizationProviderId
    }
}

struct AssociateWebsiteAuthorizationProviderOutputResponseBody: Equatable {
    public let authorizationProviderId: String?
}

extension AssociateWebsiteAuthorizationProviderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizationProviderId = "AuthorizationProviderId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationProviderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizationProviderId)
        authorizationProviderId = authorizationProviderIdDecoded
    }
}

public struct AssociateWebsiteCertificateAuthorityInputBodyMiddleware: Middleware {
    public let id: String = "AssociateWebsiteCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateWebsiteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateWebsiteCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<AssociateWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateWebsiteCertificateAuthorityOutputError>
}

extension AssociateWebsiteCertificateAuthorityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateWebsiteCertificateAuthorityInput(certificate: \(String(describing: certificate)), displayName: \(String(describing: displayName)), fleetArn: \(String(describing: fleetArn)))"}
}

extension AssociateWebsiteCertificateAuthorityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct AssociateWebsiteCertificateAuthorityInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateWebsiteCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateWebsiteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateWebsiteCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<AssociateWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateWebsiteCertificateAuthorityOutputError>
}

public struct AssociateWebsiteCertificateAuthorityInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateWebsiteCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateWebsiteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateWebsiteCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<AssociateWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateWebsiteCertificateAuthorityOutputError>
}

public struct AssociateWebsiteCertificateAuthorityInput: Equatable {
    /// <p>The root certificate of the CA.</p>
    public let certificate: String?
    /// <p>The certificate name to display.</p>
    public let displayName: String?
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?

    public init (
        certificate: String? = nil,
        displayName: String? = nil,
        fleetArn: String? = nil
    )
    {
        self.certificate = certificate
        self.displayName = displayName
        self.fleetArn = fleetArn
    }
}

struct AssociateWebsiteCertificateAuthorityInputBody: Equatable {
    public let fleetArn: String?
    public let certificate: String?
    public let displayName: String?
}

extension AssociateWebsiteCertificateAuthorityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension AssociateWebsiteCertificateAuthorityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWebsiteCertificateAuthorityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateWebsiteCertificateAuthorityOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWebsiteCertificateAuthorityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateWebsiteCertificateAuthorityOutputResponse(websiteCaId: \(String(describing: websiteCaId)))"}
}

extension AssociateWebsiteCertificateAuthorityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateWebsiteCertificateAuthorityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.websiteCaId = output.websiteCaId
        } else {
            self.websiteCaId = nil
        }
    }
}

public struct AssociateWebsiteCertificateAuthorityOutputResponse: Equatable {
    /// <p>A unique identifier for the CA.</p>
    public let websiteCaId: String?

    public init (
        websiteCaId: String? = nil
    )
    {
        self.websiteCaId = websiteCaId
    }
}

struct AssociateWebsiteCertificateAuthorityOutputResponseBody: Equatable {
    public let websiteCaId: String?
}

extension AssociateWebsiteCertificateAuthorityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case websiteCaId = "WebsiteCaId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websiteCaIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .websiteCaId)
        websiteCaId = websiteCaIdDecoded
    }
}

public enum AuthorizationProviderType {
    case saml
    case sdkUnknown(String)
}

extension AuthorizationProviderType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthorizationProviderType] {
        return [
            .saml,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .saml: return "SAML"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthorizationProviderType(rawValue: rawValue) ?? AuthorizationProviderType.sdkUnknown(rawValue)
    }
}

public struct CreateFleetInputBodyMiddleware: Middleware {
    public let id: String = "CreateFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFleetInput>
    public typealias MOutput = OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFleetOutputError>
}

extension CreateFleetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFleetInput(displayName: \(String(describing: displayName)), fleetName: \(String(describing: fleetName)), optimizeForEndUserLocation: \(String(describing: optimizeForEndUserLocation)), tags: \(String(describing: tags)))"}
}

extension CreateFleetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName = "DisplayName"
        case fleetName = "FleetName"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let optimizeForEndUserLocation = optimizeForEndUserLocation {
            try encodeContainer.encode(optimizeForEndUserLocation, forKey: .optimizeForEndUserLocation)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateFleetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFleetInput>
    public typealias MOutput = OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFleetOutputError>
}

public struct CreateFleetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFleetInput>
    public typealias MOutput = OperationOutput<CreateFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFleetOutputError>
}

public struct CreateFleetInput: Equatable {
    /// <p>The fleet name to display.</p>
    public let displayName: String?
    /// <p>A unique name for the fleet.</p>
    public let fleetName: String?
    /// <p>The option to optimize for better performance by routing traffic through the closest
    ///             AWS Region to users, which may be outside of your home Region.</p>
    public let optimizeForEndUserLocation: Bool?
    /// <p> The tags to add to the resource. A tag is a key-value pair.</p>
    public let tags: [String:String]?

    public init (
        displayName: String? = nil,
        fleetName: String? = nil,
        optimizeForEndUserLocation: Bool? = nil,
        tags: [String:String]? = nil
    )
    {
        self.displayName = displayName
        self.fleetName = fleetName
        self.optimizeForEndUserLocation = optimizeForEndUserLocation
        self.tags = tags
    }
}

struct CreateFleetInputBody: Equatable {
    public let fleetName: String?
    public let displayName: String?
    public let optimizeForEndUserLocation: Bool?
    public let tags: [String:String]?
}

extension CreateFleetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case displayName = "DisplayName"
        case fleetName = "FleetName"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let optimizeForEndUserLocationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .optimizeForEndUserLocation)
        optimizeForEndUserLocation = optimizeForEndUserLocationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFleetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFleetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFleetOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFleetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFleetOutputResponse(fleetArn: \(String(describing: fleetArn)))"}
}

extension CreateFleetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFleetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fleetArn = output.fleetArn
        } else {
            self.fleetArn = nil
        }
    }
}

public struct CreateFleetOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let fleetArn: String?

    public init (
        fleetArn: String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct CreateFleetOutputResponseBody: Equatable {
    public let fleetArn: String?
}

extension CreateFleetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

public struct DeleteFleetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteFleetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFleetInput>
    public typealias MOutput = OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFleetOutputError>
}

extension DeleteFleetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFleetInput(fleetArn: \(String(describing: fleetArn)))"}
}

extension DeleteFleetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DeleteFleetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFleetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFleetInput>
    public typealias MOutput = OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFleetOutputError>
}

public struct DeleteFleetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFleetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFleetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFleetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFleetInput>
    public typealias MOutput = OperationOutput<DeleteFleetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFleetOutputError>
}

public struct DeleteFleetInput: Equatable {
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?

    public init (
        fleetArn: String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DeleteFleetInputBody: Equatable {
    public let fleetArn: String?
}

extension DeleteFleetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DeleteFleetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFleetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFleetOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFleetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFleetOutputResponse()"}
}

extension DeleteFleetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFleetOutputResponse: Equatable {

    public init() {}
}

struct DeleteFleetOutputResponseBody: Equatable {
}

extension DeleteFleetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeAuditStreamConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAuditStreamConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAuditStreamConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAuditStreamConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAuditStreamConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeAuditStreamConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAuditStreamConfigurationOutputError>
}

extension DescribeAuditStreamConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAuditStreamConfigurationInput(fleetArn: \(String(describing: fleetArn)))"}
}

extension DescribeAuditStreamConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DescribeAuditStreamConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAuditStreamConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAuditStreamConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAuditStreamConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAuditStreamConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeAuditStreamConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAuditStreamConfigurationOutputError>
}

public struct DescribeAuditStreamConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAuditStreamConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAuditStreamConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAuditStreamConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAuditStreamConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeAuditStreamConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAuditStreamConfigurationOutputError>
}

public struct DescribeAuditStreamConfigurationInput: Equatable {
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?

    public init (
        fleetArn: String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeAuditStreamConfigurationInputBody: Equatable {
    public let fleetArn: String?
}

extension DescribeAuditStreamConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeAuditStreamConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAuditStreamConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAuditStreamConfigurationOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAuditStreamConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAuditStreamConfigurationOutputResponse(auditStreamArn: \(String(describing: auditStreamArn)))"}
}

extension DescribeAuditStreamConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAuditStreamConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.auditStreamArn = output.auditStreamArn
        } else {
            self.auditStreamArn = nil
        }
    }
}

public struct DescribeAuditStreamConfigurationOutputResponse: Equatable {
    /// <p>The ARN of the Amazon Kinesis data stream that will receive the audit events.</p>
    public let auditStreamArn: String?

    public init (
        auditStreamArn: String? = nil
    )
    {
        self.auditStreamArn = auditStreamArn
    }
}

struct DescribeAuditStreamConfigurationOutputResponseBody: Equatable {
    public let auditStreamArn: String?
}

extension DescribeAuditStreamConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case auditStreamArn = "AuditStreamArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditStreamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .auditStreamArn)
        auditStreamArn = auditStreamArnDecoded
    }
}

public struct DescribeCompanyNetworkConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCompanyNetworkConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCompanyNetworkConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCompanyNetworkConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCompanyNetworkConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeCompanyNetworkConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCompanyNetworkConfigurationOutputError>
}

extension DescribeCompanyNetworkConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCompanyNetworkConfigurationInput(fleetArn: \(String(describing: fleetArn)))"}
}

extension DescribeCompanyNetworkConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DescribeCompanyNetworkConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCompanyNetworkConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCompanyNetworkConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCompanyNetworkConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCompanyNetworkConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeCompanyNetworkConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCompanyNetworkConfigurationOutputError>
}

public struct DescribeCompanyNetworkConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCompanyNetworkConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCompanyNetworkConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCompanyNetworkConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCompanyNetworkConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeCompanyNetworkConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCompanyNetworkConfigurationOutputError>
}

public struct DescribeCompanyNetworkConfigurationInput: Equatable {
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?

    public init (
        fleetArn: String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeCompanyNetworkConfigurationInputBody: Equatable {
    public let fleetArn: String?
}

extension DescribeCompanyNetworkConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeCompanyNetworkConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCompanyNetworkConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCompanyNetworkConfigurationOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCompanyNetworkConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCompanyNetworkConfigurationOutputResponse(securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)), vpcId: \(String(describing: vpcId)))"}
}

extension DescribeCompanyNetworkConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCompanyNetworkConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.securityGroupIds = output.securityGroupIds
            self.subnetIds = output.subnetIds
            self.vpcId = output.vpcId
        } else {
            self.securityGroupIds = nil
            self.subnetIds = nil
            self.vpcId = nil
        }
    }
}

public struct DescribeCompanyNetworkConfigurationOutputResponse: Equatable {
    /// <p>The security groups associated with access to the provided subnets.</p>
    public let securityGroupIds: [String]?
    /// <p>The subnets used for X-ENI connections from Amazon WorkLink rendering containers.</p>
    public let subnetIds: [String]?
    /// <p>The VPC with connectivity to associated websites.</p>
    public let vpcId: String?

    public init (
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil,
        vpcId: String? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

struct DescribeCompanyNetworkConfigurationOutputResponseBody: Equatable {
    public let vpcId: String?
    public let subnetIds: [String]?
    public let securityGroupIds: [String]?
}

extension DescribeCompanyNetworkConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

public struct DescribeDeviceInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDeviceInput>
    public typealias MOutput = OperationOutput<DescribeDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDeviceOutputError>
}

extension DescribeDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDeviceInput(deviceId: \(String(describing: deviceId)), fleetArn: \(String(describing: fleetArn)))"}
}

extension DescribeDeviceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceId = "DeviceId"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DescribeDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDeviceInput>
    public typealias MOutput = OperationOutput<DescribeDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDeviceOutputError>
}

public struct DescribeDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDeviceInput>
    public typealias MOutput = OperationOutput<DescribeDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDeviceOutputError>
}

public struct DescribeDeviceInput: Equatable {
    /// <p>A unique identifier for a registered user's device.</p>
    public let deviceId: String?
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?

    public init (
        deviceId: String? = nil,
        fleetArn: String? = nil
    )
    {
        self.deviceId = deviceId
        self.fleetArn = fleetArn
    }
}

struct DescribeDeviceInputBody: Equatable {
    public let fleetArn: String?
    public let deviceId: String?
}

extension DescribeDeviceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceId = "DeviceId"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension DescribeDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDeviceOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDeviceOutputResponse(firstAccessedTime: \(String(describing: firstAccessedTime)), lastAccessedTime: \(String(describing: lastAccessedTime)), manufacturer: \(String(describing: manufacturer)), model: \(String(describing: model)), operatingSystem: \(String(describing: operatingSystem)), operatingSystemVersion: \(String(describing: operatingSystemVersion)), patchLevel: \(String(describing: patchLevel)), status: \(String(describing: status)), username: \(String(describing: username)))"}
}

extension DescribeDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDeviceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firstAccessedTime = output.firstAccessedTime
            self.lastAccessedTime = output.lastAccessedTime
            self.manufacturer = output.manufacturer
            self.model = output.model
            self.operatingSystem = output.operatingSystem
            self.operatingSystemVersion = output.operatingSystemVersion
            self.patchLevel = output.patchLevel
            self.status = output.status
            self.username = output.username
        } else {
            self.firstAccessedTime = nil
            self.lastAccessedTime = nil
            self.manufacturer = nil
            self.model = nil
            self.operatingSystem = nil
            self.operatingSystemVersion = nil
            self.patchLevel = nil
            self.status = nil
            self.username = nil
        }
    }
}

public struct DescribeDeviceOutputResponse: Equatable {
    /// <p>The date that the device first signed in to Amazon WorkLink.</p>
    public let firstAccessedTime: Date?
    /// <p>The date that the device last accessed Amazon WorkLink.</p>
    public let lastAccessedTime: Date?
    /// <p>The manufacturer of the device.</p>
    public let manufacturer: String?
    /// <p>The model of the device.</p>
    public let model: String?
    /// <p>The operating system of the device.</p>
    public let operatingSystem: String?
    /// <p>The operating system version of the device.</p>
    public let operatingSystemVersion: String?
    /// <p>The operating system patch level of the device.</p>
    public let patchLevel: String?
    /// <p>The current state of the device.</p>
    public let status: DeviceStatus?
    /// <p>The user name associated with the device.</p>
    public let username: String?

    public init (
        firstAccessedTime: Date? = nil,
        lastAccessedTime: Date? = nil,
        manufacturer: String? = nil,
        model: String? = nil,
        operatingSystem: String? = nil,
        operatingSystemVersion: String? = nil,
        patchLevel: String? = nil,
        status: DeviceStatus? = nil,
        username: String? = nil
    )
    {
        self.firstAccessedTime = firstAccessedTime
        self.lastAccessedTime = lastAccessedTime
        self.manufacturer = manufacturer
        self.model = model
        self.operatingSystem = operatingSystem
        self.operatingSystemVersion = operatingSystemVersion
        self.patchLevel = patchLevel
        self.status = status
        self.username = username
    }
}

struct DescribeDeviceOutputResponseBody: Equatable {
    public let status: DeviceStatus?
    public let model: String?
    public let manufacturer: String?
    public let operatingSystem: String?
    public let operatingSystemVersion: String?
    public let patchLevel: String?
    public let firstAccessedTime: Date?
    public let lastAccessedTime: Date?
    public let username: String?
}

extension DescribeDeviceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firstAccessedTime = "FirstAccessedTime"
        case lastAccessedTime = "LastAccessedTime"
        case manufacturer = "Manufacturer"
        case model = "Model"
        case operatingSystem = "OperatingSystem"
        case operatingSystemVersion = "OperatingSystemVersion"
        case patchLevel = "PatchLevel"
        case status = "Status"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(DeviceStatus.self, forKey: .status)
        status = statusDecoded
        let modelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .model)
        model = modelDecoded
        let manufacturerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manufacturer)
        manufacturer = manufacturerDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let operatingSystemVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operatingSystemVersion)
        operatingSystemVersion = operatingSystemVersionDecoded
        let patchLevelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patchLevel)
        patchLevel = patchLevelDecoded
        let firstAccessedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .firstAccessedTime)
        firstAccessedTime = firstAccessedTimeDecoded
        let lastAccessedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAccessedTime)
        lastAccessedTime = lastAccessedTimeDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
    }
}

public struct DescribeDevicePolicyConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDevicePolicyConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDevicePolicyConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDevicePolicyConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDevicePolicyConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeDevicePolicyConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDevicePolicyConfigurationOutputError>
}

extension DescribeDevicePolicyConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDevicePolicyConfigurationInput(fleetArn: \(String(describing: fleetArn)))"}
}

extension DescribeDevicePolicyConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DescribeDevicePolicyConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDevicePolicyConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDevicePolicyConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDevicePolicyConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDevicePolicyConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeDevicePolicyConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDevicePolicyConfigurationOutputError>
}

public struct DescribeDevicePolicyConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDevicePolicyConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDevicePolicyConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDevicePolicyConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDevicePolicyConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeDevicePolicyConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDevicePolicyConfigurationOutputError>
}

public struct DescribeDevicePolicyConfigurationInput: Equatable {
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?

    public init (
        fleetArn: String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeDevicePolicyConfigurationInputBody: Equatable {
    public let fleetArn: String?
}

extension DescribeDevicePolicyConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeDevicePolicyConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDevicePolicyConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDevicePolicyConfigurationOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDevicePolicyConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDevicePolicyConfigurationOutputResponse(deviceCaCertificate: \(String(describing: deviceCaCertificate)))"}
}

extension DescribeDevicePolicyConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDevicePolicyConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deviceCaCertificate = output.deviceCaCertificate
        } else {
            self.deviceCaCertificate = nil
        }
    }
}

public struct DescribeDevicePolicyConfigurationOutputResponse: Equatable {
    /// <p>The certificate chain, including intermediate certificates and the root certificate authority certificate used to issue device certificates.</p>
    public let deviceCaCertificate: String?

    public init (
        deviceCaCertificate: String? = nil
    )
    {
        self.deviceCaCertificate = deviceCaCertificate
    }
}

struct DescribeDevicePolicyConfigurationOutputResponseBody: Equatable {
    public let deviceCaCertificate: String?
}

extension DescribeDevicePolicyConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceCaCertificate = "DeviceCaCertificate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceCaCertificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceCaCertificate)
        deviceCaCertificate = deviceCaCertificateDecoded
    }
}

public struct DescribeDomainInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDomainInput>
    public typealias MOutput = OperationOutput<DescribeDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDomainOutputError>
}

extension DescribeDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDomainInput(domainName: \(String(describing: domainName)), fleetArn: \(String(describing: fleetArn)))"}
}

extension DescribeDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DescribeDomainInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDomainInput>
    public typealias MOutput = OperationOutput<DescribeDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDomainOutputError>
}

public struct DescribeDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDomainInput>
    public typealias MOutput = OperationOutput<DescribeDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDomainOutputError>
}

public struct DescribeDomainInput: Equatable {
    /// <p>The name of the domain.</p>
    public let domainName: String?
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?

    public init (
        domainName: String? = nil,
        fleetArn: String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct DescribeDomainInputBody: Equatable {
    public let fleetArn: String?
    public let domainName: String?
}

extension DescribeDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DescribeDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDomainOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDomainOutputResponse(acmCertificateArn: \(String(describing: acmCertificateArn)), createdTime: \(String(describing: createdTime)), displayName: \(String(describing: displayName)), domainName: \(String(describing: domainName)), domainStatus: \(String(describing: domainStatus)))"}
}

extension DescribeDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDomainOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.acmCertificateArn = output.acmCertificateArn
            self.createdTime = output.createdTime
            self.displayName = output.displayName
            self.domainName = output.domainName
            self.domainStatus = output.domainStatus
        } else {
            self.acmCertificateArn = nil
            self.createdTime = nil
            self.displayName = nil
            self.domainName = nil
            self.domainStatus = nil
        }
    }
}

public struct DescribeDomainOutputResponse: Equatable {
    /// <p>The ARN of an issued ACM certificate that is valid for the domain being associated.</p>
    public let acmCertificateArn: String?
    /// <p>The time that the domain was added.</p>
    public let createdTime: Date?
    /// <p>The name to display.</p>
    public let displayName: String?
    /// <p>The name of the domain.</p>
    public let domainName: String?
    /// <p>The current state for the domain.</p>
    public let domainStatus: DomainStatus?

    public init (
        acmCertificateArn: String? = nil,
        createdTime: Date? = nil,
        displayName: String? = nil,
        domainName: String? = nil,
        domainStatus: DomainStatus? = nil
    )
    {
        self.acmCertificateArn = acmCertificateArn
        self.createdTime = createdTime
        self.displayName = displayName
        self.domainName = domainName
        self.domainStatus = domainStatus
    }
}

struct DescribeDomainOutputResponseBody: Equatable {
    public let domainName: String?
    public let displayName: String?
    public let createdTime: Date?
    public let domainStatus: DomainStatus?
    public let acmCertificateArn: String?
}

extension DescribeDomainOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case acmCertificateArn = "AcmCertificateArn"
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case domainStatus = "DomainStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
        let acmCertificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .acmCertificateArn)
        acmCertificateArn = acmCertificateArnDecoded
    }
}

public struct DescribeFleetMetadataInputBodyMiddleware: Middleware {
    public let id: String = "DescribeFleetMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFleetMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFleetMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFleetMetadataInput>
    public typealias MOutput = OperationOutput<DescribeFleetMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFleetMetadataOutputError>
}

extension DescribeFleetMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFleetMetadataInput(fleetArn: \(String(describing: fleetArn)))"}
}

extension DescribeFleetMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DescribeFleetMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFleetMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFleetMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFleetMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFleetMetadataInput>
    public typealias MOutput = OperationOutput<DescribeFleetMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFleetMetadataOutputError>
}

public struct DescribeFleetMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFleetMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFleetMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFleetMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFleetMetadataInput>
    public typealias MOutput = OperationOutput<DescribeFleetMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFleetMetadataOutputError>
}

public struct DescribeFleetMetadataInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let fleetArn: String?

    public init (
        fleetArn: String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeFleetMetadataInputBody: Equatable {
    public let fleetArn: String?
}

extension DescribeFleetMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeFleetMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFleetMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFleetMetadataOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFleetMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFleetMetadataOutputResponse(companyCode: \(String(describing: companyCode)), createdTime: \(String(describing: createdTime)), displayName: \(String(describing: displayName)), fleetName: \(String(describing: fleetName)), fleetStatus: \(String(describing: fleetStatus)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), optimizeForEndUserLocation: \(String(describing: optimizeForEndUserLocation)), tags: \(String(describing: tags)))"}
}

extension DescribeFleetMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFleetMetadataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.companyCode = output.companyCode
            self.createdTime = output.createdTime
            self.displayName = output.displayName
            self.fleetName = output.fleetName
            self.fleetStatus = output.fleetStatus
            self.lastUpdatedTime = output.lastUpdatedTime
            self.optimizeForEndUserLocation = output.optimizeForEndUserLocation
            self.tags = output.tags
        } else {
            self.companyCode = nil
            self.createdTime = nil
            self.displayName = nil
            self.fleetName = nil
            self.fleetStatus = nil
            self.lastUpdatedTime = nil
            self.optimizeForEndUserLocation = nil
            self.tags = nil
        }
    }
}

public struct DescribeFleetMetadataOutputResponse: Equatable {
    /// <p>The identifier used by users to sign in to the Amazon WorkLink app.</p>
    public let companyCode: String?
    /// <p>The time that the fleet was created.</p>
    public let createdTime: Date?
    /// <p>The name to display.</p>
    public let displayName: String?
    /// <p>The name of the fleet.</p>
    public let fleetName: String?
    /// <p>The current state of the fleet.</p>
    public let fleetStatus: FleetStatus?
    /// <p>The time that the fleet was last updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The option to optimize for better performance by routing traffic through the closest
    ///             AWS Region to users, which may be outside of your home Region.</p>
    public let optimizeForEndUserLocation: Bool?
    /// <p>The tags attached to the resource. A tag is a key-value pair.</p>
    public let tags: [String:String]?

    public init (
        companyCode: String? = nil,
        createdTime: Date? = nil,
        displayName: String? = nil,
        fleetName: String? = nil,
        fleetStatus: FleetStatus? = nil,
        lastUpdatedTime: Date? = nil,
        optimizeForEndUserLocation: Bool? = nil,
        tags: [String:String]? = nil
    )
    {
        self.companyCode = companyCode
        self.createdTime = createdTime
        self.displayName = displayName
        self.fleetName = fleetName
        self.fleetStatus = fleetStatus
        self.lastUpdatedTime = lastUpdatedTime
        self.optimizeForEndUserLocation = optimizeForEndUserLocation
        self.tags = tags
    }
}

struct DescribeFleetMetadataOutputResponseBody: Equatable {
    public let createdTime: Date?
    public let lastUpdatedTime: Date?
    public let fleetName: String?
    public let displayName: String?
    public let optimizeForEndUserLocation: Bool?
    public let companyCode: String?
    public let fleetStatus: FleetStatus?
    public let tags: [String:String]?
}

extension DescribeFleetMetadataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case companyCode = "CompanyCode"
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case fleetName = "FleetName"
        case fleetStatus = "FleetStatus"
        case lastUpdatedTime = "LastUpdatedTime"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let optimizeForEndUserLocationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .optimizeForEndUserLocation)
        optimizeForEndUserLocation = optimizeForEndUserLocationDecoded
        let companyCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .companyCode)
        companyCode = companyCodeDecoded
        let fleetStatusDecoded = try containerValues.decodeIfPresent(FleetStatus.self, forKey: .fleetStatus)
        fleetStatus = fleetStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct DescribeIdentityProviderConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeIdentityProviderConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIdentityProviderConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIdentityProviderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIdentityProviderConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeIdentityProviderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIdentityProviderConfigurationOutputError>
}

extension DescribeIdentityProviderConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIdentityProviderConfigurationInput(fleetArn: \(String(describing: fleetArn)))"}
}

extension DescribeIdentityProviderConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DescribeIdentityProviderConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeIdentityProviderConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIdentityProviderConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIdentityProviderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIdentityProviderConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeIdentityProviderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIdentityProviderConfigurationOutputError>
}

public struct DescribeIdentityProviderConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeIdentityProviderConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIdentityProviderConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIdentityProviderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIdentityProviderConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeIdentityProviderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIdentityProviderConfigurationOutputError>
}

public struct DescribeIdentityProviderConfigurationInput: Equatable {
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?

    public init (
        fleetArn: String? = nil
    )
    {
        self.fleetArn = fleetArn
    }
}

struct DescribeIdentityProviderConfigurationInputBody: Equatable {
    public let fleetArn: String?
}

extension DescribeIdentityProviderConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
    }
}

extension DescribeIdentityProviderConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIdentityProviderConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIdentityProviderConfigurationOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIdentityProviderConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIdentityProviderConfigurationOutputResponse(identityProviderSamlMetadata: \(String(describing: identityProviderSamlMetadata)), identityProviderType: \(String(describing: identityProviderType)), serviceProviderSamlMetadata: \(String(describing: serviceProviderSamlMetadata)))"}
}

extension DescribeIdentityProviderConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeIdentityProviderConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identityProviderSamlMetadata = output.identityProviderSamlMetadata
            self.identityProviderType = output.identityProviderType
            self.serviceProviderSamlMetadata = output.serviceProviderSamlMetadata
        } else {
            self.identityProviderSamlMetadata = nil
            self.identityProviderType = nil
            self.serviceProviderSamlMetadata = nil
        }
    }
}

public struct DescribeIdentityProviderConfigurationOutputResponse: Equatable {
    /// <p>The SAML metadata document provided by the user’s identity provider.</p>
    public let identityProviderSamlMetadata: String?
    /// <p>The type of identity provider.</p>
    public let identityProviderType: IdentityProviderType?
    /// <p>The SAML metadata document uploaded to the user’s identity provider.</p>
    public let serviceProviderSamlMetadata: String?

    public init (
        identityProviderSamlMetadata: String? = nil,
        identityProviderType: IdentityProviderType? = nil,
        serviceProviderSamlMetadata: String? = nil
    )
    {
        self.identityProviderSamlMetadata = identityProviderSamlMetadata
        self.identityProviderType = identityProviderType
        self.serviceProviderSamlMetadata = serviceProviderSamlMetadata
    }
}

struct DescribeIdentityProviderConfigurationOutputResponseBody: Equatable {
    public let identityProviderType: IdentityProviderType?
    public let serviceProviderSamlMetadata: String?
    public let identityProviderSamlMetadata: String?
}

extension DescribeIdentityProviderConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityProviderSamlMetadata = "IdentityProviderSamlMetadata"
        case identityProviderType = "IdentityProviderType"
        case serviceProviderSamlMetadata = "ServiceProviderSamlMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let serviceProviderSamlMetadataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceProviderSamlMetadata)
        serviceProviderSamlMetadata = serviceProviderSamlMetadataDecoded
        let identityProviderSamlMetadataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityProviderSamlMetadata)
        identityProviderSamlMetadata = identityProviderSamlMetadataDecoded
    }
}

public struct DescribeWebsiteCertificateAuthorityInputBodyMiddleware: Middleware {
    public let id: String = "DescribeWebsiteCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWebsiteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWebsiteCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<DescribeWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWebsiteCertificateAuthorityOutputError>
}

extension DescribeWebsiteCertificateAuthorityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWebsiteCertificateAuthorityInput(fleetArn: \(String(describing: fleetArn)), websiteCaId: \(String(describing: websiteCaId)))"}
}

extension DescribeWebsiteCertificateAuthorityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
        case websiteCaId = "WebsiteCaId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let websiteCaId = websiteCaId {
            try encodeContainer.encode(websiteCaId, forKey: .websiteCaId)
        }
    }
}

public struct DescribeWebsiteCertificateAuthorityInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeWebsiteCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWebsiteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWebsiteCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<DescribeWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWebsiteCertificateAuthorityOutputError>
}

public struct DescribeWebsiteCertificateAuthorityInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeWebsiteCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWebsiteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWebsiteCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<DescribeWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWebsiteCertificateAuthorityOutputError>
}

public struct DescribeWebsiteCertificateAuthorityInput: Equatable {
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?
    /// <p>A unique identifier for the certificate authority.</p>
    public let websiteCaId: String?

    public init (
        fleetArn: String? = nil,
        websiteCaId: String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.websiteCaId = websiteCaId
    }
}

struct DescribeWebsiteCertificateAuthorityInputBody: Equatable {
    public let fleetArn: String?
    public let websiteCaId: String?
}

extension DescribeWebsiteCertificateAuthorityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
        case websiteCaId = "WebsiteCaId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let websiteCaIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .websiteCaId)
        websiteCaId = websiteCaIdDecoded
    }
}

extension DescribeWebsiteCertificateAuthorityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWebsiteCertificateAuthorityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWebsiteCertificateAuthorityOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWebsiteCertificateAuthorityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWebsiteCertificateAuthorityOutputResponse(certificate: \(String(describing: certificate)), createdTime: \(String(describing: createdTime)), displayName: \(String(describing: displayName)))"}
}

extension DescribeWebsiteCertificateAuthorityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeWebsiteCertificateAuthorityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificate = output.certificate
            self.createdTime = output.createdTime
            self.displayName = output.displayName
        } else {
            self.certificate = nil
            self.createdTime = nil
            self.displayName = nil
        }
    }
}

public struct DescribeWebsiteCertificateAuthorityOutputResponse: Equatable {
    /// <p>The root certificate of the certificate authority.</p>
    public let certificate: String?
    /// <p>The time that the certificate authority was added.</p>
    public let createdTime: Date?
    /// <p>The certificate name to display.</p>
    public let displayName: String?

    public init (
        certificate: String? = nil,
        createdTime: Date? = nil,
        displayName: String? = nil
    )
    {
        self.certificate = certificate
        self.createdTime = createdTime
        self.displayName = displayName
    }
}

struct DescribeWebsiteCertificateAuthorityOutputResponseBody: Equatable {
    public let certificate: String?
    public let createdTime: Date?
    public let displayName: String?
}

extension DescribeWebsiteCertificateAuthorityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

public enum DeviceStatus {
    case active
    case signedOut
    case sdkUnknown(String)
}

extension DeviceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeviceStatus] {
        return [
            .active,
            .signedOut,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .signedOut: return "SIGNED_OUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeviceStatus(rawValue: rawValue) ?? DeviceStatus.sdkUnknown(rawValue)
    }
}

extension DeviceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceId = "DeviceId"
        case deviceStatus = "DeviceStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let deviceStatus = deviceStatus {
            try encodeContainer.encode(deviceStatus.rawValue, forKey: .deviceStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let deviceStatusDecoded = try containerValues.decodeIfPresent(DeviceStatus.self, forKey: .deviceStatus)
        deviceStatus = deviceStatusDecoded
    }
}

extension DeviceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceSummary(deviceId: \(String(describing: deviceId)), deviceStatus: \(String(describing: deviceStatus)))"}
}

/// <p>The summary of devices.</p>
public struct DeviceSummary: Equatable {
    /// <p>The ID of the device.</p>
    public let deviceId: String?
    /// <p>The status of the device.</p>
    public let deviceStatus: DeviceStatus?

    public init (
        deviceId: String? = nil,
        deviceStatus: DeviceStatus? = nil
    )
    {
        self.deviceId = deviceId
        self.deviceStatus = deviceStatus
    }
}

public struct DisassociateDomainInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateDomainInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDomainInput>
    public typealias MOutput = OperationOutput<DisassociateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDomainOutputError>
}

extension DisassociateDomainInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateDomainInput(domainName: \(String(describing: domainName)), fleetArn: \(String(describing: fleetArn)))"}
}

extension DisassociateDomainInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DisassociateDomainInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateDomainInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDomainInput>
    public typealias MOutput = OperationOutput<DisassociateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDomainOutputError>
}

public struct DisassociateDomainInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateDomainInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDomainInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDomainOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDomainInput>
    public typealias MOutput = OperationOutput<DisassociateDomainOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDomainOutputError>
}

public struct DisassociateDomainInput: Equatable {
    /// <p>The name of the domain.</p>
    public let domainName: String?
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?

    public init (
        domainName: String? = nil,
        fleetArn: String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct DisassociateDomainInputBody: Equatable {
    public let fleetArn: String?
    public let domainName: String?
}

extension DisassociateDomainInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DisassociateDomainOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateDomainOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateDomainOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateDomainOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateDomainOutputResponse()"}
}

extension DisassociateDomainOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateDomainOutputResponse: Equatable {

    public init() {}
}

struct DisassociateDomainOutputResponseBody: Equatable {
}

extension DisassociateDomainOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateWebsiteAuthorizationProviderInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateWebsiteAuthorizationProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateWebsiteAuthorizationProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateWebsiteAuthorizationProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateWebsiteAuthorizationProviderInput>
    public typealias MOutput = OperationOutput<DisassociateWebsiteAuthorizationProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateWebsiteAuthorizationProviderOutputError>
}

extension DisassociateWebsiteAuthorizationProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateWebsiteAuthorizationProviderInput(authorizationProviderId: \(String(describing: authorizationProviderId)), fleetArn: \(String(describing: fleetArn)))"}
}

extension DisassociateWebsiteAuthorizationProviderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizationProviderId = "AuthorizationProviderId"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationProviderId = authorizationProviderId {
            try encodeContainer.encode(authorizationProviderId, forKey: .authorizationProviderId)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct DisassociateWebsiteAuthorizationProviderInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateWebsiteAuthorizationProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateWebsiteAuthorizationProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateWebsiteAuthorizationProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateWebsiteAuthorizationProviderInput>
    public typealias MOutput = OperationOutput<DisassociateWebsiteAuthorizationProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateWebsiteAuthorizationProviderOutputError>
}

public struct DisassociateWebsiteAuthorizationProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateWebsiteAuthorizationProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateWebsiteAuthorizationProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateWebsiteAuthorizationProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateWebsiteAuthorizationProviderInput>
    public typealias MOutput = OperationOutput<DisassociateWebsiteAuthorizationProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateWebsiteAuthorizationProviderOutputError>
}

public struct DisassociateWebsiteAuthorizationProviderInput: Equatable {
    /// <p>A unique identifier for the authorization provider.</p>
    public let authorizationProviderId: String?
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?

    public init (
        authorizationProviderId: String? = nil,
        fleetArn: String? = nil
    )
    {
        self.authorizationProviderId = authorizationProviderId
        self.fleetArn = fleetArn
    }
}

struct DisassociateWebsiteAuthorizationProviderInputBody: Equatable {
    public let fleetArn: String?
    public let authorizationProviderId: String?
}

extension DisassociateWebsiteAuthorizationProviderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizationProviderId = "AuthorizationProviderId"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let authorizationProviderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizationProviderId)
        authorizationProviderId = authorizationProviderIdDecoded
    }
}

extension DisassociateWebsiteAuthorizationProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWebsiteAuthorizationProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateWebsiteAuthorizationProviderOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWebsiteAuthorizationProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateWebsiteAuthorizationProviderOutputResponse()"}
}

extension DisassociateWebsiteAuthorizationProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWebsiteAuthorizationProviderOutputResponse: Equatable {

    public init() {}
}

struct DisassociateWebsiteAuthorizationProviderOutputResponseBody: Equatable {
}

extension DisassociateWebsiteAuthorizationProviderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateWebsiteCertificateAuthorityInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateWebsiteCertificateAuthorityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateWebsiteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateWebsiteCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<DisassociateWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateWebsiteCertificateAuthorityOutputError>
}

extension DisassociateWebsiteCertificateAuthorityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateWebsiteCertificateAuthorityInput(fleetArn: \(String(describing: fleetArn)), websiteCaId: \(String(describing: websiteCaId)))"}
}

extension DisassociateWebsiteCertificateAuthorityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
        case websiteCaId = "WebsiteCaId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let websiteCaId = websiteCaId {
            try encodeContainer.encode(websiteCaId, forKey: .websiteCaId)
        }
    }
}

public struct DisassociateWebsiteCertificateAuthorityInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateWebsiteCertificateAuthorityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateWebsiteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateWebsiteCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<DisassociateWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateWebsiteCertificateAuthorityOutputError>
}

public struct DisassociateWebsiteCertificateAuthorityInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateWebsiteCertificateAuthorityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateWebsiteCertificateAuthorityInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateWebsiteCertificateAuthorityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateWebsiteCertificateAuthorityInput>
    public typealias MOutput = OperationOutput<DisassociateWebsiteCertificateAuthorityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateWebsiteCertificateAuthorityOutputError>
}

public struct DisassociateWebsiteCertificateAuthorityInput: Equatable {
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?
    /// <p>A unique identifier for the CA.</p>
    public let websiteCaId: String?

    public init (
        fleetArn: String? = nil,
        websiteCaId: String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.websiteCaId = websiteCaId
    }
}

struct DisassociateWebsiteCertificateAuthorityInputBody: Equatable {
    public let fleetArn: String?
    public let websiteCaId: String?
}

extension DisassociateWebsiteCertificateAuthorityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
        case websiteCaId = "WebsiteCaId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let websiteCaIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .websiteCaId)
        websiteCaId = websiteCaIdDecoded
    }
}

extension DisassociateWebsiteCertificateAuthorityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWebsiteCertificateAuthorityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateWebsiteCertificateAuthorityOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWebsiteCertificateAuthorityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateWebsiteCertificateAuthorityOutputResponse()"}
}

extension DisassociateWebsiteCertificateAuthorityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWebsiteCertificateAuthorityOutputResponse: Equatable {

    public init() {}
}

struct DisassociateWebsiteCertificateAuthorityOutputResponseBody: Equatable {
}

extension DisassociateWebsiteCertificateAuthorityOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum DomainStatus {
    case active
    case associating
    case disassociated
    case disassociating
    case failedToAssociate
    case failedToDisassociate
    case inactive
    case pendingValidation
    case sdkUnknown(String)
}

extension DomainStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DomainStatus] {
        return [
            .active,
            .associating,
            .disassociated,
            .disassociating,
            .failedToAssociate,
            .failedToDisassociate,
            .inactive,
            .pendingValidation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .associating: return "ASSOCIATING"
        case .disassociated: return "DISASSOCIATED"
        case .disassociating: return "DISASSOCIATING"
        case .failedToAssociate: return "FAILED_TO_ASSOCIATE"
        case .failedToDisassociate: return "FAILED_TO_DISASSOCIATE"
        case .inactive: return "INACTIVE"
        case .pendingValidation: return "PENDING_VALIDATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DomainStatus(rawValue: rawValue) ?? DomainStatus.sdkUnknown(rawValue)
    }
}

extension DomainSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case domainStatus = "DomainStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainStatus = domainStatus {
            try encodeContainer.encode(domainStatus.rawValue, forKey: .domainStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
    }
}

extension DomainSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainSummary(createdTime: \(String(describing: createdTime)), displayName: \(String(describing: displayName)), domainName: \(String(describing: domainName)), domainStatus: \(String(describing: domainStatus)))"}
}

/// <p>The summary of the domain.</p>
public struct DomainSummary: Equatable {
    /// <p>The time that the domain was created.</p>
    public let createdTime: Date?
    /// <p>The name to display.</p>
    public let displayName: String?
    /// <p>The name of the domain.</p>
    public let domainName: String?
    /// <p>The status of the domain.</p>
    public let domainStatus: DomainStatus?

    public init (
        createdTime: Date? = nil,
        displayName: String? = nil,
        domainName: String? = nil,
        domainStatus: DomainStatus? = nil
    )
    {
        self.createdTime = createdTime
        self.displayName = displayName
        self.domainName = domainName
        self.domainStatus = domainStatus
    }
}

public enum FleetStatus {
    case active
    case creating
    case deleted
    case deleting
    case failedToCreate
    case failedToDelete
    case sdkUnknown(String)
}

extension FleetStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FleetStatus] {
        return [
            .active,
            .creating,
            .deleted,
            .deleting,
            .failedToCreate,
            .failedToDelete,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleted: return "DELETED"
        case .deleting: return "DELETING"
        case .failedToCreate: return "FAILED_TO_CREATE"
        case .failedToDelete: return "FAILED_TO_DELETE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FleetStatus(rawValue: rawValue) ?? FleetStatus.sdkUnknown(rawValue)
    }
}

extension FleetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case companyCode = "CompanyCode"
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
        case fleetName = "FleetName"
        case fleetStatus = "FleetStatus"
        case lastUpdatedTime = "LastUpdatedTime"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let companyCode = companyCode {
            try encodeContainer.encode(companyCode, forKey: .companyCode)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let fleetStatus = fleetStatus {
            try encodeContainer.encode(fleetStatus.rawValue, forKey: .fleetStatus)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let companyCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .companyCode)
        companyCode = companyCodeDecoded
        let fleetStatusDecoded = try containerValues.decodeIfPresent(FleetStatus.self, forKey: .fleetStatus)
        fleetStatus = fleetStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FleetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FleetSummary(companyCode: \(String(describing: companyCode)), createdTime: \(String(describing: createdTime)), displayName: \(String(describing: displayName)), fleetArn: \(String(describing: fleetArn)), fleetName: \(String(describing: fleetName)), fleetStatus: \(String(describing: fleetStatus)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), tags: \(String(describing: tags)))"}
}

/// <p>The summary of the fleet.</p>
public struct FleetSummary: Equatable {
    /// <p>The identifier used by users to sign into the Amazon WorkLink app.</p>
    public let companyCode: String?
    /// <p>The time when the fleet was created.</p>
    public let createdTime: Date?
    /// <p>The name of the fleet to display.</p>
    public let displayName: String?
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let fleetArn: String?
    /// <p>The name of the fleet.</p>
    public let fleetName: String?
    /// <p>The status of the fleet.</p>
    public let fleetStatus: FleetStatus?
    /// <p>The time when the fleet was last updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The tags attached to the resource. A tag is a key-value pair.</p>
    public let tags: [String:String]?

    public init (
        companyCode: String? = nil,
        createdTime: Date? = nil,
        displayName: String? = nil,
        fleetArn: String? = nil,
        fleetName: String? = nil,
        fleetStatus: FleetStatus? = nil,
        lastUpdatedTime: Date? = nil,
        tags: [String:String]? = nil
    )
    {
        self.companyCode = companyCode
        self.createdTime = createdTime
        self.displayName = displayName
        self.fleetArn = fleetArn
        self.fleetName = fleetName
        self.fleetStatus = fleetStatus
        self.lastUpdatedTime = lastUpdatedTime
        self.tags = tags
    }
}

public enum IdentityProviderType {
    case saml
    case sdkUnknown(String)
}

extension IdentityProviderType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IdentityProviderType] {
        return [
            .saml,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .saml: return "SAML"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IdentityProviderType(rawValue: rawValue) ?? IdentityProviderType.sdkUnknown(rawValue)
    }
}

extension InternalServerErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerErrorException(message: \(String(describing: message)))"}
}

extension InternalServerErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is temporarily unavailable.</p>
public struct InternalServerErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request is not valid.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListDevicesInputBodyMiddleware: Middleware {
    public let id: String = "ListDevicesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDevicesInput>
    public typealias MOutput = OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDevicesOutputError>
}

extension ListDevicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDevicesInput(fleetArn: \(String(describing: fleetArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDevicesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDevicesInputHeadersMiddleware: Middleware {
    public let id: String = "ListDevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDevicesInput>
    public typealias MOutput = OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDevicesOutputError>
}

public struct ListDevicesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDevicesInput>
    public typealias MOutput = OperationOutput<ListDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDevicesOutputError>
}

public struct ListDevicesInput: Equatable {
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?
    /// <p>The maximum number of results to be included in the next page.</p>
    public let maxResults: Int?
    /// <p>The pagination token used to retrieve the next page of results for this operation. If
    ///             this value is null, it retrieves the first page.</p>
    public let nextToken: String?

    public init (
        fleetArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDevicesInputBody: Equatable {
    public let fleetArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDevicesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDevicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDevicesOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDevicesOutputResponse(devices: \(String(describing: devices)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDevicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDevicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevicesOutputResponse: Equatable {
    /// <p>Information about the devices.</p>
    public let devices: [DeviceSummary]?
    /// <p>The pagination token used to retrieve the next page of results for this operation. If
    ///             there are no more pages, this value is null.</p>
    public let nextToken: String?

    public init (
        devices: [DeviceSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct ListDevicesOutputResponseBody: Equatable {
    public let devices: [DeviceSummary]?
    public let nextToken: String?
}

extension ListDevicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case devices = "Devices"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([DeviceSummary?].self, forKey: .devices)
        var devicesDecoded0:[DeviceSummary]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [DeviceSummary]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDomainsInputBodyMiddleware: Middleware {
    public let id: String = "ListDomainsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainsInput>
    public typealias MOutput = OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainsOutputError>
}

extension ListDomainsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainsInput(fleetArn: \(String(describing: fleetArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDomainsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDomainsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDomainsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainsInput>
    public typealias MOutput = OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainsOutputError>
}

public struct ListDomainsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDomainsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDomainsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDomainsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDomainsInput>
    public typealias MOutput = OperationOutput<ListDomainsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDomainsOutputError>
}

public struct ListDomainsInput: Equatable {
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?
    /// <p>The maximum number of results to be included in the next page.</p>
    public let maxResults: Int?
    /// <p>The pagination token used to retrieve the next page of results for this operation. If
    ///             this value is null, it retrieves the first page.</p>
    public let nextToken: String?

    public init (
        fleetArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainsInputBody: Equatable {
    public let fleetArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDomainsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDomainsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainsOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDomainsOutputResponse(domains: \(String(describing: domains)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDomainsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDomainsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.domains = output.domains
            self.nextToken = output.nextToken
        } else {
            self.domains = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainsOutputResponse: Equatable {
    /// <p>Information about the domains.</p>
    public let domains: [DomainSummary]?
    /// <p>The pagination token used to retrieve the next page of results for this operation. If
    ///             there are no more pages, this value is null.</p>
    public let nextToken: String?

    public init (
        domains: [DomainSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.domains = domains
        self.nextToken = nextToken
    }
}

struct ListDomainsOutputResponseBody: Equatable {
    public let domains: [DomainSummary]?
    public let nextToken: String?
}

extension ListDomainsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domains = "Domains"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainsContainer = try containerValues.decodeIfPresent([DomainSummary?].self, forKey: .domains)
        var domainsDecoded0:[DomainSummary]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [DomainSummary]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFleetsInputBodyMiddleware: Middleware {
    public let id: String = "ListFleetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFleetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFleetsInput>
    public typealias MOutput = OperationOutput<ListFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFleetsOutputError>
}

extension ListFleetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFleetsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFleetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFleetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFleetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFleetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFleetsInput>
    public typealias MOutput = OperationOutput<ListFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFleetsOutputError>
}

public struct ListFleetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFleetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFleetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFleetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFleetsInput>
    public typealias MOutput = OperationOutput<ListFleetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFleetsOutputError>
}

public struct ListFleetsInput: Equatable {
    /// <p>The maximum number of results to be included in the next page.</p>
    public let maxResults: Int?
    /// <p>The pagination token used to retrieve the next page of results for this operation. If
    ///             this value is null, it retrieves the first page.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFleetsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListFleetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFleetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFleetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFleetsOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFleetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFleetsOutputResponse(fleetSummaryList: \(String(describing: fleetSummaryList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFleetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFleetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fleetSummaryList = output.fleetSummaryList
            self.nextToken = output.nextToken
        } else {
            self.fleetSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFleetsOutputResponse: Equatable {
    /// <p>The summary list of the fleets.</p>
    public let fleetSummaryList: [FleetSummary]?
    /// <p>The pagination token used to retrieve the next page of results for this operation. If
    ///             there are no more pages, this value is null.</p>
    public let nextToken: String?

    public init (
        fleetSummaryList: [FleetSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.fleetSummaryList = fleetSummaryList
        self.nextToken = nextToken
    }
}

struct ListFleetsOutputResponseBody: Equatable {
    public let fleetSummaryList: [FleetSummary]?
    public let nextToken: String?
}

extension ListFleetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetSummaryList = "FleetSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetSummaryListContainer = try containerValues.decodeIfPresent([FleetSummary?].self, forKey: .fleetSummaryList)
        var fleetSummaryListDecoded0:[FleetSummary]? = nil
        if let fleetSummaryListContainer = fleetSummaryListContainer {
            fleetSummaryListDecoded0 = [FleetSummary]()
            for structure0 in fleetSummaryListContainer {
                if let structure0 = structure0 {
                    fleetSummaryListDecoded0?.append(structure0)
                }
            }
        }
        fleetSummaryList = fleetSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags attached to the resource. A tag is a key-value pair.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListWebsiteAuthorizationProvidersInputBodyMiddleware: Middleware {
    public let id: String = "ListWebsiteAuthorizationProvidersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWebsiteAuthorizationProvidersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWebsiteAuthorizationProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWebsiteAuthorizationProvidersInput>
    public typealias MOutput = OperationOutput<ListWebsiteAuthorizationProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWebsiteAuthorizationProvidersOutputError>
}

extension ListWebsiteAuthorizationProvidersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWebsiteAuthorizationProvidersInput(fleetArn: \(String(describing: fleetArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListWebsiteAuthorizationProvidersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListWebsiteAuthorizationProvidersInputHeadersMiddleware: Middleware {
    public let id: String = "ListWebsiteAuthorizationProvidersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWebsiteAuthorizationProvidersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWebsiteAuthorizationProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWebsiteAuthorizationProvidersInput>
    public typealias MOutput = OperationOutput<ListWebsiteAuthorizationProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWebsiteAuthorizationProvidersOutputError>
}

public struct ListWebsiteAuthorizationProvidersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWebsiteAuthorizationProvidersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWebsiteAuthorizationProvidersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWebsiteAuthorizationProvidersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWebsiteAuthorizationProvidersInput>
    public typealias MOutput = OperationOutput<ListWebsiteAuthorizationProvidersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWebsiteAuthorizationProvidersOutputError>
}

public struct ListWebsiteAuthorizationProvidersInput: Equatable {
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?
    /// <p>The maximum number of results to be included in the next page.</p>
    public let maxResults: Int?
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?

    public init (
        fleetArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWebsiteAuthorizationProvidersInputBody: Equatable {
    public let fleetArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListWebsiteAuthorizationProvidersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWebsiteAuthorizationProvidersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWebsiteAuthorizationProvidersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWebsiteAuthorizationProvidersOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWebsiteAuthorizationProvidersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWebsiteAuthorizationProvidersOutputResponse(nextToken: \(String(describing: nextToken)), websiteAuthorizationProviders: \(String(describing: websiteAuthorizationProviders)))"}
}

extension ListWebsiteAuthorizationProvidersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListWebsiteAuthorizationProvidersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.websiteAuthorizationProviders = output.websiteAuthorizationProviders
        } else {
            self.nextToken = nil
            self.websiteAuthorizationProviders = nil
        }
    }
}

public struct ListWebsiteAuthorizationProvidersOutputResponse: Equatable {
    /// <p>The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.</p>
    public let nextToken: String?
    /// <p>The website authorization providers.</p>
    public let websiteAuthorizationProviders: [WebsiteAuthorizationProviderSummary]?

    public init (
        nextToken: String? = nil,
        websiteAuthorizationProviders: [WebsiteAuthorizationProviderSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.websiteAuthorizationProviders = websiteAuthorizationProviders
    }
}

struct ListWebsiteAuthorizationProvidersOutputResponseBody: Equatable {
    public let websiteAuthorizationProviders: [WebsiteAuthorizationProviderSummary]?
    public let nextToken: String?
}

extension ListWebsiteAuthorizationProvidersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case websiteAuthorizationProviders = "WebsiteAuthorizationProviders"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websiteAuthorizationProvidersContainer = try containerValues.decodeIfPresent([WebsiteAuthorizationProviderSummary?].self, forKey: .websiteAuthorizationProviders)
        var websiteAuthorizationProvidersDecoded0:[WebsiteAuthorizationProviderSummary]? = nil
        if let websiteAuthorizationProvidersContainer = websiteAuthorizationProvidersContainer {
            websiteAuthorizationProvidersDecoded0 = [WebsiteAuthorizationProviderSummary]()
            for structure0 in websiteAuthorizationProvidersContainer {
                if let structure0 = structure0 {
                    websiteAuthorizationProvidersDecoded0?.append(structure0)
                }
            }
        }
        websiteAuthorizationProviders = websiteAuthorizationProvidersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListWebsiteCertificateAuthoritiesInputBodyMiddleware: Middleware {
    public let id: String = "ListWebsiteCertificateAuthoritiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWebsiteCertificateAuthoritiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWebsiteCertificateAuthoritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWebsiteCertificateAuthoritiesInput>
    public typealias MOutput = OperationOutput<ListWebsiteCertificateAuthoritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWebsiteCertificateAuthoritiesOutputError>
}

extension ListWebsiteCertificateAuthoritiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWebsiteCertificateAuthoritiesInput(fleetArn: \(String(describing: fleetArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListWebsiteCertificateAuthoritiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListWebsiteCertificateAuthoritiesInputHeadersMiddleware: Middleware {
    public let id: String = "ListWebsiteCertificateAuthoritiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWebsiteCertificateAuthoritiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWebsiteCertificateAuthoritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWebsiteCertificateAuthoritiesInput>
    public typealias MOutput = OperationOutput<ListWebsiteCertificateAuthoritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWebsiteCertificateAuthoritiesOutputError>
}

public struct ListWebsiteCertificateAuthoritiesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWebsiteCertificateAuthoritiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWebsiteCertificateAuthoritiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWebsiteCertificateAuthoritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWebsiteCertificateAuthoritiesInput>
    public typealias MOutput = OperationOutput<ListWebsiteCertificateAuthoritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWebsiteCertificateAuthoritiesOutputError>
}

public struct ListWebsiteCertificateAuthoritiesInput: Equatable {
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?
    /// <p>The maximum number of results to be included in the next page.</p>
    public let maxResults: Int?
    /// <p>The pagination token used to retrieve the next page of results for this operation. If
    ///             this value is null, it retrieves the first page.</p>
    public let nextToken: String?

    public init (
        fleetArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWebsiteCertificateAuthoritiesInputBody: Equatable {
    public let fleetArn: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListWebsiteCertificateAuthoritiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWebsiteCertificateAuthoritiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWebsiteCertificateAuthoritiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWebsiteCertificateAuthoritiesOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWebsiteCertificateAuthoritiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWebsiteCertificateAuthoritiesOutputResponse(nextToken: \(String(describing: nextToken)), websiteCertificateAuthorities: \(String(describing: websiteCertificateAuthorities)))"}
}

extension ListWebsiteCertificateAuthoritiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListWebsiteCertificateAuthoritiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.websiteCertificateAuthorities = output.websiteCertificateAuthorities
        } else {
            self.nextToken = nil
            self.websiteCertificateAuthorities = nil
        }
    }
}

public struct ListWebsiteCertificateAuthoritiesOutputResponse: Equatable {
    /// <p>The pagination token used to retrieve the next page of results for this operation. If
    ///             there are no more pages, this value is null.</p>
    public let nextToken: String?
    /// <p>Information about the certificates.</p>
    public let websiteCertificateAuthorities: [WebsiteCaSummary]?

    public init (
        nextToken: String? = nil,
        websiteCertificateAuthorities: [WebsiteCaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.websiteCertificateAuthorities = websiteCertificateAuthorities
    }
}

struct ListWebsiteCertificateAuthoritiesOutputResponseBody: Equatable {
    public let websiteCertificateAuthorities: [WebsiteCaSummary]?
    public let nextToken: String?
}

extension ListWebsiteCertificateAuthoritiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case websiteCertificateAuthorities = "WebsiteCertificateAuthorities"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websiteCertificateAuthoritiesContainer = try containerValues.decodeIfPresent([WebsiteCaSummary?].self, forKey: .websiteCertificateAuthorities)
        var websiteCertificateAuthoritiesDecoded0:[WebsiteCaSummary]? = nil
        if let websiteCertificateAuthoritiesContainer = websiteCertificateAuthoritiesContainer {
            websiteCertificateAuthoritiesDecoded0 = [WebsiteCaSummary]()
            for structure0 in websiteCertificateAuthoritiesContainer {
                if let structure0 = structure0 {
                    websiteCertificateAuthoritiesDecoded0?.append(structure0)
                }
            }
        }
        websiteCertificateAuthorities = websiteCertificateAuthoritiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource already exists.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RestoreDomainAccessInputBodyMiddleware: Middleware {
    public let id: String = "RestoreDomainAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDomainAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDomainAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDomainAccessInput>
    public typealias MOutput = OperationOutput<RestoreDomainAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDomainAccessOutputError>
}

extension RestoreDomainAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreDomainAccessInput(domainName: \(String(describing: domainName)), fleetArn: \(String(describing: fleetArn)))"}
}

extension RestoreDomainAccessInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct RestoreDomainAccessInputHeadersMiddleware: Middleware {
    public let id: String = "RestoreDomainAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDomainAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDomainAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDomainAccessInput>
    public typealias MOutput = OperationOutput<RestoreDomainAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDomainAccessOutputError>
}

public struct RestoreDomainAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreDomainAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreDomainAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreDomainAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreDomainAccessInput>
    public typealias MOutput = OperationOutput<RestoreDomainAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreDomainAccessOutputError>
}

public struct RestoreDomainAccessInput: Equatable {
    /// <p>The name of the domain.</p>
    public let domainName: String?
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?

    public init (
        domainName: String? = nil,
        fleetArn: String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct RestoreDomainAccessInputBody: Equatable {
    public let fleetArn: String?
    public let domainName: String?
}

extension RestoreDomainAccessInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension RestoreDomainAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreDomainAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreDomainAccessOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreDomainAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreDomainAccessOutputResponse()"}
}

extension RestoreDomainAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RestoreDomainAccessOutputResponse: Equatable {

    public init() {}
}

struct RestoreDomainAccessOutputResponseBody: Equatable {
}

extension RestoreDomainAccessOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RevokeDomainAccessInputBodyMiddleware: Middleware {
    public let id: String = "RevokeDomainAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeDomainAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeDomainAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeDomainAccessInput>
    public typealias MOutput = OperationOutput<RevokeDomainAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeDomainAccessOutputError>
}

extension RevokeDomainAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeDomainAccessInput(domainName: \(String(describing: domainName)), fleetArn: \(String(describing: fleetArn)))"}
}

extension RevokeDomainAccessInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct RevokeDomainAccessInputHeadersMiddleware: Middleware {
    public let id: String = "RevokeDomainAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeDomainAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeDomainAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeDomainAccessInput>
    public typealias MOutput = OperationOutput<RevokeDomainAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeDomainAccessOutputError>
}

public struct RevokeDomainAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "RevokeDomainAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RevokeDomainAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<RevokeDomainAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RevokeDomainAccessInput>
    public typealias MOutput = OperationOutput<RevokeDomainAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RevokeDomainAccessOutputError>
}

public struct RevokeDomainAccessInput: Equatable {
    /// <p>The name of the domain.</p>
    public let domainName: String?
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?

    public init (
        domainName: String? = nil,
        fleetArn: String? = nil
    )
    {
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct RevokeDomainAccessInputBody: Equatable {
    public let fleetArn: String?
    public let domainName: String?
}

extension RevokeDomainAccessInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension RevokeDomainAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RevokeDomainAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeDomainAccessOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeDomainAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RevokeDomainAccessOutputResponse()"}
}

extension RevokeDomainAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RevokeDomainAccessOutputResponse: Equatable {

    public init() {}
}

struct RevokeDomainAccessOutputResponseBody: Equatable {
}

extension RevokeDomainAccessOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SignOutUserInputBodyMiddleware: Middleware {
    public let id: String = "SignOutUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SignOutUserInput>,
                  next: H) -> Swift.Result<OperationOutput<SignOutUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SignOutUserInput>
    public typealias MOutput = OperationOutput<SignOutUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SignOutUserOutputError>
}

extension SignOutUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SignOutUserInput(fleetArn: \(String(describing: fleetArn)), username: \(String(describing: username)))"}
}

extension SignOutUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

public struct SignOutUserInputHeadersMiddleware: Middleware {
    public let id: String = "SignOutUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SignOutUserInput>,
                  next: H) -> Swift.Result<OperationOutput<SignOutUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SignOutUserInput>
    public typealias MOutput = OperationOutput<SignOutUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SignOutUserOutputError>
}

public struct SignOutUserInputQueryItemMiddleware: Middleware {
    public let id: String = "SignOutUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SignOutUserInput>,
                  next: H) -> Swift.Result<OperationOutput<SignOutUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SignOutUserInput>
    public typealias MOutput = OperationOutput<SignOutUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SignOutUserOutputError>
}

public struct SignOutUserInput: Equatable {
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?
    /// <p>The name of the user.</p>
    public let username: String?

    public init (
        fleetArn: String? = nil,
        username: String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.username = username
    }
}

struct SignOutUserInputBody: Equatable {
    public let fleetArn: String?
    public let username: String?
}

extension SignOutUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
        case username = "Username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension SignOutUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SignOutUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SignOutUserOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SignOutUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SignOutUserOutputResponse()"}
}

extension SignOutUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SignOutUserOutputResponse: Equatable {

    public init() {}
}

struct SignOutUserOutputResponseBody: Equatable {
}

extension SignOutUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let resourceArn: String?
    /// <p>The tags to add to the resource. A tag is a key-value pair.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of requests exceeds the limit.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedException(message: \(String(describing: message)))"}
}

extension UnauthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You are not authorized to perform this action.</p>
public struct UnauthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Equatable {
    public let message: String?
}

extension UnauthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the fleet.</p>
    public let resourceArn: String?
    /// <p>The list of tag keys to remove from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAuditStreamConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAuditStreamConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAuditStreamConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAuditStreamConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAuditStreamConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateAuditStreamConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAuditStreamConfigurationOutputError>
}

extension UpdateAuditStreamConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAuditStreamConfigurationInput(auditStreamArn: \(String(describing: auditStreamArn)), fleetArn: \(String(describing: fleetArn)))"}
}

extension UpdateAuditStreamConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case auditStreamArn = "AuditStreamArn"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditStreamArn = auditStreamArn {
            try encodeContainer.encode(auditStreamArn, forKey: .auditStreamArn)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct UpdateAuditStreamConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAuditStreamConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAuditStreamConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAuditStreamConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAuditStreamConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateAuditStreamConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAuditStreamConfigurationOutputError>
}

public struct UpdateAuditStreamConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAuditStreamConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAuditStreamConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAuditStreamConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAuditStreamConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateAuditStreamConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAuditStreamConfigurationOutputError>
}

public struct UpdateAuditStreamConfigurationInput: Equatable {
    /// <p>The ARN of the Amazon Kinesis data stream that receives the audit events.</p>
    public let auditStreamArn: String?
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?

    public init (
        auditStreamArn: String? = nil,
        fleetArn: String? = nil
    )
    {
        self.auditStreamArn = auditStreamArn
        self.fleetArn = fleetArn
    }
}

struct UpdateAuditStreamConfigurationInputBody: Equatable {
    public let fleetArn: String?
    public let auditStreamArn: String?
}

extension UpdateAuditStreamConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case auditStreamArn = "AuditStreamArn"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let auditStreamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .auditStreamArn)
        auditStreamArn = auditStreamArnDecoded
    }
}

extension UpdateAuditStreamConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAuditStreamConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAuditStreamConfigurationOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAuditStreamConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAuditStreamConfigurationOutputResponse()"}
}

extension UpdateAuditStreamConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAuditStreamConfigurationOutputResponse: Equatable {

    public init() {}
}

struct UpdateAuditStreamConfigurationOutputResponseBody: Equatable {
}

extension UpdateAuditStreamConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateCompanyNetworkConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCompanyNetworkConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCompanyNetworkConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCompanyNetworkConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCompanyNetworkConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateCompanyNetworkConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCompanyNetworkConfigurationOutputError>
}

extension UpdateCompanyNetworkConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCompanyNetworkConfigurationInput(fleetArn: \(String(describing: fleetArn)), securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)), vpcId: \(String(describing: vpcId)))"}
}

extension UpdateCompanyNetworkConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

public struct UpdateCompanyNetworkConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCompanyNetworkConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCompanyNetworkConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCompanyNetworkConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCompanyNetworkConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateCompanyNetworkConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCompanyNetworkConfigurationOutputError>
}

public struct UpdateCompanyNetworkConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCompanyNetworkConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCompanyNetworkConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCompanyNetworkConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCompanyNetworkConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateCompanyNetworkConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCompanyNetworkConfigurationOutputError>
}

public struct UpdateCompanyNetworkConfigurationInput: Equatable {
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?
    /// <p>The security groups associated with access to the provided subnets.</p>
    public let securityGroupIds: [String]?
    /// <p>The subnets used for X-ENI connections from Amazon WorkLink rendering containers.</p>
    public let subnetIds: [String]?
    /// <p>The VPC with connectivity to associated websites.</p>
    public let vpcId: String?

    public init (
        fleetArn: String? = nil,
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil,
        vpcId: String? = nil
    )
    {
        self.fleetArn = fleetArn
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

struct UpdateCompanyNetworkConfigurationInputBody: Equatable {
    public let fleetArn: String?
    public let vpcId: String?
    public let subnetIds: [String]?
    public let securityGroupIds: [String]?
}

extension UpdateCompanyNetworkConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension UpdateCompanyNetworkConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCompanyNetworkConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCompanyNetworkConfigurationOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCompanyNetworkConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCompanyNetworkConfigurationOutputResponse()"}
}

extension UpdateCompanyNetworkConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateCompanyNetworkConfigurationOutputResponse: Equatable {

    public init() {}
}

struct UpdateCompanyNetworkConfigurationOutputResponseBody: Equatable {
}

extension UpdateCompanyNetworkConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDevicePolicyConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDevicePolicyConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDevicePolicyConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDevicePolicyConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDevicePolicyConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateDevicePolicyConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDevicePolicyConfigurationOutputError>
}

extension UpdateDevicePolicyConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDevicePolicyConfigurationInput(deviceCaCertificate: \(String(describing: deviceCaCertificate)), fleetArn: \(String(describing: fleetArn)))"}
}

extension UpdateDevicePolicyConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceCaCertificate = "DeviceCaCertificate"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceCaCertificate = deviceCaCertificate {
            try encodeContainer.encode(deviceCaCertificate, forKey: .deviceCaCertificate)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct UpdateDevicePolicyConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDevicePolicyConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDevicePolicyConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDevicePolicyConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDevicePolicyConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateDevicePolicyConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDevicePolicyConfigurationOutputError>
}

public struct UpdateDevicePolicyConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDevicePolicyConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDevicePolicyConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDevicePolicyConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDevicePolicyConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateDevicePolicyConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDevicePolicyConfigurationOutputError>
}

public struct UpdateDevicePolicyConfigurationInput: Equatable {
    /// <p>The certificate chain, including intermediate certificates and the root certificate authority certificate used to issue device certificates.</p>
    public let deviceCaCertificate: String?
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?

    public init (
        deviceCaCertificate: String? = nil,
        fleetArn: String? = nil
    )
    {
        self.deviceCaCertificate = deviceCaCertificate
        self.fleetArn = fleetArn
    }
}

struct UpdateDevicePolicyConfigurationInputBody: Equatable {
    public let fleetArn: String?
    public let deviceCaCertificate: String?
}

extension UpdateDevicePolicyConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceCaCertificate = "DeviceCaCertificate"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let deviceCaCertificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceCaCertificate)
        deviceCaCertificate = deviceCaCertificateDecoded
    }
}

extension UpdateDevicePolicyConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDevicePolicyConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDevicePolicyConfigurationOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDevicePolicyConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDevicePolicyConfigurationOutputResponse()"}
}

extension UpdateDevicePolicyConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDevicePolicyConfigurationOutputResponse: Equatable {

    public init() {}
}

struct UpdateDevicePolicyConfigurationOutputResponseBody: Equatable {
}

extension UpdateDevicePolicyConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDomainMetadataInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDomainMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainMetadataInput>
    public typealias MOutput = OperationOutput<UpdateDomainMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainMetadataOutputError>
}

extension UpdateDomainMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainMetadataInput(displayName: \(String(describing: displayName)), domainName: \(String(describing: domainName)), fleetArn: \(String(describing: fleetArn)))"}
}

extension UpdateDomainMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
    }
}

public struct UpdateDomainMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDomainMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainMetadataInput>
    public typealias MOutput = OperationOutput<UpdateDomainMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainMetadataOutputError>
}

public struct UpdateDomainMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDomainMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDomainMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDomainMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDomainMetadataInput>
    public typealias MOutput = OperationOutput<UpdateDomainMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDomainMetadataOutputError>
}

public struct UpdateDomainMetadataInput: Equatable {
    /// <p>The name to display.</p>
    public let displayName: String?
    /// <p>The name of the domain.</p>
    public let domainName: String?
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?

    public init (
        displayName: String? = nil,
        domainName: String? = nil,
        fleetArn: String? = nil
    )
    {
        self.displayName = displayName
        self.domainName = domainName
        self.fleetArn = fleetArn
    }
}

struct UpdateDomainMetadataInputBody: Equatable {
    public let fleetArn: String?
    public let domainName: String?
    public let displayName: String?
}

extension UpdateDomainMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case displayName = "DisplayName"
        case domainName = "DomainName"
        case fleetArn = "FleetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension UpdateDomainMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDomainMetadataOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDomainMetadataOutputResponse()"}
}

extension UpdateDomainMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDomainMetadataOutputResponse: Equatable {

    public init() {}
}

struct UpdateDomainMetadataOutputResponseBody: Equatable {
}

extension UpdateDomainMetadataOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateFleetMetadataInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFleetMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFleetMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFleetMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFleetMetadataInput>
    public typealias MOutput = OperationOutput<UpdateFleetMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFleetMetadataOutputError>
}

extension UpdateFleetMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFleetMetadataInput(displayName: \(String(describing: displayName)), fleetArn: \(String(describing: fleetArn)), optimizeForEndUserLocation: \(String(describing: optimizeForEndUserLocation)))"}
}

extension UpdateFleetMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let optimizeForEndUserLocation = optimizeForEndUserLocation {
            try encodeContainer.encode(optimizeForEndUserLocation, forKey: .optimizeForEndUserLocation)
        }
    }
}

public struct UpdateFleetMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFleetMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFleetMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFleetMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFleetMetadataInput>
    public typealias MOutput = OperationOutput<UpdateFleetMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFleetMetadataOutputError>
}

public struct UpdateFleetMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFleetMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFleetMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFleetMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFleetMetadataInput>
    public typealias MOutput = OperationOutput<UpdateFleetMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFleetMetadataOutputError>
}

public struct UpdateFleetMetadataInput: Equatable {
    /// <p>The fleet name to display. The existing DisplayName is unset if null is passed.</p>
    public let displayName: String?
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?
    /// <p>The option to optimize for better performance by routing traffic through the closest
    ///             AWS Region to users, which may be outside of your home Region.</p>
    public let optimizeForEndUserLocation: Bool?

    public init (
        displayName: String? = nil,
        fleetArn: String? = nil,
        optimizeForEndUserLocation: Bool? = nil
    )
    {
        self.displayName = displayName
        self.fleetArn = fleetArn
        self.optimizeForEndUserLocation = optimizeForEndUserLocation
    }
}

struct UpdateFleetMetadataInputBody: Equatable {
    public let fleetArn: String?
    public let displayName: String?
    public let optimizeForEndUserLocation: Bool?
}

extension UpdateFleetMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case displayName = "DisplayName"
        case fleetArn = "FleetArn"
        case optimizeForEndUserLocation = "OptimizeForEndUserLocation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let optimizeForEndUserLocationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .optimizeForEndUserLocation)
        optimizeForEndUserLocation = optimizeForEndUserLocationDecoded
    }
}

extension UpdateFleetMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFleetMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFleetMetadataOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFleetMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFleetMetadataOutputResponse()"}
}

extension UpdateFleetMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFleetMetadataOutputResponse: Equatable {

    public init() {}
}

struct UpdateFleetMetadataOutputResponseBody: Equatable {
}

extension UpdateFleetMetadataOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateIdentityProviderConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateIdentityProviderConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIdentityProviderConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIdentityProviderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIdentityProviderConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateIdentityProviderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIdentityProviderConfigurationOutputError>
}

extension UpdateIdentityProviderConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIdentityProviderConfigurationInput(fleetArn: \(String(describing: fleetArn)), identityProviderSamlMetadata: \(String(describing: identityProviderSamlMetadata)), identityProviderType: \(String(describing: identityProviderType)))"}
}

extension UpdateIdentityProviderConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
        case identityProviderSamlMetadata = "IdentityProviderSamlMetadata"
        case identityProviderType = "IdentityProviderType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetArn = fleetArn {
            try encodeContainer.encode(fleetArn, forKey: .fleetArn)
        }
        if let identityProviderSamlMetadata = identityProviderSamlMetadata {
            try encodeContainer.encode(identityProviderSamlMetadata, forKey: .identityProviderSamlMetadata)
        }
        if let identityProviderType = identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
    }
}

public struct UpdateIdentityProviderConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateIdentityProviderConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIdentityProviderConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIdentityProviderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIdentityProviderConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateIdentityProviderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIdentityProviderConfigurationOutputError>
}

public struct UpdateIdentityProviderConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateIdentityProviderConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIdentityProviderConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIdentityProviderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIdentityProviderConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateIdentityProviderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIdentityProviderConfigurationOutputError>
}

public struct UpdateIdentityProviderConfigurationInput: Equatable {
    /// <p>The ARN of the fleet.</p>
    public let fleetArn: String?
    /// <p>The SAML metadata document provided by the customer’s identity provider. The existing
    ///             IdentityProviderSamlMetadata is unset if null is passed.</p>
    public let identityProviderSamlMetadata: String?
    /// <p>The type of identity provider.</p>
    public let identityProviderType: IdentityProviderType?

    public init (
        fleetArn: String? = nil,
        identityProviderSamlMetadata: String? = nil,
        identityProviderType: IdentityProviderType? = nil
    )
    {
        self.fleetArn = fleetArn
        self.identityProviderSamlMetadata = identityProviderSamlMetadata
        self.identityProviderType = identityProviderType
    }
}

struct UpdateIdentityProviderConfigurationInputBody: Equatable {
    public let fleetArn: String?
    public let identityProviderType: IdentityProviderType?
    public let identityProviderSamlMetadata: String?
}

extension UpdateIdentityProviderConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetArn = "FleetArn"
        case identityProviderSamlMetadata = "IdentityProviderSamlMetadata"
        case identityProviderType = "IdentityProviderType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetArn)
        fleetArn = fleetArnDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let identityProviderSamlMetadataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityProviderSamlMetadata)
        identityProviderSamlMetadata = identityProviderSamlMetadataDecoded
    }
}

extension UpdateIdentityProviderConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIdentityProviderConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIdentityProviderConfigurationOutputError: Equatable {
    case internalServerErrorException(InternalServerErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIdentityProviderConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIdentityProviderConfigurationOutputResponse()"}
}

extension UpdateIdentityProviderConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateIdentityProviderConfigurationOutputResponse: Equatable {

    public init() {}
}

struct UpdateIdentityProviderConfigurationOutputResponseBody: Equatable {
}

extension UpdateIdentityProviderConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension WebsiteAuthorizationProviderSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizationProviderId = "AuthorizationProviderId"
        case authorizationProviderType = "AuthorizationProviderType"
        case createdTime = "CreatedTime"
        case domainName = "DomainName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationProviderId = authorizationProviderId {
            try encodeContainer.encode(authorizationProviderId, forKey: .authorizationProviderId)
        }
        if let authorizationProviderType = authorizationProviderType {
            try encodeContainer.encode(authorizationProviderType.rawValue, forKey: .authorizationProviderType)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationProviderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizationProviderId)
        authorizationProviderId = authorizationProviderIdDecoded
        let authorizationProviderTypeDecoded = try containerValues.decodeIfPresent(AuthorizationProviderType.self, forKey: .authorizationProviderType)
        authorizationProviderType = authorizationProviderTypeDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension WebsiteAuthorizationProviderSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WebsiteAuthorizationProviderSummary(authorizationProviderId: \(String(describing: authorizationProviderId)), authorizationProviderType: \(String(describing: authorizationProviderType)), createdTime: \(String(describing: createdTime)), domainName: \(String(describing: domainName)))"}
}

/// <p>The summary of the website authorization provider.</p>
public struct WebsiteAuthorizationProviderSummary: Equatable {
    /// <p>A unique identifier for the authorization provider.</p>
    public let authorizationProviderId: String?
    /// <p>The authorization provider type.</p>
    public let authorizationProviderType: AuthorizationProviderType?
    /// <p>The time of creation.</p>
    public let createdTime: Date?
    /// <p>The domain name of the authorization provider. This applies only to SAML-based
    ///             authorization providers.</p>
    public let domainName: String?

    public init (
        authorizationProviderId: String? = nil,
        authorizationProviderType: AuthorizationProviderType? = nil,
        createdTime: Date? = nil,
        domainName: String? = nil
    )
    {
        self.authorizationProviderId = authorizationProviderId
        self.authorizationProviderType = authorizationProviderType
        self.createdTime = createdTime
        self.domainName = domainName
    }
}

extension WebsiteCaSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case displayName = "DisplayName"
        case websiteCaId = "WebsiteCaId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let websiteCaId = websiteCaId {
            try encodeContainer.encode(websiteCaId, forKey: .websiteCaId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websiteCaIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .websiteCaId)
        websiteCaId = websiteCaIdDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension WebsiteCaSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WebsiteCaSummary(createdTime: \(String(describing: createdTime)), displayName: \(String(describing: displayName)), websiteCaId: \(String(describing: websiteCaId)))"}
}

/// <p>The summary of the certificate authority (CA).</p>
public struct WebsiteCaSummary: Equatable {
    /// <p>The time when the CA was added.</p>
    public let createdTime: Date?
    /// <p>The name to display.</p>
    public let displayName: String?
    /// <p>A unique identifier for the CA.</p>
    public let websiteCaId: String?

    public init (
        createdTime: Date? = nil,
        displayName: String? = nil,
        websiteCaId: String? = nil
    )
    {
        self.createdTime = createdTime
        self.displayName = displayName
        self.websiteCaId = websiteCaId
    }
}
