// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AuthException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthException(message: \(String(describing: message)))"}
}

extension AuthException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AuthExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Either your AWS credentials are not valid or you do not have access to the EC2 instance.</p>
public struct AuthException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AuthExceptionBody: Equatable {
    public let message: String?
}

extension AuthExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EC2InstanceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EC2InstanceNotFoundException(message: \(String(describing: message)))"}
}

extension EC2InstanceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EC2InstanceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified instance was not found.</p>
public struct EC2InstanceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EC2InstanceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension EC2InstanceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EC2InstanceTypeInvalidException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EC2InstanceTypeInvalidException(message: \(String(describing: message)))"}
}

extension EC2InstanceTypeInvalidException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EC2InstanceTypeInvalidExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The instance type is not supported for connecting via the serial console. Only Nitro
///             instance types are currently supported.</p>
public struct EC2InstanceTypeInvalidException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EC2InstanceTypeInvalidExceptionBody: Equatable {
    public let message: String?
}

extension EC2InstanceTypeInvalidExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidArgsException(message: \(String(describing: message)))"}
}

extension InvalidArgsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidArgsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One of the parameters is not valid.</p>
public struct InvalidArgsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgsExceptionBody: Equatable {
    public let message: String?
}

extension InvalidArgsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SendSSHPublicKeyInputBodyMiddleware: Middleware {
    public let id: String = "SendSSHPublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendSSHPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<SendSSHPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendSSHPublicKeyInput>
    public typealias MOutput = OperationOutput<SendSSHPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendSSHPublicKeyOutputError>
}

extension SendSSHPublicKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendSSHPublicKeyInput(availabilityZone: \(String(describing: availabilityZone)), instanceId: \(String(describing: instanceId)), instanceOSUser: \(String(describing: instanceOSUser)), sSHPublicKey: \(String(describing: sSHPublicKey)))"}
}

extension SendSSHPublicKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case instanceId = "InstanceId"
        case instanceOSUser = "InstanceOSUser"
        case sSHPublicKey = "SSHPublicKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceOSUser = instanceOSUser {
            try encodeContainer.encode(instanceOSUser, forKey: .instanceOSUser)
        }
        if let sSHPublicKey = sSHPublicKey {
            try encodeContainer.encode(sSHPublicKey, forKey: .sSHPublicKey)
        }
    }
}

public struct SendSSHPublicKeyInputHeadersMiddleware: Middleware {
    public let id: String = "SendSSHPublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendSSHPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<SendSSHPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendSSHPublicKeyInput>
    public typealias MOutput = OperationOutput<SendSSHPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendSSHPublicKeyOutputError>
}

public struct SendSSHPublicKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "SendSSHPublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendSSHPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<SendSSHPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendSSHPublicKeyInput>
    public typealias MOutput = OperationOutput<SendSSHPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendSSHPublicKeyOutputError>
}

public struct SendSSHPublicKeyInput: Equatable {
    /// <p>The Availability Zone in which the EC2 instance was launched.</p>
    public let availabilityZone: String?
    /// <p>The ID of the EC2 instance.</p>
    public let instanceId: String?
    /// <p>The OS user on the EC2 instance for whom the key can be used to authenticate.</p>
    public let instanceOSUser: String?
    /// <p>The public key material. To use the public key, you must have the matching private key.</p>
    public let sSHPublicKey: String?

    public init (
        availabilityZone: String? = nil,
        instanceId: String? = nil,
        instanceOSUser: String? = nil,
        sSHPublicKey: String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.instanceId = instanceId
        self.instanceOSUser = instanceOSUser
        self.sSHPublicKey = sSHPublicKey
    }
}

struct SendSSHPublicKeyInputBody: Equatable {
    public let instanceId: String?
    public let instanceOSUser: String?
    public let sSHPublicKey: String?
    public let availabilityZone: String?
}

extension SendSSHPublicKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case instanceId = "InstanceId"
        case instanceOSUser = "InstanceOSUser"
        case sSHPublicKey = "SSHPublicKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceOSUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceOSUser)
        instanceOSUser = instanceOSUserDecoded
        let sSHPublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sSHPublicKey)
        sSHPublicKey = sSHPublicKeyDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
    }
}

extension SendSSHPublicKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendSSHPublicKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthException" : self = .authException(try AuthException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EC2InstanceNotFoundException" : self = .eC2InstanceNotFoundException(try EC2InstanceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgsException" : self = .invalidArgsException(try InvalidArgsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendSSHPublicKeyOutputError: Equatable {
    case authException(AuthException)
    case eC2InstanceNotFoundException(EC2InstanceNotFoundException)
    case invalidArgsException(InvalidArgsException)
    case serviceException(ServiceException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendSSHPublicKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendSSHPublicKeyOutputResponse(requestId: \(String(describing: requestId)), success: \(String(describing: success)))"}
}

extension SendSSHPublicKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendSSHPublicKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
            self.success = output.success
        } else {
            self.requestId = nil
            self.success = false
        }
    }
}

public struct SendSSHPublicKeyOutputResponse: Equatable {
    /// <p>The ID of the request. Please provide this ID when contacting AWS Support for assistance.</p>
    public let requestId: String?
    /// <p>Is true if the request succeeds and an error otherwise.</p>
    public let success: Bool

    public init (
        requestId: String? = nil,
        success: Bool = false
    )
    {
        self.requestId = requestId
        self.success = success
    }
}

struct SendSSHPublicKeyOutputResponseBody: Equatable {
    public let requestId: String?
    public let success: Bool
}

extension SendSSHPublicKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case success = "Success"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let successDecoded = try containerValues.decode(Bool.self, forKey: .success)
        success = successDecoded
    }
}

public struct SendSerialConsoleSSHPublicKeyInputBodyMiddleware: Middleware {
    public let id: String = "SendSerialConsoleSSHPublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendSerialConsoleSSHPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<SendSerialConsoleSSHPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendSerialConsoleSSHPublicKeyInput>
    public typealias MOutput = OperationOutput<SendSerialConsoleSSHPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendSerialConsoleSSHPublicKeyOutputError>
}

extension SendSerialConsoleSSHPublicKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendSerialConsoleSSHPublicKeyInput(instanceId: \(String(describing: instanceId)), sSHPublicKey: \(String(describing: sSHPublicKey)), serialPort: \(String(describing: serialPort)))"}
}

extension SendSerialConsoleSSHPublicKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case sSHPublicKey = "SSHPublicKey"
        case serialPort = "SerialPort"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let sSHPublicKey = sSHPublicKey {
            try encodeContainer.encode(sSHPublicKey, forKey: .sSHPublicKey)
        }
        if serialPort != 0 {
            try encodeContainer.encode(serialPort, forKey: .serialPort)
        }
    }
}

public struct SendSerialConsoleSSHPublicKeyInputHeadersMiddleware: Middleware {
    public let id: String = "SendSerialConsoleSSHPublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendSerialConsoleSSHPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<SendSerialConsoleSSHPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendSerialConsoleSSHPublicKeyInput>
    public typealias MOutput = OperationOutput<SendSerialConsoleSSHPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendSerialConsoleSSHPublicKeyOutputError>
}

public struct SendSerialConsoleSSHPublicKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "SendSerialConsoleSSHPublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendSerialConsoleSSHPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<SendSerialConsoleSSHPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendSerialConsoleSSHPublicKeyInput>
    public typealias MOutput = OperationOutput<SendSerialConsoleSSHPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendSerialConsoleSSHPublicKeyOutputError>
}

public struct SendSerialConsoleSSHPublicKeyInput: Equatable {
    /// <p>The ID of the EC2 instance.</p>
    public let instanceId: String?
    /// <p>The public key material. To use the public key, you must have the matching private
    ///             key. For information about the supported key formats and lengths, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html#how-to-generate-your-own-key-and-import-it-to-aws">Requirements for key pairs</a> in the <i>Amazon EC2 User
    ///             Guide</i>.</p>
    public let sSHPublicKey: String?
    /// <p>The serial port of the EC2 instance. Currently only port 0 is supported.</p>
    ///         <p>Default: 0</p>
    public let serialPort: Int

    public init (
        instanceId: String? = nil,
        sSHPublicKey: String? = nil,
        serialPort: Int = 0
    )
    {
        self.instanceId = instanceId
        self.sSHPublicKey = sSHPublicKey
        self.serialPort = serialPort
    }
}

struct SendSerialConsoleSSHPublicKeyInputBody: Equatable {
    public let instanceId: String?
    public let serialPort: Int
    public let sSHPublicKey: String?
}

extension SendSerialConsoleSSHPublicKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case instanceId = "InstanceId"
        case sSHPublicKey = "SSHPublicKey"
        case serialPort = "SerialPort"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let serialPortDecoded = try containerValues.decode(Int.self, forKey: .serialPort)
        serialPort = serialPortDecoded
        let sSHPublicKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sSHPublicKey)
        sSHPublicKey = sSHPublicKeyDecoded
    }
}

extension SendSerialConsoleSSHPublicKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendSerialConsoleSSHPublicKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AuthException" : self = .authException(try AuthException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EC2InstanceNotFoundException" : self = .eC2InstanceNotFoundException(try EC2InstanceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EC2InstanceTypeInvalidException" : self = .eC2InstanceTypeInvalidException(try EC2InstanceTypeInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgsException" : self = .invalidArgsException(try InvalidArgsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SerialConsoleAccessDisabledException" : self = .serialConsoleAccessDisabledException(try SerialConsoleAccessDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SerialConsoleSessionLimitExceededException" : self = .serialConsoleSessionLimitExceededException(try SerialConsoleSessionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SerialConsoleSessionUnavailableException" : self = .serialConsoleSessionUnavailableException(try SerialConsoleSessionUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendSerialConsoleSSHPublicKeyOutputError: Equatable {
    case authException(AuthException)
    case eC2InstanceNotFoundException(EC2InstanceNotFoundException)
    case eC2InstanceTypeInvalidException(EC2InstanceTypeInvalidException)
    case invalidArgsException(InvalidArgsException)
    case serialConsoleAccessDisabledException(SerialConsoleAccessDisabledException)
    case serialConsoleSessionLimitExceededException(SerialConsoleSessionLimitExceededException)
    case serialConsoleSessionUnavailableException(SerialConsoleSessionUnavailableException)
    case serviceException(ServiceException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendSerialConsoleSSHPublicKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendSerialConsoleSSHPublicKeyOutputResponse(requestId: \(String(describing: requestId)), success: \(String(describing: success)))"}
}

extension SendSerialConsoleSSHPublicKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendSerialConsoleSSHPublicKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.requestId = output.requestId
            self.success = output.success
        } else {
            self.requestId = nil
            self.success = false
        }
    }
}

public struct SendSerialConsoleSSHPublicKeyOutputResponse: Equatable {
    /// <p>The ID of the request. Please provide this ID when contacting AWS Support for assistance.</p>
    public let requestId: String?
    /// <p>Is true if the request succeeds and an error otherwise.</p>
    public let success: Bool

    public init (
        requestId: String? = nil,
        success: Bool = false
    )
    {
        self.requestId = requestId
        self.success = success
    }
}

struct SendSerialConsoleSSHPublicKeyOutputResponseBody: Equatable {
    public let requestId: String?
    public let success: Bool
}

extension SendSerialConsoleSSHPublicKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case requestId = "RequestId"
        case success = "Success"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let successDecoded = try containerValues.decode(Bool.self, forKey: .success)
        success = successDecoded
    }
}

extension SerialConsoleAccessDisabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SerialConsoleAccessDisabledException(message: \(String(describing: message)))"}
}

extension SerialConsoleAccessDisabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SerialConsoleAccessDisabledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your account is not authorized to use the EC2 Serial Console. To authorize your
///             account, run the EnableSerialConsoleAccess API. For more information, see
///             <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_EnableSerialConsoleAccess.html">EnableSerialConsoleAccess</a> in the <i>Amazon EC2 API Reference</i>.</p>
public struct SerialConsoleAccessDisabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SerialConsoleAccessDisabledExceptionBody: Equatable {
    public let message: String?
}

extension SerialConsoleAccessDisabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SerialConsoleSessionLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SerialConsoleSessionLimitExceededException(message: \(String(describing: message)))"}
}

extension SerialConsoleSessionLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SerialConsoleSessionLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The instance currently has 1 active serial console session. Only 1 session is supported at a time.</p>
public struct SerialConsoleSessionLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SerialConsoleSessionLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension SerialConsoleSessionLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SerialConsoleSessionUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SerialConsoleSessionUnavailableException(message: \(String(describing: message)))"}
}

extension SerialConsoleSessionUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SerialConsoleSessionUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Unable to start a serial console session. Please try again.</p>
public struct SerialConsoleSessionUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SerialConsoleSessionUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension SerialConsoleSessionUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceException(message: \(String(describing: message)))"}
}

extension ServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service encountered an error. Follow the instructions in the error message and try again.</p>
public struct ServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceExceptionBody: Equatable {
    public let message: String?
}

extension ServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requests were made too frequently and have been throttled. Wait a while and try again.
///             To increase the limit on your request frequency, contact AWS Support.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
