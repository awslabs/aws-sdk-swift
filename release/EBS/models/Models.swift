// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)), reason: \(String(describing: reason)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The reason for the exception.</p>
    public var reason: AccessDeniedExceptionReason?

    public init (
        message: String? = nil,
        reason: AccessDeniedExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
    public let reason: AccessDeniedExceptionReason?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(AccessDeniedExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

public enum AccessDeniedExceptionReason {
    case dependencyAccessDenied
    case unauthorizedAccount
    case sdkUnknown(String)
}

extension AccessDeniedExceptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AccessDeniedExceptionReason] {
        return [
            .dependencyAccessDenied,
            .unauthorizedAccount,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dependencyAccessDenied: return "DEPENDENCY_ACCESS_DENIED"
        case .unauthorizedAccount: return "UNAUTHORIZED_ACCOUNT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AccessDeniedExceptionReason(rawValue: rawValue) ?? AccessDeniedExceptionReason.sdkUnknown(rawValue)
    }
}

extension Block: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockIndex = "BlockIndex"
        case blockToken = "BlockToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockIndex = blockIndex {
            try encodeContainer.encode(blockIndex, forKey: .blockIndex)
        }
        if let blockToken = blockToken {
            try encodeContainer.encode(blockToken, forKey: .blockToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockIndexDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .blockIndex)
        blockIndex = blockIndexDecoded
        let blockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .blockToken)
        blockToken = blockTokenDecoded
    }
}

extension Block: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Block(blockIndex: \(String(describing: blockIndex)), blockToken: \(String(describing: blockToken)))"}
}

/// <p>A block of data in an Amazon Elastic Block Store snapshot.</p>
public struct Block: Equatable {
    /// <p>The block index.</p>
    public let blockIndex: Int?
    /// <p>The block token for the block index.</p>
    public let blockToken: String?

    public init (
        blockIndex: Int? = nil,
        blockToken: String? = nil
    )
    {
        self.blockIndex = blockIndex
        self.blockToken = blockToken
    }
}

extension ChangedBlock: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockIndex = "BlockIndex"
        case firstBlockToken = "FirstBlockToken"
        case secondBlockToken = "SecondBlockToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockIndex = blockIndex {
            try encodeContainer.encode(blockIndex, forKey: .blockIndex)
        }
        if let firstBlockToken = firstBlockToken {
            try encodeContainer.encode(firstBlockToken, forKey: .firstBlockToken)
        }
        if let secondBlockToken = secondBlockToken {
            try encodeContainer.encode(secondBlockToken, forKey: .secondBlockToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockIndexDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .blockIndex)
        blockIndex = blockIndexDecoded
        let firstBlockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firstBlockToken)
        firstBlockToken = firstBlockTokenDecoded
        let secondBlockTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secondBlockToken)
        secondBlockToken = secondBlockTokenDecoded
    }
}

extension ChangedBlock: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

/// <p>A block of data in an Amazon Elastic Block Store snapshot that is different from another snapshot of
///             the same volume/snapshot lineage.</p>
public struct ChangedBlock: Equatable {
    /// <p>The block index.</p>
    public let blockIndex: Int?
    /// <p>The block token for the block index of the <code>FirstSnapshotId</code> specified in
    ///             the <code>ListChangedBlocks</code> operation. This value is absent if the first snapshot
    ///             does not have the changed block that is on the second snapshot.</p>
    public let firstBlockToken: String?
    /// <p>The block token for the block index of the <code>SecondSnapshotId</code> specified in
    ///             the <code>ListChangedBlocks</code> operation.</p>
    public let secondBlockToken: String?

    public init (
        blockIndex: Int? = nil,
        firstBlockToken: String? = nil,
        secondBlockToken: String? = nil
    )
    {
        self.blockIndex = blockIndex
        self.firstBlockToken = firstBlockToken
        self.secondBlockToken = secondBlockToken
    }
}

public enum ChecksumAggregationMethod {
    case checksumAggregationLinear
    case sdkUnknown(String)
}

extension ChecksumAggregationMethod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChecksumAggregationMethod] {
        return [
            .checksumAggregationLinear,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .checksumAggregationLinear: return "LINEAR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChecksumAggregationMethod(rawValue: rawValue) ?? ChecksumAggregationMethod.sdkUnknown(rawValue)
    }
}

public enum ChecksumAlgorithm {
    case checksumAlgorithmSha256
    case sdkUnknown(String)
}

extension ChecksumAlgorithm : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChecksumAlgorithm] {
        return [
            .checksumAlgorithmSha256,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .checksumAlgorithmSha256: return "SHA256"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChecksumAlgorithm(rawValue: rawValue) ?? ChecksumAlgorithm.sdkUnknown(rawValue)
    }
}

extension CompleteSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompleteSnapshotInput(changedBlocksCount: \(String(describing: changedBlocksCount)), checksum: \(String(describing: checksum)), checksumAggregationMethod: \(String(describing: checksumAggregationMethod)), checksumAlgorithm: \(String(describing: checksumAlgorithm)), snapshotId: \(String(describing: snapshotId)))"}
}

extension CompleteSnapshotInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CompleteSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "CompleteSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CompleteSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CompleteSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let changedBlocksCount = input.operationInput.changedBlocksCount {
            input.builder.withHeader(name: "x-amz-ChangedBlocksCount", value: String(changedBlocksCount))
        }
        if let checksum = input.operationInput.checksum {
            input.builder.withHeader(name: "x-amz-Checksum", value: String(checksum))
        }
        if let checksumAggregationMethod = input.operationInput.checksumAggregationMethod {
            input.builder.withHeader(name: "x-amz-Checksum-Aggregation-Method", value: String(checksumAggregationMethod.rawValue))
        }
        if let checksumAlgorithm = input.operationInput.checksumAlgorithm {
            input.builder.withHeader(name: "x-amz-Checksum-Algorithm", value: String(checksumAlgorithm.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CompleteSnapshotInput>
    public typealias MOutput = OperationOutput<CompleteSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CompleteSnapshotOutputError>
}

public struct CompleteSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "CompleteSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CompleteSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<CompleteSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CompleteSnapshotInput>
    public typealias MOutput = OperationOutput<CompleteSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CompleteSnapshotOutputError>
}

public struct CompleteSnapshotInput: Equatable {
    /// <p>The number of blocks that were written to the snapshot.</p>
    public let changedBlocksCount: Int?
    /// <p>An aggregated Base-64 SHA256 checksum based on the checksums of each written
    ///             block.</p>
    ///         <p>To generate the aggregated checksum using the linear aggregation method, arrange the
    ///             checksums for each written block in ascending order of their block index, concatenate
    ///             them to form a single string, and then generate the checksum on the entire string using
    ///             the SHA256 algorithm.</p>
    public let checksum: String?
    /// <p>The aggregation method used to generate the checksum. Currently, the only supported
    ///             aggregation method is <code>LINEAR</code>.</p>
    public let checksumAggregationMethod: ChecksumAggregationMethod?
    /// <p>The algorithm used to generate the checksum. Currently, the only supported algorithm
    ///             is <code>SHA256</code>.</p>
    public let checksumAlgorithm: ChecksumAlgorithm?
    /// <p>The ID of the snapshot.</p>
    public let snapshotId: String?

    public init (
        changedBlocksCount: Int? = nil,
        checksum: String? = nil,
        checksumAggregationMethod: ChecksumAggregationMethod? = nil,
        checksumAlgorithm: ChecksumAlgorithm? = nil,
        snapshotId: String? = nil
    )
    {
        self.changedBlocksCount = changedBlocksCount
        self.checksum = checksum
        self.checksumAggregationMethod = checksumAggregationMethod
        self.checksumAlgorithm = checksumAlgorithm
        self.snapshotId = snapshotId
    }
}

struct CompleteSnapshotInputBody: Equatable {
}

extension CompleteSnapshotInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CompleteSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CompleteSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestThrottledException" : self = .requestThrottledException(try RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CompleteSnapshotOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestThrottledException(RequestThrottledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CompleteSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompleteSnapshotOutputResponse(status: \(String(describing: status)))"}
}

extension CompleteSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CompleteSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct CompleteSnapshotOutputResponse: Equatable {
    /// <p>The status of the snapshot.</p>
    public let status: Status?

    public init (
        status: Status? = nil
    )
    {
        self.status = status
    }
}

struct CompleteSnapshotOutputResponseBody: Equatable {
    public let status: Status?
}

extension CompleteSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension ConcurrentLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentLimitExceededException(message: \(String(describing: message)))"}
}

extension ConcurrentLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the limit for concurrent API requests. For more information, see
///                 <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-accessing-snapshot.html#ebsapi-performance">Optimizing performance of the EBS direct APIs</a> in the <i>Amazon Elastic Compute Cloud
///                 User Guide</i>.</p>
public struct ConcurrentLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request uses the same client token as a previous, but non-identical
///             request.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetSnapshotBlockInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSnapshotBlockInput(blockIndex: \(String(describing: blockIndex)), blockToken: \(String(describing: blockToken)), snapshotId: \(String(describing: snapshotId)))"}
}

extension GetSnapshotBlockInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSnapshotBlockInputHeadersMiddleware: Middleware {
    public let id: String = "GetSnapshotBlockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSnapshotBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSnapshotBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSnapshotBlockInput>
    public typealias MOutput = OperationOutput<GetSnapshotBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSnapshotBlockOutputError>
}

public struct GetSnapshotBlockInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSnapshotBlockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSnapshotBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSnapshotBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let blockToken = input.operationInput.blockToken {
            let blockTokenQueryItem = URLQueryItem(name: "blockToken".urlPercentEncoding(), value: String(blockToken).urlPercentEncoding())
            input.builder.withQueryItem(blockTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSnapshotBlockInput>
    public typealias MOutput = OperationOutput<GetSnapshotBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSnapshotBlockOutputError>
}

public struct GetSnapshotBlockInput: Equatable {
    /// <p>The block index of the block from which to get data.</p>
    ///
    ///
    ///         <p>Obtain the <code>BlockIndex</code> by running the <code>ListChangedBlocks</code> or
    ///                 <code>ListSnapshotBlocks</code> operations.</p>
    public let blockIndex: Int?
    /// <p>The block token of the block from which to get data.</p>
    ///
    ///
    ///         <p>Obtain the <code>BlockToken</code> by running the <code>ListChangedBlocks</code> or
    ///                 <code>ListSnapshotBlocks</code> operations.</p>
    public let blockToken: String?
    /// <p>The ID of the snapshot containing the block from which to get data.</p>
    public let snapshotId: String?

    public init (
        blockIndex: Int? = nil,
        blockToken: String? = nil,
        snapshotId: String? = nil
    )
    {
        self.blockIndex = blockIndex
        self.blockToken = blockToken
        self.snapshotId = snapshotId
    }
}

struct GetSnapshotBlockInputBody: Equatable {
}

extension GetSnapshotBlockInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSnapshotBlockOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSnapshotBlockOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestThrottledException" : self = .requestThrottledException(try RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSnapshotBlockOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestThrottledException(RequestThrottledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSnapshotBlockOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSnapshotBlockOutputResponse(blockData: \(String(describing: blockData)), checksum: \(String(describing: checksum)), checksumAlgorithm: \(String(describing: checksumAlgorithm)), dataLength: \(String(describing: dataLength)))"}
}

extension GetSnapshotBlockOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-Checksum") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
        if let checksumAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-Checksum-Algorithm") {
            self.checksumAlgorithm = ChecksumAlgorithm(rawValue: checksumAlgorithmHeaderValue)
        } else {
            self.checksumAlgorithm = nil
        }
        if let dataLengthHeaderValue = httpResponse.headers.value(for: "x-amz-Data-Length") {
            self.dataLength = Int(dataLengthHeaderValue) ?? 0
        } else {
            self.dataLength = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.blockData = unwrappedData
        } else {
            self.blockData = nil
        }
    }
}

public struct GetSnapshotBlockOutputResponse: Equatable {
    /// <p>The data content of the block.</p>
    public let blockData: Data?
    /// <p>The checksum generated for the block, which is Base64 encoded.</p>
    public let checksum: String?
    /// <p>The algorithm used to generate the checksum for the block, such as SHA256.</p>
    public let checksumAlgorithm: ChecksumAlgorithm?
    /// <p>The size of the data in the block.</p>
    public let dataLength: Int?

    public init (
        blockData: Data? = nil,
        checksum: String? = nil,
        checksumAlgorithm: ChecksumAlgorithm? = nil,
        dataLength: Int? = nil
    )
    {
        self.blockData = blockData
        self.checksum = checksum
        self.checksumAlgorithm = checksumAlgorithm
        self.dataLength = dataLength
    }
}

struct GetSnapshotBlockOutputResponseBody: Equatable {
    public let blockData: Data?
}

extension GetSnapshotBlockOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case blockData = "BlockData"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockDataDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .blockData)
        blockData = blockDataDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal error has occurred.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChangedBlocksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListChangedBlocksInput(firstSnapshotId: \(String(describing: firstSnapshotId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), secondSnapshotId: \(String(describing: secondSnapshotId)), startingBlockIndex: \(String(describing: startingBlockIndex)))"}
}

extension ListChangedBlocksInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListChangedBlocksInputHeadersMiddleware: Middleware {
    public let id: String = "ListChangedBlocksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListChangedBlocksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListChangedBlocksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListChangedBlocksInput>
    public typealias MOutput = OperationOutput<ListChangedBlocksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListChangedBlocksOutputError>
}

public struct ListChangedBlocksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListChangedBlocksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListChangedBlocksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListChangedBlocksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let firstSnapshotId = input.operationInput.firstSnapshotId {
            let firstSnapshotIdQueryItem = URLQueryItem(name: "firstSnapshotId".urlPercentEncoding(), value: String(firstSnapshotId).urlPercentEncoding())
            input.builder.withQueryItem(firstSnapshotIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "pageToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let startingBlockIndex = input.operationInput.startingBlockIndex {
            let startingBlockIndexQueryItem = URLQueryItem(name: "startingBlockIndex".urlPercentEncoding(), value: String(startingBlockIndex).urlPercentEncoding())
            input.builder.withQueryItem(startingBlockIndexQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListChangedBlocksInput>
    public typealias MOutput = OperationOutput<ListChangedBlocksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListChangedBlocksOutputError>
}

public struct ListChangedBlocksInput: Equatable {
    /// <p>The ID of the first snapshot to use for the comparison.</p>
    ///         <important>
    ///             <p>The <code>FirstSnapshotID</code> parameter must be specified with a
    ///                     <code>SecondSnapshotId</code> parameter; otherwise, an error occurs.</p>
    ///         </important>
    public let firstSnapshotId: String?
    /// <p>The number of results to return.</p>
    public let maxResults: Int?
    /// <p>The token to request the next page of results.</p>
    public let nextToken: String?
    /// <p>The ID of the second snapshot to use for the comparison.</p>
    ///         <important>
    ///             <p>The <code>SecondSnapshotId</code> parameter must be specified with a
    ///                     <code>FirstSnapshotID</code> parameter; otherwise, an error occurs.</p>
    ///         </important>
    public let secondSnapshotId: String?
    /// <p>The block index from which the comparison should start.</p>
    ///         <p>The list in the response will start from this block index or the next valid block
    ///             index in the snapshots.</p>
    public let startingBlockIndex: Int?

    public init (
        firstSnapshotId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        secondSnapshotId: String? = nil,
        startingBlockIndex: Int? = nil
    )
    {
        self.firstSnapshotId = firstSnapshotId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.secondSnapshotId = secondSnapshotId
        self.startingBlockIndex = startingBlockIndex
    }
}

struct ListChangedBlocksInputBody: Equatable {
}

extension ListChangedBlocksInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListChangedBlocksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChangedBlocksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestThrottledException" : self = .requestThrottledException(try RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChangedBlocksOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestThrottledException(RequestThrottledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChangedBlocksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListChangedBlocksOutputResponse(blockSize: \(String(describing: blockSize)), changedBlocks: \(String(describing: changedBlocks)), expiryTime: \(String(describing: expiryTime)), nextToken: \(String(describing: nextToken)), volumeSize: \(String(describing: volumeSize)))"}
}

extension ListChangedBlocksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListChangedBlocksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.blockSize = output.blockSize
            self.changedBlocks = output.changedBlocks
            self.expiryTime = output.expiryTime
            self.nextToken = output.nextToken
            self.volumeSize = output.volumeSize
        } else {
            self.blockSize = nil
            self.changedBlocks = nil
            self.expiryTime = nil
            self.nextToken = nil
            self.volumeSize = nil
        }
    }
}

public struct ListChangedBlocksOutputResponse: Equatable {
    /// <p>The size of the block.</p>
    public let blockSize: Int?
    /// <p>An array of objects containing information about the changed blocks.</p>
    public let changedBlocks: [ChangedBlock]?
    /// <p>The time when the <code>BlockToken</code> expires.</p>
    public let expiryTime: Date?
    /// <p>The token to use to retrieve the next page of results. This value is null when there
    ///             are no more results to return.</p>
    public let nextToken: String?
    /// <p>The size of the volume in GB.</p>
    public let volumeSize: Int?

    public init (
        blockSize: Int? = nil,
        changedBlocks: [ChangedBlock]? = nil,
        expiryTime: Date? = nil,
        nextToken: String? = nil,
        volumeSize: Int? = nil
    )
    {
        self.blockSize = blockSize
        self.changedBlocks = changedBlocks
        self.expiryTime = expiryTime
        self.nextToken = nextToken
        self.volumeSize = volumeSize
    }
}

struct ListChangedBlocksOutputResponseBody: Equatable {
    public let changedBlocks: [ChangedBlock]?
    public let expiryTime: Date?
    public let volumeSize: Int?
    public let blockSize: Int?
    public let nextToken: String?
}

extension ListChangedBlocksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case blockSize = "BlockSize"
        case changedBlocks = "ChangedBlocks"
        case expiryTime = "ExpiryTime"
        case nextToken = "NextToken"
        case volumeSize = "VolumeSize"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changedBlocksContainer = try containerValues.decodeIfPresent([ChangedBlock?].self, forKey: .changedBlocks)
        var changedBlocksDecoded0:[ChangedBlock]? = nil
        if let changedBlocksContainer = changedBlocksContainer {
            changedBlocksDecoded0 = [ChangedBlock]()
            for structure0 in changedBlocksContainer {
                if let structure0 = structure0 {
                    changedBlocksDecoded0?.append(structure0)
                }
            }
        }
        changedBlocks = changedBlocksDecoded0
        let expiryTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let blockSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .blockSize)
        blockSize = blockSizeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSnapshotBlocksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSnapshotBlocksInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), snapshotId: \(String(describing: snapshotId)), startingBlockIndex: \(String(describing: startingBlockIndex)))"}
}

extension ListSnapshotBlocksInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSnapshotBlocksInputHeadersMiddleware: Middleware {
    public let id: String = "ListSnapshotBlocksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSnapshotBlocksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSnapshotBlocksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSnapshotBlocksInput>
    public typealias MOutput = OperationOutput<ListSnapshotBlocksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSnapshotBlocksOutputError>
}

public struct ListSnapshotBlocksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSnapshotBlocksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSnapshotBlocksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSnapshotBlocksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "pageToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let startingBlockIndex = input.operationInput.startingBlockIndex {
            let startingBlockIndexQueryItem = URLQueryItem(name: "startingBlockIndex".urlPercentEncoding(), value: String(startingBlockIndex).urlPercentEncoding())
            input.builder.withQueryItem(startingBlockIndexQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSnapshotBlocksInput>
    public typealias MOutput = OperationOutput<ListSnapshotBlocksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSnapshotBlocksOutputError>
}

public struct ListSnapshotBlocksInput: Equatable {
    /// <p>The number of results to return.</p>
    public let maxResults: Int?
    /// <p>The token to request the next page of results.</p>
    public let nextToken: String?
    /// <p>The ID of the snapshot from which to get block indexes and block tokens.</p>
    public let snapshotId: String?
    /// <p>The block index from which the list should start. The list in the response will start
    ///             from this block index or the next valid block index in the snapshot.</p>
    public let startingBlockIndex: Int?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        snapshotId: String? = nil,
        startingBlockIndex: Int? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.snapshotId = snapshotId
        self.startingBlockIndex = startingBlockIndex
    }
}

struct ListSnapshotBlocksInputBody: Equatable {
}

extension ListSnapshotBlocksInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSnapshotBlocksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSnapshotBlocksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestThrottledException" : self = .requestThrottledException(try RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSnapshotBlocksOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestThrottledException(RequestThrottledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSnapshotBlocksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSnapshotBlocksOutputResponse(blockSize: \(String(describing: blockSize)), blocks: \(String(describing: blocks)), expiryTime: \(String(describing: expiryTime)), nextToken: \(String(describing: nextToken)), volumeSize: \(String(describing: volumeSize)))"}
}

extension ListSnapshotBlocksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSnapshotBlocksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.blockSize = output.blockSize
            self.blocks = output.blocks
            self.expiryTime = output.expiryTime
            self.nextToken = output.nextToken
            self.volumeSize = output.volumeSize
        } else {
            self.blockSize = nil
            self.blocks = nil
            self.expiryTime = nil
            self.nextToken = nil
            self.volumeSize = nil
        }
    }
}

public struct ListSnapshotBlocksOutputResponse: Equatable {
    /// <p>The size of the block.</p>
    public let blockSize: Int?
    /// <p>An array of objects containing information about the blocks.</p>
    public let blocks: [Block]?
    /// <p>The time when the <code>BlockToken</code> expires.</p>
    public let expiryTime: Date?
    /// <p>The token to use to retrieve the next page of results. This value is null when there
    ///             are no more results to return.</p>
    public let nextToken: String?
    /// <p>The size of the volume in GB.</p>
    public let volumeSize: Int?

    public init (
        blockSize: Int? = nil,
        blocks: [Block]? = nil,
        expiryTime: Date? = nil,
        nextToken: String? = nil,
        volumeSize: Int? = nil
    )
    {
        self.blockSize = blockSize
        self.blocks = blocks
        self.expiryTime = expiryTime
        self.nextToken = nextToken
        self.volumeSize = volumeSize
    }
}

struct ListSnapshotBlocksOutputResponseBody: Equatable {
    public let blocks: [Block]?
    public let expiryTime: Date?
    public let volumeSize: Int?
    public let blockSize: Int?
    public let nextToken: String?
}

extension ListSnapshotBlocksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case blockSize = "BlockSize"
        case blocks = "Blocks"
        case expiryTime = "ExpiryTime"
        case nextToken = "NextToken"
        case volumeSize = "VolumeSize"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blocksContainer = try containerValues.decodeIfPresent([Block?].self, forKey: .blocks)
        var blocksDecoded0:[Block]? = nil
        if let blocksContainer = blocksContainer {
            blocksDecoded0 = [Block]()
            for structure0 in blocksContainer {
                if let structure0 = structure0 {
                    blocksDecoded0?.append(structure0)
                }
            }
        }
        blocks = blocksDecoded0
        let expiryTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let blockSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .blockSize)
        blockSize = blockSizeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct PutSnapshotBlockInputBodyMiddleware: Middleware {
    public let id: String = "PutSnapshotBlockInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSnapshotBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSnapshotBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let blockData = input.operationInput.blockData {
            let data = blockData
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSnapshotBlockInput>
    public typealias MOutput = OperationOutput<PutSnapshotBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSnapshotBlockOutputError>
}

extension PutSnapshotBlockInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutSnapshotBlockInput(blockData: \(String(describing: blockData)), blockIndex: \(String(describing: blockIndex)), checksum: \(String(describing: checksum)), checksumAlgorithm: \(String(describing: checksumAlgorithm)), dataLength: \(String(describing: dataLength)), progress: \(String(describing: progress)), snapshotId: \(String(describing: snapshotId)))"}
}

extension PutSnapshotBlockInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockData = "BlockData"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockData = blockData {
            try encodeContainer.encode(blockData.base64EncodedString(), forKey: .blockData)
        }
    }
}

public struct PutSnapshotBlockInputHeadersMiddleware: Middleware {
    public let id: String = "PutSnapshotBlockInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSnapshotBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSnapshotBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let checksum = input.operationInput.checksum {
            input.builder.withHeader(name: "x-amz-Checksum", value: String(checksum))
        }
        if let checksumAlgorithm = input.operationInput.checksumAlgorithm {
            input.builder.withHeader(name: "x-amz-Checksum-Algorithm", value: String(checksumAlgorithm.rawValue))
        }
        if let dataLength = input.operationInput.dataLength {
            input.builder.withHeader(name: "x-amz-Data-Length", value: String(dataLength))
        }
        if let progress = input.operationInput.progress {
            input.builder.withHeader(name: "x-amz-Progress", value: String(progress))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSnapshotBlockInput>
    public typealias MOutput = OperationOutput<PutSnapshotBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSnapshotBlockOutputError>
}

public struct PutSnapshotBlockInputQueryItemMiddleware: Middleware {
    public let id: String = "PutSnapshotBlockInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutSnapshotBlockInput>,
                  next: H) -> Swift.Result<OperationOutput<PutSnapshotBlockOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutSnapshotBlockInput>
    public typealias MOutput = OperationOutput<PutSnapshotBlockOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutSnapshotBlockOutputError>
}

public struct PutSnapshotBlockInput: Equatable {
    /// <p>The data to write to the block.</p>
    ///         <p>The block data is not signed as part of the Signature Version 4 signing process. As a
    ///             result, you must generate and provide a Base64-encoded SHA256 checksum for the block
    ///             data using the <b>x-amz-Checksum</b> header. Also, you
    ///         	must specify the checksum algorithm using the <b>x-amz-Checksum-Algorithm</b>
    ///         	header. The checksum that you provide is part of the Signature Version 4 signing process.
    ///         	It is validated against a checksum generated by Amazon EBS to ensure the validity and authenticity
    ///         	of the data. If the checksums do not correspond, the request fails. For more information,
    ///         	see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-accessing-snapshot.html#ebsapis-using-checksums">
    ///                 Using checksums with the EBS direct APIs</a> in the <i>Amazon Elastic Compute Cloud User
    ///                 Guide</i>.</p>
    public let blockData: Data?
    /// <p>The block index of the block in which to write the data. A block index is a logical
    ///     	index in units of <code>512</code> KiB blocks. To identify the block index, divide
    ///         	the logical offset of the data in the logical volume by the block size (logical offset of
    ///         	data/<code>524288</code>). The logical offset of the data must be <code>512</code>
    ///         	KiB aligned.</p>
    public let blockIndex: Int?
    /// <p>A Base64-encoded SHA256 checksum of the data. Only SHA256 checksums are
    ///             supported.</p>
    public let checksum: String?
    /// <p>The algorithm used to generate the checksum. Currently, the only supported algorithm
    ///             is <code>SHA256</code>.</p>
    public let checksumAlgorithm: ChecksumAlgorithm?
    /// <p>The size of the data to write to the block, in bytes. Currently, the only supported
    ///             size is <code>524288</code>.</p>
    ///         <p>Valid values: <code>524288</code>
    ///          </p>
    public let dataLength: Int?
    /// <p>The progress of the write process, as a percentage.</p>
    public let progress: Int?
    /// <p>The ID of the snapshot.</p>
    public let snapshotId: String?

    public init (
        blockData: Data? = nil,
        blockIndex: Int? = nil,
        checksum: String? = nil,
        checksumAlgorithm: ChecksumAlgorithm? = nil,
        dataLength: Int? = nil,
        progress: Int? = nil,
        snapshotId: String? = nil
    )
    {
        self.blockData = blockData
        self.blockIndex = blockIndex
        self.checksum = checksum
        self.checksumAlgorithm = checksumAlgorithm
        self.dataLength = dataLength
        self.progress = progress
        self.snapshotId = snapshotId
    }
}

struct PutSnapshotBlockInputBody: Equatable {
    public let blockData: Data?
}

extension PutSnapshotBlockInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case blockData = "BlockData"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockDataDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .blockData)
        blockData = blockDataDecoded
    }
}

extension PutSnapshotBlockOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSnapshotBlockOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestThrottledException" : self = .requestThrottledException(try RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutSnapshotBlockOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestThrottledException(RequestThrottledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSnapshotBlockOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutSnapshotBlockOutputResponse(checksum: \(String(describing: checksum)), checksumAlgorithm: \(String(describing: checksumAlgorithm)))"}
}

extension PutSnapshotBlockOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let checksumHeaderValue = httpResponse.headers.value(for: "x-amz-Checksum") {
            self.checksum = checksumHeaderValue
        } else {
            self.checksum = nil
        }
        if let checksumAlgorithmHeaderValue = httpResponse.headers.value(for: "x-amz-Checksum-Algorithm") {
            self.checksumAlgorithm = ChecksumAlgorithm(rawValue: checksumAlgorithmHeaderValue)
        } else {
            self.checksumAlgorithm = nil
        }
    }
}

public struct PutSnapshotBlockOutputResponse: Equatable {
    /// <p>The SHA256 checksum generated for the block data by Amazon EBS.</p>
    public let checksum: String?
    /// <p>The algorithm used by Amazon EBS to generate the checksum.</p>
    public let checksumAlgorithm: ChecksumAlgorithm?

    public init (
        checksum: String? = nil,
        checksumAlgorithm: ChecksumAlgorithm? = nil
    )
    {
        self.checksum = checksum
        self.checksumAlgorithm = checksumAlgorithm
    }
}

struct PutSnapshotBlockOutputResponseBody: Equatable {
}

extension PutSnapshotBlockOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RequestThrottledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestThrottledException(message: \(String(describing: message)), reason: \(String(describing: reason)))"}
}

extension RequestThrottledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RequestThrottledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of API requests has exceed the maximum allowed API request throttling
///             limit.</p>
public struct RequestThrottledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The reason for the exception.</p>
    public var reason: RequestThrottledExceptionReason?

    public init (
        message: String? = nil,
        reason: RequestThrottledExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct RequestThrottledExceptionBody: Equatable {
    public let message: String?
    public let reason: RequestThrottledExceptionReason?
}

extension RequestThrottledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(RequestThrottledExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

public enum RequestThrottledExceptionReason {
    case accountThrottled
    case dependencyRequestThrottled
    case sdkUnknown(String)
}

extension RequestThrottledExceptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RequestThrottledExceptionReason] {
        return [
            .accountThrottled,
            .dependencyRequestThrottled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accountThrottled: return "ACCOUNT_THROTTLED"
        case .dependencyRequestThrottled: return "DEPENDENCY_REQUEST_THROTTLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RequestThrottledExceptionReason(rawValue: rawValue) ?? RequestThrottledExceptionReason.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), reason: \(String(describing: reason)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The reason for the exception.</p>
    public var reason: ResourceNotFoundExceptionReason?

    public init (
        message: String? = nil,
        reason: ResourceNotFoundExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let reason: ResourceNotFoundExceptionReason?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ResourceNotFoundExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

public enum ResourceNotFoundExceptionReason {
    case dependencyResourceNotFound
    case snapshotNotFound
    case sdkUnknown(String)
}

extension ResourceNotFoundExceptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceNotFoundExceptionReason] {
        return [
            .dependencyResourceNotFound,
            .snapshotNotFound,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dependencyResourceNotFound: return "DEPENDENCY_RESOURCE_NOT_FOUND"
        case .snapshotNotFound: return "SNAPSHOT_NOT_FOUND"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceNotFoundExceptionReason(rawValue: rawValue) ?? ResourceNotFoundExceptionReason.sdkUnknown(rawValue)
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)), reason: \(String(describing: reason)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your current service quotas do not allow you to perform this action.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The reason for the exception.</p>
    public var reason: ServiceQuotaExceededExceptionReason?

    public init (
        message: String? = nil,
        reason: ServiceQuotaExceededExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
    public let reason: ServiceQuotaExceededExceptionReason?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ServiceQuotaExceededExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

public enum ServiceQuotaExceededExceptionReason {
    case dependencyServiceQuotaExceeded
    case sdkUnknown(String)
}

extension ServiceQuotaExceededExceptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceQuotaExceededExceptionReason] {
        return [
            .dependencyServiceQuotaExceeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dependencyServiceQuotaExceeded: return "DEPENDENCY_SERVICE_QUOTA_EXCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceQuotaExceededExceptionReason(rawValue: rawValue) ?? ServiceQuotaExceededExceptionReason.sdkUnknown(rawValue)
    }
}

public struct StartSnapshotInputBodyMiddleware: Middleware {
    public let id: String = "StartSnapshotInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSnapshotInput>
    public typealias MOutput = OperationOutput<StartSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSnapshotOutputError>
}

extension StartSnapshotInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSnapshotInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), encrypted: \(String(describing: encrypted)), kmsKeyArn: \(String(describing: kmsKeyArn)), parentSnapshotId: \(String(describing: parentSnapshotId)), tags: \(String(describing: tags)), timeout: \(String(describing: timeout)), volumeSize: \(String(describing: volumeSize)))"}
}

extension StartSnapshotInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case encrypted = "Encrypted"
        case kmsKeyArn = "KmsKeyArn"
        case parentSnapshotId = "ParentSnapshotId"
        case tags = "Tags"
        case timeout = "Timeout"
        case volumeSize = "VolumeSize"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let parentSnapshotId = parentSnapshotId {
            try encodeContainer.encode(parentSnapshotId, forKey: .parentSnapshotId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let volumeSize = volumeSize {
            try encodeContainer.encode(volumeSize, forKey: .volumeSize)
        }
    }
}

public struct StartSnapshotInputHeadersMiddleware: Middleware {
    public let id: String = "StartSnapshotInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSnapshotInput>
    public typealias MOutput = OperationOutput<StartSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSnapshotOutputError>
}

public struct StartSnapshotInputQueryItemMiddleware: Middleware {
    public let id: String = "StartSnapshotInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSnapshotInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSnapshotOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSnapshotInput>
    public typealias MOutput = OperationOutput<StartSnapshotOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSnapshotOutputError>
}

public struct StartSnapshotInput: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///             request. Idempotency ensures that an API request completes only once. With an idempotent
    ///             request, if the original request completes successfully. The subsequent retries with the same
    ///             client token return the result from the original successful request and they have no additional
    ///             effect.</p>
    ///         <p>If you do not specify a client token, one is automatically generated by the AWS SDK.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-direct-api-idempotency.html">
    ///     		Idempotency for StartSnapshot API</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    public var clientToken: String?
    /// <p>A description for the snapshot.</p>
    public let description: String?
    /// <p>Indicates whether to encrypt the snapshot. To create an encrypted snapshot, specify
    ///                 <code>true</code>. To create an unencrypted snapshot, omit this parameter.</p>
    ///         <p>If you specify a value for <b>ParentSnapshotId</b>, omit
    ///             this parameter.</p>
    ///         <p>If you specify <code>true</code>, the snapshot is encrypted using the CMK specified
    ///             using the <b>KmsKeyArn</b> parameter. If no value is specified
    ///             for <b>KmsKeyArn</b>, the default CMK for your account is
    ///         	used. If no default CMK has been specified for your account, the AWS managed CMK is used.
    ///         	To set a default CMK for your account, use <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyEbsDefaultKmsKeyId.html">
    ///         		ModifyEbsDefaultKmsKeyId</a>.</p>
    ///         <p>If your account is enabled for encryption by default, you cannot set this parameter to
    ///                 <code>false</code>. In this case, you can omit this parameter.</p>
    ///
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-accessing-snapshot.html#ebsapis-using-encryption">
    ///                 Using encryption</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    public let encrypted: Bool?
    /// <p>The Amazon Resource Name (ARN) of the AWS Key Management Service (AWS KMS)
    ///         	customer master key (CMK) to be used to encrypt the snapshot. If you do not specify a
    ///         	CMK, the default AWS managed CMK is used.</p>
    ///         <p>If you specify a <b>ParentSnapshotId</b>, omit this
    ///             parameter; the snapshot will be encrypted using the same CMK that was used to encrypt
    ///             the parent snapshot.</p>
    ///         <p>If <b>Encrypted</b> is set to <code>true</code>,
    ///         	you must specify a CMK ARN. </p>
    public let kmsKeyArn: String?
    /// <p>The ID of the parent snapshot. If there is no parent snapshot, or if you are creating
    ///             the first snapshot for an on-premises volume, omit this parameter.</p>
    ///         <p>If your account is enabled for encryption by default, you cannot use an unencrypted
    ///             snapshot as a parent snapshot. You must first create an encrypted copy of the parent
    ///             snapshot using <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CopySnapshot.html">CopySnapshot</a>.</p>
    public let parentSnapshotId: String?
    /// <p>The tags to apply to the snapshot.</p>
    public let tags: [Tag]?
    /// <p>The amount of time (in minutes) after which the snapshot is automatically cancelled
    ///             if:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>No blocks are written to the snapshot.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The snapshot is not completed after writing the last block of data.</p>
    ///             </li>
    ///          </ul>
    ///         <p>If no value is specified, the timeout defaults to <code>60</code> minutes.</p>
    public let timeout: Int?
    /// <p>The size of the volume, in GiB. The maximum size is <code>16384</code> GiB (16
    ///             TiB).</p>
    public let volumeSize: Int?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        encrypted: Bool? = nil,
        kmsKeyArn: String? = nil,
        parentSnapshotId: String? = nil,
        tags: [Tag]? = nil,
        timeout: Int? = nil,
        volumeSize: Int? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.encrypted = encrypted
        self.kmsKeyArn = kmsKeyArn
        self.parentSnapshotId = parentSnapshotId
        self.tags = tags
        self.timeout = timeout
        self.volumeSize = volumeSize
    }
}

struct StartSnapshotInputBody: Equatable {
    public let volumeSize: Int?
    public let parentSnapshotId: String?
    public let tags: [Tag]?
    public let description: String?
    public let clientToken: String?
    public let encrypted: Bool?
    public let kmsKeyArn: String?
    public let timeout: Int?
}

extension StartSnapshotInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case encrypted = "Encrypted"
        case kmsKeyArn = "KmsKeyArn"
        case parentSnapshotId = "ParentSnapshotId"
        case tags = "Tags"
        case timeout = "Timeout"
        case volumeSize = "VolumeSize"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let parentSnapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentSnapshotId)
        parentSnapshotId = parentSnapshotIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
    }
}

extension StartSnapshotOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSnapshotOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentLimitExceededException" : self = .concurrentLimitExceededException(try ConcurrentLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestThrottledException" : self = .requestThrottledException(try RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSnapshotOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case concurrentLimitExceededException(ConcurrentLimitExceededException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestThrottledException(RequestThrottledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSnapshotOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSnapshotOutputResponse(blockSize: \(String(describing: blockSize)), description: \(String(describing: description)), kmsKeyArn: \(String(describing: kmsKeyArn)), ownerId: \(String(describing: ownerId)), parentSnapshotId: \(String(describing: parentSnapshotId)), snapshotId: \(String(describing: snapshotId)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), tags: \(String(describing: tags)), volumeSize: \(String(describing: volumeSize)))"}
}

extension StartSnapshotOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartSnapshotOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.blockSize = output.blockSize
            self.description = output.description
            self.kmsKeyArn = output.kmsKeyArn
            self.ownerId = output.ownerId
            self.parentSnapshotId = output.parentSnapshotId
            self.snapshotId = output.snapshotId
            self.startTime = output.startTime
            self.status = output.status
            self.tags = output.tags
            self.volumeSize = output.volumeSize
        } else {
            self.blockSize = nil
            self.description = nil
            self.kmsKeyArn = nil
            self.ownerId = nil
            self.parentSnapshotId = nil
            self.snapshotId = nil
            self.startTime = nil
            self.status = nil
            self.tags = nil
            self.volumeSize = nil
        }
    }
}

public struct StartSnapshotOutputResponse: Equatable {
    /// <p>The size of the blocks in the snapshot, in bytes.</p>
    public let blockSize: Int?
    /// <p>The description of the snapshot.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Key Management Service (AWS KMS) customer
    ///             master key (CMK) used to encrypt the snapshot.</p>
    public let kmsKeyArn: String?
    /// <p>The AWS account ID of the snapshot owner.</p>
    public let ownerId: String?
    /// <p>The ID of the parent snapshot.</p>
    public let parentSnapshotId: String?
    /// <p>The ID of the snapshot.</p>
    public let snapshotId: String?
    /// <p>The timestamp when the snapshot was created.</p>
    public let startTime: Date?
    /// <p>The status of the snapshot.</p>
    public let status: Status?
    /// <p>The tags applied to the snapshot. You can specify up to 50 tags per snapshot. For more
    ///             information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html"> Tagging your Amazon EC2
    ///                 resources</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
    public let tags: [Tag]?
    /// <p>The size of the volume, in GiB.</p>
    public let volumeSize: Int?

    public init (
        blockSize: Int? = nil,
        description: String? = nil,
        kmsKeyArn: String? = nil,
        ownerId: String? = nil,
        parentSnapshotId: String? = nil,
        snapshotId: String? = nil,
        startTime: Date? = nil,
        status: Status? = nil,
        tags: [Tag]? = nil,
        volumeSize: Int? = nil
    )
    {
        self.blockSize = blockSize
        self.description = description
        self.kmsKeyArn = kmsKeyArn
        self.ownerId = ownerId
        self.parentSnapshotId = parentSnapshotId
        self.snapshotId = snapshotId
        self.startTime = startTime
        self.status = status
        self.tags = tags
        self.volumeSize = volumeSize
    }
}

struct StartSnapshotOutputResponseBody: Equatable {
    public let description: String?
    public let snapshotId: String?
    public let ownerId: String?
    public let status: Status?
    public let startTime: Date?
    public let volumeSize: Int?
    public let blockSize: Int?
    public let tags: [Tag]?
    public let parentSnapshotId: String?
    public let kmsKeyArn: String?
}

extension StartSnapshotOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case blockSize = "BlockSize"
        case description = "Description"
        case kmsKeyArn = "KmsKeyArn"
        case ownerId = "OwnerId"
        case parentSnapshotId = "ParentSnapshotId"
        case snapshotId = "SnapshotId"
        case startTime = "StartTime"
        case status = "Status"
        case tags = "Tags"
        case volumeSize = "VolumeSize"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let blockSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .blockSize)
        blockSize = blockSizeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let parentSnapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentSnapshotId)
        parentSnapshotId = parentSnapshotIdDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

public enum Status {
    case completed
    case error
    case pending
    case sdkUnknown(String)
}

extension Status : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Status] {
        return [
            .completed,
            .error,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "completed"
        case .error: return "error"
        case .pending: return "pending"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Describes a tag.</p>
public struct Tag: Equatable {
    /// <p>The key of the tag.</p>
    public let key: String?
    /// <p>The value of the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)), reason: \(String(describing: reason)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input fails to satisfy the constraints of the EBS direct APIs.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The reason for the validation exception.</p>
    public var reason: ValidationExceptionReason?

    public init (
        message: String? = nil,
        reason: ValidationExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
    public let reason: ValidationExceptionReason?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

public enum ValidationExceptionReason {
    case invalidBlock
    case invalidBlockToken
    case invalidContentEncoding
    case invalidCustomerKey
    case invalidDependencyRequest
    case invalidPageToken
    case invalidParameterValue
    case invalidSnapshotId
    case invalidTag
    case invalidVolumeSize
    case unrelatedSnapshots
    case sdkUnknown(String)
}

extension ValidationExceptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidationExceptionReason] {
        return [
            .invalidBlock,
            .invalidBlockToken,
            .invalidContentEncoding,
            .invalidCustomerKey,
            .invalidDependencyRequest,
            .invalidPageToken,
            .invalidParameterValue,
            .invalidSnapshotId,
            .invalidTag,
            .invalidVolumeSize,
            .unrelatedSnapshots,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .invalidBlock: return "INVALID_BLOCK"
        case .invalidBlockToken: return "INVALID_BLOCK_TOKEN"
        case .invalidContentEncoding: return "INVALID_CONTENT_ENCODING"
        case .invalidCustomerKey: return "INVALID_CUSTOMER_KEY"
        case .invalidDependencyRequest: return "INVALID_DEPENDENCY_REQUEST"
        case .invalidPageToken: return "INVALID_PAGE_TOKEN"
        case .invalidParameterValue: return "INVALID_PARAMETER_VALUE"
        case .invalidSnapshotId: return "INVALID_SNAPSHOT_ID"
        case .invalidTag: return "INVALID_TAG"
        case .invalidVolumeSize: return "INVALID_VOLUME_SIZE"
        case .unrelatedSnapshots: return "UNRELATED_SNAPSHOTS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
    }
}
