// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension OpenSearchClientTypes.AWSDomainInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case ownerId = "OwnerId"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
    }
}

extension OpenSearchClientTypes {
    public struct AWSDomainInformation: Swift.Equatable {
        /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
        /// This member is required.
        public var domainName: Swift.String?
        public var ownerId: Swift.String?
        public var region: Swift.String?

        public init (
            domainName: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.ownerId = ownerId
            self.region = region
        }
    }

}

extension AcceptInboundConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectionId = connectionId else {
            return nil
        }
        return "/2021-01-01/opensearch/cc/inboundConnection/\(connectionId.urlPercentEncoding())/accept"
    }
}

/// Container for the parameters to the [AcceptInboundConnection] operation.
public struct AcceptInboundConnectionInput: Swift.Equatable {
    /// The ID of the inbound connection you want to accept.
    /// This member is required.
    public var connectionId: Swift.String?

    public init (
        connectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

struct AcceptInboundConnectionInputBody: Swift.Equatable {
}

extension AcceptInboundConnectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AcceptInboundConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptInboundConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptInboundConnectionOutputError: Swift.Error, Swift.Equatable {
    case disabledOperationException(DisabledOperationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptInboundConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AcceptInboundConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

/// The result of an [AcceptInboundConnection] operation. Contains details about the accepted inbound connection.
public struct AcceptInboundConnectionOutputResponse: Swift.Equatable {
    /// The [InboundConnection] of the accepted inbound connection.
    public var connection: OpenSearchClientTypes.InboundConnection?

    public init (
        connection: OpenSearchClientTypes.InboundConnection? = nil
    )
    {
        self.connection = connection
    }
}

struct AcceptInboundConnectionOutputResponseBody: Swift.Equatable {
    let connection: OpenSearchClientTypes.InboundConnection?
}

extension AcceptInboundConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.InboundConnection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occurred because user does not have permissions to access the resource. Returns HTTP status code 403.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpenSearchClientTypes.AccessPoliciesStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchClientTypes {
    /// The configured access rules for the domain's document and search endpoints, and the current status of those rules.
    public struct AccessPoliciesStatus: Swift.Equatable {
        /// The access policy configured for the domain. Access policies can be resource-based, IP-based, or IAM-based. See [ Configuring access policies](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-access-policies)for more information.
        /// This member is required.
        public var options: Swift.String?
        /// The status of the access policy for the domain. See OptionStatus for the status information that's included.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init (
            options: Swift.String? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension AddTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case tagList = "TagList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = self.aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
    }
}

extension AddTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/tags"
    }
}

/// Container for the parameters to the [AddTags] operation. Specifies the tags to attach to the domain.
public struct AddTagsInput: Swift.Equatable {
    /// Specify the ARN of the domain you want to add tags to.
    /// This member is required.
    public var aRN: Swift.String?
    /// List of Tag to add to the domain.
    /// This member is required.
    public var tagList: [OpenSearchClientTypes.Tag]?

    public init (
        aRN: Swift.String? = nil,
        tagList: [OpenSearchClientTypes.Tag]? = nil
    )
    {
        self.aRN = aRN
        self.tagList = tagList
    }
}

struct AddTagsInputBody: Swift.Equatable {
    let aRN: Swift.String?
    let tagList: [OpenSearchClientTypes.Tag]?
}

extension AddTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let tagListContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[OpenSearchClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [OpenSearchClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension AddTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AddTagsOutputResponse: Swift.Equatable {

    public init () { }
}

extension OpenSearchClientTypes.AdditionalLimit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limitName = "LimitName"
        case limitValues = "LimitValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limitName = self.limitName {
            try encodeContainer.encode(limitName, forKey: .limitName)
        }
        if let limitValues = limitValues {
            var limitValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .limitValues)
            for limitvaluelist0 in limitValues {
                try limitValuesContainer.encode(limitvaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limitName)
        limitName = limitNameDecoded
        let limitValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .limitValues)
        var limitValuesDecoded0:[Swift.String]? = nil
        if let limitValuesContainer = limitValuesContainer {
            limitValuesDecoded0 = [Swift.String]()
            for string0 in limitValuesContainer {
                if let string0 = string0 {
                    limitValuesDecoded0?.append(string0)
                }
            }
        }
        limitValues = limitValuesDecoded0
    }
}

extension OpenSearchClientTypes {
    /// List of limits that are specific to a given InstanceType and for each of its [InstanceRole] .
    public struct AdditionalLimit: Swift.Equatable {
        /// Additional limit is specific to a given InstanceType and for each of its [InstanceRole] etc.
        ///
        ///
        ///
        ///
        ///
        /// Attributes and their details:
        ///
        ///
        ///
        ///
        ///
        ///
        ///
        /// * MaximumNumberOfDataNodesSupported
        ///  This attribute is present on the master node only to specify how much data nodes up to which given [ESPartitionInstanceType] can support as master node.
        /// * MaximumNumberOfDataNodesWithoutMasterNode
        ///  This attribute is present on data node only to specify how much data nodes of given [ESPartitionInstanceType] up to which you don't need any master nodes to govern them.
        public var limitName: Swift.String?
        /// Value for a given [AdditionalLimit$LimitName] .
        public var limitValues: [Swift.String]?

        public init (
            limitName: Swift.String? = nil,
            limitValues: [Swift.String]? = nil
        )
        {
            self.limitName = limitName
            self.limitValues = limitValues
        }
    }

}

extension OpenSearchClientTypes.AdvancedOptionsStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = options {
            var optionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .options)
            for (dictKey0, advancedoptions0) in options {
                try optionsContainer.encode(advancedoptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .options)
        var optionsDecoded0: [Swift.String:Swift.String]? = nil
        if let optionsContainer = optionsContainer {
            optionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in optionsContainer {
                if let string0 = string0 {
                    optionsDecoded0?[key0] = string0
                }
            }
        }
        options = optionsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchClientTypes {
    /// Status of the advanced options for the specified domain. Currently, the following advanced options are available:
    ///
    /// * Option to allow references to indices in an HTTP request body. Must be false when configuring access to individual sub-resources. By default, the value is true. See [Advanced cluster parameters ](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options) for more information.
    ///
    /// * Option to specify the percentage of heap space allocated to field data. By default, this setting is unbounded.
    ///
    ///
    /// For more information, see [ Advanced cluster parameters](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options).
    public struct AdvancedOptionsStatus: Swift.Equatable {
        /// The status of advanced options for the specified domain.
        /// This member is required.
        public var options: [Swift.String:Swift.String]?
        /// The OptionStatus for advanced options for the specified domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init (
            options: [Swift.String:Swift.String]? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes.AdvancedSecurityOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anonymousAuthDisableDate = "AnonymousAuthDisableDate"
        case anonymousAuthEnabled = "AnonymousAuthEnabled"
        case enabled = "Enabled"
        case internalUserDatabaseEnabled = "InternalUserDatabaseEnabled"
        case sAMLOptions = "SAMLOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anonymousAuthDisableDate = self.anonymousAuthDisableDate {
            try encodeContainer.encode(anonymousAuthDisableDate.timeIntervalSince1970, forKey: .anonymousAuthDisableDate)
        }
        if let anonymousAuthEnabled = self.anonymousAuthEnabled {
            try encodeContainer.encode(anonymousAuthEnabled, forKey: .anonymousAuthEnabled)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let internalUserDatabaseEnabled = self.internalUserDatabaseEnabled {
            try encodeContainer.encode(internalUserDatabaseEnabled, forKey: .internalUserDatabaseEnabled)
        }
        if let sAMLOptions = self.sAMLOptions {
            try encodeContainer.encode(sAMLOptions, forKey: .sAMLOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let internalUserDatabaseEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .internalUserDatabaseEnabled)
        internalUserDatabaseEnabled = internalUserDatabaseEnabledDecoded
        let sAMLOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.SAMLOptionsOutput.self, forKey: .sAMLOptions)
        sAMLOptions = sAMLOptionsDecoded
        let anonymousAuthDisableDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .anonymousAuthDisableDate)
        anonymousAuthDisableDate = anonymousAuthDisableDateDecoded
        let anonymousAuthEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .anonymousAuthEnabled)
        anonymousAuthEnabled = anonymousAuthEnabledDecoded
    }
}

extension OpenSearchClientTypes {
    /// The advanced security configuration: whether advanced security is enabled, whether the internal database option is enabled.
    public struct AdvancedSecurityOptions: Swift.Equatable {
        /// Specifies the Anonymous Auth Disable Date when Anonymous Auth is enabled.
        public var anonymousAuthDisableDate: ClientRuntime.Date?
        /// True if Anonymous auth is enabled. Anonymous auth can be enabled only when AdvancedSecurity is enabled on existing domains.
        public var anonymousAuthEnabled: Swift.Bool?
        /// True if advanced security is enabled.
        public var enabled: Swift.Bool?
        /// True if the internal user database is enabled.
        public var internalUserDatabaseEnabled: Swift.Bool?
        /// Describes the SAML application configured for a domain.
        public var sAMLOptions: OpenSearchClientTypes.SAMLOptionsOutput?

        public init (
            anonymousAuthDisableDate: ClientRuntime.Date? = nil,
            anonymousAuthEnabled: Swift.Bool? = nil,
            enabled: Swift.Bool? = nil,
            internalUserDatabaseEnabled: Swift.Bool? = nil,
            sAMLOptions: OpenSearchClientTypes.SAMLOptionsOutput? = nil
        )
        {
            self.anonymousAuthDisableDate = anonymousAuthDisableDate
            self.anonymousAuthEnabled = anonymousAuthEnabled
            self.enabled = enabled
            self.internalUserDatabaseEnabled = internalUserDatabaseEnabled
            self.sAMLOptions = sAMLOptions
        }
    }

}

extension OpenSearchClientTypes.AdvancedSecurityOptionsInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anonymousAuthEnabled = "AnonymousAuthEnabled"
        case enabled = "Enabled"
        case internalUserDatabaseEnabled = "InternalUserDatabaseEnabled"
        case masterUserOptions = "MasterUserOptions"
        case sAMLOptions = "SAMLOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anonymousAuthEnabled = self.anonymousAuthEnabled {
            try encodeContainer.encode(anonymousAuthEnabled, forKey: .anonymousAuthEnabled)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let internalUserDatabaseEnabled = self.internalUserDatabaseEnabled {
            try encodeContainer.encode(internalUserDatabaseEnabled, forKey: .internalUserDatabaseEnabled)
        }
        if let masterUserOptions = self.masterUserOptions {
            try encodeContainer.encode(masterUserOptions, forKey: .masterUserOptions)
        }
        if let sAMLOptions = self.sAMLOptions {
            try encodeContainer.encode(sAMLOptions, forKey: .sAMLOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let internalUserDatabaseEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .internalUserDatabaseEnabled)
        internalUserDatabaseEnabled = internalUserDatabaseEnabledDecoded
        let masterUserOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.MasterUserOptions.self, forKey: .masterUserOptions)
        masterUserOptions = masterUserOptionsDecoded
        let sAMLOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.SAMLOptionsInput.self, forKey: .sAMLOptions)
        sAMLOptions = sAMLOptionsDecoded
        let anonymousAuthEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .anonymousAuthEnabled)
        anonymousAuthEnabled = anonymousAuthEnabledDecoded
    }
}

extension OpenSearchClientTypes {
    /// The advanced security configuration: whether advanced security is enabled, whether the internal database option is enabled, master username and password (if internal database is enabled), and master user ARN (if IAM is enabled).
    public struct AdvancedSecurityOptionsInput: Swift.Equatable {
        /// True if Anonymous auth is enabled. Anonymous auth can be enabled only when AdvancedSecurity is enabled on existing domains.
        public var anonymousAuthEnabled: Swift.Bool?
        /// True if advanced security is enabled.
        public var enabled: Swift.Bool?
        /// True if the internal user database is enabled.
        public var internalUserDatabaseEnabled: Swift.Bool?
        /// Credentials for the master user: username and password, ARN, or both.
        public var masterUserOptions: OpenSearchClientTypes.MasterUserOptions?
        /// The SAML application configuration for the domain.
        public var sAMLOptions: OpenSearchClientTypes.SAMLOptionsInput?

        public init (
            anonymousAuthEnabled: Swift.Bool? = nil,
            enabled: Swift.Bool? = nil,
            internalUserDatabaseEnabled: Swift.Bool? = nil,
            masterUserOptions: OpenSearchClientTypes.MasterUserOptions? = nil,
            sAMLOptions: OpenSearchClientTypes.SAMLOptionsInput? = nil
        )
        {
            self.anonymousAuthEnabled = anonymousAuthEnabled
            self.enabled = enabled
            self.internalUserDatabaseEnabled = internalUserDatabaseEnabled
            self.masterUserOptions = masterUserOptions
            self.sAMLOptions = sAMLOptions
        }
    }

}

extension OpenSearchClientTypes.AdvancedSecurityOptionsStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AdvancedSecurityOptions.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchClientTypes {
    /// The status of advanced security options for the specified domain.
    public struct AdvancedSecurityOptionsStatus: Swift.Equatable {
        /// Advanced security options for the specified domain.
        /// This member is required.
        public var options: OpenSearchClientTypes.AdvancedSecurityOptions?
        /// Status of the advanced security options for the specified domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init (
            options: OpenSearchClientTypes.AdvancedSecurityOptions? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension AssociatePackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageID = packageID else {
            return nil
        }
        guard let domainName = domainName else {
            return nil
        }
        return "/2021-01-01/packages/associate/\(packageID.urlPercentEncoding())/\(domainName.urlPercentEncoding())"
    }
}

/// Container for the request parameters to the [AssociatePackage] operation.
public struct AssociatePackageInput: Swift.Equatable {
    /// The name of the domain to associate the package with.
    /// This member is required.
    public var domainName: Swift.String?
    /// Internal ID of the package to associate with a domain. Use DescribePackages to find this value.
    /// This member is required.
    public var packageID: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        packageID: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.packageID = packageID
    }
}

struct AssociatePackageInputBody: Swift.Equatable {
}

extension AssociatePackageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AssociatePackageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociatePackageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociatePackageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case baseException(BaseException)
    case conflictException(ConflictException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociatePackageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociatePackageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainPackageDetails = output.domainPackageDetails
        } else {
            self.domainPackageDetails = nil
        }
    }
}

/// Container for the response returned by [AssociatePackage] operation.
public struct AssociatePackageOutputResponse: Swift.Equatable {
    ///     DomainPackageDetails
    public var domainPackageDetails: OpenSearchClientTypes.DomainPackageDetails?

    public init (
        domainPackageDetails: OpenSearchClientTypes.DomainPackageDetails? = nil
    )
    {
        self.domainPackageDetails = domainPackageDetails
    }
}

struct AssociatePackageOutputResponseBody: Swift.Equatable {
    let domainPackageDetails: OpenSearchClientTypes.DomainPackageDetails?
}

extension AssociatePackageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainPackageDetails = "DomainPackageDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainPackageDetailsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainPackageDetails.self, forKey: .domainPackageDetails)
        domainPackageDetails = domainPackageDetailsDecoded
    }
}

extension OpenSearchClientTypes.AutoTune: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoTuneDetails = "AutoTuneDetails"
        case autoTuneType = "AutoTuneType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoTuneDetails = self.autoTuneDetails {
            try encodeContainer.encode(autoTuneDetails, forKey: .autoTuneDetails)
        }
        if let autoTuneType = self.autoTuneType {
            try encodeContainer.encode(autoTuneType.rawValue, forKey: .autoTuneType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoTuneTypeDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AutoTuneType.self, forKey: .autoTuneType)
        autoTuneType = autoTuneTypeDecoded
        let autoTuneDetailsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AutoTuneDetails.self, forKey: .autoTuneDetails)
        autoTuneDetails = autoTuneDetailsDecoded
    }
}

extension OpenSearchClientTypes {
    /// Specifies the Auto-Tune type and Auto-Tune action details.
    public struct AutoTune: Swift.Equatable {
        /// Specifies details about the Auto-Tune action. See [ Auto-Tune for Amazon OpenSearch Service ](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html) for more information.
        public var autoTuneDetails: OpenSearchClientTypes.AutoTuneDetails?
        /// Specifies the Auto-Tune type. Valid value is SCHEDULED_ACTION.
        public var autoTuneType: OpenSearchClientTypes.AutoTuneType?

        public init (
            autoTuneDetails: OpenSearchClientTypes.AutoTuneDetails? = nil,
            autoTuneType: OpenSearchClientTypes.AutoTuneType? = nil
        )
        {
            self.autoTuneDetails = autoTuneDetails
            self.autoTuneType = autoTuneType
        }
    }

}

extension OpenSearchClientTypes {
    /// The Auto-Tune desired state. Valid values are ENABLED and DISABLED.
    public enum AutoTuneDesiredState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoTuneDesiredState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoTuneDesiredState(rawValue: rawValue) ?? AutoTuneDesiredState.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes.AutoTuneDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduledAutoTuneDetails = "ScheduledAutoTuneDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduledAutoTuneDetails = self.scheduledAutoTuneDetails {
            try encodeContainer.encode(scheduledAutoTuneDetails, forKey: .scheduledAutoTuneDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledAutoTuneDetailsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ScheduledAutoTuneDetails.self, forKey: .scheduledAutoTuneDetails)
        scheduledAutoTuneDetails = scheduledAutoTuneDetailsDecoded
    }
}

extension OpenSearchClientTypes {
    /// Specifies details about the Auto-Tune action. See [ Auto-Tune for Amazon OpenSearch Service ](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html) for more information.
    public struct AutoTuneDetails: Swift.Equatable {
        /// Specifies details about the scheduled Auto-Tune action. See [ Auto-Tune for Amazon OpenSearch Service ](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html) for more information.
        public var scheduledAutoTuneDetails: OpenSearchClientTypes.ScheduledAutoTuneDetails?

        public init (
            scheduledAutoTuneDetails: OpenSearchClientTypes.ScheduledAutoTuneDetails? = nil
        )
        {
            self.scheduledAutoTuneDetails = scheduledAutoTuneDetails
        }
    }

}

extension OpenSearchClientTypes.AutoTuneMaintenanceSchedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cronExpressionForRecurrence = "CronExpressionForRecurrence"
        case duration = "Duration"
        case startAt = "StartAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cronExpressionForRecurrence = self.cronExpressionForRecurrence {
            try encodeContainer.encode(cronExpressionForRecurrence, forKey: .cronExpressionForRecurrence)
        }
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let startAt = self.startAt {
            try encodeContainer.encode(startAt.timeIntervalSince1970, forKey: .startAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startAt)
        startAt = startAtDecoded
        let durationDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.Duration.self, forKey: .duration)
        duration = durationDecoded
        let cronExpressionForRecurrenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cronExpressionForRecurrence)
        cronExpressionForRecurrence = cronExpressionForRecurrenceDecoded
    }
}

extension OpenSearchClientTypes {
    /// Specifies the Auto-Tune maintenance schedule. See [ Auto-Tune for Amazon OpenSearch Service ](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html) for more information.
    public struct AutoTuneMaintenanceSchedule: Swift.Equatable {
        /// A cron expression for a recurring maintenance schedule. See [ Auto-Tune for Amazon OpenSearch Service ](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html) for more information.
        public var cronExpressionForRecurrence: Swift.String?
        /// Specifies maintenance schedule duration: duration value and duration unit. See [ Auto-Tune for Amazon OpenSearch Service ](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html) for more information.
        public var duration: OpenSearchClientTypes.Duration?
        /// The timestamp at which the Auto-Tune maintenance schedule starts.
        public var startAt: ClientRuntime.Date?

        public init (
            cronExpressionForRecurrence: Swift.String? = nil,
            duration: OpenSearchClientTypes.Duration? = nil,
            startAt: ClientRuntime.Date? = nil
        )
        {
            self.cronExpressionForRecurrence = cronExpressionForRecurrence
            self.duration = duration
            self.startAt = startAt
        }
    }

}

extension OpenSearchClientTypes.AutoTuneOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredState = "DesiredState"
        case maintenanceSchedules = "MaintenanceSchedules"
        case rollbackOnDisable = "RollbackOnDisable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredState = self.desiredState {
            try encodeContainer.encode(desiredState.rawValue, forKey: .desiredState)
        }
        if let maintenanceSchedules = maintenanceSchedules {
            var maintenanceSchedulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .maintenanceSchedules)
            for autotunemaintenanceschedulelist0 in maintenanceSchedules {
                try maintenanceSchedulesContainer.encode(autotunemaintenanceschedulelist0)
            }
        }
        if let rollbackOnDisable = self.rollbackOnDisable {
            try encodeContainer.encode(rollbackOnDisable.rawValue, forKey: .rollbackOnDisable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredStateDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AutoTuneDesiredState.self, forKey: .desiredState)
        desiredState = desiredStateDecoded
        let rollbackOnDisableDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.RollbackOnDisable.self, forKey: .rollbackOnDisable)
        rollbackOnDisable = rollbackOnDisableDecoded
        let maintenanceSchedulesContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.AutoTuneMaintenanceSchedule?].self, forKey: .maintenanceSchedules)
        var maintenanceSchedulesDecoded0:[OpenSearchClientTypes.AutoTuneMaintenanceSchedule]? = nil
        if let maintenanceSchedulesContainer = maintenanceSchedulesContainer {
            maintenanceSchedulesDecoded0 = [OpenSearchClientTypes.AutoTuneMaintenanceSchedule]()
            for structure0 in maintenanceSchedulesContainer {
                if let structure0 = structure0 {
                    maintenanceSchedulesDecoded0?.append(structure0)
                }
            }
        }
        maintenanceSchedules = maintenanceSchedulesDecoded0
    }
}

extension OpenSearchClientTypes {
    /// The Auto-Tune options: the Auto-Tune desired state for the domain, rollback state when disabling Auto-Tune options and list of maintenance schedules.
    public struct AutoTuneOptions: Swift.Equatable {
        /// The Auto-Tune desired state. Valid values are ENABLED and DISABLED.
        public var desiredState: OpenSearchClientTypes.AutoTuneDesiredState?
        /// A list of maintenance schedules. See [ Auto-Tune for Amazon OpenSearch Service ](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html) for more information.
        public var maintenanceSchedules: [OpenSearchClientTypes.AutoTuneMaintenanceSchedule]?
        /// The rollback state while disabling Auto-Tune for the domain. Valid values are NO_ROLLBACK and DEFAULT_ROLLBACK.
        public var rollbackOnDisable: OpenSearchClientTypes.RollbackOnDisable?

        public init (
            desiredState: OpenSearchClientTypes.AutoTuneDesiredState? = nil,
            maintenanceSchedules: [OpenSearchClientTypes.AutoTuneMaintenanceSchedule]? = nil,
            rollbackOnDisable: OpenSearchClientTypes.RollbackOnDisable? = nil
        )
        {
            self.desiredState = desiredState
            self.maintenanceSchedules = maintenanceSchedules
            self.rollbackOnDisable = rollbackOnDisable
        }
    }

}

extension OpenSearchClientTypes.AutoTuneOptionsInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredState = "DesiredState"
        case maintenanceSchedules = "MaintenanceSchedules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredState = self.desiredState {
            try encodeContainer.encode(desiredState.rawValue, forKey: .desiredState)
        }
        if let maintenanceSchedules = maintenanceSchedules {
            var maintenanceSchedulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .maintenanceSchedules)
            for autotunemaintenanceschedulelist0 in maintenanceSchedules {
                try maintenanceSchedulesContainer.encode(autotunemaintenanceschedulelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredStateDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AutoTuneDesiredState.self, forKey: .desiredState)
        desiredState = desiredStateDecoded
        let maintenanceSchedulesContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.AutoTuneMaintenanceSchedule?].self, forKey: .maintenanceSchedules)
        var maintenanceSchedulesDecoded0:[OpenSearchClientTypes.AutoTuneMaintenanceSchedule]? = nil
        if let maintenanceSchedulesContainer = maintenanceSchedulesContainer {
            maintenanceSchedulesDecoded0 = [OpenSearchClientTypes.AutoTuneMaintenanceSchedule]()
            for structure0 in maintenanceSchedulesContainer {
                if let structure0 = structure0 {
                    maintenanceSchedulesDecoded0?.append(structure0)
                }
            }
        }
        maintenanceSchedules = maintenanceSchedulesDecoded0
    }
}

extension OpenSearchClientTypes {
    /// The Auto-Tune options: the Auto-Tune desired state for the domain and list of maintenance schedules.
    public struct AutoTuneOptionsInput: Swift.Equatable {
        /// The Auto-Tune desired state. Valid values are ENABLED and DISABLED.
        public var desiredState: OpenSearchClientTypes.AutoTuneDesiredState?
        /// A list of maintenance schedules. See [ Auto-Tune for Amazon OpenSearch Service ](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html) for more information.
        public var maintenanceSchedules: [OpenSearchClientTypes.AutoTuneMaintenanceSchedule]?

        public init (
            desiredState: OpenSearchClientTypes.AutoTuneDesiredState? = nil,
            maintenanceSchedules: [OpenSearchClientTypes.AutoTuneMaintenanceSchedule]? = nil
        )
        {
            self.desiredState = desiredState
            self.maintenanceSchedules = maintenanceSchedules
        }
    }

}

extension OpenSearchClientTypes.AutoTuneOptionsOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage = "ErrorMessage"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AutoTuneState.self, forKey: .state)
        state = stateDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension OpenSearchClientTypes {
    /// The Auto-Tune options: the Auto-Tune desired state for the domain and list of maintenance schedules.
    public struct AutoTuneOptionsOutput: Swift.Equatable {
        /// The error message while enabling or disabling Auto-Tune.
        public var errorMessage: Swift.String?
        /// The AutoTuneState for the domain.
        public var state: OpenSearchClientTypes.AutoTuneState?

        public init (
            errorMessage: Swift.String? = nil,
            state: OpenSearchClientTypes.AutoTuneState? = nil
        )
        {
            self.errorMessage = errorMessage
            self.state = state
        }
    }

}

extension OpenSearchClientTypes.AutoTuneOptionsStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AutoTuneOptions.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AutoTuneStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchClientTypes {
    /// The Auto-Tune status for the domain.
    public struct AutoTuneOptionsStatus: Swift.Equatable {
        /// Specifies Auto-Tune options for the domain.
        public var options: OpenSearchClientTypes.AutoTuneOptions?
        /// The status of the Auto-Tune options for the domain.
        public var status: OpenSearchClientTypes.AutoTuneStatus?

        public init (
            options: OpenSearchClientTypes.AutoTuneOptions? = nil,
            status: OpenSearchClientTypes.AutoTuneStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    /// The Auto-Tune state for the domain. For valid states see [ Auto-Tune for Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html).
    public enum AutoTuneState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disabledAndRollbackComplete
        case disabledAndRollbackError
        case disabledAndRollbackInProgress
        case disabledAndRollbackScheduled
        case disableInProgress
        case enabled
        case enableInProgress
        case error
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoTuneState] {
            return [
                .disabled,
                .disabledAndRollbackComplete,
                .disabledAndRollbackError,
                .disabledAndRollbackInProgress,
                .disabledAndRollbackScheduled,
                .disableInProgress,
                .enabled,
                .enableInProgress,
                .error,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabledAndRollbackComplete: return "DISABLED_AND_ROLLBACK_COMPLETE"
            case .disabledAndRollbackError: return "DISABLED_AND_ROLLBACK_ERROR"
            case .disabledAndRollbackInProgress: return "DISABLED_AND_ROLLBACK_IN_PROGRESS"
            case .disabledAndRollbackScheduled: return "DISABLED_AND_ROLLBACK_SCHEDULED"
            case .disableInProgress: return "DISABLE_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case .enableInProgress: return "ENABLE_IN_PROGRESS"
            case .error: return "ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoTuneState(rawValue: rawValue) ?? AutoTuneState.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes.AutoTuneStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case errorMessage = "ErrorMessage"
        case pendingDeletion = "PendingDeletion"
        case state = "State"
        case updateDate = "UpdateDate"
        case updateVersion = "UpdateVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let pendingDeletion = self.pendingDeletion {
            try encodeContainer.encode(pendingDeletion, forKey: .pendingDeletion)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let updateDate = self.updateDate {
            try encodeContainer.encode(updateDate.timeIntervalSince1970, forKey: .updateDate)
        }
        if updateVersion != 0 {
            try encodeContainer.encode(updateVersion, forKey: .updateVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let updateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDate)
        updateDate = updateDateDecoded
        let updateVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .updateVersion) ?? 0
        updateVersion = updateVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AutoTuneState.self, forKey: .state)
        state = stateDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let pendingDeletionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .pendingDeletion)
        pendingDeletion = pendingDeletionDecoded
    }
}

extension OpenSearchClientTypes {
    /// Provides the current Auto-Tune status for the domain.
    public struct AutoTuneStatus: Swift.Equatable {
        /// The timestamp of the Auto-Tune options creation date.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// The error message while enabling or disabling Auto-Tune.
        public var errorMessage: Swift.String?
        /// Indicates whether the domain is being deleted.
        public var pendingDeletion: Swift.Bool?
        /// The AutoTuneState for the domain.
        /// This member is required.
        public var state: OpenSearchClientTypes.AutoTuneState?
        /// The timestamp of when the Auto-Tune options were last updated.
        /// This member is required.
        public var updateDate: ClientRuntime.Date?
        /// The latest version of the Auto-Tune options.
        public var updateVersion: Swift.Int

        public init (
            creationDate: ClientRuntime.Date? = nil,
            errorMessage: Swift.String? = nil,
            pendingDeletion: Swift.Bool? = nil,
            state: OpenSearchClientTypes.AutoTuneState? = nil,
            updateDate: ClientRuntime.Date? = nil,
            updateVersion: Swift.Int = 0
        )
        {
            self.creationDate = creationDate
            self.errorMessage = errorMessage
            self.pendingDeletion = pendingDeletion
            self.state = state
            self.updateDate = updateDate
            self.updateVersion = updateVersion
        }
    }

}

extension OpenSearchClientTypes {
    /// Specifies the Auto-Tune type. Valid value is SCHEDULED_ACTION.
    public enum AutoTuneType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case scheduledAction
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoTuneType] {
            return [
                .scheduledAction,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .scheduledAction: return "SCHEDULED_ACTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoTuneType(rawValue: rawValue) ?? AutoTuneType.sdkUnknown(rawValue)
        }
    }
}

extension BaseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BaseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occurred while processing the request.
public struct BaseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BaseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BaseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CancelServiceSoftwareUpdateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

extension CancelServiceSoftwareUpdateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/opensearch/serviceSoftwareUpdate/cancel"
    }
}

/// Container for the parameters to the [CancelServiceSoftwareUpdate] operation. Specifies the name of the domain that you wish to cancel a service software update on.
public struct CancelServiceSoftwareUpdateInput: Swift.Equatable {
    /// The name of the domain that you want to stop the latest service software update on.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct CancelServiceSoftwareUpdateInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension CancelServiceSoftwareUpdateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension CancelServiceSoftwareUpdateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelServiceSoftwareUpdateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelServiceSoftwareUpdateOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelServiceSoftwareUpdateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelServiceSoftwareUpdateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceSoftwareOptions = output.serviceSoftwareOptions
        } else {
            self.serviceSoftwareOptions = nil
        }
    }
}

/// The result of a CancelServiceSoftwareUpdate operation. Contains the status of the update.
public struct CancelServiceSoftwareUpdateOutputResponse: Swift.Equatable {
    /// The current status of the OpenSearch service software update.
    public var serviceSoftwareOptions: OpenSearchClientTypes.ServiceSoftwareOptions?

    public init (
        serviceSoftwareOptions: OpenSearchClientTypes.ServiceSoftwareOptions? = nil
    )
    {
        self.serviceSoftwareOptions = serviceSoftwareOptions
    }
}

struct CancelServiceSoftwareUpdateOutputResponseBody: Swift.Equatable {
    let serviceSoftwareOptions: OpenSearchClientTypes.ServiceSoftwareOptions?
}

extension CancelServiceSoftwareUpdateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSoftwareOptions = "ServiceSoftwareOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSoftwareOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ServiceSoftwareOptions.self, forKey: .serviceSoftwareOptions)
        serviceSoftwareOptions = serviceSoftwareOptionsDecoded
    }
}

extension OpenSearchClientTypes.ChangeProgressDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeId = "ChangeId"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeId = self.changeId {
            try encodeContainer.encode(changeId, forKey: .changeId)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeId)
        changeId = changeIdDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpenSearchClientTypes {
    /// Specifies change details of the domain configuration change.
    public struct ChangeProgressDetails: Swift.Equatable {
        /// The unique change identifier associated with a specific domain configuration change.
        public var changeId: Swift.String?
        /// Contains an optional message associated with the domain configuration change.
        public var message: Swift.String?

        public init (
            changeId: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.changeId = changeId
            self.message = message
        }
    }

}

extension OpenSearchClientTypes.ChangeProgressStage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case lastUpdated = "LastUpdated"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encode(lastUpdated.timeIntervalSince1970, forKey: .lastUpdated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension OpenSearchClientTypes {
    /// A progress stage details of a specific domain configuration change.
    public struct ChangeProgressStage: Swift.Equatable {
        /// The description of the progress stage.
        public var description: Swift.String?
        /// The last updated timestamp of the progress stage.
        public var lastUpdated: ClientRuntime.Date?
        /// The name of the specific progress stage.
        public var name: Swift.String?
        /// The overall status of a specific progress stage.
        public var status: Swift.String?

        public init (
            description: Swift.String? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.description = description
            self.lastUpdated = lastUpdated
            self.name = name
            self.status = status
        }
    }

}

extension OpenSearchClientTypes.ChangeProgressStatusDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeId = "ChangeId"
        case changeProgressStages = "ChangeProgressStages"
        case completedProperties = "CompletedProperties"
        case pendingProperties = "PendingProperties"
        case startTime = "StartTime"
        case status = "Status"
        case totalNumberOfStages = "TotalNumberOfStages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeId = self.changeId {
            try encodeContainer.encode(changeId, forKey: .changeId)
        }
        if let changeProgressStages = changeProgressStages {
            var changeProgressStagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .changeProgressStages)
            for changeprogressstagelist0 in changeProgressStages {
                try changeProgressStagesContainer.encode(changeprogressstagelist0)
            }
        }
        if let completedProperties = completedProperties {
            var completedPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .completedProperties)
            for stringlist0 in completedProperties {
                try completedPropertiesContainer.encode(stringlist0)
            }
        }
        if let pendingProperties = pendingProperties {
            var pendingPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pendingProperties)
            for stringlist0 in pendingProperties {
                try pendingPropertiesContainer.encode(stringlist0)
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if totalNumberOfStages != 0 {
            try encodeContainer.encode(totalNumberOfStages, forKey: .totalNumberOfStages)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeId)
        changeId = changeIdDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OverallChangeStatus.self, forKey: .status)
        status = statusDecoded
        let pendingPropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pendingProperties)
        var pendingPropertiesDecoded0:[Swift.String]? = nil
        if let pendingPropertiesContainer = pendingPropertiesContainer {
            pendingPropertiesDecoded0 = [Swift.String]()
            for string0 in pendingPropertiesContainer {
                if let string0 = string0 {
                    pendingPropertiesDecoded0?.append(string0)
                }
            }
        }
        pendingProperties = pendingPropertiesDecoded0
        let completedPropertiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .completedProperties)
        var completedPropertiesDecoded0:[Swift.String]? = nil
        if let completedPropertiesContainer = completedPropertiesContainer {
            completedPropertiesDecoded0 = [Swift.String]()
            for string0 in completedPropertiesContainer {
                if let string0 = string0 {
                    completedPropertiesDecoded0?.append(string0)
                }
            }
        }
        completedProperties = completedPropertiesDecoded0
        let totalNumberOfStagesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNumberOfStages) ?? 0
        totalNumberOfStages = totalNumberOfStagesDecoded
        let changeProgressStagesContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.ChangeProgressStage?].self, forKey: .changeProgressStages)
        var changeProgressStagesDecoded0:[OpenSearchClientTypes.ChangeProgressStage]? = nil
        if let changeProgressStagesContainer = changeProgressStagesContainer {
            changeProgressStagesDecoded0 = [OpenSearchClientTypes.ChangeProgressStage]()
            for structure0 in changeProgressStagesContainer {
                if let structure0 = structure0 {
                    changeProgressStagesDecoded0?.append(structure0)
                }
            }
        }
        changeProgressStages = changeProgressStagesDecoded0
    }
}

extension OpenSearchClientTypes {
    /// The progress details of a specific domain configuration change.
    public struct ChangeProgressStatusDetails: Swift.Equatable {
        /// The unique change identifier associated with a specific domain configuration change.
        public var changeId: Swift.String?
        /// The specific stages that the domain is going through to perform the configuration change.
        public var changeProgressStages: [OpenSearchClientTypes.ChangeProgressStage]?
        /// The list of properties involved in the domain configuration change that are completed.
        public var completedProperties: [Swift.String]?
        /// The list of properties involved in the domain configuration change that are still in pending.
        public var pendingProperties: [Swift.String]?
        /// The time at which the configuration change is made on the domain.
        public var startTime: ClientRuntime.Date?
        /// The overall status of the domain configuration change. This field can take the following values: PENDING, PROCESSING, COMPLETED and FAILED
        public var status: OpenSearchClientTypes.OverallChangeStatus?
        /// The total number of stages required for the configuration change.
        public var totalNumberOfStages: Swift.Int

        public init (
            changeId: Swift.String? = nil,
            changeProgressStages: [OpenSearchClientTypes.ChangeProgressStage]? = nil,
            completedProperties: [Swift.String]? = nil,
            pendingProperties: [Swift.String]? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: OpenSearchClientTypes.OverallChangeStatus? = nil,
            totalNumberOfStages: Swift.Int = 0
        )
        {
            self.changeId = changeId
            self.changeProgressStages = changeProgressStages
            self.completedProperties = completedProperties
            self.pendingProperties = pendingProperties
            self.startTime = startTime
            self.status = status
            self.totalNumberOfStages = totalNumberOfStages
        }
    }

}

extension OpenSearchClientTypes.ClusterConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coldStorageOptions = "ColdStorageOptions"
        case dedicatedMasterCount = "DedicatedMasterCount"
        case dedicatedMasterEnabled = "DedicatedMasterEnabled"
        case dedicatedMasterType = "DedicatedMasterType"
        case instanceCount = "InstanceCount"
        case instanceType = "InstanceType"
        case warmCount = "WarmCount"
        case warmEnabled = "WarmEnabled"
        case warmType = "WarmType"
        case zoneAwarenessConfig = "ZoneAwarenessConfig"
        case zoneAwarenessEnabled = "ZoneAwarenessEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coldStorageOptions = self.coldStorageOptions {
            try encodeContainer.encode(coldStorageOptions, forKey: .coldStorageOptions)
        }
        if let dedicatedMasterCount = self.dedicatedMasterCount {
            try encodeContainer.encode(dedicatedMasterCount, forKey: .dedicatedMasterCount)
        }
        if let dedicatedMasterEnabled = self.dedicatedMasterEnabled {
            try encodeContainer.encode(dedicatedMasterEnabled, forKey: .dedicatedMasterEnabled)
        }
        if let dedicatedMasterType = self.dedicatedMasterType {
            try encodeContainer.encode(dedicatedMasterType.rawValue, forKey: .dedicatedMasterType)
        }
        if let instanceCount = self.instanceCount {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType.rawValue, forKey: .instanceType)
        }
        if let warmCount = self.warmCount {
            try encodeContainer.encode(warmCount, forKey: .warmCount)
        }
        if let warmEnabled = self.warmEnabled {
            try encodeContainer.encode(warmEnabled, forKey: .warmEnabled)
        }
        if let warmType = self.warmType {
            try encodeContainer.encode(warmType.rawValue, forKey: .warmType)
        }
        if let zoneAwarenessConfig = self.zoneAwarenessConfig {
            try encodeContainer.encode(zoneAwarenessConfig, forKey: .zoneAwarenessConfig)
        }
        if let zoneAwarenessEnabled = self.zoneAwarenessEnabled {
            try encodeContainer.encode(zoneAwarenessEnabled, forKey: .zoneAwarenessEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceTypeDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OpenSearchPartitionInstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount)
        instanceCount = instanceCountDecoded
        let dedicatedMasterEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dedicatedMasterEnabled)
        dedicatedMasterEnabled = dedicatedMasterEnabledDecoded
        let zoneAwarenessEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .zoneAwarenessEnabled)
        zoneAwarenessEnabled = zoneAwarenessEnabledDecoded
        let zoneAwarenessConfigDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ZoneAwarenessConfig.self, forKey: .zoneAwarenessConfig)
        zoneAwarenessConfig = zoneAwarenessConfigDecoded
        let dedicatedMasterTypeDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OpenSearchPartitionInstanceType.self, forKey: .dedicatedMasterType)
        dedicatedMasterType = dedicatedMasterTypeDecoded
        let dedicatedMasterCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dedicatedMasterCount)
        dedicatedMasterCount = dedicatedMasterCountDecoded
        let warmEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .warmEnabled)
        warmEnabled = warmEnabledDecoded
        let warmTypeDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OpenSearchWarmPartitionInstanceType.self, forKey: .warmType)
        warmType = warmTypeDecoded
        let warmCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .warmCount)
        warmCount = warmCountDecoded
        let coldStorageOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ColdStorageOptions.self, forKey: .coldStorageOptions)
        coldStorageOptions = coldStorageOptionsDecoded
    }
}

extension OpenSearchClientTypes {
    /// The configuration for the domain cluster, such as the type and number of instances.
    public struct ClusterConfig: Swift.Equatable {
        /// Specifies the ColdStorageOptions config for a Domain
        public var coldStorageOptions: OpenSearchClientTypes.ColdStorageOptions?
        /// Total number of dedicated master nodes, active and on standby, for the cluster.
        public var dedicatedMasterCount: Swift.Int?
        /// A boolean value to indicate whether a dedicated master node is enabled. See [Dedicated master nodes in Amazon OpenSearch Service ](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains.html#managedomains-dedicatedmasternodes) for more information.
        public var dedicatedMasterEnabled: Swift.Bool?
        /// The instance type for a dedicated master node.
        public var dedicatedMasterType: OpenSearchClientTypes.OpenSearchPartitionInstanceType?
        /// The number of instances in the specified domain cluster.
        public var instanceCount: Swift.Int?
        /// The instance type for an OpenSearch cluster. UltraWarm instance types are not supported for data instances.
        public var instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType?
        /// The number of UltraWarm nodes in the cluster.
        public var warmCount: Swift.Int?
        /// True to enable UltraWarm storage.
        public var warmEnabled: Swift.Bool?
        /// The instance type for the OpenSearch cluster's warm nodes.
        public var warmType: OpenSearchClientTypes.OpenSearchWarmPartitionInstanceType?
        /// The zone awareness configuration for a domain when zone awareness is enabled.
        public var zoneAwarenessConfig: OpenSearchClientTypes.ZoneAwarenessConfig?
        /// A boolean value to indicate whether zone awareness is enabled. See [Configuring a multi-AZ domain in Amazon OpenSearch Service ](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html) for more information.
        public var zoneAwarenessEnabled: Swift.Bool?

        public init (
            coldStorageOptions: OpenSearchClientTypes.ColdStorageOptions? = nil,
            dedicatedMasterCount: Swift.Int? = nil,
            dedicatedMasterEnabled: Swift.Bool? = nil,
            dedicatedMasterType: OpenSearchClientTypes.OpenSearchPartitionInstanceType? = nil,
            instanceCount: Swift.Int? = nil,
            instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType? = nil,
            warmCount: Swift.Int? = nil,
            warmEnabled: Swift.Bool? = nil,
            warmType: OpenSearchClientTypes.OpenSearchWarmPartitionInstanceType? = nil,
            zoneAwarenessConfig: OpenSearchClientTypes.ZoneAwarenessConfig? = nil,
            zoneAwarenessEnabled: Swift.Bool? = nil
        )
        {
            self.coldStorageOptions = coldStorageOptions
            self.dedicatedMasterCount = dedicatedMasterCount
            self.dedicatedMasterEnabled = dedicatedMasterEnabled
            self.dedicatedMasterType = dedicatedMasterType
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.warmCount = warmCount
            self.warmEnabled = warmEnabled
            self.warmType = warmType
            self.zoneAwarenessConfig = zoneAwarenessConfig
            self.zoneAwarenessEnabled = zoneAwarenessEnabled
        }
    }

}

extension OpenSearchClientTypes.ClusterConfigStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ClusterConfig.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchClientTypes {
    /// The configuration status for the specified domain.
    public struct ClusterConfigStatus: Swift.Equatable {
        /// The cluster configuration for the specified domain.
        /// This member is required.
        public var options: OpenSearchClientTypes.ClusterConfig?
        /// The cluster configuration status for the specified domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init (
            options: OpenSearchClientTypes.ClusterConfig? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes.CognitoOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case identityPoolId = "IdentityPoolId"
        case roleArn = "RoleArn"
        case userPoolId = "UserPoolId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let identityPoolId = self.identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let userPoolId = self.userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let userPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension OpenSearchClientTypes {
    /// Options to specify the Cognito user and identity pools for OpenSearch Dashboards authentication. For more information, see [Configuring Amazon Cognito authentication for OpenSearch Dashboards](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html).
    public struct CognitoOptions: Swift.Equatable {
        /// The option to enable Cognito for OpenSearch Dashboards authentication.
        public var enabled: Swift.Bool?
        /// The Cognito identity pool ID for OpenSearch Dashboards authentication.
        public var identityPoolId: Swift.String?
        /// The role ARN that provides OpenSearch permissions for accessing Cognito resources.
        public var roleArn: Swift.String?
        /// The Cognito user pool ID for OpenSearch Dashboards authentication.
        public var userPoolId: Swift.String?

        public init (
            enabled: Swift.Bool? = nil,
            identityPoolId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            userPoolId: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.identityPoolId = identityPoolId
            self.roleArn = roleArn
            self.userPoolId = userPoolId
        }
    }

}

extension OpenSearchClientTypes.CognitoOptionsStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.CognitoOptions.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchClientTypes {
    /// The status of the Cognito options for the specified domain.
    public struct CognitoOptionsStatus: Swift.Equatable {
        /// Cognito options for the specified domain.
        /// This member is required.
        public var options: OpenSearchClientTypes.CognitoOptions?
        /// The status of the Cognito options for the specified domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init (
            options: OpenSearchClientTypes.CognitoOptions? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes.ColdStorageOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension OpenSearchClientTypes {
    /// Specifies the configuration for cold storage options such as enabled
    public struct ColdStorageOptions: Swift.Equatable {
        /// Enable cold storage option. Accepted values true or false
        /// This member is required.
        public var enabled: Swift.Bool?

        public init (
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension OpenSearchClientTypes.CompatibleVersionsMap: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceVersion = "SourceVersion"
        case targetVersions = "TargetVersions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let targetVersions = targetVersions {
            var targetVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetVersions)
            for versionlist0 in targetVersions {
                try targetVersionsContainer.encode(versionlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let targetVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetVersions)
        var targetVersionsDecoded0:[Swift.String]? = nil
        if let targetVersionsContainer = targetVersionsContainer {
            targetVersionsDecoded0 = [Swift.String]()
            for string0 in targetVersionsContainer {
                if let string0 = string0 {
                    targetVersionsDecoded0?.append(string0)
                }
            }
        }
        targetVersions = targetVersionsDecoded0
    }
}

extension OpenSearchClientTypes {
    /// A map from an [EngineVersion] to a list of compatible [EngineVersion] s to which the domain can be upgraded.
    public struct CompatibleVersionsMap: Swift.Equatable {
        /// The current version of OpenSearch a domain is on.
        public var sourceVersion: Swift.String?
        /// List of supported OpenSearch versions.
        public var targetVersions: [Swift.String]?

        public init (
            sourceVersion: Swift.String? = nil,
            targetVersions: [Swift.String]? = nil
        )
        {
            self.sourceVersion = sourceVersion
            self.targetVersions = targetVersions
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occurred because the client attempts to remove a resource that is currently in use. Returns HTTP status code 409.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicies = "AccessPolicies"
        case advancedOptions = "AdvancedOptions"
        case advancedSecurityOptions = "AdvancedSecurityOptions"
        case autoTuneOptions = "AutoTuneOptions"
        case clusterConfig = "ClusterConfig"
        case cognitoOptions = "CognitoOptions"
        case domainEndpointOptions = "DomainEndpointOptions"
        case domainName = "DomainName"
        case eBSOptions = "EBSOptions"
        case encryptionAtRestOptions = "EncryptionAtRestOptions"
        case engineVersion = "EngineVersion"
        case logPublishingOptions = "LogPublishingOptions"
        case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
        case snapshotOptions = "SnapshotOptions"
        case tagList = "TagList"
        case vPCOptions = "VPCOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPolicies = self.accessPolicies {
            try encodeContainer.encode(accessPolicies, forKey: .accessPolicies)
        }
        if let advancedOptions = advancedOptions {
            var advancedOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .advancedOptions)
            for (dictKey0, advancedoptions0) in advancedOptions {
                try advancedOptionsContainer.encode(advancedoptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let advancedSecurityOptions = self.advancedSecurityOptions {
            try encodeContainer.encode(advancedSecurityOptions, forKey: .advancedSecurityOptions)
        }
        if let autoTuneOptions = self.autoTuneOptions {
            try encodeContainer.encode(autoTuneOptions, forKey: .autoTuneOptions)
        }
        if let clusterConfig = self.clusterConfig {
            try encodeContainer.encode(clusterConfig, forKey: .clusterConfig)
        }
        if let cognitoOptions = self.cognitoOptions {
            try encodeContainer.encode(cognitoOptions, forKey: .cognitoOptions)
        }
        if let domainEndpointOptions = self.domainEndpointOptions {
            try encodeContainer.encode(domainEndpointOptions, forKey: .domainEndpointOptions)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let eBSOptions = self.eBSOptions {
            try encodeContainer.encode(eBSOptions, forKey: .eBSOptions)
        }
        if let encryptionAtRestOptions = self.encryptionAtRestOptions {
            try encodeContainer.encode(encryptionAtRestOptions, forKey: .encryptionAtRestOptions)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let logPublishingOptions = logPublishingOptions {
            var logPublishingOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logPublishingOptions)
            for (dictKey0, logpublishingoptions0) in logPublishingOptions {
                try logPublishingOptionsContainer.encode(logpublishingoptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let nodeToNodeEncryptionOptions = self.nodeToNodeEncryptionOptions {
            try encodeContainer.encode(nodeToNodeEncryptionOptions, forKey: .nodeToNodeEncryptionOptions)
        }
        if let snapshotOptions = self.snapshotOptions {
            try encodeContainer.encode(snapshotOptions, forKey: .snapshotOptions)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
        if let vPCOptions = self.vPCOptions {
            try encodeContainer.encode(vPCOptions, forKey: .vPCOptions)
        }
    }
}

extension CreateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/opensearch/domain"
    }
}

public struct CreateDomainInput: Swift.Equatable {
    /// IAM access policy as a JSON-formatted string.
    public var accessPolicies: Swift.String?
    /// Option to allow references to indices in an HTTP request body. Must be false when configuring access to individual sub-resources. By default, the value is true. See [Advanced cluster parameters ](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options) for more information.
    public var advancedOptions: [Swift.String:Swift.String]?
    /// Specifies advanced security options.
    public var advancedSecurityOptions: OpenSearchClientTypes.AdvancedSecurityOptionsInput?
    /// Specifies Auto-Tune options.
    public var autoTuneOptions: OpenSearchClientTypes.AutoTuneOptionsInput?
    /// Configuration options for a domain. Specifies the instance type and number of instances in the domain.
    public var clusterConfig: OpenSearchClientTypes.ClusterConfig?
    /// Options to specify the Cognito user and identity pools for OpenSearch Dashboards authentication. For more information, see [Configuring Amazon Cognito authentication for OpenSearch Dashboards](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html).
    public var cognitoOptions: OpenSearchClientTypes.CognitoOptions?
    /// Options to specify configurations that will be applied to the domain endpoint.
    public var domainEndpointOptions: OpenSearchClientTypes.DomainEndpointOptions?
    /// The name of the Amazon OpenSearch Service domain you're creating. Domain names are unique across the domains owned by an account within an AWS region. Domain names must start with a lowercase letter and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// Options to enable, disable, and specify the type and size of EBS storage volumes.
    public var eBSOptions: OpenSearchClientTypes.EBSOptions?
    /// Options for encryption of data at rest.
    public var encryptionAtRestOptions: OpenSearchClientTypes.EncryptionAtRestOptions?
    /// String of format Elasticsearch_X.Y or OpenSearch_X.Y to specify the engine version for the Amazon OpenSearch Service domain. For example, "OpenSearch_1.0" or "Elasticsearch_7.9". For more information, see [Creating and managing Amazon OpenSearch Service domains ](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomains).
    public var engineVersion: Swift.String?
    /// Map of LogType and LogPublishingOption, each containing options to publish a given type of OpenSearch log.
    public var logPublishingOptions: [Swift.String:OpenSearchClientTypes.LogPublishingOption]?
    /// Node-to-node encryption options.
    public var nodeToNodeEncryptionOptions: OpenSearchClientTypes.NodeToNodeEncryptionOptions?
    /// Option to set time, in UTC format, of the daily automated snapshot. Default value is 0 hours.
    public var snapshotOptions: OpenSearchClientTypes.SnapshotOptions?
    /// A list of Tag added during domain creation.
    public var tagList: [OpenSearchClientTypes.Tag]?
    /// Options to specify the subnets and security groups for a VPC endpoint. For more information, see [Launching your Amazon OpenSearch Service domains using a VPC ](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html).
    public var vPCOptions: OpenSearchClientTypes.VPCOptions?

    public init (
        accessPolicies: Swift.String? = nil,
        advancedOptions: [Swift.String:Swift.String]? = nil,
        advancedSecurityOptions: OpenSearchClientTypes.AdvancedSecurityOptionsInput? = nil,
        autoTuneOptions: OpenSearchClientTypes.AutoTuneOptionsInput? = nil,
        clusterConfig: OpenSearchClientTypes.ClusterConfig? = nil,
        cognitoOptions: OpenSearchClientTypes.CognitoOptions? = nil,
        domainEndpointOptions: OpenSearchClientTypes.DomainEndpointOptions? = nil,
        domainName: Swift.String? = nil,
        eBSOptions: OpenSearchClientTypes.EBSOptions? = nil,
        encryptionAtRestOptions: OpenSearchClientTypes.EncryptionAtRestOptions? = nil,
        engineVersion: Swift.String? = nil,
        logPublishingOptions: [Swift.String:OpenSearchClientTypes.LogPublishingOption]? = nil,
        nodeToNodeEncryptionOptions: OpenSearchClientTypes.NodeToNodeEncryptionOptions? = nil,
        snapshotOptions: OpenSearchClientTypes.SnapshotOptions? = nil,
        tagList: [OpenSearchClientTypes.Tag]? = nil,
        vPCOptions: OpenSearchClientTypes.VPCOptions? = nil
    )
    {
        self.accessPolicies = accessPolicies
        self.advancedOptions = advancedOptions
        self.advancedSecurityOptions = advancedSecurityOptions
        self.autoTuneOptions = autoTuneOptions
        self.clusterConfig = clusterConfig
        self.cognitoOptions = cognitoOptions
        self.domainEndpointOptions = domainEndpointOptions
        self.domainName = domainName
        self.eBSOptions = eBSOptions
        self.encryptionAtRestOptions = encryptionAtRestOptions
        self.engineVersion = engineVersion
        self.logPublishingOptions = logPublishingOptions
        self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
        self.snapshotOptions = snapshotOptions
        self.tagList = tagList
        self.vPCOptions = vPCOptions
    }
}

struct CreateDomainInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let engineVersion: Swift.String?
    let clusterConfig: OpenSearchClientTypes.ClusterConfig?
    let eBSOptions: OpenSearchClientTypes.EBSOptions?
    let accessPolicies: Swift.String?
    let snapshotOptions: OpenSearchClientTypes.SnapshotOptions?
    let vPCOptions: OpenSearchClientTypes.VPCOptions?
    let cognitoOptions: OpenSearchClientTypes.CognitoOptions?
    let encryptionAtRestOptions: OpenSearchClientTypes.EncryptionAtRestOptions?
    let nodeToNodeEncryptionOptions: OpenSearchClientTypes.NodeToNodeEncryptionOptions?
    let advancedOptions: [Swift.String:Swift.String]?
    let logPublishingOptions: [Swift.String:OpenSearchClientTypes.LogPublishingOption]?
    let domainEndpointOptions: OpenSearchClientTypes.DomainEndpointOptions?
    let advancedSecurityOptions: OpenSearchClientTypes.AdvancedSecurityOptionsInput?
    let tagList: [OpenSearchClientTypes.Tag]?
    let autoTuneOptions: OpenSearchClientTypes.AutoTuneOptionsInput?
}

extension CreateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicies = "AccessPolicies"
        case advancedOptions = "AdvancedOptions"
        case advancedSecurityOptions = "AdvancedSecurityOptions"
        case autoTuneOptions = "AutoTuneOptions"
        case clusterConfig = "ClusterConfig"
        case cognitoOptions = "CognitoOptions"
        case domainEndpointOptions = "DomainEndpointOptions"
        case domainName = "DomainName"
        case eBSOptions = "EBSOptions"
        case encryptionAtRestOptions = "EncryptionAtRestOptions"
        case engineVersion = "EngineVersion"
        case logPublishingOptions = "LogPublishingOptions"
        case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
        case snapshotOptions = "SnapshotOptions"
        case tagList = "TagList"
        case vPCOptions = "VPCOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let clusterConfigDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ClusterConfig.self, forKey: .clusterConfig)
        clusterConfig = clusterConfigDecoded
        let eBSOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.EBSOptions.self, forKey: .eBSOptions)
        eBSOptions = eBSOptionsDecoded
        let accessPoliciesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicies)
        accessPolicies = accessPoliciesDecoded
        let snapshotOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.SnapshotOptions.self, forKey: .snapshotOptions)
        snapshotOptions = snapshotOptionsDecoded
        let vPCOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.VPCOptions.self, forKey: .vPCOptions)
        vPCOptions = vPCOptionsDecoded
        let cognitoOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.CognitoOptions.self, forKey: .cognitoOptions)
        cognitoOptions = cognitoOptionsDecoded
        let encryptionAtRestOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.EncryptionAtRestOptions.self, forKey: .encryptionAtRestOptions)
        encryptionAtRestOptions = encryptionAtRestOptionsDecoded
        let nodeToNodeEncryptionOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.NodeToNodeEncryptionOptions.self, forKey: .nodeToNodeEncryptionOptions)
        nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptionsDecoded
        let advancedOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .advancedOptions)
        var advancedOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let advancedOptionsContainer = advancedOptionsContainer {
            advancedOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in advancedOptionsContainer {
                if let string0 = string0 {
                    advancedOptionsDecoded0?[key0] = string0
                }
            }
        }
        advancedOptions = advancedOptionsDecoded0
        let logPublishingOptionsContainer = try containerValues.decodeIfPresent([Swift.String: OpenSearchClientTypes.LogPublishingOption?].self, forKey: .logPublishingOptions)
        var logPublishingOptionsDecoded0: [Swift.String:OpenSearchClientTypes.LogPublishingOption]? = nil
        if let logPublishingOptionsContainer = logPublishingOptionsContainer {
            logPublishingOptionsDecoded0 = [Swift.String:OpenSearchClientTypes.LogPublishingOption]()
            for (key0, logpublishingoption0) in logPublishingOptionsContainer {
                if let logpublishingoption0 = logpublishingoption0 {
                    logPublishingOptionsDecoded0?[key0] = logpublishingoption0
                }
            }
        }
        logPublishingOptions = logPublishingOptionsDecoded0
        let domainEndpointOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainEndpointOptions.self, forKey: .domainEndpointOptions)
        domainEndpointOptions = domainEndpointOptionsDecoded
        let advancedSecurityOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AdvancedSecurityOptionsInput.self, forKey: .advancedSecurityOptions)
        advancedSecurityOptions = advancedSecurityOptionsDecoded
        let tagListContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[OpenSearchClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [OpenSearchClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
        let autoTuneOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AutoTuneOptionsInput.self, forKey: .autoTuneOptions)
        autoTuneOptions = autoTuneOptionsDecoded
    }
}

extension CreateDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDomainOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainStatus = output.domainStatus
        } else {
            self.domainStatus = nil
        }
    }
}

/// The result of a CreateDomain operation. Contains the status of the newly created Amazon OpenSearch Service domain.
public struct CreateDomainOutputResponse: Swift.Equatable {
    /// The status of the newly created domain.
    public var domainStatus: OpenSearchClientTypes.DomainStatus?

    public init (
        domainStatus: OpenSearchClientTypes.DomainStatus? = nil
    )
    {
        self.domainStatus = domainStatus
    }
}

struct CreateDomainOutputResponseBody: Swift.Equatable {
    let domainStatus: OpenSearchClientTypes.DomainStatus?
}

extension CreateDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainStatus = "DomainStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainStatusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
    }
}

extension CreateOutboundConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionAlias = "ConnectionAlias"
        case localDomainInfo = "LocalDomainInfo"
        case remoteDomainInfo = "RemoteDomainInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionAlias = self.connectionAlias {
            try encodeContainer.encode(connectionAlias, forKey: .connectionAlias)
        }
        if let localDomainInfo = self.localDomainInfo {
            try encodeContainer.encode(localDomainInfo, forKey: .localDomainInfo)
        }
        if let remoteDomainInfo = self.remoteDomainInfo {
            try encodeContainer.encode(remoteDomainInfo, forKey: .remoteDomainInfo)
        }
    }
}

extension CreateOutboundConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/opensearch/cc/outboundConnection"
    }
}

/// Container for the parameters to the [CreateOutboundConnection] operation.
public struct CreateOutboundConnectionInput: Swift.Equatable {
    /// The connection alias used used by the customer for this cross-cluster connection.
    /// This member is required.
    public var connectionAlias: Swift.String?
    /// The [AWSDomainInformation] for the local OpenSearch domain.
    /// This member is required.
    public var localDomainInfo: OpenSearchClientTypes.DomainInformationContainer?
    /// The [AWSDomainInformation] for the remote OpenSearch domain.
    /// This member is required.
    public var remoteDomainInfo: OpenSearchClientTypes.DomainInformationContainer?

    public init (
        connectionAlias: Swift.String? = nil,
        localDomainInfo: OpenSearchClientTypes.DomainInformationContainer? = nil,
        remoteDomainInfo: OpenSearchClientTypes.DomainInformationContainer? = nil
    )
    {
        self.connectionAlias = connectionAlias
        self.localDomainInfo = localDomainInfo
        self.remoteDomainInfo = remoteDomainInfo
    }
}

struct CreateOutboundConnectionInputBody: Swift.Equatable {
    let localDomainInfo: OpenSearchClientTypes.DomainInformationContainer?
    let remoteDomainInfo: OpenSearchClientTypes.DomainInformationContainer?
    let connectionAlias: Swift.String?
}

extension CreateOutboundConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionAlias = "ConnectionAlias"
        case localDomainInfo = "LocalDomainInfo"
        case remoteDomainInfo = "RemoteDomainInfo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localDomainInfoDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainInformationContainer.self, forKey: .localDomainInfo)
        localDomainInfo = localDomainInfoDecoded
        let remoteDomainInfoDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainInformationContainer.self, forKey: .remoteDomainInfo)
        remoteDomainInfo = remoteDomainInfoDecoded
        let connectionAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionAlias)
        connectionAlias = connectionAliasDecoded
    }
}

extension CreateOutboundConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateOutboundConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOutboundConnectionOutputError: Swift.Error, Swift.Equatable {
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOutboundConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateOutboundConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionAlias = output.connectionAlias
            self.connectionId = output.connectionId
            self.connectionStatus = output.connectionStatus
            self.localDomainInfo = output.localDomainInfo
            self.remoteDomainInfo = output.remoteDomainInfo
        } else {
            self.connectionAlias = nil
            self.connectionId = nil
            self.connectionStatus = nil
            self.localDomainInfo = nil
            self.remoteDomainInfo = nil
        }
    }
}

/// The result of a [CreateOutboundConnection] request. Contains the details about the newly created cross-cluster connection.
public struct CreateOutboundConnectionOutputResponse: Swift.Equatable {
    /// The connection alias provided during the create connection request.
    public var connectionAlias: Swift.String?
    /// The unique ID for the created outbound connection, which is used for subsequent operations on the connection.
    public var connectionId: Swift.String?
    /// The [OutboundConnectionStatus] for the newly created connection.
    public var connectionStatus: OpenSearchClientTypes.OutboundConnectionStatus?
    /// The [AWSDomainInformation] for the local OpenSearch domain.
    public var localDomainInfo: OpenSearchClientTypes.DomainInformationContainer?
    /// The [AWSDomainInformation] for the remote OpenSearch domain.
    public var remoteDomainInfo: OpenSearchClientTypes.DomainInformationContainer?

    public init (
        connectionAlias: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionStatus: OpenSearchClientTypes.OutboundConnectionStatus? = nil,
        localDomainInfo: OpenSearchClientTypes.DomainInformationContainer? = nil,
        remoteDomainInfo: OpenSearchClientTypes.DomainInformationContainer? = nil
    )
    {
        self.connectionAlias = connectionAlias
        self.connectionId = connectionId
        self.connectionStatus = connectionStatus
        self.localDomainInfo = localDomainInfo
        self.remoteDomainInfo = remoteDomainInfo
    }
}

struct CreateOutboundConnectionOutputResponseBody: Swift.Equatable {
    let localDomainInfo: OpenSearchClientTypes.DomainInformationContainer?
    let remoteDomainInfo: OpenSearchClientTypes.DomainInformationContainer?
    let connectionAlias: Swift.String?
    let connectionStatus: OpenSearchClientTypes.OutboundConnectionStatus?
    let connectionId: Swift.String?
}

extension CreateOutboundConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionAlias = "ConnectionAlias"
        case connectionId = "ConnectionId"
        case connectionStatus = "ConnectionStatus"
        case localDomainInfo = "LocalDomainInfo"
        case remoteDomainInfo = "RemoteDomainInfo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localDomainInfoDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainInformationContainer.self, forKey: .localDomainInfo)
        localDomainInfo = localDomainInfoDecoded
        let remoteDomainInfoDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainInformationContainer.self, forKey: .remoteDomainInfo)
        remoteDomainInfo = remoteDomainInfoDecoded
        let connectionAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionAlias)
        connectionAlias = connectionAliasDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OutboundConnectionStatus.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
    }
}

extension CreatePackageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageDescription = "PackageDescription"
        case packageName = "PackageName"
        case packageSource = "PackageSource"
        case packageType = "PackageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let packageDescription = self.packageDescription {
            try encodeContainer.encode(packageDescription, forKey: .packageDescription)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let packageSource = self.packageSource {
            try encodeContainer.encode(packageSource, forKey: .packageSource)
        }
        if let packageType = self.packageType {
            try encodeContainer.encode(packageType.rawValue, forKey: .packageType)
        }
    }
}

extension CreatePackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/packages"
    }
}

/// Container for request parameters to the [CreatePackage] operation.
public struct CreatePackageInput: Swift.Equatable {
    /// Description of the package.
    public var packageDescription: Swift.String?
    /// Unique identifier for the package.
    /// This member is required.
    public var packageName: Swift.String?
    /// The Amazon S3 location from which to import the package.
    /// This member is required.
    public var packageSource: OpenSearchClientTypes.PackageSource?
    /// Type of package. Currently supports only TXT-DICTIONARY.
    /// This member is required.
    public var packageType: OpenSearchClientTypes.PackageType?

    public init (
        packageDescription: Swift.String? = nil,
        packageName: Swift.String? = nil,
        packageSource: OpenSearchClientTypes.PackageSource? = nil,
        packageType: OpenSearchClientTypes.PackageType? = nil
    )
    {
        self.packageDescription = packageDescription
        self.packageName = packageName
        self.packageSource = packageSource
        self.packageType = packageType
    }
}

struct CreatePackageInputBody: Swift.Equatable {
    let packageName: Swift.String?
    let packageType: OpenSearchClientTypes.PackageType?
    let packageDescription: Swift.String?
    let packageSource: OpenSearchClientTypes.PackageSource?
}

extension CreatePackageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageDescription = "PackageDescription"
        case packageName = "PackageName"
        case packageSource = "PackageSource"
        case packageType = "PackageType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageTypeDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let packageDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageDescription)
        packageDescription = packageDescriptionDecoded
        let packageSourceDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.PackageSource.self, forKey: .packageSource)
        packageSource = packageSourceDecoded
    }
}

extension CreatePackageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePackageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePackageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePackageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePackageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.packageDetails = output.packageDetails
        } else {
            self.packageDetails = nil
        }
    }
}

/// Container for the response returned by the [CreatePackage] operation.
public struct CreatePackageOutputResponse: Swift.Equatable {
    /// Information about the package.
    public var packageDetails: OpenSearchClientTypes.PackageDetails?

    public init (
        packageDetails: OpenSearchClientTypes.PackageDetails? = nil
    )
    {
        self.packageDetails = packageDetails
    }
}

struct CreatePackageOutputResponseBody: Swift.Equatable {
    let packageDetails: OpenSearchClientTypes.PackageDetails?
}

extension CreatePackageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageDetails = "PackageDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageDetailsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.PackageDetails.self, forKey: .packageDetails)
        packageDetails = packageDetailsDecoded
    }
}

extension DeleteDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())"
    }
}

/// Container for the parameters to the [DeleteDomain] operation. Specifies the name of the domain you want to delete.
public struct DeleteDomainInput: Swift.Equatable {
    /// The name of the domain you want to permanently delete.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DeleteDomainInputBody: Swift.Equatable {
}

extension DeleteDomainInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainStatus = output.domainStatus
        } else {
            self.domainStatus = nil
        }
    }
}

/// The result of a DeleteDomain request. Contains the status of the pending deletion, or a "domain not found" error if the domain and all of its resources have been deleted.
public struct DeleteDomainOutputResponse: Swift.Equatable {
    /// The status of the domain being deleted.
    public var domainStatus: OpenSearchClientTypes.DomainStatus?

    public init (
        domainStatus: OpenSearchClientTypes.DomainStatus? = nil
    )
    {
        self.domainStatus = domainStatus
    }
}

struct DeleteDomainOutputResponseBody: Swift.Equatable {
    let domainStatus: OpenSearchClientTypes.DomainStatus?
}

extension DeleteDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainStatus = "DomainStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainStatusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
    }
}

extension DeleteInboundConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectionId = connectionId else {
            return nil
        }
        return "/2021-01-01/opensearch/cc/inboundConnection/\(connectionId.urlPercentEncoding())"
    }
}

/// Container for the parameters to the [DeleteInboundConnection] operation.
public struct DeleteInboundConnectionInput: Swift.Equatable {
    /// The ID of the inbound connection to permanently delete.
    /// This member is required.
    public var connectionId: Swift.String?

    public init (
        connectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

struct DeleteInboundConnectionInputBody: Swift.Equatable {
}

extension DeleteInboundConnectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteInboundConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInboundConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInboundConnectionOutputError: Swift.Error, Swift.Equatable {
    case disabledOperationException(DisabledOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInboundConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteInboundConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

/// The result of a [DeleteInboundConnection] operation. Contains details about the deleted inbound connection.
public struct DeleteInboundConnectionOutputResponse: Swift.Equatable {
    /// The [InboundConnection] of the deleted inbound connection.
    public var connection: OpenSearchClientTypes.InboundConnection?

    public init (
        connection: OpenSearchClientTypes.InboundConnection? = nil
    )
    {
        self.connection = connection
    }
}

struct DeleteInboundConnectionOutputResponseBody: Swift.Equatable {
    let connection: OpenSearchClientTypes.InboundConnection?
}

extension DeleteInboundConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.InboundConnection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

extension DeleteOutboundConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectionId = connectionId else {
            return nil
        }
        return "/2021-01-01/opensearch/cc/outboundConnection/\(connectionId.urlPercentEncoding())"
    }
}

/// Container for the parameters to the [DeleteOutboundConnection] operation.
public struct DeleteOutboundConnectionInput: Swift.Equatable {
    /// The ID of the outbound connection you want to permanently delete.
    /// This member is required.
    public var connectionId: Swift.String?

    public init (
        connectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

struct DeleteOutboundConnectionInputBody: Swift.Equatable {
}

extension DeleteOutboundConnectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteOutboundConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOutboundConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOutboundConnectionOutputError: Swift.Error, Swift.Equatable {
    case disabledOperationException(DisabledOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOutboundConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteOutboundConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

/// The result of a [DeleteOutboundConnection] operation. Contains details about the deleted outbound connection.
public struct DeleteOutboundConnectionOutputResponse: Swift.Equatable {
    /// The [OutboundConnection] of the deleted outbound connection.
    public var connection: OpenSearchClientTypes.OutboundConnection?

    public init (
        connection: OpenSearchClientTypes.OutboundConnection? = nil
    )
    {
        self.connection = connection
    }
}

struct DeleteOutboundConnectionOutputResponseBody: Swift.Equatable {
    let connection: OpenSearchClientTypes.OutboundConnection?
}

extension DeleteOutboundConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OutboundConnection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

extension DeletePackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageID = packageID else {
            return nil
        }
        return "/2021-01-01/packages/\(packageID.urlPercentEncoding())"
    }
}

/// Container for the request parameters to the [DeletePackage] operation.
public struct DeletePackageInput: Swift.Equatable {
    /// The internal ID of the package you want to delete. Use DescribePackages to find this value.
    /// This member is required.
    public var packageID: Swift.String?

    public init (
        packageID: Swift.String? = nil
    )
    {
        self.packageID = packageID
    }
}

struct DeletePackageInputBody: Swift.Equatable {
}

extension DeletePackageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePackageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePackageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePackageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case baseException(BaseException)
    case conflictException(ConflictException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePackageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeletePackageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.packageDetails = output.packageDetails
        } else {
            self.packageDetails = nil
        }
    }
}

/// Container for the response parameters to the [DeletePackage] operation.
public struct DeletePackageOutputResponse: Swift.Equatable {
    ///     PackageDetails
    public var packageDetails: OpenSearchClientTypes.PackageDetails?

    public init (
        packageDetails: OpenSearchClientTypes.PackageDetails? = nil
    )
    {
        self.packageDetails = packageDetails
    }
}

struct DeletePackageOutputResponseBody: Swift.Equatable {
    let packageDetails: OpenSearchClientTypes.PackageDetails?
}

extension DeletePackageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageDetails = "PackageDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageDetailsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.PackageDetails.self, forKey: .packageDetails)
        packageDetails = packageDetailsDecoded
    }
}

extension OpenSearchClientTypes {
    public enum DeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case eligible
        case inProgress
        case notEligible
        case pendingUpdate
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .completed,
                .eligible,
                .inProgress,
                .notEligible,
                .pendingUpdate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .eligible: return "ELIGIBLE"
            case .inProgress: return "IN_PROGRESS"
            case .notEligible: return "NOT_ELIGIBLE"
            case .pendingUpdate: return "PENDING_UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentStatus(rawValue: rawValue) ?? DeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension DescribeDomainAutoTunesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeDomainAutoTunesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/autoTunes"
    }
}

/// Container for the parameters to the DescribeDomainAutoTunes operation.
public struct DescribeDomainAutoTunesInput: Swift.Equatable {
    /// The domain name for which you want Auto-Tune action details.
    /// This member is required.
    public var domainName: Swift.String?
    /// Set this value to limit the number of results returned. If not specified, defaults to 100.
    public var maxResults: Swift.Int
    /// NextToken is sent in case the earlier API call results contain the NextToken. Used for pagination.
    public var nextToken: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeDomainAutoTunesInputBody: Swift.Equatable {
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeDomainAutoTunesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDomainAutoTunesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDomainAutoTunesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDomainAutoTunesOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainAutoTunesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDomainAutoTunesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoTunes = output.autoTunes
            self.nextToken = output.nextToken
        } else {
            self.autoTunes = nil
            self.nextToken = nil
        }
    }
}

/// The result of a DescribeDomainAutoTunes request. See [ Auto-Tune for Amazon OpenSearch Service ](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html) for more information.
public struct DescribeDomainAutoTunesOutputResponse: Swift.Equatable {
    /// The list of setting adjustments that Auto-Tune has made to the domain. See [ Auto-Tune for Amazon OpenSearch Service ](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html) for more information.
    public var autoTunes: [OpenSearchClientTypes.AutoTune]?
    /// An identifier to allow retrieval of paginated results.
    public var nextToken: Swift.String?

    public init (
        autoTunes: [OpenSearchClientTypes.AutoTune]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.autoTunes = autoTunes
        self.nextToken = nextToken
    }
}

struct DescribeDomainAutoTunesOutputResponseBody: Swift.Equatable {
    let autoTunes: [OpenSearchClientTypes.AutoTune]?
    let nextToken: Swift.String?
}

extension DescribeDomainAutoTunesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoTunes = "AutoTunes"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoTunesContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.AutoTune?].self, forKey: .autoTunes)
        var autoTunesDecoded0:[OpenSearchClientTypes.AutoTune]? = nil
        if let autoTunesContainer = autoTunesContainer {
            autoTunesDecoded0 = [OpenSearchClientTypes.AutoTune]()
            for structure0 in autoTunesContainer {
                if let structure0 = structure0 {
                    autoTunesDecoded0?.append(structure0)
                }
            }
        }
        autoTunes = autoTunesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDomainChangeProgressInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let changeId = changeId {
            let changeIdQueryItem = ClientRuntime.URLQueryItem(name: "changeid".urlPercentEncoding(), value: Swift.String(changeId).urlPercentEncoding())
            items.append(changeIdQueryItem)
        }
        return items
    }
}

extension DescribeDomainChangeProgressInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/progress"
    }
}

/// Container for the parameters to the DescribeDomainChangeProgress operation. Specifies the domain name and optional change specific identity for which you want progress information.
public struct DescribeDomainChangeProgressInput: Swift.Equatable {
    /// The specific change ID for which you want to get progress information. This is an optional parameter. If omitted, the service returns information about the most recent configuration change.
    public var changeId: Swift.String?
    /// The domain you want to get the progress information about.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        changeId: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.changeId = changeId
        self.domainName = domainName
    }
}

struct DescribeDomainChangeProgressInputBody: Swift.Equatable {
}

extension DescribeDomainChangeProgressInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDomainChangeProgressOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDomainChangeProgressOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDomainChangeProgressOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainChangeProgressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDomainChangeProgressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.changeProgressStatus = output.changeProgressStatus
        } else {
            self.changeProgressStatus = nil
        }
    }
}

/// The result of a DescribeDomainChangeProgress request. Contains the progress information of the requested domain change.
public struct DescribeDomainChangeProgressOutputResponse: Swift.Equatable {
    /// Progress information for the configuration change that is requested in the DescribeDomainChangeProgress request.
    public var changeProgressStatus: OpenSearchClientTypes.ChangeProgressStatusDetails?

    public init (
        changeProgressStatus: OpenSearchClientTypes.ChangeProgressStatusDetails? = nil
    )
    {
        self.changeProgressStatus = changeProgressStatus
    }
}

struct DescribeDomainChangeProgressOutputResponseBody: Swift.Equatable {
    let changeProgressStatus: OpenSearchClientTypes.ChangeProgressStatusDetails?
}

extension DescribeDomainChangeProgressOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeProgressStatus = "ChangeProgressStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeProgressStatusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ChangeProgressStatusDetails.self, forKey: .changeProgressStatus)
        changeProgressStatus = changeProgressStatusDecoded
    }
}

extension DescribeDomainConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/config"
    }
}

/// Container for the parameters to the DescribeDomainConfig operation. Specifies the domain name for which you want configuration information.
public struct DescribeDomainConfigInput: Swift.Equatable {
    /// The domain you want to get information about.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DescribeDomainConfigInputBody: Swift.Equatable {
}

extension DescribeDomainConfigInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDomainConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDomainConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDomainConfigOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDomainConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainConfig = output.domainConfig
        } else {
            self.domainConfig = nil
        }
    }
}

/// The result of a DescribeDomainConfig request. Contains the configuration information of the requested domain.
public struct DescribeDomainConfigOutputResponse: Swift.Equatable {
    /// The configuration information of the domain requested in the DescribeDomainConfig request.
    /// This member is required.
    public var domainConfig: OpenSearchClientTypes.DomainConfig?

    public init (
        domainConfig: OpenSearchClientTypes.DomainConfig? = nil
    )
    {
        self.domainConfig = domainConfig
    }
}

struct DescribeDomainConfigOutputResponseBody: Swift.Equatable {
    let domainConfig: OpenSearchClientTypes.DomainConfig?
}

extension DescribeDomainConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainConfig = "DomainConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainConfigDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainConfig.self, forKey: .domainConfig)
        domainConfig = domainConfigDecoded
    }
}

extension DescribeDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())"
    }
}

/// Container for the parameters to the [DescribeDomain] operation.
public struct DescribeDomainInput: Swift.Equatable {
    /// The name of the domain for which you want information.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DescribeDomainInputBody: Swift.Equatable {
}

extension DescribeDomainInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDomainOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainStatus = output.domainStatus
        } else {
            self.domainStatus = nil
        }
    }
}

/// The result of a DescribeDomain request. Contains the status of the domain specified in the request.
public struct DescribeDomainOutputResponse: Swift.Equatable {
    /// The current status of the domain.
    /// This member is required.
    public var domainStatus: OpenSearchClientTypes.DomainStatus?

    public init (
        domainStatus: OpenSearchClientTypes.DomainStatus? = nil
    )
    {
        self.domainStatus = domainStatus
    }
}

struct DescribeDomainOutputResponseBody: Swift.Equatable {
    let domainStatus: OpenSearchClientTypes.DomainStatus?
}

extension DescribeDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainStatus = "DomainStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainStatusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
    }
}

extension DescribeDomainsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNames = "DomainNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainNames = domainNames {
            var domainNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainNames)
            for domainnamelist0 in domainNames {
                try domainNamesContainer.encode(domainnamelist0)
            }
        }
    }
}

extension DescribeDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/opensearch/domain-info"
    }
}

/// Container for the parameters to the [DescribeDomains] operation. By default, the API returns the status of all domains.
public struct DescribeDomainsInput: Swift.Equatable {
    /// The domains for which you want information.
    /// This member is required.
    public var domainNames: [Swift.String]?

    public init (
        domainNames: [Swift.String]? = nil
    )
    {
        self.domainNames = domainNames
    }
}

struct DescribeDomainsInputBody: Swift.Equatable {
    let domainNames: [Swift.String]?
}

extension DescribeDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNames = "DomainNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .domainNames)
        var domainNamesDecoded0:[Swift.String]? = nil
        if let domainNamesContainer = domainNamesContainer {
            domainNamesDecoded0 = [Swift.String]()
            for string0 in domainNamesContainer {
                if let string0 = string0 {
                    domainNamesDecoded0?.append(string0)
                }
            }
        }
        domainNames = domainNamesDecoded0
    }
}

extension DescribeDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDomainsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainStatusList = output.domainStatusList
        } else {
            self.domainStatusList = nil
        }
    }
}

/// The result of a DescribeDomains request. Contains the status of the specified domains or all domains owned by the account.
public struct DescribeDomainsOutputResponse: Swift.Equatable {
    /// The status of the domains requested in the DescribeDomains request.
    /// This member is required.
    public var domainStatusList: [OpenSearchClientTypes.DomainStatus]?

    public init (
        domainStatusList: [OpenSearchClientTypes.DomainStatus]? = nil
    )
    {
        self.domainStatusList = domainStatusList
    }
}

struct DescribeDomainsOutputResponseBody: Swift.Equatable {
    let domainStatusList: [OpenSearchClientTypes.DomainStatus]?
}

extension DescribeDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainStatusList = "DomainStatusList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainStatusListContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.DomainStatus?].self, forKey: .domainStatusList)
        var domainStatusListDecoded0:[OpenSearchClientTypes.DomainStatus]? = nil
        if let domainStatusListContainer = domainStatusListContainer {
            domainStatusListDecoded0 = [OpenSearchClientTypes.DomainStatus]()
            for structure0 in domainStatusListContainer {
                if let structure0 = structure0 {
                    domainStatusListDecoded0?.append(structure0)
                }
            }
        }
        domainStatusList = domainStatusListDecoded0
    }
}

extension DescribeInboundConnectionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeInboundConnectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/opensearch/cc/inboundConnection/search"
    }
}

/// Container for the parameters to the [DescribeInboundConnections] operation.
public struct DescribeInboundConnectionsInput: Swift.Equatable {
    /// A list of filters used to match properties for inbound cross-cluster connections. Available [Filter] values are:
    ///
    /// * connection-id
    ///
    /// * local-domain-info.domain-name
    ///
    /// * local-domain-info.owner-id
    ///
    /// * local-domain-info.region
    ///
    /// * remote-domain-info.domain-name
    public var filters: [OpenSearchClientTypes.Filter]?
    /// Set this value to limit the number of results returned. If not specified, defaults to 100.
    public var maxResults: Swift.Int
    /// If more results are available and NextToken is present, make the next request to the same API with the received NextToken to paginate the remaining results.
    public var nextToken: Swift.String?

    public init (
        filters: [OpenSearchClientTypes.Filter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeInboundConnectionsInputBody: Swift.Equatable {
    let filters: [OpenSearchClientTypes.Filter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeInboundConnectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[OpenSearchClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [OpenSearchClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeInboundConnectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInboundConnectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInboundConnectionsOutputError: Swift.Error, Swift.Equatable {
    case disabledOperationException(DisabledOperationException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInboundConnectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInboundConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connections = output.connections
            self.nextToken = output.nextToken
        } else {
            self.connections = nil
            self.nextToken = nil
        }
    }
}

/// The result of a [DescribeInboundConnections] request. Contains a list of connections matching the filter criteria.
public struct DescribeInboundConnectionsOutputResponse: Swift.Equatable {
    /// A list of [InboundConnection] matching the specified filter criteria.
    public var connections: [OpenSearchClientTypes.InboundConnection]?
    /// If more results are available and NextToken is present, make the next request to the same API with the received NextToken to paginate the remaining results.
    public var nextToken: Swift.String?

    public init (
        connections: [OpenSearchClientTypes.InboundConnection]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connections = connections
        self.nextToken = nextToken
    }
}

struct DescribeInboundConnectionsOutputResponseBody: Swift.Equatable {
    let connections: [OpenSearchClientTypes.InboundConnection]?
    let nextToken: Swift.String?
}

extension DescribeInboundConnectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connections = "Connections"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.InboundConnection?].self, forKey: .connections)
        var connectionsDecoded0:[OpenSearchClientTypes.InboundConnection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [OpenSearchClientTypes.InboundConnection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeInstanceTypeLimitsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let domainName = domainName {
            let domainNameQueryItem = ClientRuntime.URLQueryItem(name: "domainName".urlPercentEncoding(), value: Swift.String(domainName).urlPercentEncoding())
            items.append(domainNameQueryItem)
        }
        return items
    }
}

extension DescribeInstanceTypeLimitsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let engineVersion = engineVersion else {
            return nil
        }
        guard let instanceType = instanceType else {
            return nil
        }
        return "/2021-01-01/opensearch/instanceTypeLimits/\(engineVersion.urlPercentEncoding())/\(instanceType.rawValue.urlPercentEncoding())"
    }
}

/// Container for the parameters to the [DescribeInstanceTypeLimits] operation.
public struct DescribeInstanceTypeLimitsInput: Swift.Equatable {
    /// The name of the domain you want to modify. Only include this value if you're querying OpenSearch [Limits] for an existing domain.
    public var domainName: Swift.String?
    /// Version of OpenSearch for which [Limits] are needed.
    /// This member is required.
    public var engineVersion: Swift.String?
    /// The instance type for an OpenSearch cluster for which OpenSearch [Limits] are needed.
    /// This member is required.
    public var instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType?

    public init (
        domainName: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType? = nil
    )
    {
        self.domainName = domainName
        self.engineVersion = engineVersion
        self.instanceType = instanceType
    }
}

struct DescribeInstanceTypeLimitsInputBody: Swift.Equatable {
}

extension DescribeInstanceTypeLimitsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeInstanceTypeLimitsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInstanceTypeLimitsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInstanceTypeLimitsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInstanceTypeLimitsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeInstanceTypeLimitsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.limitsByRole = output.limitsByRole
        } else {
            self.limitsByRole = nil
        }
    }
}

/// Container for the parameters received from the [DescribeInstanceTypeLimits] operation.
public struct DescribeInstanceTypeLimitsOutputResponse: Swift.Equatable {
    /// The role of a given instance and all applicable limits. The role performed by a given OpenSearch instance can be one of the following:
    ///
    /// * data: If the given InstanceType is used as a data node
    ///
    /// * master: If the given InstanceType is used as a master node
    ///
    /// * ultra_warm: If the given InstanceType is used as a warm node
    public var limitsByRole: [Swift.String:OpenSearchClientTypes.Limits]?

    public init (
        limitsByRole: [Swift.String:OpenSearchClientTypes.Limits]? = nil
    )
    {
        self.limitsByRole = limitsByRole
    }
}

struct DescribeInstanceTypeLimitsOutputResponseBody: Swift.Equatable {
    let limitsByRole: [Swift.String:OpenSearchClientTypes.Limits]?
}

extension DescribeInstanceTypeLimitsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limitsByRole = "LimitsByRole"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitsByRoleContainer = try containerValues.decodeIfPresent([Swift.String: OpenSearchClientTypes.Limits?].self, forKey: .limitsByRole)
        var limitsByRoleDecoded0: [Swift.String:OpenSearchClientTypes.Limits]? = nil
        if let limitsByRoleContainer = limitsByRoleContainer {
            limitsByRoleDecoded0 = [Swift.String:OpenSearchClientTypes.Limits]()
            for (key0, limits0) in limitsByRoleContainer {
                if let limits0 = limits0 {
                    limitsByRoleDecoded0?[key0] = limits0
                }
            }
        }
        limitsByRole = limitsByRoleDecoded0
    }
}

extension DescribeOutboundConnectionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeOutboundConnectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/opensearch/cc/outboundConnection/search"
    }
}

/// Container for the parameters to the [DescribeOutboundConnections] operation.
public struct DescribeOutboundConnectionsInput: Swift.Equatable {
    /// A list of filters used to match properties for outbound cross-cluster connections. Available [Filter] names for this operation are:
    ///
    /// * connection-id
    ///
    /// * remote-domain-info.domain-name
    ///
    /// * remote-domain-info.owner-id
    ///
    /// * remote-domain-info.region
    ///
    /// * local-domain-info.domain-name
    public var filters: [OpenSearchClientTypes.Filter]?
    /// Set this value to limit the number of results returned. If not specified, defaults to 100.
    public var maxResults: Swift.Int
    /// NextToken is sent in case the earlier API call results contain the NextToken parameter. Used for pagination.
    public var nextToken: Swift.String?

    public init (
        filters: [OpenSearchClientTypes.Filter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeOutboundConnectionsInputBody: Swift.Equatable {
    let filters: [OpenSearchClientTypes.Filter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeOutboundConnectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[OpenSearchClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [OpenSearchClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeOutboundConnectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOutboundConnectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOutboundConnectionsOutputError: Swift.Error, Swift.Equatable {
    case disabledOperationException(DisabledOperationException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOutboundConnectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOutboundConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connections = output.connections
            self.nextToken = output.nextToken
        } else {
            self.connections = nil
            self.nextToken = nil
        }
    }
}

/// The result of a [DescribeOutboundConnections] request. Contains the list of connections matching the filter criteria.
public struct DescribeOutboundConnectionsOutputResponse: Swift.Equatable {
    /// A list of [OutboundConnection] matching the specified filter criteria.
    public var connections: [OpenSearchClientTypes.OutboundConnection]?
    /// If more results are available and NextToken is present, make the next request to the same API with the received NextToken to paginate the remaining results.
    public var nextToken: Swift.String?

    public init (
        connections: [OpenSearchClientTypes.OutboundConnection]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connections = connections
        self.nextToken = nextToken
    }
}

struct DescribeOutboundConnectionsOutputResponseBody: Swift.Equatable {
    let connections: [OpenSearchClientTypes.OutboundConnection]?
    let nextToken: Swift.String?
}

extension DescribeOutboundConnectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connections = "Connections"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.OutboundConnection?].self, forKey: .connections)
        var connectionsDecoded0:[OpenSearchClientTypes.OutboundConnection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [OpenSearchClientTypes.OutboundConnection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension OpenSearchClientTypes.DescribePackagesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            var valueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .value)
            for describepackagesfiltervalues0 in value {
                try valueContainer.encode(describepackagesfiltervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DescribePackagesFilterName.self, forKey: .name)
        name = nameDecoded
        let valueContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .value)
        var valueDecoded0:[Swift.String]? = nil
        if let valueContainer = valueContainer {
            valueDecoded0 = [Swift.String]()
            for string0 in valueContainer {
                if let string0 = string0 {
                    valueDecoded0?.append(string0)
                }
            }
        }
        value = valueDecoded0
    }
}

extension OpenSearchClientTypes {
    /// A filter to apply to the DescribePackage response.
    public struct DescribePackagesFilter: Swift.Equatable {
        /// Any field from PackageDetails.
        public var name: OpenSearchClientTypes.DescribePackagesFilterName?
        /// A list of values for the specified field.
        public var value: [Swift.String]?

        public init (
            name: OpenSearchClientTypes.DescribePackagesFilterName? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension OpenSearchClientTypes {
    public enum DescribePackagesFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case packageid
        case packagename
        case packagestatus
        case sdkUnknown(Swift.String)

        public static var allCases: [DescribePackagesFilterName] {
            return [
                .packageid,
                .packagename,
                .packagestatus,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .packageid: return "PackageID"
            case .packagename: return "PackageName"
            case .packagestatus: return "PackageStatus"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DescribePackagesFilterName(rawValue: rawValue) ?? DescribePackagesFilterName.sdkUnknown(rawValue)
        }
    }
}

extension DescribePackagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for describepackagesfilterlist0 in filters {
                try filtersContainer.encode(describepackagesfilterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribePackagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/packages/describe"
    }
}

/// Container for the request parameters to the [DescribePackage] operation.
public struct DescribePackagesInput: Swift.Equatable {
    /// Only returns packages that match the DescribePackagesFilterList values.
    public var filters: [OpenSearchClientTypes.DescribePackagesFilter]?
    /// Limits results to a maximum number of packages.
    public var maxResults: Swift.Int
    /// Used for pagination. Only necessary if a previous API call includes a non-null NextToken value. If provided, returns results for the next page.
    public var nextToken: Swift.String?

    public init (
        filters: [OpenSearchClientTypes.DescribePackagesFilter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribePackagesInputBody: Swift.Equatable {
    let filters: [OpenSearchClientTypes.DescribePackagesFilter]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribePackagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.DescribePackagesFilter?].self, forKey: .filters)
        var filtersDecoded0:[OpenSearchClientTypes.DescribePackagesFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [OpenSearchClientTypes.DescribePackagesFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribePackagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePackagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePackagesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePackagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePackagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.packageDetailsList = output.packageDetailsList
        } else {
            self.nextToken = nil
            self.packageDetailsList = nil
        }
    }
}

/// Container for the response returned by the [DescribePackages] operation.
public struct DescribePackagesOutputResponse: Swift.Equatable {
    public var nextToken: Swift.String?
    /// List of PackageDetails objects.
    public var packageDetailsList: [OpenSearchClientTypes.PackageDetails]?

    public init (
        nextToken: Swift.String? = nil,
        packageDetailsList: [OpenSearchClientTypes.PackageDetails]? = nil
    )
    {
        self.nextToken = nextToken
        self.packageDetailsList = packageDetailsList
    }
}

struct DescribePackagesOutputResponseBody: Swift.Equatable {
    let packageDetailsList: [OpenSearchClientTypes.PackageDetails]?
    let nextToken: Swift.String?
}

extension DescribePackagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case packageDetailsList = "PackageDetailsList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageDetailsListContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.PackageDetails?].self, forKey: .packageDetailsList)
        var packageDetailsListDecoded0:[OpenSearchClientTypes.PackageDetails]? = nil
        if let packageDetailsListContainer = packageDetailsListContainer {
            packageDetailsListDecoded0 = [OpenSearchClientTypes.PackageDetails]()
            for structure0 in packageDetailsListContainer {
                if let structure0 = structure0 {
                    packageDetailsListDecoded0?.append(structure0)
                }
            }
        }
        packageDetailsList = packageDetailsListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeReservedInstanceOfferingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let reservedInstanceOfferingId = reservedInstanceOfferingId {
            let reservedInstanceOfferingIdQueryItem = ClientRuntime.URLQueryItem(name: "offeringId".urlPercentEncoding(), value: Swift.String(reservedInstanceOfferingId).urlPercentEncoding())
            items.append(reservedInstanceOfferingIdQueryItem)
        }
        return items
    }
}

extension DescribeReservedInstanceOfferingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/opensearch/reservedInstanceOfferings"
    }
}

/// Container for parameters to DescribeReservedInstanceOfferings
public struct DescribeReservedInstanceOfferingsInput: Swift.Equatable {
    /// Set this value to limit the number of results returned. If not specified, defaults to 100.
    public var maxResults: Swift.Int
    /// Provides an identifier to allow retrieval of paginated results.
    public var nextToken: Swift.String?
    /// The offering identifier filter value. Use this parameter to show only the available offering that matches the specified reservation identifier.
    public var reservedInstanceOfferingId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        reservedInstanceOfferingId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reservedInstanceOfferingId = reservedInstanceOfferingId
    }
}

struct DescribeReservedInstanceOfferingsInputBody: Swift.Equatable {
}

extension DescribeReservedInstanceOfferingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeReservedInstanceOfferingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReservedInstanceOfferingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReservedInstanceOfferingsOutputError: Swift.Error, Swift.Equatable {
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReservedInstanceOfferingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReservedInstanceOfferingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reservedInstanceOfferings = output.reservedInstanceOfferings
        } else {
            self.nextToken = nil
            self.reservedInstanceOfferings = nil
        }
    }
}

/// Container for results from DescribeReservedInstanceOfferings
public struct DescribeReservedInstanceOfferingsOutputResponse: Swift.Equatable {
    /// Provides an identifier to allow retrieval of paginated results.
    public var nextToken: Swift.String?
    /// List of reserved OpenSearch instance offerings
    public var reservedInstanceOfferings: [OpenSearchClientTypes.ReservedInstanceOffering]?

    public init (
        nextToken: Swift.String? = nil,
        reservedInstanceOfferings: [OpenSearchClientTypes.ReservedInstanceOffering]? = nil
    )
    {
        self.nextToken = nextToken
        self.reservedInstanceOfferings = reservedInstanceOfferings
    }
}

struct DescribeReservedInstanceOfferingsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let reservedInstanceOfferings: [OpenSearchClientTypes.ReservedInstanceOffering]?
}

extension DescribeReservedInstanceOfferingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case reservedInstanceOfferings = "ReservedInstanceOfferings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let reservedInstanceOfferingsContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.ReservedInstanceOffering?].self, forKey: .reservedInstanceOfferings)
        var reservedInstanceOfferingsDecoded0:[OpenSearchClientTypes.ReservedInstanceOffering]? = nil
        if let reservedInstanceOfferingsContainer = reservedInstanceOfferingsContainer {
            reservedInstanceOfferingsDecoded0 = [OpenSearchClientTypes.ReservedInstanceOffering]()
            for structure0 in reservedInstanceOfferingsContainer {
                if let structure0 = structure0 {
                    reservedInstanceOfferingsDecoded0?.append(structure0)
                }
            }
        }
        reservedInstanceOfferings = reservedInstanceOfferingsDecoded0
    }
}

extension DescribeReservedInstancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let reservedInstanceId = reservedInstanceId {
            let reservedInstanceIdQueryItem = ClientRuntime.URLQueryItem(name: "reservationId".urlPercentEncoding(), value: Swift.String(reservedInstanceId).urlPercentEncoding())
            items.append(reservedInstanceIdQueryItem)
        }
        return items
    }
}

extension DescribeReservedInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/opensearch/reservedInstances"
    }
}

/// Container for parameters to DescribeReservedInstances
public struct DescribeReservedInstancesInput: Swift.Equatable {
    /// Set this value to limit the number of results returned. If not specified, defaults to 100.
    public var maxResults: Swift.Int
    /// Provides an identifier to allow retrieval of paginated results.
    public var nextToken: Swift.String?
    /// The reserved instance identifier filter value. Use this parameter to show only the reservation that matches the specified reserved OpenSearch instance ID.
    public var reservedInstanceId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        reservedInstanceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reservedInstanceId = reservedInstanceId
    }
}

struct DescribeReservedInstancesInputBody: Swift.Equatable {
}

extension DescribeReservedInstancesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeReservedInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReservedInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReservedInstancesOutputError: Swift.Error, Swift.Equatable {
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReservedInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReservedInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reservedInstances = output.reservedInstances
        } else {
            self.nextToken = nil
            self.reservedInstances = nil
        }
    }
}

/// Container for results from DescribeReservedInstances
public struct DescribeReservedInstancesOutputResponse: Swift.Equatable {
    /// Provides an identifier to allow retrieval of paginated results.
    public var nextToken: Swift.String?
    /// List of reserved OpenSearch instances.
    public var reservedInstances: [OpenSearchClientTypes.ReservedInstance]?

    public init (
        nextToken: Swift.String? = nil,
        reservedInstances: [OpenSearchClientTypes.ReservedInstance]? = nil
    )
    {
        self.nextToken = nextToken
        self.reservedInstances = reservedInstances
    }
}

struct DescribeReservedInstancesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let reservedInstances: [OpenSearchClientTypes.ReservedInstance]?
}

extension DescribeReservedInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case reservedInstances = "ReservedInstances"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let reservedInstancesContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.ReservedInstance?].self, forKey: .reservedInstances)
        var reservedInstancesDecoded0:[OpenSearchClientTypes.ReservedInstance]? = nil
        if let reservedInstancesContainer = reservedInstancesContainer {
            reservedInstancesDecoded0 = [OpenSearchClientTypes.ReservedInstance]()
            for structure0 in reservedInstancesContainer {
                if let structure0 = structure0 {
                    reservedInstancesDecoded0?.append(structure0)
                }
            }
        }
        reservedInstances = reservedInstancesDecoded0
    }
}

extension DisabledOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisabledOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occured because the client wanted to access a not supported operation. Gives http status code of 409.
public struct DisabledOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DisabledOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DisabledOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DissociatePackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageID = packageID else {
            return nil
        }
        guard let domainName = domainName else {
            return nil
        }
        return "/2021-01-01/packages/dissociate/\(packageID.urlPercentEncoding())/\(domainName.urlPercentEncoding())"
    }
}

/// Container for the request parameters to the [DissociatePackage] operation.
public struct DissociatePackageInput: Swift.Equatable {
    /// The name of the domain to associate the package with.
    /// This member is required.
    public var domainName: Swift.String?
    /// The internal ID of the package to associate with a domain. Use DescribePackages to find this value.
    /// This member is required.
    public var packageID: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        packageID: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.packageID = packageID
    }
}

struct DissociatePackageInputBody: Swift.Equatable {
}

extension DissociatePackageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DissociatePackageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DissociatePackageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DissociatePackageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case baseException(BaseException)
    case conflictException(ConflictException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DissociatePackageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DissociatePackageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainPackageDetails = output.domainPackageDetails
        } else {
            self.domainPackageDetails = nil
        }
    }
}

/// Container for the response returned by [DissociatePackage] operation.
public struct DissociatePackageOutputResponse: Swift.Equatable {
    ///     DomainPackageDetails
    public var domainPackageDetails: OpenSearchClientTypes.DomainPackageDetails?

    public init (
        domainPackageDetails: OpenSearchClientTypes.DomainPackageDetails? = nil
    )
    {
        self.domainPackageDetails = domainPackageDetails
    }
}

struct DissociatePackageOutputResponseBody: Swift.Equatable {
    let domainPackageDetails: OpenSearchClientTypes.DomainPackageDetails?
}

extension DissociatePackageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainPackageDetails = "DomainPackageDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainPackageDetailsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainPackageDetails.self, forKey: .domainPackageDetails)
        domainPackageDetails = domainPackageDetailsDecoded
    }
}

extension OpenSearchClientTypes.DomainConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicies = "AccessPolicies"
        case advancedOptions = "AdvancedOptions"
        case advancedSecurityOptions = "AdvancedSecurityOptions"
        case autoTuneOptions = "AutoTuneOptions"
        case changeProgressDetails = "ChangeProgressDetails"
        case clusterConfig = "ClusterConfig"
        case cognitoOptions = "CognitoOptions"
        case domainEndpointOptions = "DomainEndpointOptions"
        case eBSOptions = "EBSOptions"
        case encryptionAtRestOptions = "EncryptionAtRestOptions"
        case engineVersion = "EngineVersion"
        case logPublishingOptions = "LogPublishingOptions"
        case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
        case snapshotOptions = "SnapshotOptions"
        case vPCOptions = "VPCOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPolicies = self.accessPolicies {
            try encodeContainer.encode(accessPolicies, forKey: .accessPolicies)
        }
        if let advancedOptions = self.advancedOptions {
            try encodeContainer.encode(advancedOptions, forKey: .advancedOptions)
        }
        if let advancedSecurityOptions = self.advancedSecurityOptions {
            try encodeContainer.encode(advancedSecurityOptions, forKey: .advancedSecurityOptions)
        }
        if let autoTuneOptions = self.autoTuneOptions {
            try encodeContainer.encode(autoTuneOptions, forKey: .autoTuneOptions)
        }
        if let changeProgressDetails = self.changeProgressDetails {
            try encodeContainer.encode(changeProgressDetails, forKey: .changeProgressDetails)
        }
        if let clusterConfig = self.clusterConfig {
            try encodeContainer.encode(clusterConfig, forKey: .clusterConfig)
        }
        if let cognitoOptions = self.cognitoOptions {
            try encodeContainer.encode(cognitoOptions, forKey: .cognitoOptions)
        }
        if let domainEndpointOptions = self.domainEndpointOptions {
            try encodeContainer.encode(domainEndpointOptions, forKey: .domainEndpointOptions)
        }
        if let eBSOptions = self.eBSOptions {
            try encodeContainer.encode(eBSOptions, forKey: .eBSOptions)
        }
        if let encryptionAtRestOptions = self.encryptionAtRestOptions {
            try encodeContainer.encode(encryptionAtRestOptions, forKey: .encryptionAtRestOptions)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let logPublishingOptions = self.logPublishingOptions {
            try encodeContainer.encode(logPublishingOptions, forKey: .logPublishingOptions)
        }
        if let nodeToNodeEncryptionOptions = self.nodeToNodeEncryptionOptions {
            try encodeContainer.encode(nodeToNodeEncryptionOptions, forKey: .nodeToNodeEncryptionOptions)
        }
        if let snapshotOptions = self.snapshotOptions {
            try encodeContainer.encode(snapshotOptions, forKey: .snapshotOptions)
        }
        if let vPCOptions = self.vPCOptions {
            try encodeContainer.encode(vPCOptions, forKey: .vPCOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineVersionDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.VersionStatus.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let clusterConfigDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ClusterConfigStatus.self, forKey: .clusterConfig)
        clusterConfig = clusterConfigDecoded
        let eBSOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.EBSOptionsStatus.self, forKey: .eBSOptions)
        eBSOptions = eBSOptionsDecoded
        let accessPoliciesDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AccessPoliciesStatus.self, forKey: .accessPolicies)
        accessPolicies = accessPoliciesDecoded
        let snapshotOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.SnapshotOptionsStatus.self, forKey: .snapshotOptions)
        snapshotOptions = snapshotOptionsDecoded
        let vPCOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.VPCDerivedInfoStatus.self, forKey: .vPCOptions)
        vPCOptions = vPCOptionsDecoded
        let cognitoOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.CognitoOptionsStatus.self, forKey: .cognitoOptions)
        cognitoOptions = cognitoOptionsDecoded
        let encryptionAtRestOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.EncryptionAtRestOptionsStatus.self, forKey: .encryptionAtRestOptions)
        encryptionAtRestOptions = encryptionAtRestOptionsDecoded
        let nodeToNodeEncryptionOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.NodeToNodeEncryptionOptionsStatus.self, forKey: .nodeToNodeEncryptionOptions)
        nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptionsDecoded
        let advancedOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AdvancedOptionsStatus.self, forKey: .advancedOptions)
        advancedOptions = advancedOptionsDecoded
        let logPublishingOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.LogPublishingOptionsStatus.self, forKey: .logPublishingOptions)
        logPublishingOptions = logPublishingOptionsDecoded
        let domainEndpointOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainEndpointOptionsStatus.self, forKey: .domainEndpointOptions)
        domainEndpointOptions = domainEndpointOptionsDecoded
        let advancedSecurityOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AdvancedSecurityOptionsStatus.self, forKey: .advancedSecurityOptions)
        advancedSecurityOptions = advancedSecurityOptionsDecoded
        let autoTuneOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AutoTuneOptionsStatus.self, forKey: .autoTuneOptions)
        autoTuneOptions = autoTuneOptionsDecoded
        let changeProgressDetailsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ChangeProgressDetails.self, forKey: .changeProgressDetails)
        changeProgressDetails = changeProgressDetailsDecoded
    }
}

extension OpenSearchClientTypes {
    /// The configuration of a domain.
    public struct DomainConfig: Swift.Equatable {
        /// IAM access policy as a JSON-formatted string.
        public var accessPolicies: OpenSearchClientTypes.AccessPoliciesStatus?
        /// The AdvancedOptions for the domain. See [Advanced options ](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options) for more information.
        public var advancedOptions: OpenSearchClientTypes.AdvancedOptionsStatus?
        /// Specifies AdvancedSecurityOptions for the domain.
        public var advancedSecurityOptions: OpenSearchClientTypes.AdvancedSecurityOptionsStatus?
        /// Specifies AutoTuneOptions for the domain.
        public var autoTuneOptions: OpenSearchClientTypes.AutoTuneOptionsStatus?
        /// Specifies change details of the domain configuration change.
        public var changeProgressDetails: OpenSearchClientTypes.ChangeProgressDetails?
        /// The ClusterConfig for the domain.
        public var clusterConfig: OpenSearchClientTypes.ClusterConfigStatus?
        /// The CognitoOptions for the specified domain. For more information, see [Configuring Amazon Cognito authentication for OpenSearch Dashboards](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html).
        public var cognitoOptions: OpenSearchClientTypes.CognitoOptionsStatus?
        /// The DomainEndpointOptions for the domain.
        public var domainEndpointOptions: OpenSearchClientTypes.DomainEndpointOptionsStatus?
        /// The EBSOptions for the domain.
        public var eBSOptions: OpenSearchClientTypes.EBSOptionsStatus?
        /// The EncryptionAtRestOptions for the domain.
        public var encryptionAtRestOptions: OpenSearchClientTypes.EncryptionAtRestOptionsStatus?
        /// String of format Elasticsearch_X.Y or OpenSearch_X.Y to specify the engine version for the OpenSearch or Elasticsearch domain.
        public var engineVersion: OpenSearchClientTypes.VersionStatus?
        /// Log publishing options for the given domain.
        public var logPublishingOptions: OpenSearchClientTypes.LogPublishingOptionsStatus?
        /// The NodeToNodeEncryptionOptions for the domain.
        public var nodeToNodeEncryptionOptions: OpenSearchClientTypes.NodeToNodeEncryptionOptionsStatus?
        /// The SnapshotOptions for the domain.
        public var snapshotOptions: OpenSearchClientTypes.SnapshotOptionsStatus?
        /// The VPCOptions for the specified domain. For more information, see [ Launching your Amazon OpenSearch Service domains using a VPC](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html).
        public var vPCOptions: OpenSearchClientTypes.VPCDerivedInfoStatus?

        public init (
            accessPolicies: OpenSearchClientTypes.AccessPoliciesStatus? = nil,
            advancedOptions: OpenSearchClientTypes.AdvancedOptionsStatus? = nil,
            advancedSecurityOptions: OpenSearchClientTypes.AdvancedSecurityOptionsStatus? = nil,
            autoTuneOptions: OpenSearchClientTypes.AutoTuneOptionsStatus? = nil,
            changeProgressDetails: OpenSearchClientTypes.ChangeProgressDetails? = nil,
            clusterConfig: OpenSearchClientTypes.ClusterConfigStatus? = nil,
            cognitoOptions: OpenSearchClientTypes.CognitoOptionsStatus? = nil,
            domainEndpointOptions: OpenSearchClientTypes.DomainEndpointOptionsStatus? = nil,
            eBSOptions: OpenSearchClientTypes.EBSOptionsStatus? = nil,
            encryptionAtRestOptions: OpenSearchClientTypes.EncryptionAtRestOptionsStatus? = nil,
            engineVersion: OpenSearchClientTypes.VersionStatus? = nil,
            logPublishingOptions: OpenSearchClientTypes.LogPublishingOptionsStatus? = nil,
            nodeToNodeEncryptionOptions: OpenSearchClientTypes.NodeToNodeEncryptionOptionsStatus? = nil,
            snapshotOptions: OpenSearchClientTypes.SnapshotOptionsStatus? = nil,
            vPCOptions: OpenSearchClientTypes.VPCDerivedInfoStatus? = nil
        )
        {
            self.accessPolicies = accessPolicies
            self.advancedOptions = advancedOptions
            self.advancedSecurityOptions = advancedSecurityOptions
            self.autoTuneOptions = autoTuneOptions
            self.changeProgressDetails = changeProgressDetails
            self.clusterConfig = clusterConfig
            self.cognitoOptions = cognitoOptions
            self.domainEndpointOptions = domainEndpointOptions
            self.eBSOptions = eBSOptions
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.engineVersion = engineVersion
            self.logPublishingOptions = logPublishingOptions
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.snapshotOptions = snapshotOptions
            self.vPCOptions = vPCOptions
        }
    }

}

extension OpenSearchClientTypes.DomainEndpointOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customEndpoint = "CustomEndpoint"
        case customEndpointCertificateArn = "CustomEndpointCertificateArn"
        case customEndpointEnabled = "CustomEndpointEnabled"
        case enforceHTTPS = "EnforceHTTPS"
        case tLSSecurityPolicy = "TLSSecurityPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customEndpoint = self.customEndpoint {
            try encodeContainer.encode(customEndpoint, forKey: .customEndpoint)
        }
        if let customEndpointCertificateArn = self.customEndpointCertificateArn {
            try encodeContainer.encode(customEndpointCertificateArn, forKey: .customEndpointCertificateArn)
        }
        if let customEndpointEnabled = self.customEndpointEnabled {
            try encodeContainer.encode(customEndpointEnabled, forKey: .customEndpointEnabled)
        }
        if let enforceHTTPS = self.enforceHTTPS {
            try encodeContainer.encode(enforceHTTPS, forKey: .enforceHTTPS)
        }
        if let tLSSecurityPolicy = self.tLSSecurityPolicy {
            try encodeContainer.encode(tLSSecurityPolicy.rawValue, forKey: .tLSSecurityPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enforceHTTPSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enforceHTTPS)
        enforceHTTPS = enforceHTTPSDecoded
        let tLSSecurityPolicyDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.TLSSecurityPolicy.self, forKey: .tLSSecurityPolicy)
        tLSSecurityPolicy = tLSSecurityPolicyDecoded
        let customEndpointEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .customEndpointEnabled)
        customEndpointEnabled = customEndpointEnabledDecoded
        let customEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customEndpoint)
        customEndpoint = customEndpointDecoded
        let customEndpointCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customEndpointCertificateArn)
        customEndpointCertificateArn = customEndpointCertificateArnDecoded
    }
}

extension OpenSearchClientTypes {
    /// Options to configure the endpoint for the domain.
    public struct DomainEndpointOptions: Swift.Equatable {
        /// The fully qualified domain for your custom endpoint.
        public var customEndpoint: Swift.String?
        /// The ACM certificate ARN for your custom endpoint.
        public var customEndpointCertificateArn: Swift.String?
        /// Whether to enable a custom endpoint for the domain.
        public var customEndpointEnabled: Swift.Bool?
        /// Whether only HTTPS endpoint should be enabled for the domain.
        public var enforceHTTPS: Swift.Bool?
        /// Specify the TLS security policy to apply to the HTTPS endpoint of the domain.
        ///
        ///
        ///
        ///
        ///
        /// Can be one of the following values:
        ///
        /// * Policy-Min-TLS-1-0-2019-07: TLS security policy which supports TLSv1.0 and higher.
        ///
        /// * Policy-Min-TLS-1-2-2019-07: TLS security policy which supports only TLSv1.2
        public var tLSSecurityPolicy: OpenSearchClientTypes.TLSSecurityPolicy?

        public init (
            customEndpoint: Swift.String? = nil,
            customEndpointCertificateArn: Swift.String? = nil,
            customEndpointEnabled: Swift.Bool? = nil,
            enforceHTTPS: Swift.Bool? = nil,
            tLSSecurityPolicy: OpenSearchClientTypes.TLSSecurityPolicy? = nil
        )
        {
            self.customEndpoint = customEndpoint
            self.customEndpointCertificateArn = customEndpointCertificateArn
            self.customEndpointEnabled = customEndpointEnabled
            self.enforceHTTPS = enforceHTTPS
            self.tLSSecurityPolicy = tLSSecurityPolicy
        }
    }

}

extension OpenSearchClientTypes.DomainEndpointOptionsStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainEndpointOptions.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchClientTypes {
    /// The configured endpoint options for the domain and their current status.
    public struct DomainEndpointOptionsStatus: Swift.Equatable {
        /// Options to configure the endpoint for the domain.
        /// This member is required.
        public var options: OpenSearchClientTypes.DomainEndpointOptions?
        /// The status of the endpoint options for the domain. See OptionStatus for the status information that's included.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init (
            options: OpenSearchClientTypes.DomainEndpointOptions? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes.DomainInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case engineType = "EngineType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let engineType = self.engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
    }
}

extension OpenSearchClientTypes {
    public struct DomainInfo: Swift.Equatable {
        /// The DomainName.
        public var domainName: Swift.String?
        /// Specifies the EngineType of the domain.
        public var engineType: OpenSearchClientTypes.EngineType?

        public init (
            domainName: Swift.String? = nil,
            engineType: OpenSearchClientTypes.EngineType? = nil
        )
        {
            self.domainName = domainName
            self.engineType = engineType
        }
    }

}

extension OpenSearchClientTypes.DomainInformationContainer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aWSDomainInformation = "AWSDomainInformation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aWSDomainInformation = self.aWSDomainInformation {
            try encodeContainer.encode(aWSDomainInformation, forKey: .aWSDomainInformation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aWSDomainInformationDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AWSDomainInformation.self, forKey: .aWSDomainInformation)
        aWSDomainInformation = aWSDomainInformationDecoded
    }
}

extension OpenSearchClientTypes {
    public struct DomainInformationContainer: Swift.Equatable {
        public var aWSDomainInformation: OpenSearchClientTypes.AWSDomainInformation?

        public init (
            aWSDomainInformation: OpenSearchClientTypes.AWSDomainInformation? = nil
        )
        {
            self.aWSDomainInformation = aWSDomainInformation
        }
    }

}

extension OpenSearchClientTypes.DomainPackageDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case domainPackageStatus = "DomainPackageStatus"
        case errorDetails = "ErrorDetails"
        case lastUpdated = "LastUpdated"
        case packageID = "PackageID"
        case packageName = "PackageName"
        case packageType = "PackageType"
        case packageVersion = "PackageVersion"
        case referencePath = "ReferencePath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainPackageStatus = self.domainPackageStatus {
            try encodeContainer.encode(domainPackageStatus.rawValue, forKey: .domainPackageStatus)
        }
        if let errorDetails = self.errorDetails {
            try encodeContainer.encode(errorDetails, forKey: .errorDetails)
        }
        if let lastUpdated = self.lastUpdated {
            try encodeContainer.encode(lastUpdated.timeIntervalSince1970, forKey: .lastUpdated)
        }
        if let packageID = self.packageID {
            try encodeContainer.encode(packageID, forKey: .packageID)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let packageType = self.packageType {
            try encodeContainer.encode(packageType.rawValue, forKey: .packageType)
        }
        if let packageVersion = self.packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
        if let referencePath = self.referencePath {
            try encodeContainer.encode(referencePath, forKey: .referencePath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageID)
        packageID = packageIDDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageTypeDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainPackageStatusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainPackageStatus.self, forKey: .domainPackageStatus)
        domainPackageStatus = domainPackageStatusDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let referencePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referencePath)
        referencePath = referencePathDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
    }
}

extension OpenSearchClientTypes {
    /// Information on a package associated with a domain.
    public struct DomainPackageDetails: Swift.Equatable {
        /// The name of the domain you've associated a package with.
        public var domainName: Swift.String?
        /// State of the association. Values are ASSOCIATING, ASSOCIATION_FAILED, ACTIVE, DISSOCIATING, and DISSOCIATION_FAILED.
        public var domainPackageStatus: OpenSearchClientTypes.DomainPackageStatus?
        /// Additional information if the package is in an error state. Null otherwise.
        public var errorDetails: OpenSearchClientTypes.ErrorDetails?
        /// The timestamp of the most recent update to the package association status.
        public var lastUpdated: ClientRuntime.Date?
        /// The internal ID of the package.
        public var packageID: Swift.String?
        /// User-specified name of the package.
        public var packageName: Swift.String?
        /// Currently supports only TXT-DICTIONARY.
        public var packageType: OpenSearchClientTypes.PackageType?
        public var packageVersion: Swift.String?
        /// The relative path on Amazon OpenSearch Service nodes, which can be used as synonym_path when the package is a synonym file.
        public var referencePath: Swift.String?

        public init (
            domainName: Swift.String? = nil,
            domainPackageStatus: OpenSearchClientTypes.DomainPackageStatus? = nil,
            errorDetails: OpenSearchClientTypes.ErrorDetails? = nil,
            lastUpdated: ClientRuntime.Date? = nil,
            packageID: Swift.String? = nil,
            packageName: Swift.String? = nil,
            packageType: OpenSearchClientTypes.PackageType? = nil,
            packageVersion: Swift.String? = nil,
            referencePath: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.domainPackageStatus = domainPackageStatus
            self.errorDetails = errorDetails
            self.lastUpdated = lastUpdated
            self.packageID = packageID
            self.packageName = packageName
            self.packageType = packageType
            self.packageVersion = packageVersion
            self.referencePath = referencePath
        }
    }

}

extension OpenSearchClientTypes {
    public enum DomainPackageStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case associating
        case associationFailed
        case dissociating
        case dissociationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainPackageStatus] {
            return [
                .active,
                .associating,
                .associationFailed,
                .dissociating,
                .dissociationFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .associating: return "ASSOCIATING"
            case .associationFailed: return "ASSOCIATION_FAILED"
            case .dissociating: return "DISSOCIATING"
            case .dissociationFailed: return "DISSOCIATION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainPackageStatus(rawValue: rawValue) ?? DomainPackageStatus.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes.DomainStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case accessPolicies = "AccessPolicies"
        case advancedOptions = "AdvancedOptions"
        case advancedSecurityOptions = "AdvancedSecurityOptions"
        case autoTuneOptions = "AutoTuneOptions"
        case changeProgressDetails = "ChangeProgressDetails"
        case clusterConfig = "ClusterConfig"
        case cognitoOptions = "CognitoOptions"
        case created = "Created"
        case deleted = "Deleted"
        case domainEndpointOptions = "DomainEndpointOptions"
        case domainId = "DomainId"
        case domainName = "DomainName"
        case eBSOptions = "EBSOptions"
        case encryptionAtRestOptions = "EncryptionAtRestOptions"
        case endpoint = "Endpoint"
        case endpoints = "Endpoints"
        case engineVersion = "EngineVersion"
        case logPublishingOptions = "LogPublishingOptions"
        case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
        case processing = "Processing"
        case serviceSoftwareOptions = "ServiceSoftwareOptions"
        case snapshotOptions = "SnapshotOptions"
        case upgradeProcessing = "UpgradeProcessing"
        case vPCOptions = "VPCOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = self.aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let accessPolicies = self.accessPolicies {
            try encodeContainer.encode(accessPolicies, forKey: .accessPolicies)
        }
        if let advancedOptions = advancedOptions {
            var advancedOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .advancedOptions)
            for (dictKey0, advancedoptions0) in advancedOptions {
                try advancedOptionsContainer.encode(advancedoptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let advancedSecurityOptions = self.advancedSecurityOptions {
            try encodeContainer.encode(advancedSecurityOptions, forKey: .advancedSecurityOptions)
        }
        if let autoTuneOptions = self.autoTuneOptions {
            try encodeContainer.encode(autoTuneOptions, forKey: .autoTuneOptions)
        }
        if let changeProgressDetails = self.changeProgressDetails {
            try encodeContainer.encode(changeProgressDetails, forKey: .changeProgressDetails)
        }
        if let clusterConfig = self.clusterConfig {
            try encodeContainer.encode(clusterConfig, forKey: .clusterConfig)
        }
        if let cognitoOptions = self.cognitoOptions {
            try encodeContainer.encode(cognitoOptions, forKey: .cognitoOptions)
        }
        if let created = self.created {
            try encodeContainer.encode(created, forKey: .created)
        }
        if let deleted = self.deleted {
            try encodeContainer.encode(deleted, forKey: .deleted)
        }
        if let domainEndpointOptions = self.domainEndpointOptions {
            try encodeContainer.encode(domainEndpointOptions, forKey: .domainEndpointOptions)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let eBSOptions = self.eBSOptions {
            try encodeContainer.encode(eBSOptions, forKey: .eBSOptions)
        }
        if let encryptionAtRestOptions = self.encryptionAtRestOptions {
            try encodeContainer.encode(encryptionAtRestOptions, forKey: .encryptionAtRestOptions)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .endpoints)
            for (dictKey0, endpointsmap0) in endpoints {
                try endpointsContainer.encode(endpointsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let logPublishingOptions = logPublishingOptions {
            var logPublishingOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logPublishingOptions)
            for (dictKey0, logpublishingoptions0) in logPublishingOptions {
                try logPublishingOptionsContainer.encode(logpublishingoptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let nodeToNodeEncryptionOptions = self.nodeToNodeEncryptionOptions {
            try encodeContainer.encode(nodeToNodeEncryptionOptions, forKey: .nodeToNodeEncryptionOptions)
        }
        if let processing = self.processing {
            try encodeContainer.encode(processing, forKey: .processing)
        }
        if let serviceSoftwareOptions = self.serviceSoftwareOptions {
            try encodeContainer.encode(serviceSoftwareOptions, forKey: .serviceSoftwareOptions)
        }
        if let snapshotOptions = self.snapshotOptions {
            try encodeContainer.encode(snapshotOptions, forKey: .snapshotOptions)
        }
        if let upgradeProcessing = self.upgradeProcessing {
            try encodeContainer.encode(upgradeProcessing, forKey: .upgradeProcessing)
        }
        if let vPCOptions = self.vPCOptions {
            try encodeContainer.encode(vPCOptions, forKey: .vPCOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .created)
        created = createdDecoded
        let deletedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleted)
        deleted = deletedDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .endpoints)
        var endpointsDecoded0: [Swift.String:Swift.String]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [Swift.String:Swift.String]()
            for (key0, serviceurl0) in endpointsContainer {
                if let serviceurl0 = serviceurl0 {
                    endpointsDecoded0?[key0] = serviceurl0
                }
            }
        }
        endpoints = endpointsDecoded0
        let processingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .processing)
        processing = processingDecoded
        let upgradeProcessingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .upgradeProcessing)
        upgradeProcessing = upgradeProcessingDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let clusterConfigDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ClusterConfig.self, forKey: .clusterConfig)
        clusterConfig = clusterConfigDecoded
        let eBSOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.EBSOptions.self, forKey: .eBSOptions)
        eBSOptions = eBSOptionsDecoded
        let accessPoliciesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicies)
        accessPolicies = accessPoliciesDecoded
        let snapshotOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.SnapshotOptions.self, forKey: .snapshotOptions)
        snapshotOptions = snapshotOptionsDecoded
        let vPCOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.VPCDerivedInfo.self, forKey: .vPCOptions)
        vPCOptions = vPCOptionsDecoded
        let cognitoOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.CognitoOptions.self, forKey: .cognitoOptions)
        cognitoOptions = cognitoOptionsDecoded
        let encryptionAtRestOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.EncryptionAtRestOptions.self, forKey: .encryptionAtRestOptions)
        encryptionAtRestOptions = encryptionAtRestOptionsDecoded
        let nodeToNodeEncryptionOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.NodeToNodeEncryptionOptions.self, forKey: .nodeToNodeEncryptionOptions)
        nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptionsDecoded
        let advancedOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .advancedOptions)
        var advancedOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let advancedOptionsContainer = advancedOptionsContainer {
            advancedOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in advancedOptionsContainer {
                if let string0 = string0 {
                    advancedOptionsDecoded0?[key0] = string0
                }
            }
        }
        advancedOptions = advancedOptionsDecoded0
        let logPublishingOptionsContainer = try containerValues.decodeIfPresent([Swift.String: OpenSearchClientTypes.LogPublishingOption?].self, forKey: .logPublishingOptions)
        var logPublishingOptionsDecoded0: [Swift.String:OpenSearchClientTypes.LogPublishingOption]? = nil
        if let logPublishingOptionsContainer = logPublishingOptionsContainer {
            logPublishingOptionsDecoded0 = [Swift.String:OpenSearchClientTypes.LogPublishingOption]()
            for (key0, logpublishingoption0) in logPublishingOptionsContainer {
                if let logpublishingoption0 = logpublishingoption0 {
                    logPublishingOptionsDecoded0?[key0] = logpublishingoption0
                }
            }
        }
        logPublishingOptions = logPublishingOptionsDecoded0
        let serviceSoftwareOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ServiceSoftwareOptions.self, forKey: .serviceSoftwareOptions)
        serviceSoftwareOptions = serviceSoftwareOptionsDecoded
        let domainEndpointOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainEndpointOptions.self, forKey: .domainEndpointOptions)
        domainEndpointOptions = domainEndpointOptionsDecoded
        let advancedSecurityOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AdvancedSecurityOptions.self, forKey: .advancedSecurityOptions)
        advancedSecurityOptions = advancedSecurityOptionsDecoded
        let autoTuneOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AutoTuneOptionsOutput.self, forKey: .autoTuneOptions)
        autoTuneOptions = autoTuneOptionsDecoded
        let changeProgressDetailsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ChangeProgressDetails.self, forKey: .changeProgressDetails)
        changeProgressDetails = changeProgressDetailsDecoded
    }
}

extension OpenSearchClientTypes {
    /// The current status of a domain.
    public struct DomainStatus: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of a domain. See [IAM identifiers ](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the AWS Identity and Access Management User Guide for more information.
        /// This member is required.
        public var aRN: Swift.String?
        /// IAM access policy as a JSON-formatted string.
        public var accessPolicies: Swift.String?
        /// The status of the AdvancedOptions.
        public var advancedOptions: [Swift.String:Swift.String]?
        /// The current status of the domain's advanced security options.
        public var advancedSecurityOptions: OpenSearchClientTypes.AdvancedSecurityOptions?
        /// The current status of the domain's Auto-Tune options.
        public var autoTuneOptions: OpenSearchClientTypes.AutoTuneOptionsOutput?
        /// Specifies change details of the domain configuration change.
        public var changeProgressDetails: OpenSearchClientTypes.ChangeProgressDetails?
        /// The type and number of instances in the domain.
        /// This member is required.
        public var clusterConfig: OpenSearchClientTypes.ClusterConfig?
        /// The CognitoOptions for the specified domain. For more information, see [Configuring Amazon Cognito authentication for OpenSearch Dashboards](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html).
        public var cognitoOptions: OpenSearchClientTypes.CognitoOptions?
        /// The domain creation status. True if the creation of a domain is complete.  False  if domain creation is still in progress.
        public var created: Swift.Bool?
        /// The domain deletion status. True if a delete request has been received for the domain but resource cleanup is still in progress. False if the domain has not been deleted. Once domain deletion is complete, the status of the domain is no longer returned.
        public var deleted: Swift.Bool?
        /// The current status of the domain's endpoint options.
        public var domainEndpointOptions: OpenSearchClientTypes.DomainEndpointOptions?
        /// The unique identifier for the specified domain.
        /// This member is required.
        public var domainId: Swift.String?
        /// The name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
        /// This member is required.
        public var domainName: Swift.String?
        /// The EBSOptions for the specified domain.
        public var eBSOptions: OpenSearchClientTypes.EBSOptions?
        /// The status of the EncryptionAtRestOptions.
        public var encryptionAtRestOptions: OpenSearchClientTypes.EncryptionAtRestOptions?
        /// The domain endpoint that you use to submit index and search requests.
        public var endpoint: Swift.String?
        /// Map containing the domain endpoints used to submit index and search requests. Example key, value: 'vpc','vpc-endpoint-h2dsd34efgyghrtguk5gt6j2foh4.us-east-1.es.amazonaws.com'.
        public var endpoints: [Swift.String:Swift.String]?
        public var engineVersion: Swift.String?
        /// Log publishing options for the given domain.
        public var logPublishingOptions: [Swift.String:OpenSearchClientTypes.LogPublishingOption]?
        /// The status of the NodeToNodeEncryptionOptions.
        public var nodeToNodeEncryptionOptions: OpenSearchClientTypes.NodeToNodeEncryptionOptions?
        /// The status of the domain configuration. True if Amazon OpenSearch Service is processing configuration changes. False if the configuration is active.
        public var processing: Swift.Bool?
        /// The current status of the domain's service software.
        public var serviceSoftwareOptions: OpenSearchClientTypes.ServiceSoftwareOptions?
        /// The status of the SnapshotOptions.
        public var snapshotOptions: OpenSearchClientTypes.SnapshotOptions?
        /// The status of a domain version upgrade. True if Amazon OpenSearch Service is undergoing a version upgrade. False if the configuration is active.
        public var upgradeProcessing: Swift.Bool?
        /// The VPCOptions for the specified domain. For more information, see [ Launching your Amazon OpenSearch Service domains using a VPC](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html).
        public var vPCOptions: OpenSearchClientTypes.VPCDerivedInfo?

        public init (
            aRN: Swift.String? = nil,
            accessPolicies: Swift.String? = nil,
            advancedOptions: [Swift.String:Swift.String]? = nil,
            advancedSecurityOptions: OpenSearchClientTypes.AdvancedSecurityOptions? = nil,
            autoTuneOptions: OpenSearchClientTypes.AutoTuneOptionsOutput? = nil,
            changeProgressDetails: OpenSearchClientTypes.ChangeProgressDetails? = nil,
            clusterConfig: OpenSearchClientTypes.ClusterConfig? = nil,
            cognitoOptions: OpenSearchClientTypes.CognitoOptions? = nil,
            created: Swift.Bool? = nil,
            deleted: Swift.Bool? = nil,
            domainEndpointOptions: OpenSearchClientTypes.DomainEndpointOptions? = nil,
            domainId: Swift.String? = nil,
            domainName: Swift.String? = nil,
            eBSOptions: OpenSearchClientTypes.EBSOptions? = nil,
            encryptionAtRestOptions: OpenSearchClientTypes.EncryptionAtRestOptions? = nil,
            endpoint: Swift.String? = nil,
            endpoints: [Swift.String:Swift.String]? = nil,
            engineVersion: Swift.String? = nil,
            logPublishingOptions: [Swift.String:OpenSearchClientTypes.LogPublishingOption]? = nil,
            nodeToNodeEncryptionOptions: OpenSearchClientTypes.NodeToNodeEncryptionOptions? = nil,
            processing: Swift.Bool? = nil,
            serviceSoftwareOptions: OpenSearchClientTypes.ServiceSoftwareOptions? = nil,
            snapshotOptions: OpenSearchClientTypes.SnapshotOptions? = nil,
            upgradeProcessing: Swift.Bool? = nil,
            vPCOptions: OpenSearchClientTypes.VPCDerivedInfo? = nil
        )
        {
            self.aRN = aRN
            self.accessPolicies = accessPolicies
            self.advancedOptions = advancedOptions
            self.advancedSecurityOptions = advancedSecurityOptions
            self.autoTuneOptions = autoTuneOptions
            self.changeProgressDetails = changeProgressDetails
            self.clusterConfig = clusterConfig
            self.cognitoOptions = cognitoOptions
            self.created = created
            self.deleted = deleted
            self.domainEndpointOptions = domainEndpointOptions
            self.domainId = domainId
            self.domainName = domainName
            self.eBSOptions = eBSOptions
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.endpoint = endpoint
            self.endpoints = endpoints
            self.engineVersion = engineVersion
            self.logPublishingOptions = logPublishingOptions
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.processing = processing
            self.serviceSoftwareOptions = serviceSoftwareOptions
            self.snapshotOptions = snapshotOptions
            self.upgradeProcessing = upgradeProcessing
            self.vPCOptions = vPCOptions
        }
    }

}

extension OpenSearchClientTypes.DryRunResults: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentType = "DeploymentType"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentType = self.deploymentType {
            try encodeContainer.encode(deploymentType, forKey: .deploymentType)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpenSearchClientTypes {
    public struct DryRunResults: Swift.Equatable {
        /// Specifies the way in which Amazon OpenSearch Service applies the update. Possible responses are Blue/Green (the update requires a blue/green deployment), DynamicUpdate (no blue/green required), Undetermined (the domain is undergoing an update and can't predict the deployment type; try again after the update is complete), and None (the request doesn't include any configuration changes).
        public var deploymentType: Swift.String?
        /// Contains an optional message associated with the DryRunResults.
        public var message: Swift.String?

        public init (
            deploymentType: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.deploymentType = deploymentType
            self.message = message
        }
    }

}

extension OpenSearchClientTypes.Duration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unit = "Unit"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if value != 0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .value) ?? 0
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.TimeUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension OpenSearchClientTypes {
    /// The maintenance schedule duration: duration value and duration unit. See [ Auto-Tune for Amazon OpenSearch Service ](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html) for more information.
    public struct Duration: Swift.Equatable {
        /// The unit of a maintenance schedule duration. Valid value is HOURS. See [ Auto-Tune for Amazon OpenSearch Service ](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html) for more information.
        public var unit: OpenSearchClientTypes.TimeUnit?
        /// Integer to specify the value of a maintenance schedule duration. See [ Auto-Tune for Amazon OpenSearch Service ](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html) for more information.
        public var value: Swift.Int

        public init (
            unit: OpenSearchClientTypes.TimeUnit? = nil,
            value: Swift.Int = 0
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension OpenSearchClientTypes.EBSOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eBSEnabled = "EBSEnabled"
        case iops = "Iops"
        case throughput = "Throughput"
        case volumeSize = "VolumeSize"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eBSEnabled = self.eBSEnabled {
            try encodeContainer.encode(eBSEnabled, forKey: .eBSEnabled)
        }
        if let iops = self.iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let throughput = self.throughput {
            try encodeContainer.encode(throughput, forKey: .throughput)
        }
        if let volumeSize = self.volumeSize {
            try encodeContainer.encode(volumeSize, forKey: .volumeSize)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType.rawValue, forKey: .volumeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eBSEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .eBSEnabled)
        eBSEnabled = eBSEnabledDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.VolumeType.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let throughputDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throughput)
        throughput = throughputDecoded
    }
}

extension OpenSearchClientTypes {
    /// Options to enable, disable, and specify the properties of EBS storage volumes.
    public struct EBSOptions: Swift.Equatable {
        /// Whether EBS-based storage is enabled.
        public var eBSEnabled: Swift.Bool?
        /// The IOPS for Provisioned IOPS And GP3 EBS volume (SSD).
        public var iops: Swift.Int?
        /// The Throughput for GP3 EBS volume (SSD).
        public var throughput: Swift.Int?
        /// Integer to specify the size of an EBS volume.
        public var volumeSize: Swift.Int?
        /// The volume type for EBS-based storage.
        public var volumeType: OpenSearchClientTypes.VolumeType?

        public init (
            eBSEnabled: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            throughput: Swift.Int? = nil,
            volumeSize: Swift.Int? = nil,
            volumeType: OpenSearchClientTypes.VolumeType? = nil
        )
        {
            self.eBSEnabled = eBSEnabled
            self.iops = iops
            self.throughput = throughput
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }
    }

}

extension OpenSearchClientTypes.EBSOptionsStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.EBSOptions.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchClientTypes {
    /// Status of the EBS options for the specified domain.
    public struct EBSOptionsStatus: Swift.Equatable {
        /// The EBS options for the specified domain.
        /// This member is required.
        public var options: OpenSearchClientTypes.EBSOptions?
        /// The status of the EBS options for the specified domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init (
            options: OpenSearchClientTypes.EBSOptions? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes.EncryptionAtRestOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case kmsKeyId = "KmsKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension OpenSearchClientTypes {
    /// Specifies encryption at rest options.
    public struct EncryptionAtRestOptions: Swift.Equatable {
        /// The option to enable encryption at rest.
        public var enabled: Swift.Bool?
        /// The KMS key ID for encryption at rest options.
        public var kmsKeyId: Swift.String?

        public init (
            enabled: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension OpenSearchClientTypes.EncryptionAtRestOptionsStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.EncryptionAtRestOptions.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchClientTypes {
    /// Status of the encryption At Rest options for the specified domain.
    public struct EncryptionAtRestOptionsStatus: Swift.Equatable {
        /// The Encryption At Rest options for the specified domain.
        /// This member is required.
        public var options: OpenSearchClientTypes.EncryptionAtRestOptions?
        /// The status of the Encryption At Rest options for the specified domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init (
            options: OpenSearchClientTypes.EncryptionAtRestOptions? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    public enum EngineType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case elasticsearch
        case opensearch
        case sdkUnknown(Swift.String)

        public static var allCases: [EngineType] {
            return [
                .elasticsearch,
                .opensearch,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .elasticsearch: return "Elasticsearch"
            case .opensearch: return "OpenSearch"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EngineType(rawValue: rawValue) ?? EngineType.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes.ErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage = "ErrorMessage"
        case errorType = "ErrorType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorType = self.errorType {
            try encodeContainer.encode(errorType, forKey: .errorType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorType)
        errorType = errorTypeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension OpenSearchClientTypes {
    public struct ErrorDetails: Swift.Equatable {
        public var errorMessage: Swift.String?
        public var errorType: Swift.String?

        public init (
            errorMessage: Swift.String? = nil,
            errorType: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
            self.errorType = errorType
        }
    }

}

extension OpenSearchClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for valuestringlist0 in values {
                try valuesContainer.encode(valuestringlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension OpenSearchClientTypes {
    /// A filter used to limit results when describing inbound or outbound cross-cluster connections. Multiple values can be specified per filter. A cross-cluster connection must match at least one of the specified values for it to be returned from an operation.
    public struct Filter: Swift.Equatable {
        /// The name of the filter.
        public var name: Swift.String?
        /// Contains one or more values for the filter.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension GetCompatibleVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let domainName = domainName {
            let domainNameQueryItem = ClientRuntime.URLQueryItem(name: "domainName".urlPercentEncoding(), value: Swift.String(domainName).urlPercentEncoding())
            items.append(domainNameQueryItem)
        }
        return items
    }
}

extension GetCompatibleVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/opensearch/compatibleVersions"
    }
}

/// Container for the request parameters to [GetCompatibleVersions] operation.
public struct GetCompatibleVersionsInput: Swift.Equatable {
    /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct GetCompatibleVersionsInputBody: Swift.Equatable {
}

extension GetCompatibleVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCompatibleVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCompatibleVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCompatibleVersionsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCompatibleVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCompatibleVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.compatibleVersions = output.compatibleVersions
        } else {
            self.compatibleVersions = nil
        }
    }
}

/// Container for the response returned by the [GetCompatibleVersions] operation.
public struct GetCompatibleVersionsOutputResponse: Swift.Equatable {
    /// A map of compatible OpenSearch versions returned as part of the [GetCompatibleVersions] operation.
    public var compatibleVersions: [OpenSearchClientTypes.CompatibleVersionsMap]?

    public init (
        compatibleVersions: [OpenSearchClientTypes.CompatibleVersionsMap]? = nil
    )
    {
        self.compatibleVersions = compatibleVersions
    }
}

struct GetCompatibleVersionsOutputResponseBody: Swift.Equatable {
    let compatibleVersions: [OpenSearchClientTypes.CompatibleVersionsMap]?
}

extension GetCompatibleVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleVersions = "CompatibleVersions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compatibleVersionsContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.CompatibleVersionsMap?].self, forKey: .compatibleVersions)
        var compatibleVersionsDecoded0:[OpenSearchClientTypes.CompatibleVersionsMap]? = nil
        if let compatibleVersionsContainer = compatibleVersionsContainer {
            compatibleVersionsDecoded0 = [OpenSearchClientTypes.CompatibleVersionsMap]()
            for structure0 in compatibleVersionsContainer {
                if let structure0 = structure0 {
                    compatibleVersionsDecoded0?.append(structure0)
                }
            }
        }
        compatibleVersions = compatibleVersionsDecoded0
    }
}

extension GetPackageVersionHistoryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetPackageVersionHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageID = packageID else {
            return nil
        }
        return "/2021-01-01/packages/\(packageID.urlPercentEncoding())/history"
    }
}

/// Container for the request parameters to the [GetPackageVersionHistory] operation.
public struct GetPackageVersionHistoryInput: Swift.Equatable {
    /// Limits results to a maximum number of package versions.
    public var maxResults: Swift.Int
    /// Used for pagination. Only necessary if a previous API call includes a non-null NextToken value. If provided, returns results for the next page.
    public var nextToken: Swift.String?
    /// Returns an audit history of package versions.
    /// This member is required.
    public var packageID: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        packageID: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.packageID = packageID
    }
}

struct GetPackageVersionHistoryInputBody: Swift.Equatable {
}

extension GetPackageVersionHistoryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPackageVersionHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPackageVersionHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPackageVersionHistoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPackageVersionHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPackageVersionHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.packageID = output.packageID
            self.packageVersionHistoryList = output.packageVersionHistoryList
        } else {
            self.nextToken = nil
            self.packageID = nil
            self.packageVersionHistoryList = nil
        }
    }
}

/// Container for response returned by [GetPackageVersionHistory] operation.
public struct GetPackageVersionHistoryOutputResponse: Swift.Equatable {
    public var nextToken: Swift.String?
    public var packageID: Swift.String?
    /// List of PackageVersionHistory objects.
    public var packageVersionHistoryList: [OpenSearchClientTypes.PackageVersionHistory]?

    public init (
        nextToken: Swift.String? = nil,
        packageID: Swift.String? = nil,
        packageVersionHistoryList: [OpenSearchClientTypes.PackageVersionHistory]? = nil
    )
    {
        self.nextToken = nextToken
        self.packageID = packageID
        self.packageVersionHistoryList = packageVersionHistoryList
    }
}

struct GetPackageVersionHistoryOutputResponseBody: Swift.Equatable {
    let packageID: Swift.String?
    let packageVersionHistoryList: [OpenSearchClientTypes.PackageVersionHistory]?
    let nextToken: Swift.String?
}

extension GetPackageVersionHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case packageID = "PackageID"
        case packageVersionHistoryList = "PackageVersionHistoryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageID)
        packageID = packageIDDecoded
        let packageVersionHistoryListContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.PackageVersionHistory?].self, forKey: .packageVersionHistoryList)
        var packageVersionHistoryListDecoded0:[OpenSearchClientTypes.PackageVersionHistory]? = nil
        if let packageVersionHistoryListContainer = packageVersionHistoryListContainer {
            packageVersionHistoryListDecoded0 = [OpenSearchClientTypes.PackageVersionHistory]()
            for structure0 in packageVersionHistoryListContainer {
                if let structure0 = structure0 {
                    packageVersionHistoryListDecoded0?.append(structure0)
                }
            }
        }
        packageVersionHistoryList = packageVersionHistoryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetUpgradeHistoryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetUpgradeHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/upgradeDomain/\(domainName.urlPercentEncoding())/history"
    }
}

/// Container for the request parameters to the [GetUpgradeHistory] operation.
public struct GetUpgradeHistoryInput: Swift.Equatable {
    /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// Set this value to limit the number of results returned.
    public var maxResults: Swift.Int
    /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
    public var nextToken: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetUpgradeHistoryInputBody: Swift.Equatable {
}

extension GetUpgradeHistoryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetUpgradeHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUpgradeHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUpgradeHistoryOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUpgradeHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetUpgradeHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.upgradeHistories = output.upgradeHistories
        } else {
            self.nextToken = nil
            self.upgradeHistories = nil
        }
    }
}

/// Container for the response returned by the [GetUpgradeHistory] operation.
public struct GetUpgradeHistoryOutputResponse: Swift.Equatable {
    /// Pagination token that needs to be supplied to the next call to get the next page of results.
    public var nextToken: Swift.String?
    /// A list of [UpgradeHistory] objects corresponding to each upgrade or upgrade eligibility check performed on a domain returned as part of the [GetUpgradeHistoryResponse] object.
    public var upgradeHistories: [OpenSearchClientTypes.UpgradeHistory]?

    public init (
        nextToken: Swift.String? = nil,
        upgradeHistories: [OpenSearchClientTypes.UpgradeHistory]? = nil
    )
    {
        self.nextToken = nextToken
        self.upgradeHistories = upgradeHistories
    }
}

struct GetUpgradeHistoryOutputResponseBody: Swift.Equatable {
    let upgradeHistories: [OpenSearchClientTypes.UpgradeHistory]?
    let nextToken: Swift.String?
}

extension GetUpgradeHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case upgradeHistories = "UpgradeHistories"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let upgradeHistoriesContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.UpgradeHistory?].self, forKey: .upgradeHistories)
        var upgradeHistoriesDecoded0:[OpenSearchClientTypes.UpgradeHistory]? = nil
        if let upgradeHistoriesContainer = upgradeHistoriesContainer {
            upgradeHistoriesDecoded0 = [OpenSearchClientTypes.UpgradeHistory]()
            for structure0 in upgradeHistoriesContainer {
                if let structure0 = structure0 {
                    upgradeHistoriesDecoded0?.append(structure0)
                }
            }
        }
        upgradeHistories = upgradeHistoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetUpgradeStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/upgradeDomain/\(domainName.urlPercentEncoding())/status"
    }
}

/// Container for the request parameters to the [GetUpgradeStatus] operation.
public struct GetUpgradeStatusInput: Swift.Equatable {
    /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct GetUpgradeStatusInputBody: Swift.Equatable {
}

extension GetUpgradeStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetUpgradeStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUpgradeStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUpgradeStatusOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUpgradeStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetUpgradeStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stepStatus = output.stepStatus
            self.upgradeName = output.upgradeName
            self.upgradeStep = output.upgradeStep
        } else {
            self.stepStatus = nil
            self.upgradeName = nil
            self.upgradeStep = nil
        }
    }
}

/// Container for the response returned by the [GetUpgradeStatus] operation.
public struct GetUpgradeStatusOutputResponse: Swift.Equatable {
    /// One of four statuses an upgrade have, returned as part of the [GetUpgradeStatusResponse] object. The status can take one of the following values:
    ///
    /// * In Progress
    ///
    /// * Succeeded
    ///
    /// * Succeeded with Issues
    ///
    /// * Failed
    public var stepStatus: OpenSearchClientTypes.UpgradeStatus?
    /// A string that briefly describes the update.
    public var upgradeName: Swift.String?
    /// One of three steps an upgrade or upgrade eligibility check goes through:
    ///
    /// * PreUpgradeCheck
    ///
    /// * Snapshot
    ///
    /// * Upgrade
    public var upgradeStep: OpenSearchClientTypes.UpgradeStep?

    public init (
        stepStatus: OpenSearchClientTypes.UpgradeStatus? = nil,
        upgradeName: Swift.String? = nil,
        upgradeStep: OpenSearchClientTypes.UpgradeStep? = nil
    )
    {
        self.stepStatus = stepStatus
        self.upgradeName = upgradeName
        self.upgradeStep = upgradeStep
    }
}

struct GetUpgradeStatusOutputResponseBody: Swift.Equatable {
    let upgradeStep: OpenSearchClientTypes.UpgradeStep?
    let stepStatus: OpenSearchClientTypes.UpgradeStatus?
    let upgradeName: Swift.String?
}

extension GetUpgradeStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stepStatus = "StepStatus"
        case upgradeName = "UpgradeName"
        case upgradeStep = "UpgradeStep"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let upgradeStepDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.UpgradeStep.self, forKey: .upgradeStep)
        upgradeStep = upgradeStepDecoded
        let stepStatusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.UpgradeStatus.self, forKey: .stepStatus)
        stepStatus = stepStatusDecoded
        let upgradeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upgradeName)
        upgradeName = upgradeNameDecoded
    }
}

extension OpenSearchClientTypes.InboundConnection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionId = "ConnectionId"
        case connectionStatus = "ConnectionStatus"
        case localDomainInfo = "LocalDomainInfo"
        case remoteDomainInfo = "RemoteDomainInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionStatus = self.connectionStatus {
            try encodeContainer.encode(connectionStatus, forKey: .connectionStatus)
        }
        if let localDomainInfo = self.localDomainInfo {
            try encodeContainer.encode(localDomainInfo, forKey: .localDomainInfo)
        }
        if let remoteDomainInfo = self.remoteDomainInfo {
            try encodeContainer.encode(remoteDomainInfo, forKey: .remoteDomainInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localDomainInfoDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainInformationContainer.self, forKey: .localDomainInfo)
        localDomainInfo = localDomainInfoDecoded
        let remoteDomainInfoDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainInformationContainer.self, forKey: .remoteDomainInfo)
        remoteDomainInfo = remoteDomainInfoDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.InboundConnectionStatus.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
    }
}

extension OpenSearchClientTypes {
    /// Details of an inbound connection.
    public struct InboundConnection: Swift.Equatable {
        /// The connection ID for the inbound cross-cluster connection.
        public var connectionId: Swift.String?
        /// The [InboundConnectionStatus] for the outbound connection.
        public var connectionStatus: OpenSearchClientTypes.InboundConnectionStatus?
        /// The [AWSDomainInformation] for the local OpenSearch domain.
        public var localDomainInfo: OpenSearchClientTypes.DomainInformationContainer?
        /// The [AWSDomainInformation] for the remote OpenSearch domain.
        public var remoteDomainInfo: OpenSearchClientTypes.DomainInformationContainer?

        public init (
            connectionId: Swift.String? = nil,
            connectionStatus: OpenSearchClientTypes.InboundConnectionStatus? = nil,
            localDomainInfo: OpenSearchClientTypes.DomainInformationContainer? = nil,
            remoteDomainInfo: OpenSearchClientTypes.DomainInformationContainer? = nil
        )
        {
            self.connectionId = connectionId
            self.connectionStatus = connectionStatus
            self.localDomainInfo = localDomainInfo
            self.remoteDomainInfo = remoteDomainInfo
        }
    }

}

extension OpenSearchClientTypes.InboundConnectionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case statusCode = "StatusCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.InboundConnectionStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpenSearchClientTypes {
    /// The connection status of an inbound cross-cluster connection.
    public struct InboundConnectionStatus: Swift.Equatable {
        /// Verbose information for the inbound connection status.
        public var message: Swift.String?
        /// The state code for the inbound connection. Can be one of the following:
        ///
        /// * PENDING_ACCEPTANCE: Inbound connection is not yet accepted by the remote domain owner.
        ///
        /// * APPROVED: Inbound connection is pending acceptance by the remote domain owner.
        ///
        /// * PROVISIONING: Inbound connection provisioning is in progress.
        ///
        /// * ACTIVE: Inbound connection is active and ready to use.
        ///
        /// * REJECTING: Inbound connection rejection is in process.
        ///
        /// * REJECTED: Inbound connection is rejected.
        ///
        /// * DELETING: Inbound connection deletion is in progress.
        ///
        /// * DELETED: Inbound connection is deleted and can no longer be used.
        public var statusCode: OpenSearchClientTypes.InboundConnectionStatusCode?

        public init (
            message: Swift.String? = nil,
            statusCode: OpenSearchClientTypes.InboundConnectionStatusCode? = nil
        )
        {
            self.message = message
            self.statusCode = statusCode
        }
    }

}

extension OpenSearchClientTypes {
    public enum InboundConnectionStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case approved
        case deleted
        case deleting
        case pendingAcceptance
        case provisioning
        case rejected
        case rejecting
        case sdkUnknown(Swift.String)

        public static var allCases: [InboundConnectionStatusCode] {
            return [
                .active,
                .approved,
                .deleted,
                .deleting,
                .pendingAcceptance,
                .provisioning,
                .rejected,
                .rejecting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .approved: return "APPROVED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pendingAcceptance: return "PENDING_ACCEPTANCE"
            case .provisioning: return "PROVISIONING"
            case .rejected: return "REJECTED"
            case .rejecting: return "REJECTING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InboundConnectionStatusCode(rawValue: rawValue) ?? InboundConnectionStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes.InstanceCountLimits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximumInstanceCount = "MaximumInstanceCount"
        case minimumInstanceCount = "MinimumInstanceCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maximumInstanceCount != 0 {
            try encodeContainer.encode(maximumInstanceCount, forKey: .maximumInstanceCount)
        }
        if minimumInstanceCount != 0 {
            try encodeContainer.encode(minimumInstanceCount, forKey: .minimumInstanceCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minimumInstanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumInstanceCount) ?? 0
        minimumInstanceCount = minimumInstanceCountDecoded
        let maximumInstanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumInstanceCount) ?? 0
        maximumInstanceCount = maximumInstanceCountDecoded
    }
}

extension OpenSearchClientTypes {
    /// InstanceCountLimits represents the limits on the number of instances that can be created in Amazon OpenSearch Service for a given InstanceType.
    public struct InstanceCountLimits: Swift.Equatable {
        /// Maximum number of instances that can be instantiated for a given InstanceType.
        public var maximumInstanceCount: Swift.Int
        /// Minimum number of instances that can be instantiated for a given InstanceType.
        public var minimumInstanceCount: Swift.Int

        public init (
            maximumInstanceCount: Swift.Int = 0,
            minimumInstanceCount: Swift.Int = 0
        )
        {
            self.maximumInstanceCount = maximumInstanceCount
            self.minimumInstanceCount = minimumInstanceCount
        }
    }

}

extension OpenSearchClientTypes.InstanceLimits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceCountLimits = "InstanceCountLimits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceCountLimits = self.instanceCountLimits {
            try encodeContainer.encode(instanceCountLimits, forKey: .instanceCountLimits)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceCountLimitsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.InstanceCountLimits.self, forKey: .instanceCountLimits)
        instanceCountLimits = instanceCountLimitsDecoded
    }
}

extension OpenSearchClientTypes {
    /// InstanceLimits represents the list of instance-related attributes that are available for a given InstanceType.
    public struct InstanceLimits: Swift.Equatable {
        /// InstanceCountLimits represents the limits on the number of instances that can be created in Amazon OpenSearch Service for a given InstanceType.
        public var instanceCountLimits: OpenSearchClientTypes.InstanceCountLimits?

        public init (
            instanceCountLimits: OpenSearchClientTypes.InstanceCountLimits? = nil
        )
        {
            self.instanceCountLimits = instanceCountLimits
        }
    }

}

extension OpenSearchClientTypes.InstanceTypeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedSecurityEnabled = "AdvancedSecurityEnabled"
        case appLogsEnabled = "AppLogsEnabled"
        case cognitoEnabled = "CognitoEnabled"
        case encryptionEnabled = "EncryptionEnabled"
        case instanceRole = "InstanceRole"
        case instanceType = "InstanceType"
        case warmEnabled = "WarmEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedSecurityEnabled = self.advancedSecurityEnabled {
            try encodeContainer.encode(advancedSecurityEnabled, forKey: .advancedSecurityEnabled)
        }
        if let appLogsEnabled = self.appLogsEnabled {
            try encodeContainer.encode(appLogsEnabled, forKey: .appLogsEnabled)
        }
        if let cognitoEnabled = self.cognitoEnabled {
            try encodeContainer.encode(cognitoEnabled, forKey: .cognitoEnabled)
        }
        if let encryptionEnabled = self.encryptionEnabled {
            try encodeContainer.encode(encryptionEnabled, forKey: .encryptionEnabled)
        }
        if let instanceRole = instanceRole {
            var instanceRoleContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceRole)
            for instancerolelist0 in instanceRole {
                try instanceRoleContainer.encode(instancerolelist0)
            }
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType.rawValue, forKey: .instanceType)
        }
        if let warmEnabled = self.warmEnabled {
            try encodeContainer.encode(warmEnabled, forKey: .warmEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceTypeDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OpenSearchPartitionInstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let encryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encryptionEnabled)
        encryptionEnabled = encryptionEnabledDecoded
        let cognitoEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cognitoEnabled)
        cognitoEnabled = cognitoEnabledDecoded
        let appLogsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .appLogsEnabled)
        appLogsEnabled = appLogsEnabledDecoded
        let advancedSecurityEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .advancedSecurityEnabled)
        advancedSecurityEnabled = advancedSecurityEnabledDecoded
        let warmEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .warmEnabled)
        warmEnabled = warmEnabledDecoded
        let instanceRoleContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceRole)
        var instanceRoleDecoded0:[Swift.String]? = nil
        if let instanceRoleContainer = instanceRoleContainer {
            instanceRoleDecoded0 = [Swift.String]()
            for string0 in instanceRoleContainer {
                if let string0 = string0 {
                    instanceRoleDecoded0?.append(string0)
                }
            }
        }
        instanceRole = instanceRoleDecoded0
    }
}

extension OpenSearchClientTypes {
    public struct InstanceTypeDetails: Swift.Equatable {
        public var advancedSecurityEnabled: Swift.Bool?
        public var appLogsEnabled: Swift.Bool?
        public var cognitoEnabled: Swift.Bool?
        public var encryptionEnabled: Swift.Bool?
        public var instanceRole: [Swift.String]?
        public var instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType?
        public var warmEnabled: Swift.Bool?

        public init (
            advancedSecurityEnabled: Swift.Bool? = nil,
            appLogsEnabled: Swift.Bool? = nil,
            cognitoEnabled: Swift.Bool? = nil,
            encryptionEnabled: Swift.Bool? = nil,
            instanceRole: [Swift.String]? = nil,
            instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType? = nil,
            warmEnabled: Swift.Bool? = nil
        )
        {
            self.advancedSecurityEnabled = advancedSecurityEnabled
            self.appLogsEnabled = appLogsEnabled
            self.cognitoEnabled = cognitoEnabled
            self.encryptionEnabled = encryptionEnabled
            self.instanceRole = instanceRole
            self.instanceType = instanceType
            self.warmEnabled = warmEnabled
        }
    }

}

extension InternalException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure (the failure is internal to the service) . Gives http status code of 500.
public struct InternalException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// A description of the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPaginationTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidPaginationTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request processing has failed because of invalid pagination token provided by customer. Returns an HTTP status code of 400.
public struct InvalidPaginationTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPaginationTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPaginationTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception for trying to create or access sub-resource that is either invalid or not supported. Gives http status code of 409.
public struct InvalidTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTypeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception for trying to create more than allowed resources or sub-resources. Gives http status code of 409.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpenSearchClientTypes.Limits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalLimits = "AdditionalLimits"
        case instanceLimits = "InstanceLimits"
        case storageTypes = "StorageTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalLimits = additionalLimits {
            var additionalLimitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalLimits)
            for additionallimitlist0 in additionalLimits {
                try additionalLimitsContainer.encode(additionallimitlist0)
            }
        }
        if let instanceLimits = self.instanceLimits {
            try encodeContainer.encode(instanceLimits, forKey: .instanceLimits)
        }
        if let storageTypes = storageTypes {
            var storageTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .storageTypes)
            for storagetypelist0 in storageTypes {
                try storageTypesContainer.encode(storagetypelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageTypesContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.StorageType?].self, forKey: .storageTypes)
        var storageTypesDecoded0:[OpenSearchClientTypes.StorageType]? = nil
        if let storageTypesContainer = storageTypesContainer {
            storageTypesDecoded0 = [OpenSearchClientTypes.StorageType]()
            for structure0 in storageTypesContainer {
                if let structure0 = structure0 {
                    storageTypesDecoded0?.append(structure0)
                }
            }
        }
        storageTypes = storageTypesDecoded0
        let instanceLimitsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.InstanceLimits.self, forKey: .instanceLimits)
        instanceLimits = instanceLimitsDecoded
        let additionalLimitsContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.AdditionalLimit?].self, forKey: .additionalLimits)
        var additionalLimitsDecoded0:[OpenSearchClientTypes.AdditionalLimit]? = nil
        if let additionalLimitsContainer = additionalLimitsContainer {
            additionalLimitsDecoded0 = [OpenSearchClientTypes.AdditionalLimit]()
            for structure0 in additionalLimitsContainer {
                if let structure0 = structure0 {
                    additionalLimitsDecoded0?.append(structure0)
                }
            }
        }
        additionalLimits = additionalLimitsDecoded0
    }
}

extension OpenSearchClientTypes {
    /// Limits for a given InstanceType and for each of its roles.
    ///
    ///
    ///
    ///
    ///
    /// Limits contains the following: [StorageTypes], [InstanceLimits], and [AdditionalLimits]
    public struct Limits: Swift.Equatable {
        /// List of additional limits that are specific to a given InstanceType and for each of its [InstanceRole] .
        public var additionalLimits: [OpenSearchClientTypes.AdditionalLimit]?
        /// InstanceLimits represents the list of instance-related attributes that are available for a given InstanceType.
        public var instanceLimits: OpenSearchClientTypes.InstanceLimits?
        /// Storage-related types and attributes that are available for a given InstanceType.
        public var storageTypes: [OpenSearchClientTypes.StorageType]?

        public init (
            additionalLimits: [OpenSearchClientTypes.AdditionalLimit]? = nil,
            instanceLimits: OpenSearchClientTypes.InstanceLimits? = nil,
            storageTypes: [OpenSearchClientTypes.StorageType]? = nil
        )
        {
            self.additionalLimits = additionalLimits
            self.instanceLimits = instanceLimits
            self.storageTypes = storageTypes
        }
    }

}

extension ListDomainNamesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let engineType = engineType {
            let engineTypeQueryItem = ClientRuntime.URLQueryItem(name: "engineType".urlPercentEncoding(), value: Swift.String(engineType.rawValue).urlPercentEncoding())
            items.append(engineTypeQueryItem)
        }
        return items
    }
}

extension ListDomainNamesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/domain"
    }
}

/// Container for the parameters to the [ListDomainNames] operation.
public struct ListDomainNamesInput: Swift.Equatable {
    /// Optional parameter to filter the output by domain engine type. Acceptable values are 'Elasticsearch' and 'OpenSearch'.
    public var engineType: OpenSearchClientTypes.EngineType?

    public init (
        engineType: OpenSearchClientTypes.EngineType? = nil
    )
    {
        self.engineType = engineType
    }
}

struct ListDomainNamesInputBody: Swift.Equatable {
}

extension ListDomainNamesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDomainNamesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainNamesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainNamesOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainNamesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDomainNamesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainNames = output.domainNames
        } else {
            self.domainNames = nil
        }
    }
}

/// The result of a ListDomainNames operation. Contains the names of all domains owned by this account and their respective engine types.
public struct ListDomainNamesOutputResponse: Swift.Equatable {
    /// List of domain names and respective engine types.
    public var domainNames: [OpenSearchClientTypes.DomainInfo]?

    public init (
        domainNames: [OpenSearchClientTypes.DomainInfo]? = nil
    )
    {
        self.domainNames = domainNames
    }
}

struct ListDomainNamesOutputResponseBody: Swift.Equatable {
    let domainNames: [OpenSearchClientTypes.DomainInfo]?
}

extension ListDomainNamesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainNames = "DomainNames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNamesContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.DomainInfo?].self, forKey: .domainNames)
        var domainNamesDecoded0:[OpenSearchClientTypes.DomainInfo]? = nil
        if let domainNamesContainer = domainNamesContainer {
            domainNamesDecoded0 = [OpenSearchClientTypes.DomainInfo]()
            for structure0 in domainNamesContainer {
                if let structure0 = structure0 {
                    domainNamesDecoded0?.append(structure0)
                }
            }
        }
        domainNames = domainNamesDecoded0
    }
}

extension ListDomainsForPackageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDomainsForPackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageID = packageID else {
            return nil
        }
        return "/2021-01-01/packages/\(packageID.urlPercentEncoding())/domains"
    }
}

/// Container for the request parameters to the [ListDomainsForPackage] operation.
public struct ListDomainsForPackageInput: Swift.Equatable {
    /// Limits the results to a maximum number of domains.
    public var maxResults: Swift.Int
    /// Used for pagination. Only necessary if a previous API call includes a non-null NextToken value. If provided, returns results for the next page.
    public var nextToken: Swift.String?
    /// The package for which to list associated domains.
    /// This member is required.
    public var packageID: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        packageID: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.packageID = packageID
    }
}

struct ListDomainsForPackageInputBody: Swift.Equatable {
}

extension ListDomainsForPackageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDomainsForPackageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainsForPackageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDomainsForPackageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainsForPackageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDomainsForPackageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainPackageDetailsList = output.domainPackageDetailsList
            self.nextToken = output.nextToken
        } else {
            self.domainPackageDetailsList = nil
            self.nextToken = nil
        }
    }
}

/// Container for the response parameters to the [ListDomainsForPackage] operation.
public struct ListDomainsForPackageOutputResponse: Swift.Equatable {
    /// List of DomainPackageDetails objects.
    public var domainPackageDetailsList: [OpenSearchClientTypes.DomainPackageDetails]?
    public var nextToken: Swift.String?

    public init (
        domainPackageDetailsList: [OpenSearchClientTypes.DomainPackageDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainPackageDetailsList = domainPackageDetailsList
        self.nextToken = nextToken
    }
}

struct ListDomainsForPackageOutputResponseBody: Swift.Equatable {
    let domainPackageDetailsList: [OpenSearchClientTypes.DomainPackageDetails]?
    let nextToken: Swift.String?
}

extension ListDomainsForPackageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainPackageDetailsList = "DomainPackageDetailsList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainPackageDetailsListContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.DomainPackageDetails?].self, forKey: .domainPackageDetailsList)
        var domainPackageDetailsListDecoded0:[OpenSearchClientTypes.DomainPackageDetails]? = nil
        if let domainPackageDetailsListContainer = domainPackageDetailsListContainer {
            domainPackageDetailsListDecoded0 = [OpenSearchClientTypes.DomainPackageDetails]()
            for structure0 in domainPackageDetailsListContainer {
                if let structure0 = structure0 {
                    domainPackageDetailsListDecoded0?.append(structure0)
                }
            }
        }
        domainPackageDetailsList = domainPackageDetailsListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstanceTypeDetailsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let domainName = domainName {
            let domainNameQueryItem = ClientRuntime.URLQueryItem(name: "domainName".urlPercentEncoding(), value: Swift.String(domainName).urlPercentEncoding())
            items.append(domainNameQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListInstanceTypeDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let engineVersion = engineVersion else {
            return nil
        }
        return "/2021-01-01/opensearch/instanceTypeDetails/\(engineVersion.urlPercentEncoding())"
    }
}

public struct ListInstanceTypeDetailsInput: Swift.Equatable {
    /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    public var domainName: Swift.String?
    /// This member is required.
    public var engineVersion: Swift.String?
    /// Set this value to limit the number of results returned.
    public var maxResults: Swift.Int
    /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
    public var nextToken: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.engineVersion = engineVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInstanceTypeDetailsInputBody: Swift.Equatable {
}

extension ListInstanceTypeDetailsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListInstanceTypeDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInstanceTypeDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInstanceTypeDetailsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInstanceTypeDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInstanceTypeDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instanceTypeDetails = output.instanceTypeDetails
            self.nextToken = output.nextToken
        } else {
            self.instanceTypeDetails = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstanceTypeDetailsOutputResponse: Swift.Equatable {
    public var instanceTypeDetails: [OpenSearchClientTypes.InstanceTypeDetails]?
    /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
    public var nextToken: Swift.String?

    public init (
        instanceTypeDetails: [OpenSearchClientTypes.InstanceTypeDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceTypeDetails = instanceTypeDetails
        self.nextToken = nextToken
    }
}

struct ListInstanceTypeDetailsOutputResponseBody: Swift.Equatable {
    let instanceTypeDetails: [OpenSearchClientTypes.InstanceTypeDetails]?
    let nextToken: Swift.String?
}

extension ListInstanceTypeDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceTypeDetails = "InstanceTypeDetails"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceTypeDetailsContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.InstanceTypeDetails?].self, forKey: .instanceTypeDetails)
        var instanceTypeDetailsDecoded0:[OpenSearchClientTypes.InstanceTypeDetails]? = nil
        if let instanceTypeDetailsContainer = instanceTypeDetailsContainer {
            instanceTypeDetailsDecoded0 = [OpenSearchClientTypes.InstanceTypeDetails]()
            for structure0 in instanceTypeDetailsContainer {
                if let structure0 = structure0 {
                    instanceTypeDetailsDecoded0?.append(structure0)
                }
            }
        }
        instanceTypeDetails = instanceTypeDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPackagesForDomainInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPackagesForDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/2021-01-01/domain/\(domainName.urlPercentEncoding())/packages"
    }
}

/// Container for the request parameters to the [ListPackagesForDomain] operation.
public struct ListPackagesForDomainInput: Swift.Equatable {
    /// The name of the domain for which you want to list associated packages.
    /// This member is required.
    public var domainName: Swift.String?
    /// Limits results to a maximum number of packages.
    public var maxResults: Swift.Int
    /// Used for pagination. Only necessary if a previous API call includes a non-null NextToken value. If provided, returns results for the next page.
    public var nextToken: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPackagesForDomainInputBody: Swift.Equatable {
}

extension ListPackagesForDomainInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPackagesForDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackagesForDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPackagesForDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackagesForDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPackagesForDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainPackageDetailsList = output.domainPackageDetailsList
            self.nextToken = output.nextToken
        } else {
            self.domainPackageDetailsList = nil
            self.nextToken = nil
        }
    }
}

/// Container for the response parameters to the [ListPackagesForDomain] operation.
public struct ListPackagesForDomainOutputResponse: Swift.Equatable {
    /// List of DomainPackageDetails objects.
    public var domainPackageDetailsList: [OpenSearchClientTypes.DomainPackageDetails]?
    /// Pagination token to supply to the next call to get the next page of results.
    public var nextToken: Swift.String?

    public init (
        domainPackageDetailsList: [OpenSearchClientTypes.DomainPackageDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainPackageDetailsList = domainPackageDetailsList
        self.nextToken = nextToken
    }
}

struct ListPackagesForDomainOutputResponseBody: Swift.Equatable {
    let domainPackageDetailsList: [OpenSearchClientTypes.DomainPackageDetails]?
    let nextToken: Swift.String?
}

extension ListPackagesForDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainPackageDetailsList = "DomainPackageDetailsList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainPackageDetailsListContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.DomainPackageDetails?].self, forKey: .domainPackageDetailsList)
        var domainPackageDetailsListDecoded0:[OpenSearchClientTypes.DomainPackageDetails]? = nil
        if let domainPackageDetailsListContainer = domainPackageDetailsListContainer {
            domainPackageDetailsListDecoded0 = [OpenSearchClientTypes.DomainPackageDetails]()
            for structure0 in domainPackageDetailsListContainer {
                if let structure0 = structure0 {
                    domainPackageDetailsListDecoded0?.append(structure0)
                }
            }
        }
        domainPackageDetailsList = domainPackageDetailsListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let aRN = aRN {
            let aRNQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(aRN).urlPercentEncoding())
            items.append(aRNQueryItem)
        }
        return items
    }
}

extension ListTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/tags"
    }
}

/// Container for the parameters to the [ListTags] operation. Specify the ARN of the domain that the tags you want to view are attached to.
public struct ListTagsInput: Swift.Equatable {
    /// Specify the ARN of the domain that the tags you want to view are attached to.
    /// This member is required.
    public var aRN: Swift.String?

    public init (
        aRN: Swift.String? = nil
    )
    {
        self.aRN = aRN
    }
}

struct ListTagsInputBody: Swift.Equatable {
}

extension ListTagsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

/// The result of a ListTags operation. Contains tags for all requested domains.
public struct ListTagsOutputResponse: Swift.Equatable {
    /// List of Tag for the requested domain.
    public var tagList: [OpenSearchClientTypes.Tag]?

    public init (
        tagList: [OpenSearchClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsOutputResponseBody: Swift.Equatable {
    let tagList: [OpenSearchClientTypes.Tag]?
}

extension ListTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.Tag?].self, forKey: .tagList)
        var tagListDecoded0:[OpenSearchClientTypes.Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [OpenSearchClientTypes.Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension ListVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/opensearch/versions"
    }
}

/// Container for the parameters to the [ListVersions] operation. Use [MaxResults] to control the maximum number of results to retrieve in a single call. Use [NextToken] in response to retrieve more results. If the received response does not contain a NextToken, there are no more results to retrieve.
public struct ListVersionsInput: Swift.Equatable {
    /// Set this value to limit the number of results returned. Value must be greater than 10 or it won't be honored.
    public var maxResults: Swift.Int
    /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVersionsInputBody: Swift.Equatable {
}

extension ListVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVersionsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

/// Container for the parameters for response received from the [ListVersions] operation.
public struct ListVersionsOutputResponse: Swift.Equatable {
    /// Paginated APIs accept the NextToken input to return the next page of results and provide a NextToken output in the response, which you can use to retrieve more results.
    public var nextToken: Swift.String?
    /// List of supported OpenSearch versions.
    public var versions: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        versions: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListVersionsOutputResponseBody: Swift.Equatable {
    let versions: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versions)
        var versionsDecoded0:[Swift.String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [Swift.String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension OpenSearchClientTypes.LogPublishingOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroupArn = self.cloudWatchLogsLogGroupArn {
            try encodeContainer.encode(cloudWatchLogsLogGroupArn, forKey: .cloudWatchLogsLogGroupArn)
        }
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension OpenSearchClientTypes {
    /// Log Publishing option that is set for a given domain.
    ///
    ///
    ///
    ///
    ///
    /// Attributes and their details:
    ///
    /// * CloudWatchLogsLogGroupArn: ARN of the Cloudwatch log group to publish logs to.
    ///
    /// * Enabled: Whether the log publishing for a given log type is enabled or not.
    public struct LogPublishingOption: Swift.Equatable {
        /// ARN of the Cloudwatch log group to publish logs to.
        public var cloudWatchLogsLogGroupArn: Swift.String?
        /// Whether the given log publishing option is enabled or not.
        public var enabled: Swift.Bool?

        public init (
            cloudWatchLogsLogGroupArn: Swift.String? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.enabled = enabled
        }
    }

}

extension OpenSearchClientTypes.LogPublishingOptionsStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = options {
            var optionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .options)
            for (dictKey0, logpublishingoptions0) in options {
                try optionsContainer.encode(logpublishingoptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsContainer = try containerValues.decodeIfPresent([Swift.String: OpenSearchClientTypes.LogPublishingOption?].self, forKey: .options)
        var optionsDecoded0: [Swift.String:OpenSearchClientTypes.LogPublishingOption]? = nil
        if let optionsContainer = optionsContainer {
            optionsDecoded0 = [Swift.String:OpenSearchClientTypes.LogPublishingOption]()
            for (key0, logpublishingoption0) in optionsContainer {
                if let logpublishingoption0 = logpublishingoption0 {
                    optionsDecoded0?[key0] = logpublishingoption0
                }
            }
        }
        options = optionsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchClientTypes {
    /// The configured log publishing options for the domain and their current status.
    public struct LogPublishingOptionsStatus: Swift.Equatable {
        /// The log publishing options configured for the domain.
        public var options: [Swift.String:OpenSearchClientTypes.LogPublishingOption]?
        /// The status of the log publishing options for the domain. See OptionStatus for the status information that's included.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init (
            options: [Swift.String:OpenSearchClientTypes.LogPublishingOption]? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    /// Type of log file. Can be one of the following:
    ///
    /// * INDEX_SLOW_LOGS: Index slow logs contain insert requests that took more time than configured index query log threshold to execute.
    ///
    /// * SEARCH_SLOW_LOGS: Search slow logs contain search queries that took more time than configured search query log threshold to execute.
    ///
    /// * ES_APPLICATION_LOGS: OpenSearch application logs contain information about errors and warnings raised during the operation of the service and can be useful for troubleshooting.
    ///
    /// * AUDIT_LOGS: Audit logs contain records of user requests for access from the domain.
    public enum LogType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auditLogs
        case esApplicationLogs
        case indexSlowLogs
        case searchSlowLogs
        case sdkUnknown(Swift.String)

        public static var allCases: [LogType] {
            return [
                .auditLogs,
                .esApplicationLogs,
                .indexSlowLogs,
                .searchSlowLogs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auditLogs: return "AUDIT_LOGS"
            case .esApplicationLogs: return "ES_APPLICATION_LOGS"
            case .indexSlowLogs: return "INDEX_SLOW_LOGS"
            case .searchSlowLogs: return "SEARCH_SLOW_LOGS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogType(rawValue: rawValue) ?? LogType.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes.MasterUserOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case masterUserARN = "MasterUserARN"
        case masterUserName = "MasterUserName"
        case masterUserPassword = "MasterUserPassword"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let masterUserARN = self.masterUserARN {
            try encodeContainer.encode(masterUserARN, forKey: .masterUserARN)
        }
        if let masterUserName = self.masterUserName {
            try encodeContainer.encode(masterUserName, forKey: .masterUserName)
        }
        if let masterUserPassword = self.masterUserPassword {
            try encodeContainer.encode(masterUserPassword, forKey: .masterUserPassword)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let masterUserARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserARN)
        masterUserARN = masterUserARNDecoded
        let masterUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserName)
        masterUserName = masterUserNameDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
    }
}

extension OpenSearchClientTypes.MasterUserOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MasterUserOptions(masterUserARN: \(Swift.String(describing: masterUserARN)), masterUserName: \"CONTENT_REDACTED\", masterUserPassword: \"CONTENT_REDACTED\")"}
}

extension OpenSearchClientTypes {
    /// Credentials for the master user: username and password, ARN, or both.
    public struct MasterUserOptions: Swift.Equatable {
        /// ARN for the master user (if IAM is enabled).
        public var masterUserARN: Swift.String?
        /// The master user's username, which is stored in the Amazon OpenSearch Service domain's internal database.
        public var masterUserName: Swift.String?
        /// The master user's password, which is stored in the Amazon OpenSearch Service domain's internal database.
        public var masterUserPassword: Swift.String?

        public init (
            masterUserARN: Swift.String? = nil,
            masterUserName: Swift.String? = nil,
            masterUserPassword: Swift.String? = nil
        )
        {
            self.masterUserARN = masterUserARN
            self.masterUserName = masterUserName
            self.masterUserPassword = masterUserPassword
        }
    }

}

extension OpenSearchClientTypes.NodeToNodeEncryptionOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension OpenSearchClientTypes {
    /// The node-to-node encryption options.
    public struct NodeToNodeEncryptionOptions: Swift.Equatable {
        /// True to enable node-to-node encryption.
        public var enabled: Swift.Bool?

        public init (
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension OpenSearchClientTypes.NodeToNodeEncryptionOptionsStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.NodeToNodeEncryptionOptions.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchClientTypes {
    /// Status of the node-to-node encryption options for the specified domain.
    public struct NodeToNodeEncryptionOptionsStatus: Swift.Equatable {
        /// The node-to-node encryption options for the specified domain.
        /// This member is required.
        public var options: OpenSearchClientTypes.NodeToNodeEncryptionOptions?
        /// The status of the node-to-node encryption options for the specified domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init (
            options: OpenSearchClientTypes.NodeToNodeEncryptionOptions? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    public enum OpenSearchPartitionInstanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case c42xlargeSearch
        case c44xlargeSearch
        case c48xlargeSearch
        case c4LargeSearch
        case c4XlargeSearch
        case c518xlargeSearch
        case c52xlargeSearch
        case c54xlargeSearch
        case c59xlargeSearch
        case c5LargeSearch
        case c5XlargeSearch
        case c6g12xlargeSearch
        case c6g2xlargeSearch
        case c6g4xlargeSearch
        case c6g8xlargeSearch
        case c6gLargeSearch
        case c6gXlargeSearch
        case d22xlargeSearch
        case d24xlargeSearch
        case d28xlargeSearch
        case d2XlargeSearch
        case i22xlargeSearch
        case i2XlargeSearch
        case i316xlargeSearch
        case i32xlargeSearch
        case i34xlargeSearch
        case i38xlargeSearch
        case i3LargeSearch
        case i3XlargeSearch
        case m32xlargeSearch
        case m3LargeSearch
        case m3MediumSearch
        case m3XlargeSearch
        case m410xlargeSearch
        case m42xlargeSearch
        case m44xlargeSearch
        case m4LargeSearch
        case m4XlargeSearch
        case m512xlargeSearch
        case m524xlargeSearch
        case m52xlargeSearch
        case m54xlargeSearch
        case m5LargeSearch
        case m5XlargeSearch
        case m6g12xlargeSearch
        case m6g2xlargeSearch
        case m6g4xlargeSearch
        case m6g8xlargeSearch
        case m6gLargeSearch
        case m6gXlargeSearch
        case r32xlargeSearch
        case r34xlargeSearch
        case r38xlargeSearch
        case r3LargeSearch
        case r3XlargeSearch
        case r416xlargeSearch
        case r42xlargeSearch
        case r44xlargeSearch
        case r48xlargeSearch
        case r4LargeSearch
        case r4XlargeSearch
        case r512xlargeSearch
        case r524xlargeSearch
        case r52xlargeSearch
        case r54xlargeSearch
        case r5LargeSearch
        case r5XlargeSearch
        case r6g12xlargeSearch
        case r6g2xlargeSearch
        case r6g4xlargeSearch
        case r6g8xlargeSearch
        case r6gLargeSearch
        case r6gXlargeSearch
        case r6gd12xlargeSearch
        case r6gd16xlargeSearch
        case r6gd2xlargeSearch
        case r6gd4xlargeSearch
        case r6gd8xlargeSearch
        case r6gdLargeSearch
        case r6gdXlargeSearch
        case t2MediumSearch
        case t2MicroSearch
        case t2SmallSearch
        case t32xlargeSearch
        case t3LargeSearch
        case t3MediumSearch
        case t3MicroSearch
        case t3NanoSearch
        case t3SmallSearch
        case t3XlargeSearch
        case t4gMediumSearch
        case t4gSmallSearch
        case ultrawarm1LargeSearch
        case ultrawarm1MediumSearch
        case ultrawarm1XlargeSearch
        case sdkUnknown(Swift.String)

        public static var allCases: [OpenSearchPartitionInstanceType] {
            return [
                .c42xlargeSearch,
                .c44xlargeSearch,
                .c48xlargeSearch,
                .c4LargeSearch,
                .c4XlargeSearch,
                .c518xlargeSearch,
                .c52xlargeSearch,
                .c54xlargeSearch,
                .c59xlargeSearch,
                .c5LargeSearch,
                .c5XlargeSearch,
                .c6g12xlargeSearch,
                .c6g2xlargeSearch,
                .c6g4xlargeSearch,
                .c6g8xlargeSearch,
                .c6gLargeSearch,
                .c6gXlargeSearch,
                .d22xlargeSearch,
                .d24xlargeSearch,
                .d28xlargeSearch,
                .d2XlargeSearch,
                .i22xlargeSearch,
                .i2XlargeSearch,
                .i316xlargeSearch,
                .i32xlargeSearch,
                .i34xlargeSearch,
                .i38xlargeSearch,
                .i3LargeSearch,
                .i3XlargeSearch,
                .m32xlargeSearch,
                .m3LargeSearch,
                .m3MediumSearch,
                .m3XlargeSearch,
                .m410xlargeSearch,
                .m42xlargeSearch,
                .m44xlargeSearch,
                .m4LargeSearch,
                .m4XlargeSearch,
                .m512xlargeSearch,
                .m524xlargeSearch,
                .m52xlargeSearch,
                .m54xlargeSearch,
                .m5LargeSearch,
                .m5XlargeSearch,
                .m6g12xlargeSearch,
                .m6g2xlargeSearch,
                .m6g4xlargeSearch,
                .m6g8xlargeSearch,
                .m6gLargeSearch,
                .m6gXlargeSearch,
                .r32xlargeSearch,
                .r34xlargeSearch,
                .r38xlargeSearch,
                .r3LargeSearch,
                .r3XlargeSearch,
                .r416xlargeSearch,
                .r42xlargeSearch,
                .r44xlargeSearch,
                .r48xlargeSearch,
                .r4LargeSearch,
                .r4XlargeSearch,
                .r512xlargeSearch,
                .r524xlargeSearch,
                .r52xlargeSearch,
                .r54xlargeSearch,
                .r5LargeSearch,
                .r5XlargeSearch,
                .r6g12xlargeSearch,
                .r6g2xlargeSearch,
                .r6g4xlargeSearch,
                .r6g8xlargeSearch,
                .r6gLargeSearch,
                .r6gXlargeSearch,
                .r6gd12xlargeSearch,
                .r6gd16xlargeSearch,
                .r6gd2xlargeSearch,
                .r6gd4xlargeSearch,
                .r6gd8xlargeSearch,
                .r6gdLargeSearch,
                .r6gdXlargeSearch,
                .t2MediumSearch,
                .t2MicroSearch,
                .t2SmallSearch,
                .t32xlargeSearch,
                .t3LargeSearch,
                .t3MediumSearch,
                .t3MicroSearch,
                .t3NanoSearch,
                .t3SmallSearch,
                .t3XlargeSearch,
                .t4gMediumSearch,
                .t4gSmallSearch,
                .ultrawarm1LargeSearch,
                .ultrawarm1MediumSearch,
                .ultrawarm1XlargeSearch,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .c42xlargeSearch: return "c4.2xlarge.search"
            case .c44xlargeSearch: return "c4.4xlarge.search"
            case .c48xlargeSearch: return "c4.8xlarge.search"
            case .c4LargeSearch: return "c4.large.search"
            case .c4XlargeSearch: return "c4.xlarge.search"
            case .c518xlargeSearch: return "c5.18xlarge.search"
            case .c52xlargeSearch: return "c5.2xlarge.search"
            case .c54xlargeSearch: return "c5.4xlarge.search"
            case .c59xlargeSearch: return "c5.9xlarge.search"
            case .c5LargeSearch: return "c5.large.search"
            case .c5XlargeSearch: return "c5.xlarge.search"
            case .c6g12xlargeSearch: return "c6g.12xlarge.search"
            case .c6g2xlargeSearch: return "c6g.2xlarge.search"
            case .c6g4xlargeSearch: return "c6g.4xlarge.search"
            case .c6g8xlargeSearch: return "c6g.8xlarge.search"
            case .c6gLargeSearch: return "c6g.large.search"
            case .c6gXlargeSearch: return "c6g.xlarge.search"
            case .d22xlargeSearch: return "d2.2xlarge.search"
            case .d24xlargeSearch: return "d2.4xlarge.search"
            case .d28xlargeSearch: return "d2.8xlarge.search"
            case .d2XlargeSearch: return "d2.xlarge.search"
            case .i22xlargeSearch: return "i2.2xlarge.search"
            case .i2XlargeSearch: return "i2.xlarge.search"
            case .i316xlargeSearch: return "i3.16xlarge.search"
            case .i32xlargeSearch: return "i3.2xlarge.search"
            case .i34xlargeSearch: return "i3.4xlarge.search"
            case .i38xlargeSearch: return "i3.8xlarge.search"
            case .i3LargeSearch: return "i3.large.search"
            case .i3XlargeSearch: return "i3.xlarge.search"
            case .m32xlargeSearch: return "m3.2xlarge.search"
            case .m3LargeSearch: return "m3.large.search"
            case .m3MediumSearch: return "m3.medium.search"
            case .m3XlargeSearch: return "m3.xlarge.search"
            case .m410xlargeSearch: return "m4.10xlarge.search"
            case .m42xlargeSearch: return "m4.2xlarge.search"
            case .m44xlargeSearch: return "m4.4xlarge.search"
            case .m4LargeSearch: return "m4.large.search"
            case .m4XlargeSearch: return "m4.xlarge.search"
            case .m512xlargeSearch: return "m5.12xlarge.search"
            case .m524xlargeSearch: return "m5.24xlarge.search"
            case .m52xlargeSearch: return "m5.2xlarge.search"
            case .m54xlargeSearch: return "m5.4xlarge.search"
            case .m5LargeSearch: return "m5.large.search"
            case .m5XlargeSearch: return "m5.xlarge.search"
            case .m6g12xlargeSearch: return "m6g.12xlarge.search"
            case .m6g2xlargeSearch: return "m6g.2xlarge.search"
            case .m6g4xlargeSearch: return "m6g.4xlarge.search"
            case .m6g8xlargeSearch: return "m6g.8xlarge.search"
            case .m6gLargeSearch: return "m6g.large.search"
            case .m6gXlargeSearch: return "m6g.xlarge.search"
            case .r32xlargeSearch: return "r3.2xlarge.search"
            case .r34xlargeSearch: return "r3.4xlarge.search"
            case .r38xlargeSearch: return "r3.8xlarge.search"
            case .r3LargeSearch: return "r3.large.search"
            case .r3XlargeSearch: return "r3.xlarge.search"
            case .r416xlargeSearch: return "r4.16xlarge.search"
            case .r42xlargeSearch: return "r4.2xlarge.search"
            case .r44xlargeSearch: return "r4.4xlarge.search"
            case .r48xlargeSearch: return "r4.8xlarge.search"
            case .r4LargeSearch: return "r4.large.search"
            case .r4XlargeSearch: return "r4.xlarge.search"
            case .r512xlargeSearch: return "r5.12xlarge.search"
            case .r524xlargeSearch: return "r5.24xlarge.search"
            case .r52xlargeSearch: return "r5.2xlarge.search"
            case .r54xlargeSearch: return "r5.4xlarge.search"
            case .r5LargeSearch: return "r5.large.search"
            case .r5XlargeSearch: return "r5.xlarge.search"
            case .r6g12xlargeSearch: return "r6g.12xlarge.search"
            case .r6g2xlargeSearch: return "r6g.2xlarge.search"
            case .r6g4xlargeSearch: return "r6g.4xlarge.search"
            case .r6g8xlargeSearch: return "r6g.8xlarge.search"
            case .r6gLargeSearch: return "r6g.large.search"
            case .r6gXlargeSearch: return "r6g.xlarge.search"
            case .r6gd12xlargeSearch: return "r6gd.12xlarge.search"
            case .r6gd16xlargeSearch: return "r6gd.16xlarge.search"
            case .r6gd2xlargeSearch: return "r6gd.2xlarge.search"
            case .r6gd4xlargeSearch: return "r6gd.4xlarge.search"
            case .r6gd8xlargeSearch: return "r6gd.8xlarge.search"
            case .r6gdLargeSearch: return "r6gd.large.search"
            case .r6gdXlargeSearch: return "r6gd.xlarge.search"
            case .t2MediumSearch: return "t2.medium.search"
            case .t2MicroSearch: return "t2.micro.search"
            case .t2SmallSearch: return "t2.small.search"
            case .t32xlargeSearch: return "t3.2xlarge.search"
            case .t3LargeSearch: return "t3.large.search"
            case .t3MediumSearch: return "t3.medium.search"
            case .t3MicroSearch: return "t3.micro.search"
            case .t3NanoSearch: return "t3.nano.search"
            case .t3SmallSearch: return "t3.small.search"
            case .t3XlargeSearch: return "t3.xlarge.search"
            case .t4gMediumSearch: return "t4g.medium.search"
            case .t4gSmallSearch: return "t4g.small.search"
            case .ultrawarm1LargeSearch: return "ultrawarm1.large.search"
            case .ultrawarm1MediumSearch: return "ultrawarm1.medium.search"
            case .ultrawarm1XlargeSearch: return "ultrawarm1.xlarge.search"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpenSearchPartitionInstanceType(rawValue: rawValue) ?? OpenSearchPartitionInstanceType.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes {
    public enum OpenSearchWarmPartitionInstanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ultrawarm1LargeSearch
        case ultrawarm1MediumSearch
        case ultrawarm1XlargeSearch
        case sdkUnknown(Swift.String)

        public static var allCases: [OpenSearchWarmPartitionInstanceType] {
            return [
                .ultrawarm1LargeSearch,
                .ultrawarm1MediumSearch,
                .ultrawarm1XlargeSearch,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ultrawarm1LargeSearch: return "ultrawarm1.large.search"
            case .ultrawarm1MediumSearch: return "ultrawarm1.medium.search"
            case .ultrawarm1XlargeSearch: return "ultrawarm1.xlarge.search"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OpenSearchWarmPartitionInstanceType(rawValue: rawValue) ?? OpenSearchWarmPartitionInstanceType.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes {
    /// The state of a requested change. One of the following:
    ///
    /// * Processing: The request change is still in progress.
    ///
    /// * Active: The request change is processed and deployed to the domain.
    public enum OptionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case processing
        case requiresindexdocuments
        case sdkUnknown(Swift.String)

        public static var allCases: [OptionState] {
            return [
                .active,
                .processing,
                .requiresindexdocuments,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .processing: return "Processing"
            case .requiresindexdocuments: return "RequiresIndexDocuments"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OptionState(rawValue: rawValue) ?? OptionState.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes.OptionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case pendingDeletion = "PendingDeletion"
        case state = "State"
        case updateDate = "UpdateDate"
        case updateVersion = "UpdateVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let pendingDeletion = self.pendingDeletion {
            try encodeContainer.encode(pendingDeletion, forKey: .pendingDeletion)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let updateDate = self.updateDate {
            try encodeContainer.encode(updateDate.timeIntervalSince1970, forKey: .updateDate)
        }
        if updateVersion != 0 {
            try encodeContainer.encode(updateVersion, forKey: .updateVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let updateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updateDate)
        updateDate = updateDateDecoded
        let updateVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .updateVersion) ?? 0
        updateVersion = updateVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OptionState.self, forKey: .state)
        state = stateDecoded
        let pendingDeletionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .pendingDeletion)
        pendingDeletion = pendingDeletionDecoded
    }
}

extension OpenSearchClientTypes {
    /// Provides the current status of the entity.
    public struct OptionStatus: Swift.Equatable {
        /// The timestamp of when the entity was created.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// Indicates whether the domain is being deleted.
        public var pendingDeletion: Swift.Bool?
        /// Provides the OptionState for the domain.
        /// This member is required.
        public var state: OpenSearchClientTypes.OptionState?
        /// The timestamp of the last time the entity was updated.
        /// This member is required.
        public var updateDate: ClientRuntime.Date?
        /// The latest version of the entity.
        public var updateVersion: Swift.Int

        public init (
            creationDate: ClientRuntime.Date? = nil,
            pendingDeletion: Swift.Bool? = nil,
            state: OpenSearchClientTypes.OptionState? = nil,
            updateDate: ClientRuntime.Date? = nil,
            updateVersion: Swift.Int = 0
        )
        {
            self.creationDate = creationDate
            self.pendingDeletion = pendingDeletion
            self.state = state
            self.updateDate = updateDate
            self.updateVersion = updateVersion
        }
    }

}

extension OpenSearchClientTypes.OutboundConnection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionAlias = "ConnectionAlias"
        case connectionId = "ConnectionId"
        case connectionStatus = "ConnectionStatus"
        case localDomainInfo = "LocalDomainInfo"
        case remoteDomainInfo = "RemoteDomainInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionAlias = self.connectionAlias {
            try encodeContainer.encode(connectionAlias, forKey: .connectionAlias)
        }
        if let connectionId = self.connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionStatus = self.connectionStatus {
            try encodeContainer.encode(connectionStatus, forKey: .connectionStatus)
        }
        if let localDomainInfo = self.localDomainInfo {
            try encodeContainer.encode(localDomainInfo, forKey: .localDomainInfo)
        }
        if let remoteDomainInfo = self.remoteDomainInfo {
            try encodeContainer.encode(remoteDomainInfo, forKey: .remoteDomainInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localDomainInfoDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainInformationContainer.self, forKey: .localDomainInfo)
        localDomainInfo = localDomainInfoDecoded
        let remoteDomainInfoDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainInformationContainer.self, forKey: .remoteDomainInfo)
        remoteDomainInfo = remoteDomainInfoDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionAlias)
        connectionAlias = connectionAliasDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OutboundConnectionStatus.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
    }
}

extension OpenSearchClientTypes {
    /// Specifies details about an outbound connection.
    public struct OutboundConnection: Swift.Equatable {
        /// The connection alias for the outbound cross-cluster connection.
        public var connectionAlias: Swift.String?
        /// The connection ID for the outbound cross-cluster connection.
        public var connectionId: Swift.String?
        /// The [OutboundConnectionStatus] for the outbound connection.
        public var connectionStatus: OpenSearchClientTypes.OutboundConnectionStatus?
        /// The [DomainInformation] for the local OpenSearch domain.
        public var localDomainInfo: OpenSearchClientTypes.DomainInformationContainer?
        /// The [DomainInformation] for the remote OpenSearch domain.
        public var remoteDomainInfo: OpenSearchClientTypes.DomainInformationContainer?

        public init (
            connectionAlias: Swift.String? = nil,
            connectionId: Swift.String? = nil,
            connectionStatus: OpenSearchClientTypes.OutboundConnectionStatus? = nil,
            localDomainInfo: OpenSearchClientTypes.DomainInformationContainer? = nil,
            remoteDomainInfo: OpenSearchClientTypes.DomainInformationContainer? = nil
        )
        {
            self.connectionAlias = connectionAlias
            self.connectionId = connectionId
            self.connectionStatus = connectionStatus
            self.localDomainInfo = localDomainInfo
            self.remoteDomainInfo = remoteDomainInfo
        }
    }

}

extension OpenSearchClientTypes.OutboundConnectionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case statusCode = "StatusCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OutboundConnectionStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpenSearchClientTypes {
    /// The connection status of an outbound cross-cluster connection.
    public struct OutboundConnectionStatus: Swift.Equatable {
        /// Verbose information for the outbound connection status.
        public var message: Swift.String?
        /// The state code for the outbound connection. Can be one of the following:
        ///
        /// * VALIDATING: The outbound connection request is being validated.
        ///
        /// * VALIDATION_FAILED: Validation failed for the connection request.
        ///
        /// * PENDING_ACCEPTANCE: Outbound connection request is validated and is not yet accepted by the remote domain owner.
        ///
        /// * APPROVED: Outbound connection has been approved by the remote domain owner for getting provisioned.
        ///
        /// * PROVISIONING: Outbound connection request is in process.
        ///
        /// * ACTIVE: Outbound connection is active and ready to use.
        ///
        /// * REJECTING: Outbound connection rejection by remote domain owner is in progress.
        ///
        /// * REJECTED: Outbound connection request is rejected by remote domain owner.
        ///
        /// * DELETING: Outbound connection deletion is in progress.
        ///
        /// * DELETED: Outbound connection is deleted and can no longer be used.
        public var statusCode: OpenSearchClientTypes.OutboundConnectionStatusCode?

        public init (
            message: Swift.String? = nil,
            statusCode: OpenSearchClientTypes.OutboundConnectionStatusCode? = nil
        )
        {
            self.message = message
            self.statusCode = statusCode
        }
    }

}

extension OpenSearchClientTypes {
    public enum OutboundConnectionStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case approved
        case deleted
        case deleting
        case pendingAcceptance
        case provisioning
        case rejected
        case rejecting
        case validating
        case validationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [OutboundConnectionStatusCode] {
            return [
                .active,
                .approved,
                .deleted,
                .deleting,
                .pendingAcceptance,
                .provisioning,
                .rejected,
                .rejecting,
                .validating,
                .validationFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .approved: return "APPROVED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pendingAcceptance: return "PENDING_ACCEPTANCE"
            case .provisioning: return "PROVISIONING"
            case .rejected: return "REJECTED"
            case .rejecting: return "REJECTING"
            case .validating: return "VALIDATING"
            case .validationFailed: return "VALIDATION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OutboundConnectionStatusCode(rawValue: rawValue) ?? OutboundConnectionStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes {
    /// The overall status value of the domain configuration change.
    public enum OverallChangeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case pending
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [OverallChangeStatus] {
            return [
                .completed,
                .failed,
                .pending,
                .processing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OverallChangeStatus(rawValue: rawValue) ?? OverallChangeStatus.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes.PackageDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availablePackageVersion = "AvailablePackageVersion"
        case createdAt = "CreatedAt"
        case errorDetails = "ErrorDetails"
        case lastUpdatedAt = "LastUpdatedAt"
        case packageDescription = "PackageDescription"
        case packageID = "PackageID"
        case packageName = "PackageName"
        case packageStatus = "PackageStatus"
        case packageType = "PackageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availablePackageVersion = self.availablePackageVersion {
            try encodeContainer.encode(availablePackageVersion, forKey: .availablePackageVersion)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let errorDetails = self.errorDetails {
            try encodeContainer.encode(errorDetails, forKey: .errorDetails)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let packageDescription = self.packageDescription {
            try encodeContainer.encode(packageDescription, forKey: .packageDescription)
        }
        if let packageID = self.packageID {
            try encodeContainer.encode(packageID, forKey: .packageID)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let packageStatus = self.packageStatus {
            try encodeContainer.encode(packageStatus.rawValue, forKey: .packageStatus)
        }
        if let packageType = self.packageType {
            try encodeContainer.encode(packageType.rawValue, forKey: .packageType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageID)
        packageID = packageIDDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageTypeDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let packageDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageDescription)
        packageDescription = packageDescriptionDecoded
        let packageStatusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.PackageStatus.self, forKey: .packageStatus)
        packageStatus = packageStatusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let availablePackageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availablePackageVersion)
        availablePackageVersion = availablePackageVersionDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
    }
}

extension OpenSearchClientTypes {
    /// Basic information about a package.
    public struct PackageDetails: Swift.Equatable {
        public var availablePackageVersion: Swift.String?
        /// The timestamp of when the package was created.
        public var createdAt: ClientRuntime.Date?
        /// Additional information if the package is in an error state. Null otherwise.
        public var errorDetails: OpenSearchClientTypes.ErrorDetails?
        public var lastUpdatedAt: ClientRuntime.Date?
        /// User-specified description of the package.
        public var packageDescription: Swift.String?
        /// Internal ID of the package.
        public var packageID: Swift.String?
        /// User-specified name of the package.
        public var packageName: Swift.String?
        /// Current state of the package. Values are COPYING, COPY_FAILED, AVAILABLE, DELETING, and DELETE_FAILED.
        public var packageStatus: OpenSearchClientTypes.PackageStatus?
        /// Currently supports only TXT-DICTIONARY.
        public var packageType: OpenSearchClientTypes.PackageType?

        public init (
            availablePackageVersion: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            errorDetails: OpenSearchClientTypes.ErrorDetails? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            packageDescription: Swift.String? = nil,
            packageID: Swift.String? = nil,
            packageName: Swift.String? = nil,
            packageStatus: OpenSearchClientTypes.PackageStatus? = nil,
            packageType: OpenSearchClientTypes.PackageType? = nil
        )
        {
            self.availablePackageVersion = availablePackageVersion
            self.createdAt = createdAt
            self.errorDetails = errorDetails
            self.lastUpdatedAt = lastUpdatedAt
            self.packageDescription = packageDescription
            self.packageID = packageID
            self.packageName = packageName
            self.packageStatus = packageStatus
            self.packageType = packageType
        }
    }

}

extension OpenSearchClientTypes.PackageSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketName = "S3BucketName"
        case s3Key = "S3Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
    }
}

extension OpenSearchClientTypes {
    /// The Amazon S3 location for importing the package specified as S3BucketName and S3Key
    public struct PackageSource: Swift.Equatable {
        /// The name of the Amazon S3 bucket containing the package.
        public var s3BucketName: Swift.String?
        /// Key (file name) of the package.
        public var s3Key: Swift.String?

        public init (
            s3BucketName: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3Key = s3Key
        }
    }

}

extension OpenSearchClientTypes {
    public enum PackageStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case copying
        case copyFailed
        case deleted
        case deleteFailed
        case deleting
        case validating
        case validationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageStatus] {
            return [
                .available,
                .copying,
                .copyFailed,
                .deleted,
                .deleteFailed,
                .deleting,
                .validating,
                .validationFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .copying: return "COPYING"
            case .copyFailed: return "COPY_FAILED"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .validating: return "VALIDATING"
            case .validationFailed: return "VALIDATION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageStatus(rawValue: rawValue) ?? PackageStatus.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes {
    public enum PackageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case txtDictionary
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageType] {
            return [
                .txtDictionary,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .txtDictionary: return "TXT-DICTIONARY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageType(rawValue: rawValue) ?? PackageType.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes.PackageVersionHistory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitMessage = "CommitMessage"
        case createdAt = "CreatedAt"
        case packageVersion = "PackageVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let packageVersion = self.packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension OpenSearchClientTypes {
    /// Details of a package version.
    public struct PackageVersionHistory: Swift.Equatable {
        /// A message associated with the package version.
        public var commitMessage: Swift.String?
        /// The timestamp of when the package was created.
        public var createdAt: ClientRuntime.Date?
        /// The package version.
        public var packageVersion: Swift.String?

        public init (
            commitMessage: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            packageVersion: Swift.String? = nil
        )
        {
            self.commitMessage = commitMessage
            self.createdAt = createdAt
            self.packageVersion = packageVersion
        }
    }

}

extension PurchaseReservedInstanceOfferingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceCount = "InstanceCount"
        case reservationName = "ReservationName"
        case reservedInstanceOfferingId = "ReservedInstanceOfferingId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if instanceCount != 0 {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let reservationName = self.reservationName {
            try encodeContainer.encode(reservationName, forKey: .reservationName)
        }
        if let reservedInstanceOfferingId = self.reservedInstanceOfferingId {
            try encodeContainer.encode(reservedInstanceOfferingId, forKey: .reservedInstanceOfferingId)
        }
    }
}

extension PurchaseReservedInstanceOfferingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/opensearch/purchaseReservedInstanceOffering"
    }
}

/// Container for parameters to PurchaseReservedInstanceOffering
public struct PurchaseReservedInstanceOfferingInput: Swift.Equatable {
    /// The number of OpenSearch instances to reserve.
    public var instanceCount: Swift.Int
    /// A customer-specified identifier to track this reservation.
    /// This member is required.
    public var reservationName: Swift.String?
    /// The ID of the reserved OpenSearch instance offering to purchase.
    /// This member is required.
    public var reservedInstanceOfferingId: Swift.String?

    public init (
        instanceCount: Swift.Int = 0,
        reservationName: Swift.String? = nil,
        reservedInstanceOfferingId: Swift.String? = nil
    )
    {
        self.instanceCount = instanceCount
        self.reservationName = reservationName
        self.reservedInstanceOfferingId = reservedInstanceOfferingId
    }
}

struct PurchaseReservedInstanceOfferingInputBody: Swift.Equatable {
    let reservedInstanceOfferingId: Swift.String?
    let reservationName: Swift.String?
    let instanceCount: Swift.Int
}

extension PurchaseReservedInstanceOfferingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceCount = "InstanceCount"
        case reservationName = "ReservationName"
        case reservedInstanceOfferingId = "ReservedInstanceOfferingId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedInstanceOfferingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedInstanceOfferingId)
        reservedInstanceOfferingId = reservedInstanceOfferingIdDecoded
        let reservationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservationName)
        reservationName = reservationNameDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount) ?? 0
        instanceCount = instanceCountDecoded
    }
}

extension PurchaseReservedInstanceOfferingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PurchaseReservedInstanceOfferingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PurchaseReservedInstanceOfferingOutputError: Swift.Error, Swift.Equatable {
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PurchaseReservedInstanceOfferingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PurchaseReservedInstanceOfferingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reservationName = output.reservationName
            self.reservedInstanceId = output.reservedInstanceId
        } else {
            self.reservationName = nil
            self.reservedInstanceId = nil
        }
    }
}

/// Represents the output of a PurchaseReservedInstanceOffering operation.
public struct PurchaseReservedInstanceOfferingOutputResponse: Swift.Equatable {
    /// The customer-specified identifier used to track this reservation.
    public var reservationName: Swift.String?
    /// Details of the reserved OpenSearch instance which was purchased.
    public var reservedInstanceId: Swift.String?

    public init (
        reservationName: Swift.String? = nil,
        reservedInstanceId: Swift.String? = nil
    )
    {
        self.reservationName = reservationName
        self.reservedInstanceId = reservedInstanceId
    }
}

struct PurchaseReservedInstanceOfferingOutputResponseBody: Swift.Equatable {
    let reservedInstanceId: Swift.String?
    let reservationName: Swift.String?
}

extension PurchaseReservedInstanceOfferingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservationName = "ReservationName"
        case reservedInstanceId = "ReservedInstanceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedInstanceId)
        reservedInstanceId = reservedInstanceIdDecoded
        let reservationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservationName)
        reservationName = reservationNameDecoded
    }
}

extension OpenSearchClientTypes.RecurringCharge: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recurringChargeAmount = "RecurringChargeAmount"
        case recurringChargeFrequency = "RecurringChargeFrequency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recurringChargeAmount = self.recurringChargeAmount {
            try encodeContainer.encode(recurringChargeAmount, forKey: .recurringChargeAmount)
        }
        if let recurringChargeFrequency = self.recurringChargeFrequency {
            try encodeContainer.encode(recurringChargeFrequency, forKey: .recurringChargeFrequency)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recurringChargeAmountDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .recurringChargeAmount)
        recurringChargeAmount = recurringChargeAmountDecoded
        let recurringChargeFrequencyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recurringChargeFrequency)
        recurringChargeFrequency = recurringChargeFrequencyDecoded
    }
}

extension OpenSearchClientTypes {
    /// Contains the specific price and frequency of a recurring charges for a reserved OpenSearch instance, or for a reserved OpenSearch instance offering.
    public struct RecurringCharge: Swift.Equatable {
        /// The monetary amount of the recurring charge.
        public var recurringChargeAmount: Swift.Double?
        /// The frequency of the recurring charge.
        public var recurringChargeFrequency: Swift.String?

        public init (
            recurringChargeAmount: Swift.Double? = nil,
            recurringChargeFrequency: Swift.String? = nil
        )
        {
            self.recurringChargeAmount = recurringChargeAmount
            self.recurringChargeFrequency = recurringChargeFrequency
        }
    }

}

extension RejectInboundConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectionId = connectionId else {
            return nil
        }
        return "/2021-01-01/opensearch/cc/inboundConnection/\(connectionId.urlPercentEncoding())/reject"
    }
}

/// Container for the parameters to the [RejectInboundConnection] operation.
public struct RejectInboundConnectionInput: Swift.Equatable {
    /// The ID of the inbound connection to reject.
    /// This member is required.
    public var connectionId: Swift.String?

    public init (
        connectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

struct RejectInboundConnectionInputBody: Swift.Equatable {
}

extension RejectInboundConnectionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RejectInboundConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectInboundConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectInboundConnectionOutputError: Swift.Error, Swift.Equatable {
    case disabledOperationException(DisabledOperationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectInboundConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RejectInboundConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

/// The result of a [RejectInboundConnection] operation. Contains details about the rejected inbound connection.
public struct RejectInboundConnectionOutputResponse: Swift.Equatable {
    /// The [InboundConnection] of the rejected inbound connection.
    public var connection: OpenSearchClientTypes.InboundConnection?

    public init (
        connection: OpenSearchClientTypes.InboundConnection? = nil
    )
    {
        self.connection = connection
    }
}

struct RejectInboundConnectionOutputResponseBody: Swift.Equatable {
    let connection: OpenSearchClientTypes.InboundConnection?
}

extension RejectInboundConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.InboundConnection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

extension RemoveTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = self.aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for stringlist0 in tagKeys {
                try tagKeysContainer.encode(stringlist0)
            }
        }
    }
}

extension RemoveTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/tags-removal"
    }
}

/// Container for the parameters to the [RemoveTags] operation. Specify the ARN for the domain from which you want to remove the specified TagKey.
public struct RemoveTagsInput: Swift.Equatable {
    /// The ARN of the domain from which you want to delete the specified tags.
    /// This member is required.
    public var aRN: Swift.String?
    /// The TagKey list you want to remove from the domain.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        aRN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.aRN = aRN
        self.tagKeys = tagKeys
    }
}

struct RemoveTagsInputBody: Swift.Equatable {
    let aRN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension RemoveTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension RemoveTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveTagsOutputResponse: Swift.Equatable {

    public init () { }
}

extension OpenSearchClientTypes.ReservedInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingSubscriptionId = "BillingSubscriptionId"
        case currencyCode = "CurrencyCode"
        case duration = "Duration"
        case fixedPrice = "FixedPrice"
        case instanceCount = "InstanceCount"
        case instanceType = "InstanceType"
        case paymentOption = "PaymentOption"
        case recurringCharges = "RecurringCharges"
        case reservationName = "ReservationName"
        case reservedInstanceId = "ReservedInstanceId"
        case reservedInstanceOfferingId = "ReservedInstanceOfferingId"
        case startTime = "StartTime"
        case state = "State"
        case usagePrice = "UsagePrice"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingSubscriptionId = self.billingSubscriptionId {
            try encodeContainer.encode(billingSubscriptionId, forKey: .billingSubscriptionId)
        }
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let fixedPrice = self.fixedPrice {
            try encodeContainer.encode(fixedPrice, forKey: .fixedPrice)
        }
        if instanceCount != 0 {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType.rawValue, forKey: .instanceType)
        }
        if let paymentOption = self.paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let recurringCharges = recurringCharges {
            var recurringChargesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recurringCharges)
            for recurringchargelist0 in recurringCharges {
                try recurringChargesContainer.encode(recurringchargelist0)
            }
        }
        if let reservationName = self.reservationName {
            try encodeContainer.encode(reservationName, forKey: .reservationName)
        }
        if let reservedInstanceId = self.reservedInstanceId {
            try encodeContainer.encode(reservedInstanceId, forKey: .reservedInstanceId)
        }
        if let reservedInstanceOfferingId = self.reservedInstanceOfferingId {
            try encodeContainer.encode(reservedInstanceOfferingId, forKey: .reservedInstanceOfferingId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let usagePrice = self.usagePrice {
            try encodeContainer.encode(usagePrice, forKey: .usagePrice)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservationName)
        reservationName = reservationNameDecoded
        let reservedInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedInstanceId)
        reservedInstanceId = reservedInstanceIdDecoded
        let billingSubscriptionIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .billingSubscriptionId)
        billingSubscriptionId = billingSubscriptionIdDecoded
        let reservedInstanceOfferingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedInstanceOfferingId)
        reservedInstanceOfferingId = reservedInstanceOfferingIdDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OpenSearchPartitionInstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration) ?? 0
        duration = durationDecoded
        let fixedPriceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .fixedPrice)
        fixedPrice = fixedPriceDecoded
        let usagePriceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .usagePrice)
        usagePrice = usagePriceDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount) ?? 0
        instanceCount = instanceCountDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ReservedInstancePaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let recurringChargesContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.RecurringCharge?].self, forKey: .recurringCharges)
        var recurringChargesDecoded0:[OpenSearchClientTypes.RecurringCharge]? = nil
        if let recurringChargesContainer = recurringChargesContainer {
            recurringChargesDecoded0 = [OpenSearchClientTypes.RecurringCharge]()
            for structure0 in recurringChargesContainer {
                if let structure0 = structure0 {
                    recurringChargesDecoded0?.append(structure0)
                }
            }
        }
        recurringCharges = recurringChargesDecoded0
    }
}

extension OpenSearchClientTypes {
    /// Details of a reserved OpenSearch instance.
    public struct ReservedInstance: Swift.Equatable {
        public var billingSubscriptionId: Swift.Int?
        /// The currency code for the reserved OpenSearch instance offering.
        public var currencyCode: Swift.String?
        /// The duration, in seconds, for which the OpenSearch instance is reserved.
        public var duration: Swift.Int
        /// The upfront fixed charge you will paid to purchase the specific reserved OpenSearch instance offering.
        public var fixedPrice: Swift.Double?
        /// The number of OpenSearch instances that have been reserved.
        public var instanceCount: Swift.Int
        /// The OpenSearch instance type offered by the reserved instance offering.
        public var instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType?
        /// The payment option as defined in the reserved OpenSearch instance offering.
        public var paymentOption: OpenSearchClientTypes.ReservedInstancePaymentOption?
        /// The charge to your account regardless of whether you are creating any domains using the instance offering.
        public var recurringCharges: [OpenSearchClientTypes.RecurringCharge]?
        /// The customer-specified identifier to track this reservation.
        public var reservationName: Swift.String?
        /// The unique identifier for the reservation.
        public var reservedInstanceId: Swift.String?
        /// The offering identifier.
        public var reservedInstanceOfferingId: Swift.String?
        /// The time the reservation started.
        public var startTime: ClientRuntime.Date?
        /// The state of the reserved OpenSearch instance.
        public var state: Swift.String?
        /// The rate you are charged for each hour for the domain that is using this reserved instance.
        public var usagePrice: Swift.Double?

        public init (
            billingSubscriptionId: Swift.Int? = nil,
            currencyCode: Swift.String? = nil,
            duration: Swift.Int = 0,
            fixedPrice: Swift.Double? = nil,
            instanceCount: Swift.Int = 0,
            instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType? = nil,
            paymentOption: OpenSearchClientTypes.ReservedInstancePaymentOption? = nil,
            recurringCharges: [OpenSearchClientTypes.RecurringCharge]? = nil,
            reservationName: Swift.String? = nil,
            reservedInstanceId: Swift.String? = nil,
            reservedInstanceOfferingId: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: Swift.String? = nil,
            usagePrice: Swift.Double? = nil
        )
        {
            self.billingSubscriptionId = billingSubscriptionId
            self.currencyCode = currencyCode
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.paymentOption = paymentOption
            self.recurringCharges = recurringCharges
            self.reservationName = reservationName
            self.reservedInstanceId = reservedInstanceId
            self.reservedInstanceOfferingId = reservedInstanceOfferingId
            self.startTime = startTime
            self.state = state
            self.usagePrice = usagePrice
        }
    }

}

extension OpenSearchClientTypes.ReservedInstanceOffering: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case duration = "Duration"
        case fixedPrice = "FixedPrice"
        case instanceType = "InstanceType"
        case paymentOption = "PaymentOption"
        case recurringCharges = "RecurringCharges"
        case reservedInstanceOfferingId = "ReservedInstanceOfferingId"
        case usagePrice = "UsagePrice"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let fixedPrice = self.fixedPrice {
            try encodeContainer.encode(fixedPrice, forKey: .fixedPrice)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType.rawValue, forKey: .instanceType)
        }
        if let paymentOption = self.paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let recurringCharges = recurringCharges {
            var recurringChargesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recurringCharges)
            for recurringchargelist0 in recurringCharges {
                try recurringChargesContainer.encode(recurringchargelist0)
            }
        }
        if let reservedInstanceOfferingId = self.reservedInstanceOfferingId {
            try encodeContainer.encode(reservedInstanceOfferingId, forKey: .reservedInstanceOfferingId)
        }
        if let usagePrice = self.usagePrice {
            try encodeContainer.encode(usagePrice, forKey: .usagePrice)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedInstanceOfferingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedInstanceOfferingId)
        reservedInstanceOfferingId = reservedInstanceOfferingIdDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OpenSearchPartitionInstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration) ?? 0
        duration = durationDecoded
        let fixedPriceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .fixedPrice)
        fixedPrice = fixedPriceDecoded
        let usagePriceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .usagePrice)
        usagePrice = usagePriceDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ReservedInstancePaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let recurringChargesContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.RecurringCharge?].self, forKey: .recurringCharges)
        var recurringChargesDecoded0:[OpenSearchClientTypes.RecurringCharge]? = nil
        if let recurringChargesContainer = recurringChargesContainer {
            recurringChargesDecoded0 = [OpenSearchClientTypes.RecurringCharge]()
            for structure0 in recurringChargesContainer {
                if let structure0 = structure0 {
                    recurringChargesDecoded0?.append(structure0)
                }
            }
        }
        recurringCharges = recurringChargesDecoded0
    }
}

extension OpenSearchClientTypes {
    /// Details of a reserved OpenSearch instance offering.
    public struct ReservedInstanceOffering: Swift.Equatable {
        /// The currency code for the reserved OpenSearch instance offering.
        public var currencyCode: Swift.String?
        /// The duration, in seconds, for which the offering will reserve the OpenSearch instance.
        public var duration: Swift.Int
        /// The upfront fixed charge you will pay to purchase the specific reserved OpenSearch instance offering.
        public var fixedPrice: Swift.Double?
        /// The OpenSearch instance type offered by the reserved instance offering.
        public var instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType?
        /// Payment option for the reserved OpenSearch instance offering
        public var paymentOption: OpenSearchClientTypes.ReservedInstancePaymentOption?
        /// The charge to your account regardless of whether you are creating any domains using the instance offering.
        public var recurringCharges: [OpenSearchClientTypes.RecurringCharge]?
        /// The OpenSearch reserved instance offering identifier.
        public var reservedInstanceOfferingId: Swift.String?
        /// The rate you are charged for each hour the domain that is using the offering is running.
        public var usagePrice: Swift.Double?

        public init (
            currencyCode: Swift.String? = nil,
            duration: Swift.Int = 0,
            fixedPrice: Swift.Double? = nil,
            instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType? = nil,
            paymentOption: OpenSearchClientTypes.ReservedInstancePaymentOption? = nil,
            recurringCharges: [OpenSearchClientTypes.RecurringCharge]? = nil,
            reservedInstanceOfferingId: Swift.String? = nil,
            usagePrice: Swift.Double? = nil
        )
        {
            self.currencyCode = currencyCode
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.instanceType = instanceType
            self.paymentOption = paymentOption
            self.recurringCharges = recurringCharges
            self.reservedInstanceOfferingId = reservedInstanceOfferingId
            self.usagePrice = usagePrice
        }
    }

}

extension OpenSearchClientTypes {
    public enum ReservedInstancePaymentOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allUpfront
        case noUpfront
        case partialUpfront
        case sdkUnknown(Swift.String)

        public static var allCases: [ReservedInstancePaymentOption] {
            return [
                .allUpfront,
                .noUpfront,
                .partialUpfront,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allUpfront: return "ALL_UPFRONT"
            case .noUpfront: return "NO_UPFRONT"
            case .partialUpfront: return "PARTIAL_UPFRONT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReservedInstancePaymentOption(rawValue: rawValue) ?? ReservedInstancePaymentOption.sdkUnknown(rawValue)
        }
    }
}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception for creating a resource that already exists. Gives http status code of 400.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception for accessing or deleting a resource that does not exist. Gives http status code of 400.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpenSearchClientTypes {
    /// The rollback state while disabling Auto-Tune for the domain. Valid values are NO_ROLLBACK and DEFAULT_ROLLBACK.
    public enum RollbackOnDisable: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case defaultRollback
        case noRollback
        case sdkUnknown(Swift.String)

        public static var allCases: [RollbackOnDisable] {
            return [
                .defaultRollback,
                .noRollback,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .defaultRollback: return "DEFAULT_ROLLBACK"
            case .noRollback: return "NO_ROLLBACK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RollbackOnDisable(rawValue: rawValue) ?? RollbackOnDisable.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes.SAMLIdp: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case metadataContent = "MetadataContent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let metadataContent = self.metadataContent {
            try encodeContainer.encode(metadataContent, forKey: .metadataContent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataContent)
        metadataContent = metadataContentDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension OpenSearchClientTypes {
    /// The SAML identity povider's information.
    public struct SAMLIdp: Swift.Equatable {
        /// The unique entity ID of the application in SAML identity provider.
        /// This member is required.
        public var entityId: Swift.String?
        /// The metadata of the SAML application in XML format.
        /// This member is required.
        public var metadataContent: Swift.String?

        public init (
            entityId: Swift.String? = nil,
            metadataContent: Swift.String? = nil
        )
        {
            self.entityId = entityId
            self.metadataContent = metadataContent
        }
    }

}

extension OpenSearchClientTypes.SAMLOptionsInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case idp = "Idp"
        case masterBackendRole = "MasterBackendRole"
        case masterUserName = "MasterUserName"
        case rolesKey = "RolesKey"
        case sessionTimeoutMinutes = "SessionTimeoutMinutes"
        case subjectKey = "SubjectKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let idp = self.idp {
            try encodeContainer.encode(idp, forKey: .idp)
        }
        if let masterBackendRole = self.masterBackendRole {
            try encodeContainer.encode(masterBackendRole, forKey: .masterBackendRole)
        }
        if let masterUserName = self.masterUserName {
            try encodeContainer.encode(masterUserName, forKey: .masterUserName)
        }
        if let rolesKey = self.rolesKey {
            try encodeContainer.encode(rolesKey, forKey: .rolesKey)
        }
        if let sessionTimeoutMinutes = self.sessionTimeoutMinutes {
            try encodeContainer.encode(sessionTimeoutMinutes, forKey: .sessionTimeoutMinutes)
        }
        if let subjectKey = self.subjectKey {
            try encodeContainer.encode(subjectKey, forKey: .subjectKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let idpDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.SAMLIdp.self, forKey: .idp)
        idp = idpDecoded
        let masterUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserName)
        masterUserName = masterUserNameDecoded
        let masterBackendRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterBackendRole)
        masterBackendRole = masterBackendRoleDecoded
        let subjectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectKey)
        subjectKey = subjectKeyDecoded
        let rolesKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rolesKey)
        rolesKey = rolesKeyDecoded
        let sessionTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionTimeoutMinutes)
        sessionTimeoutMinutes = sessionTimeoutMinutesDecoded
    }
}

extension OpenSearchClientTypes.SAMLOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SAMLOptionsInput(enabled: \(Swift.String(describing: enabled)), idp: \(Swift.String(describing: idp)), masterBackendRole: \(Swift.String(describing: masterBackendRole)), rolesKey: \(Swift.String(describing: rolesKey)), sessionTimeoutMinutes: \(Swift.String(describing: sessionTimeoutMinutes)), subjectKey: \(Swift.String(describing: subjectKey)), masterUserName: \"CONTENT_REDACTED\")"}
}

extension OpenSearchClientTypes {
    /// The SAML application configuration for the domain.
    public struct SAMLOptionsInput: Swift.Equatable {
        /// True if SAML is enabled.
        public var enabled: Swift.Bool?
        /// The SAML Identity Provider's information.
        public var idp: OpenSearchClientTypes.SAMLIdp?
        /// The backend role that the SAML master user is mapped to.
        public var masterBackendRole: Swift.String?
        /// The SAML master username, which is stored in the Amazon OpenSearch Service domain's internal database.
        public var masterUserName: Swift.String?
        /// Element of the SAML assertion to use for backend roles. Default is roles.
        public var rolesKey: Swift.String?
        /// The duration, in minutes, after which a user session becomes inactive. Acceptable values are between 1 and 1440, and the default value is 60.
        public var sessionTimeoutMinutes: Swift.Int?
        /// Element of the SAML assertion to use for username. Default is NameID.
        public var subjectKey: Swift.String?

        public init (
            enabled: Swift.Bool? = nil,
            idp: OpenSearchClientTypes.SAMLIdp? = nil,
            masterBackendRole: Swift.String? = nil,
            masterUserName: Swift.String? = nil,
            rolesKey: Swift.String? = nil,
            sessionTimeoutMinutes: Swift.Int? = nil,
            subjectKey: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.idp = idp
            self.masterBackendRole = masterBackendRole
            self.masterUserName = masterUserName
            self.rolesKey = rolesKey
            self.sessionTimeoutMinutes = sessionTimeoutMinutes
            self.subjectKey = subjectKey
        }
    }

}

extension OpenSearchClientTypes.SAMLOptionsOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case idp = "Idp"
        case rolesKey = "RolesKey"
        case sessionTimeoutMinutes = "SessionTimeoutMinutes"
        case subjectKey = "SubjectKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let idp = self.idp {
            try encodeContainer.encode(idp, forKey: .idp)
        }
        if let rolesKey = self.rolesKey {
            try encodeContainer.encode(rolesKey, forKey: .rolesKey)
        }
        if let sessionTimeoutMinutes = self.sessionTimeoutMinutes {
            try encodeContainer.encode(sessionTimeoutMinutes, forKey: .sessionTimeoutMinutes)
        }
        if let subjectKey = self.subjectKey {
            try encodeContainer.encode(subjectKey, forKey: .subjectKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let idpDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.SAMLIdp.self, forKey: .idp)
        idp = idpDecoded
        let subjectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectKey)
        subjectKey = subjectKeyDecoded
        let rolesKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rolesKey)
        rolesKey = rolesKeyDecoded
        let sessionTimeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sessionTimeoutMinutes)
        sessionTimeoutMinutes = sessionTimeoutMinutesDecoded
    }
}

extension OpenSearchClientTypes {
    /// Describes the SAML application configured for the domain.
    public struct SAMLOptionsOutput: Swift.Equatable {
        /// True if SAML is enabled.
        public var enabled: Swift.Bool?
        /// Describes the SAML identity provider's information.
        public var idp: OpenSearchClientTypes.SAMLIdp?
        /// The key used for matching the SAML roles attribute.
        public var rolesKey: Swift.String?
        /// The duration, in minutes, after which a user session becomes inactive.
        public var sessionTimeoutMinutes: Swift.Int?
        /// The key used for matching the SAML subject attribute.
        public var subjectKey: Swift.String?

        public init (
            enabled: Swift.Bool? = nil,
            idp: OpenSearchClientTypes.SAMLIdp? = nil,
            rolesKey: Swift.String? = nil,
            sessionTimeoutMinutes: Swift.Int? = nil,
            subjectKey: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.idp = idp
            self.rolesKey = rolesKey
            self.sessionTimeoutMinutes = sessionTimeoutMinutes
            self.subjectKey = subjectKey
        }
    }

}

extension OpenSearchClientTypes {
    /// The Auto-Tune action type. Valid values are JVM_HEAP_SIZE_TUNING, and JVM_YOUNG_GEN_TUNING.
    public enum ScheduledAutoTuneActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jvmHeapSizeTuning
        case jvmYoungGenTuning
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduledAutoTuneActionType] {
            return [
                .jvmHeapSizeTuning,
                .jvmYoungGenTuning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jvmHeapSizeTuning: return "JVM_HEAP_SIZE_TUNING"
            case .jvmYoungGenTuning: return "JVM_YOUNG_GEN_TUNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScheduledAutoTuneActionType(rawValue: rawValue) ?? ScheduledAutoTuneActionType.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes.ScheduledAutoTuneDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case actionType = "ActionType"
        case date = "Date"
        case severity = "Severity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let date = self.date {
            try encodeContainer.encode(date.timeIntervalSince1970, forKey: .date)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .date)
        date = dateDecoded
        let actionTypeDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ScheduledAutoTuneActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let severityDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ScheduledAutoTuneSeverityType.self, forKey: .severity)
        severity = severityDecoded
    }
}

extension OpenSearchClientTypes {
    /// Specifies details about the scheduled Auto-Tune action. See [ Auto-Tune for Amazon OpenSearch Service ](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html) for more information.
    public struct ScheduledAutoTuneDetails: Swift.Equatable {
        /// The Auto-Tune action description.
        public var action: Swift.String?
        /// The Auto-Tune action type. Valid values are JVM_HEAP_SIZE_TUNING and JVM_YOUNG_GEN_TUNING.
        public var actionType: OpenSearchClientTypes.ScheduledAutoTuneActionType?
        /// The timestamp of the Auto-Tune action scheduled for the domain.
        public var date: ClientRuntime.Date?
        /// The Auto-Tune action severity. Valid values are LOW, MEDIUM, and HIGH.
        public var severity: OpenSearchClientTypes.ScheduledAutoTuneSeverityType?

        public init (
            action: Swift.String? = nil,
            actionType: OpenSearchClientTypes.ScheduledAutoTuneActionType? = nil,
            date: ClientRuntime.Date? = nil,
            severity: OpenSearchClientTypes.ScheduledAutoTuneSeverityType? = nil
        )
        {
            self.action = action
            self.actionType = actionType
            self.date = date
            self.severity = severity
        }
    }

}

extension OpenSearchClientTypes {
    /// The Auto-Tune action severity. Valid values are LOW, MEDIUM, and HIGH.
    public enum ScheduledAutoTuneSeverityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduledAutoTuneSeverityType] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScheduledAutoTuneSeverityType(rawValue: rawValue) ?? ScheduledAutoTuneSeverityType.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes.ServiceSoftwareOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automatedUpdateDate = "AutomatedUpdateDate"
        case cancellable = "Cancellable"
        case currentVersion = "CurrentVersion"
        case description = "Description"
        case newVersion = "NewVersion"
        case optionalDeployment = "OptionalDeployment"
        case updateAvailable = "UpdateAvailable"
        case updateStatus = "UpdateStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automatedUpdateDate = self.automatedUpdateDate {
            try encodeContainer.encode(automatedUpdateDate.timeIntervalSince1970, forKey: .automatedUpdateDate)
        }
        if let cancellable = self.cancellable {
            try encodeContainer.encode(cancellable, forKey: .cancellable)
        }
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let newVersion = self.newVersion {
            try encodeContainer.encode(newVersion, forKey: .newVersion)
        }
        if let optionalDeployment = self.optionalDeployment {
            try encodeContainer.encode(optionalDeployment, forKey: .optionalDeployment)
        }
        if let updateAvailable = self.updateAvailable {
            try encodeContainer.encode(updateAvailable, forKey: .updateAvailable)
        }
        if let updateStatus = self.updateStatus {
            try encodeContainer.encode(updateStatus.rawValue, forKey: .updateStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let newVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newVersion)
        newVersion = newVersionDecoded
        let updateAvailableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .updateAvailable)
        updateAvailable = updateAvailableDecoded
        let cancellableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cancellable)
        cancellable = cancellableDecoded
        let updateStatusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DeploymentStatus.self, forKey: .updateStatus)
        updateStatus = updateStatusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let automatedUpdateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .automatedUpdateDate)
        automatedUpdateDate = automatedUpdateDateDecoded
        let optionalDeploymentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .optionalDeployment)
        optionalDeployment = optionalDeploymentDecoded
    }
}

extension OpenSearchClientTypes {
    /// The current options of an domain service software options.
    public struct ServiceSoftwareOptions: Swift.Equatable {
        /// The timestamp, in Epoch time, until which you can manually request a service software update. After this date, we automatically update your service software.
        public var automatedUpdateDate: ClientRuntime.Date?
        /// True if you're able to cancel your service software version update. False if you can't cancel your service software update.
        public var cancellable: Swift.Bool?
        /// The current service software version present on the domain.
        public var currentVersion: Swift.String?
        /// The description of the UpdateStatus.
        public var description: Swift.String?
        /// The new service software version if one is available.
        public var newVersion: Swift.String?
        /// True if a service software is never automatically updated. False if a service software is automatically updated after AutomatedUpdateDate.
        public var optionalDeployment: Swift.Bool?
        /// True if you're able to update your service software version. False if you can't update your service software version.
        public var updateAvailable: Swift.Bool?
        /// The status of your service software update. This field can take the following values:  ELIGIBLE, PENDING_UPDATE, IN_PROGRESS, COMPLETED, and  NOT_ELIGIBLE.
        public var updateStatus: OpenSearchClientTypes.DeploymentStatus?

        public init (
            automatedUpdateDate: ClientRuntime.Date? = nil,
            cancellable: Swift.Bool? = nil,
            currentVersion: Swift.String? = nil,
            description: Swift.String? = nil,
            newVersion: Swift.String? = nil,
            optionalDeployment: Swift.Bool? = nil,
            updateAvailable: Swift.Bool? = nil,
            updateStatus: OpenSearchClientTypes.DeploymentStatus? = nil
        )
        {
            self.automatedUpdateDate = automatedUpdateDate
            self.cancellable = cancellable
            self.currentVersion = currentVersion
            self.description = description
            self.newVersion = newVersion
            self.optionalDeployment = optionalDeployment
            self.updateAvailable = updateAvailable
            self.updateStatus = updateStatus
        }
    }

}

extension OpenSearchClientTypes.SnapshotOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automatedSnapshotStartHour = "AutomatedSnapshotStartHour"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automatedSnapshotStartHour = self.automatedSnapshotStartHour {
            try encodeContainer.encode(automatedSnapshotStartHour, forKey: .automatedSnapshotStartHour)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automatedSnapshotStartHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .automatedSnapshotStartHour)
        automatedSnapshotStartHour = automatedSnapshotStartHourDecoded
    }
}

extension OpenSearchClientTypes {
    /// The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is 0 hours.
    public struct SnapshotOptions: Swift.Equatable {
        /// The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is 0 hours.
        public var automatedSnapshotStartHour: Swift.Int?

        public init (
            automatedSnapshotStartHour: Swift.Int? = nil
        )
        {
            self.automatedSnapshotStartHour = automatedSnapshotStartHour
        }
    }

}

extension OpenSearchClientTypes.SnapshotOptionsStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.SnapshotOptions.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchClientTypes {
    /// Status of a daily automated snapshot.
    public struct SnapshotOptionsStatus: Swift.Equatable {
        /// The daily snapshot options specified for the domain.
        /// This member is required.
        public var options: OpenSearchClientTypes.SnapshotOptions?
        /// The status of a daily automated snapshot.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init (
            options: OpenSearchClientTypes.SnapshotOptions? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension StartServiceSoftwareUpdateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
    }
}

extension StartServiceSoftwareUpdateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/opensearch/serviceSoftwareUpdate/start"
    }
}

/// Container for the parameters to the [StartServiceSoftwareUpdate] operation. Specifies the name of the domain to schedule a service software update for.
public struct StartServiceSoftwareUpdateInput: Swift.Equatable {
    /// The name of the domain that you want to update to the latest service software.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct StartServiceSoftwareUpdateInputBody: Swift.Equatable {
    let domainName: Swift.String?
}

extension StartServiceSoftwareUpdateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension StartServiceSoftwareUpdateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartServiceSoftwareUpdateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartServiceSoftwareUpdateOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartServiceSoftwareUpdateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartServiceSoftwareUpdateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceSoftwareOptions = output.serviceSoftwareOptions
        } else {
            self.serviceSoftwareOptions = nil
        }
    }
}

/// The result of a StartServiceSoftwareUpdate operation. Contains the status of the update.
public struct StartServiceSoftwareUpdateOutputResponse: Swift.Equatable {
    /// The current status of the OpenSearch service software update.
    public var serviceSoftwareOptions: OpenSearchClientTypes.ServiceSoftwareOptions?

    public init (
        serviceSoftwareOptions: OpenSearchClientTypes.ServiceSoftwareOptions? = nil
    )
    {
        self.serviceSoftwareOptions = serviceSoftwareOptions
    }
}

struct StartServiceSoftwareUpdateOutputResponseBody: Swift.Equatable {
    let serviceSoftwareOptions: OpenSearchClientTypes.ServiceSoftwareOptions?
}

extension StartServiceSoftwareUpdateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceSoftwareOptions = "ServiceSoftwareOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSoftwareOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ServiceSoftwareOptions.self, forKey: .serviceSoftwareOptions)
        serviceSoftwareOptions = serviceSoftwareOptionsDecoded
    }
}

extension OpenSearchClientTypes.StorageType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageSubTypeName = "StorageSubTypeName"
        case storageTypeLimits = "StorageTypeLimits"
        case storageTypeName = "StorageTypeName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let storageSubTypeName = self.storageSubTypeName {
            try encodeContainer.encode(storageSubTypeName, forKey: .storageSubTypeName)
        }
        if let storageTypeLimits = storageTypeLimits {
            var storageTypeLimitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .storageTypeLimits)
            for storagetypelimitlist0 in storageTypeLimits {
                try storageTypeLimitsContainer.encode(storagetypelimitlist0)
            }
        }
        if let storageTypeName = self.storageTypeName {
            try encodeContainer.encode(storageTypeName, forKey: .storageTypeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageTypeName)
        storageTypeName = storageTypeNameDecoded
        let storageSubTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageSubTypeName)
        storageSubTypeName = storageSubTypeNameDecoded
        let storageTypeLimitsContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.StorageTypeLimit?].self, forKey: .storageTypeLimits)
        var storageTypeLimitsDecoded0:[OpenSearchClientTypes.StorageTypeLimit]? = nil
        if let storageTypeLimitsContainer = storageTypeLimitsContainer {
            storageTypeLimitsDecoded0 = [OpenSearchClientTypes.StorageTypeLimit]()
            for structure0 in storageTypeLimitsContainer {
                if let structure0 = structure0 {
                    storageTypeLimitsDecoded0?.append(structure0)
                }
            }
        }
        storageTypeLimits = storageTypeLimitsDecoded0
    }
}

extension OpenSearchClientTypes {
    /// StorageTypes represents the list of storage-related types and their attributes that are available for a given InstanceType.
    public struct StorageType: Swift.Equatable {
        /// Sub-type of the given storage type. List of available sub-storage options: "instance" storageType has no storageSubType. "ebs" storageType has the following valid storageSubTypes:
        ///
        /// * standard
        ///
        /// * gp2
        ///
        /// * gp3
        ///
        /// * io1
        ///
        ///
        /// See [VolumeType] for more information regarding each EBS storage option.
        public var storageSubTypeName: Swift.String?
        /// Limits that are applicable for the given storage type.
        public var storageTypeLimits: [OpenSearchClientTypes.StorageTypeLimit]?
        /// Type of storage. List of available storage options:
        ///
        /// * instance
        ///  Built-in storage available for the instance
        /// * ebs
        ///  Elastic block storage attached to the instance
        public var storageTypeName: Swift.String?

        public init (
            storageSubTypeName: Swift.String? = nil,
            storageTypeLimits: [OpenSearchClientTypes.StorageTypeLimit]? = nil,
            storageTypeName: Swift.String? = nil
        )
        {
            self.storageSubTypeName = storageSubTypeName
            self.storageTypeLimits = storageTypeLimits
            self.storageTypeName = storageTypeName
        }
    }

}

extension OpenSearchClientTypes.StorageTypeLimit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limitName = "LimitName"
        case limitValues = "LimitValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limitName = self.limitName {
            try encodeContainer.encode(limitName, forKey: .limitName)
        }
        if let limitValues = limitValues {
            var limitValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .limitValues)
            for limitvaluelist0 in limitValues {
                try limitValuesContainer.encode(limitvaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .limitName)
        limitName = limitNameDecoded
        let limitValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .limitValues)
        var limitValuesDecoded0:[Swift.String]? = nil
        if let limitValuesContainer = limitValuesContainer {
            limitValuesDecoded0 = [Swift.String]()
            for string0 in limitValuesContainer {
                if let string0 = string0 {
                    limitValuesDecoded0?.append(string0)
                }
            }
        }
        limitValues = limitValuesDecoded0
    }
}

extension OpenSearchClientTypes {
    /// Limits that are applicable for the given storage type.
    public struct StorageTypeLimit: Swift.Equatable {
        /// Name of storage limits that are applicable for the given storage type. If [StorageType] is "ebs", the following storage options are applicable:
        ///
        /// * MinimumVolumeSize
        ///  Minimum amount of volume size that is applicable for the given storage type. Can be empty if not applicable.
        /// * MaximumVolumeSize
        ///  Maximum amount of volume size that is applicable for the given storage type. Can be empty if not applicable.
        /// * MaximumIops
        ///  Maximum amount of Iops that is applicable for given the storage type. Can be empty if not applicable.
        /// * MinimumIops
        ///  Minimum amount of Iops that is applicable for given the storage type. Can be empty if not applicable.
        /// * MaximumThroughput
        ///  Maximum amount of Throughput that is applicable for given the storage type. Can be empty if not applicable.
        /// * MinimumThroughput
        ///  Minimum amount of Throughput that is applicable for given the storage type. Can be empty if not applicable.
        public var limitName: Swift.String?
        /// Values for the [StorageTypeLimit$LimitName] .
        public var limitValues: [Swift.String]?

        public init (
            limitName: Swift.String? = nil,
            limitValues: [Swift.String]? = nil
        )
        {
            self.limitName = limitName
            self.limitValues = limitValues
        }
    }

}

extension OpenSearchClientTypes {
    public enum TLSSecurityPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case policyMinTls10201907
        case policyMinTls12201907
        case sdkUnknown(Swift.String)

        public static var allCases: [TLSSecurityPolicy] {
            return [
                .policyMinTls10201907,
                .policyMinTls12201907,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .policyMinTls10201907: return "Policy-Min-TLS-1-0-2019-07"
            case .policyMinTls12201907: return "Policy-Min-TLS-1-2-2019-07"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TLSSecurityPolicy(rawValue: rawValue) ?? TLSSecurityPolicy.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension OpenSearchClientTypes {
    /// A key value pair for a resource tag.
    public struct Tag: Swift.Equatable {
        /// The TagKey, the name of the tag. Tag keys must be unique for the domain to which they are attached.
        /// This member is required.
        public var key: Swift.String?
        /// The TagValue, the value assigned to the corresponding tag key. Tag values can be null and don't have to be unique in a tag set. For example, you can have a key value pair in a tag set of project : Trinity and cost-center : Trinity
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension OpenSearchClientTypes {
    /// The unit of a maintenance schedule duration. Valid value is HOUR. See [ Auto-Tune for Amazon OpenSearch Service ](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html) for more information.
    public enum TimeUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hours
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeUnit] {
            return [
                .hours,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hours: return "HOURS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeUnit(rawValue: rawValue) ?? TimeUnit.sdkUnknown(rawValue)
        }
    }
}

extension UpdateDomainConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicies = "AccessPolicies"
        case advancedOptions = "AdvancedOptions"
        case advancedSecurityOptions = "AdvancedSecurityOptions"
        case autoTuneOptions = "AutoTuneOptions"
        case clusterConfig = "ClusterConfig"
        case cognitoOptions = "CognitoOptions"
        case domainEndpointOptions = "DomainEndpointOptions"
        case dryRun = "DryRun"
        case eBSOptions = "EBSOptions"
        case encryptionAtRestOptions = "EncryptionAtRestOptions"
        case logPublishingOptions = "LogPublishingOptions"
        case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
        case snapshotOptions = "SnapshotOptions"
        case vPCOptions = "VPCOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPolicies = self.accessPolicies {
            try encodeContainer.encode(accessPolicies, forKey: .accessPolicies)
        }
        if let advancedOptions = advancedOptions {
            var advancedOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .advancedOptions)
            for (dictKey0, advancedoptions0) in advancedOptions {
                try advancedOptionsContainer.encode(advancedoptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let advancedSecurityOptions = self.advancedSecurityOptions {
            try encodeContainer.encode(advancedSecurityOptions, forKey: .advancedSecurityOptions)
        }
        if let autoTuneOptions = self.autoTuneOptions {
            try encodeContainer.encode(autoTuneOptions, forKey: .autoTuneOptions)
        }
        if let clusterConfig = self.clusterConfig {
            try encodeContainer.encode(clusterConfig, forKey: .clusterConfig)
        }
        if let cognitoOptions = self.cognitoOptions {
            try encodeContainer.encode(cognitoOptions, forKey: .cognitoOptions)
        }
        if let domainEndpointOptions = self.domainEndpointOptions {
            try encodeContainer.encode(domainEndpointOptions, forKey: .domainEndpointOptions)
        }
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let eBSOptions = self.eBSOptions {
            try encodeContainer.encode(eBSOptions, forKey: .eBSOptions)
        }
        if let encryptionAtRestOptions = self.encryptionAtRestOptions {
            try encodeContainer.encode(encryptionAtRestOptions, forKey: .encryptionAtRestOptions)
        }
        if let logPublishingOptions = logPublishingOptions {
            var logPublishingOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .logPublishingOptions)
            for (dictKey0, logpublishingoptions0) in logPublishingOptions {
                try logPublishingOptionsContainer.encode(logpublishingoptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let nodeToNodeEncryptionOptions = self.nodeToNodeEncryptionOptions {
            try encodeContainer.encode(nodeToNodeEncryptionOptions, forKey: .nodeToNodeEncryptionOptions)
        }
        if let snapshotOptions = self.snapshotOptions {
            try encodeContainer.encode(snapshotOptions, forKey: .snapshotOptions)
        }
        if let vPCOptions = self.vPCOptions {
            try encodeContainer.encode(vPCOptions, forKey: .vPCOptions)
        }
    }
}

extension UpdateDomainConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/config"
    }
}

/// Container for the parameters to the [UpdateDomain] operation. Specifies the type and number of instances in the domain cluster.
public struct UpdateDomainConfigInput: Swift.Equatable {
    /// IAM access policy as a JSON-formatted string.
    public var accessPolicies: Swift.String?
    /// Modifies the advanced option to allow references to indices in an HTTP request body. Must be false when configuring access to individual sub-resources. By default, the value is true. See [Advanced options ](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options) for more information.
    public var advancedOptions: [Swift.String:Swift.String]?
    /// Specifies advanced security options.
    public var advancedSecurityOptions: OpenSearchClientTypes.AdvancedSecurityOptionsInput?
    /// Specifies Auto-Tune options.
    public var autoTuneOptions: OpenSearchClientTypes.AutoTuneOptions?
    /// The type and number of instances to instantiate for the domain cluster.
    public var clusterConfig: OpenSearchClientTypes.ClusterConfig?
    /// Options to specify the Cognito user and identity pools for OpenSearch Dashboards authentication. For more information, see [Configuring Amazon Cognito authentication for OpenSearch Dashboards](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html).
    public var cognitoOptions: OpenSearchClientTypes.CognitoOptions?
    /// Options to specify configuration that will be applied to the domain endpoint.
    public var domainEndpointOptions: OpenSearchClientTypes.DomainEndpointOptions?
    /// The name of the domain you're updating.
    /// This member is required.
    public var domainName: Swift.String?
    /// This flag, when set to True, specifies whether the UpdateDomain request should return the results of validation checks (DryRunResults) without actually applying the change.
    public var dryRun: Swift.Bool?
    /// Specify the type and size of the EBS volume to use.
    public var eBSOptions: OpenSearchClientTypes.EBSOptions?
    /// Specifies encryption of data at rest options.
    public var encryptionAtRestOptions: OpenSearchClientTypes.EncryptionAtRestOptions?
    /// Map of LogType and LogPublishingOption, each containing options to publish a given type of OpenSearch log.
    public var logPublishingOptions: [Swift.String:OpenSearchClientTypes.LogPublishingOption]?
    /// Specifies node-to-node encryption options.
    public var nodeToNodeEncryptionOptions: OpenSearchClientTypes.NodeToNodeEncryptionOptions?
    /// Option to set the time, in UTC format, for the daily automated snapshot. Default value is 0 hours.
    public var snapshotOptions: OpenSearchClientTypes.SnapshotOptions?
    /// Options to specify the subnets and security groups for the VPC endpoint. For more information, see [Launching your Amazon OpenSearch Service domains using a VPC ](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html).
    public var vPCOptions: OpenSearchClientTypes.VPCOptions?

    public init (
        accessPolicies: Swift.String? = nil,
        advancedOptions: [Swift.String:Swift.String]? = nil,
        advancedSecurityOptions: OpenSearchClientTypes.AdvancedSecurityOptionsInput? = nil,
        autoTuneOptions: OpenSearchClientTypes.AutoTuneOptions? = nil,
        clusterConfig: OpenSearchClientTypes.ClusterConfig? = nil,
        cognitoOptions: OpenSearchClientTypes.CognitoOptions? = nil,
        domainEndpointOptions: OpenSearchClientTypes.DomainEndpointOptions? = nil,
        domainName: Swift.String? = nil,
        dryRun: Swift.Bool? = nil,
        eBSOptions: OpenSearchClientTypes.EBSOptions? = nil,
        encryptionAtRestOptions: OpenSearchClientTypes.EncryptionAtRestOptions? = nil,
        logPublishingOptions: [Swift.String:OpenSearchClientTypes.LogPublishingOption]? = nil,
        nodeToNodeEncryptionOptions: OpenSearchClientTypes.NodeToNodeEncryptionOptions? = nil,
        snapshotOptions: OpenSearchClientTypes.SnapshotOptions? = nil,
        vPCOptions: OpenSearchClientTypes.VPCOptions? = nil
    )
    {
        self.accessPolicies = accessPolicies
        self.advancedOptions = advancedOptions
        self.advancedSecurityOptions = advancedSecurityOptions
        self.autoTuneOptions = autoTuneOptions
        self.clusterConfig = clusterConfig
        self.cognitoOptions = cognitoOptions
        self.domainEndpointOptions = domainEndpointOptions
        self.domainName = domainName
        self.dryRun = dryRun
        self.eBSOptions = eBSOptions
        self.encryptionAtRestOptions = encryptionAtRestOptions
        self.logPublishingOptions = logPublishingOptions
        self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
        self.snapshotOptions = snapshotOptions
        self.vPCOptions = vPCOptions
    }
}

struct UpdateDomainConfigInputBody: Swift.Equatable {
    let clusterConfig: OpenSearchClientTypes.ClusterConfig?
    let eBSOptions: OpenSearchClientTypes.EBSOptions?
    let snapshotOptions: OpenSearchClientTypes.SnapshotOptions?
    let vPCOptions: OpenSearchClientTypes.VPCOptions?
    let cognitoOptions: OpenSearchClientTypes.CognitoOptions?
    let advancedOptions: [Swift.String:Swift.String]?
    let accessPolicies: Swift.String?
    let logPublishingOptions: [Swift.String:OpenSearchClientTypes.LogPublishingOption]?
    let encryptionAtRestOptions: OpenSearchClientTypes.EncryptionAtRestOptions?
    let domainEndpointOptions: OpenSearchClientTypes.DomainEndpointOptions?
    let nodeToNodeEncryptionOptions: OpenSearchClientTypes.NodeToNodeEncryptionOptions?
    let advancedSecurityOptions: OpenSearchClientTypes.AdvancedSecurityOptionsInput?
    let autoTuneOptions: OpenSearchClientTypes.AutoTuneOptions?
    let dryRun: Swift.Bool?
}

extension UpdateDomainConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicies = "AccessPolicies"
        case advancedOptions = "AdvancedOptions"
        case advancedSecurityOptions = "AdvancedSecurityOptions"
        case autoTuneOptions = "AutoTuneOptions"
        case clusterConfig = "ClusterConfig"
        case cognitoOptions = "CognitoOptions"
        case domainEndpointOptions = "DomainEndpointOptions"
        case dryRun = "DryRun"
        case eBSOptions = "EBSOptions"
        case encryptionAtRestOptions = "EncryptionAtRestOptions"
        case logPublishingOptions = "LogPublishingOptions"
        case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
        case snapshotOptions = "SnapshotOptions"
        case vPCOptions = "VPCOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterConfigDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ClusterConfig.self, forKey: .clusterConfig)
        clusterConfig = clusterConfigDecoded
        let eBSOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.EBSOptions.self, forKey: .eBSOptions)
        eBSOptions = eBSOptionsDecoded
        let snapshotOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.SnapshotOptions.self, forKey: .snapshotOptions)
        snapshotOptions = snapshotOptionsDecoded
        let vPCOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.VPCOptions.self, forKey: .vPCOptions)
        vPCOptions = vPCOptionsDecoded
        let cognitoOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.CognitoOptions.self, forKey: .cognitoOptions)
        cognitoOptions = cognitoOptionsDecoded
        let advancedOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .advancedOptions)
        var advancedOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let advancedOptionsContainer = advancedOptionsContainer {
            advancedOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in advancedOptionsContainer {
                if let string0 = string0 {
                    advancedOptionsDecoded0?[key0] = string0
                }
            }
        }
        advancedOptions = advancedOptionsDecoded0
        let accessPoliciesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicies)
        accessPolicies = accessPoliciesDecoded
        let logPublishingOptionsContainer = try containerValues.decodeIfPresent([Swift.String: OpenSearchClientTypes.LogPublishingOption?].self, forKey: .logPublishingOptions)
        var logPublishingOptionsDecoded0: [Swift.String:OpenSearchClientTypes.LogPublishingOption]? = nil
        if let logPublishingOptionsContainer = logPublishingOptionsContainer {
            logPublishingOptionsDecoded0 = [Swift.String:OpenSearchClientTypes.LogPublishingOption]()
            for (key0, logpublishingoption0) in logPublishingOptionsContainer {
                if let logpublishingoption0 = logpublishingoption0 {
                    logPublishingOptionsDecoded0?[key0] = logpublishingoption0
                }
            }
        }
        logPublishingOptions = logPublishingOptionsDecoded0
        let encryptionAtRestOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.EncryptionAtRestOptions.self, forKey: .encryptionAtRestOptions)
        encryptionAtRestOptions = encryptionAtRestOptionsDecoded
        let domainEndpointOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainEndpointOptions.self, forKey: .domainEndpointOptions)
        domainEndpointOptions = domainEndpointOptionsDecoded
        let nodeToNodeEncryptionOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.NodeToNodeEncryptionOptions.self, forKey: .nodeToNodeEncryptionOptions)
        nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptionsDecoded
        let advancedSecurityOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AdvancedSecurityOptionsInput.self, forKey: .advancedSecurityOptions)
        advancedSecurityOptions = advancedSecurityOptionsDecoded
        let autoTuneOptionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.AutoTuneOptions.self, forKey: .autoTuneOptions)
        autoTuneOptions = autoTuneOptionsDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension UpdateDomainConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTypeException" : self = .invalidTypeException(try InvalidTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDomainConfigOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case internalException(InternalException)
    case invalidTypeException(InvalidTypeException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDomainConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainConfig = output.domainConfig
            self.dryRunResults = output.dryRunResults
        } else {
            self.domainConfig = nil
            self.dryRunResults = nil
        }
    }
}

/// The result of an UpdateDomain request. Contains the status of the domain being updated.
public struct UpdateDomainConfigOutputResponse: Swift.Equatable {
    /// The status of the updated domain.
    /// This member is required.
    public var domainConfig: OpenSearchClientTypes.DomainConfig?
    /// Contains result of DryRun.
    public var dryRunResults: OpenSearchClientTypes.DryRunResults?

    public init (
        domainConfig: OpenSearchClientTypes.DomainConfig? = nil,
        dryRunResults: OpenSearchClientTypes.DryRunResults? = nil
    )
    {
        self.domainConfig = domainConfig
        self.dryRunResults = dryRunResults
    }
}

struct UpdateDomainConfigOutputResponseBody: Swift.Equatable {
    let domainConfig: OpenSearchClientTypes.DomainConfig?
    let dryRunResults: OpenSearchClientTypes.DryRunResults?
}

extension UpdateDomainConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainConfig = "DomainConfig"
        case dryRunResults = "DryRunResults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainConfigDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DomainConfig.self, forKey: .domainConfig)
        domainConfig = domainConfigDecoded
        let dryRunResultsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.DryRunResults.self, forKey: .dryRunResults)
        dryRunResults = dryRunResultsDecoded
    }
}

extension UpdatePackageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitMessage = "CommitMessage"
        case packageDescription = "PackageDescription"
        case packageID = "PackageID"
        case packageSource = "PackageSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitMessage = self.commitMessage {
            try encodeContainer.encode(commitMessage, forKey: .commitMessage)
        }
        if let packageDescription = self.packageDescription {
            try encodeContainer.encode(packageDescription, forKey: .packageDescription)
        }
        if let packageID = self.packageID {
            try encodeContainer.encode(packageID, forKey: .packageID)
        }
        if let packageSource = self.packageSource {
            try encodeContainer.encode(packageSource, forKey: .packageSource)
        }
    }
}

extension UpdatePackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/packages/update"
    }
}

/// Container for request parameters to the [UpdatePackage] operation.
public struct UpdatePackageInput: Swift.Equatable {
    /// A commit message for the new version which is shown as part of GetPackageVersionHistoryResponse.
    public var commitMessage: Swift.String?
    /// A new description of the package.
    public var packageDescription: Swift.String?
    /// The unique identifier for the package.
    /// This member is required.
    public var packageID: Swift.String?
    /// The Amazon S3 location for importing the package specified as S3BucketName and S3Key
    /// This member is required.
    public var packageSource: OpenSearchClientTypes.PackageSource?

    public init (
        commitMessage: Swift.String? = nil,
        packageDescription: Swift.String? = nil,
        packageID: Swift.String? = nil,
        packageSource: OpenSearchClientTypes.PackageSource? = nil
    )
    {
        self.commitMessage = commitMessage
        self.packageDescription = packageDescription
        self.packageID = packageID
        self.packageSource = packageSource
    }
}

struct UpdatePackageInputBody: Swift.Equatable {
    let packageID: Swift.String?
    let packageSource: OpenSearchClientTypes.PackageSource?
    let packageDescription: Swift.String?
    let commitMessage: Swift.String?
}

extension UpdatePackageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitMessage = "CommitMessage"
        case packageDescription = "PackageDescription"
        case packageID = "PackageID"
        case packageSource = "PackageSource"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageID)
        packageID = packageIDDecoded
        let packageSourceDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.PackageSource.self, forKey: .packageSource)
        packageSource = packageSourceDecoded
        let packageDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageDescription)
        packageDescription = packageDescriptionDecoded
        let commitMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitMessage)
        commitMessage = commitMessageDecoded
    }
}

extension UpdatePackageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePackageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePackageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case baseException(BaseException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePackageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePackageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.packageDetails = output.packageDetails
        } else {
            self.packageDetails = nil
        }
    }
}

/// Container for the response returned by the [UpdatePackage] operation.
public struct UpdatePackageOutputResponse: Swift.Equatable {
    /// Information about the package.
    public var packageDetails: OpenSearchClientTypes.PackageDetails?

    public init (
        packageDetails: OpenSearchClientTypes.PackageDetails? = nil
    )
    {
        self.packageDetails = packageDetails
    }
}

struct UpdatePackageOutputResponseBody: Swift.Equatable {
    let packageDetails: OpenSearchClientTypes.PackageDetails?
}

extension UpdatePackageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageDetails = "PackageDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageDetailsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.PackageDetails.self, forKey: .packageDetails)
        packageDetails = packageDetailsDecoded
    }
}

extension UpgradeDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedOptions = "AdvancedOptions"
        case domainName = "DomainName"
        case performCheckOnly = "PerformCheckOnly"
        case targetVersion = "TargetVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedOptions = advancedOptions {
            var advancedOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .advancedOptions)
            for (dictKey0, advancedoptions0) in advancedOptions {
                try advancedOptionsContainer.encode(advancedoptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let performCheckOnly = self.performCheckOnly {
            try encodeContainer.encode(performCheckOnly, forKey: .performCheckOnly)
        }
        if let targetVersion = self.targetVersion {
            try encodeContainer.encode(targetVersion, forKey: .targetVersion)
        }
    }
}

extension UpgradeDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2021-01-01/opensearch/upgradeDomain"
    }
}

/// Container for the request parameters to [UpgradeDomain] operation.
public struct UpgradeDomainInput: Swift.Equatable {
    /// Exposes select native OpenSearch configuration values from opensearch.yml. Currently, the following advanced options are available:
    ///
    /// * Option to allow references to indices in an HTTP request body. Must be false when configuring access to individual sub-resources. By default, the value is true. See [Advanced cluster parameters ](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options) for more information.
    ///
    /// * Option to specify the percentage of heap space allocated to field data. By default, this setting is unbounded.
    ///
    ///
    /// For more information, see [ Advanced cluster parameters](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options).
    public var advancedOptions: [Swift.String:Swift.String]?
    /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    /// This member is required.
    public var domainName: Swift.String?
    /// When true, indicates that an upgrade eligibility check needs to be performed. Does not actually perform the upgrade.
    public var performCheckOnly: Swift.Bool?
    /// The version of OpenSearch you intend to upgrade the domain to.
    /// This member is required.
    public var targetVersion: Swift.String?

    public init (
        advancedOptions: [Swift.String:Swift.String]? = nil,
        domainName: Swift.String? = nil,
        performCheckOnly: Swift.Bool? = nil,
        targetVersion: Swift.String? = nil
    )
    {
        self.advancedOptions = advancedOptions
        self.domainName = domainName
        self.performCheckOnly = performCheckOnly
        self.targetVersion = targetVersion
    }
}

struct UpgradeDomainInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let targetVersion: Swift.String?
    let performCheckOnly: Swift.Bool?
    let advancedOptions: [Swift.String:Swift.String]?
}

extension UpgradeDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedOptions = "AdvancedOptions"
        case domainName = "DomainName"
        case performCheckOnly = "PerformCheckOnly"
        case targetVersion = "TargetVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let targetVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetVersion)
        targetVersion = targetVersionDecoded
        let performCheckOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performCheckOnly)
        performCheckOnly = performCheckOnlyDecoded
        let advancedOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .advancedOptions)
        var advancedOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let advancedOptionsContainer = advancedOptionsContainer {
            advancedOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in advancedOptionsContainer {
                if let string0 = string0 {
                    advancedOptionsDecoded0?[key0] = string0
                }
            }
        }
        advancedOptions = advancedOptionsDecoded0
    }
}

extension UpgradeDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpgradeDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BaseException" : self = .baseException(try BaseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DisabledOperationException" : self = .disabledOperationException(try DisabledOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpgradeDomainOutputError: Swift.Error, Swift.Equatable {
    case baseException(BaseException)
    case disabledOperationException(DisabledOperationException)
    case internalException(InternalException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpgradeDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpgradeDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.advancedOptions = output.advancedOptions
            self.changeProgressDetails = output.changeProgressDetails
            self.domainName = output.domainName
            self.performCheckOnly = output.performCheckOnly
            self.targetVersion = output.targetVersion
            self.upgradeId = output.upgradeId
        } else {
            self.advancedOptions = nil
            self.changeProgressDetails = nil
            self.domainName = nil
            self.performCheckOnly = nil
            self.targetVersion = nil
            self.upgradeId = nil
        }
    }
}

/// Container for response returned by [UpgradeDomain] operation.
public struct UpgradeDomainOutputResponse: Swift.Equatable {
    /// Exposes select native OpenSearch configuration values from opensearch.yml. Currently, the following advanced options are available:
    ///
    /// * Option to allow references to indices in an HTTP request body. Must be false when configuring access to individual sub-resources. By default, the value is true. See [Advanced cluster parameters ](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options) for more information.
    ///
    /// * Option to specify the percentage of heap space allocated to field data. By default, this setting is unbounded.
    ///
    ///
    /// For more information, see [ Advanced cluster parameters](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options).
    public var advancedOptions: [Swift.String:Swift.String]?
    /// Specifies change details of the domain configuration change.
    public var changeProgressDetails: OpenSearchClientTypes.ChangeProgressDetails?
    /// The name of an domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
    public var domainName: Swift.String?
    /// When true, indicates that an upgrade eligibility check needs to be performed. Does not actually perform the upgrade.
    public var performCheckOnly: Swift.Bool?
    /// The version of OpenSearch that you intend to upgrade the domain to.
    public var targetVersion: Swift.String?
    public var upgradeId: Swift.String?

    public init (
        advancedOptions: [Swift.String:Swift.String]? = nil,
        changeProgressDetails: OpenSearchClientTypes.ChangeProgressDetails? = nil,
        domainName: Swift.String? = nil,
        performCheckOnly: Swift.Bool? = nil,
        targetVersion: Swift.String? = nil,
        upgradeId: Swift.String? = nil
    )
    {
        self.advancedOptions = advancedOptions
        self.changeProgressDetails = changeProgressDetails
        self.domainName = domainName
        self.performCheckOnly = performCheckOnly
        self.targetVersion = targetVersion
        self.upgradeId = upgradeId
    }
}

struct UpgradeDomainOutputResponseBody: Swift.Equatable {
    let upgradeId: Swift.String?
    let domainName: Swift.String?
    let targetVersion: Swift.String?
    let performCheckOnly: Swift.Bool?
    let advancedOptions: [Swift.String:Swift.String]?
    let changeProgressDetails: OpenSearchClientTypes.ChangeProgressDetails?
}

extension UpgradeDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedOptions = "AdvancedOptions"
        case changeProgressDetails = "ChangeProgressDetails"
        case domainName = "DomainName"
        case performCheckOnly = "PerformCheckOnly"
        case targetVersion = "TargetVersion"
        case upgradeId = "UpgradeId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let upgradeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upgradeId)
        upgradeId = upgradeIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let targetVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetVersion)
        targetVersion = targetVersionDecoded
        let performCheckOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performCheckOnly)
        performCheckOnly = performCheckOnlyDecoded
        let advancedOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .advancedOptions)
        var advancedOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let advancedOptionsContainer = advancedOptionsContainer {
            advancedOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in advancedOptionsContainer {
                if let string0 = string0 {
                    advancedOptionsDecoded0?[key0] = string0
                }
            }
        }
        advancedOptions = advancedOptionsDecoded0
        let changeProgressDetailsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.ChangeProgressDetails.self, forKey: .changeProgressDetails)
        changeProgressDetails = changeProgressDetailsDecoded
    }
}

extension OpenSearchClientTypes.UpgradeHistory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startTimestamp = "StartTimestamp"
        case stepsList = "StepsList"
        case upgradeName = "UpgradeName"
        case upgradeStatus = "UpgradeStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startTimestamp = self.startTimestamp {
            try encodeContainer.encode(startTimestamp.timeIntervalSince1970, forKey: .startTimestamp)
        }
        if let stepsList = stepsList {
            var stepsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stepsList)
            for upgradestepslist0 in stepsList {
                try stepsListContainer.encode(upgradestepslist0)
            }
        }
        if let upgradeName = self.upgradeName {
            try encodeContainer.encode(upgradeName, forKey: .upgradeName)
        }
        if let upgradeStatus = self.upgradeStatus {
            try encodeContainer.encode(upgradeStatus.rawValue, forKey: .upgradeStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let upgradeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upgradeName)
        upgradeName = upgradeNameDecoded
        let startTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTimestamp)
        startTimestamp = startTimestampDecoded
        let upgradeStatusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.UpgradeStatus.self, forKey: .upgradeStatus)
        upgradeStatus = upgradeStatusDecoded
        let stepsListContainer = try containerValues.decodeIfPresent([OpenSearchClientTypes.UpgradeStepItem?].self, forKey: .stepsList)
        var stepsListDecoded0:[OpenSearchClientTypes.UpgradeStepItem]? = nil
        if let stepsListContainer = stepsListContainer {
            stepsListDecoded0 = [OpenSearchClientTypes.UpgradeStepItem]()
            for structure0 in stepsListContainer {
                if let structure0 = structure0 {
                    stepsListDecoded0?.append(structure0)
                }
            }
        }
        stepsList = stepsListDecoded0
    }
}

extension OpenSearchClientTypes {
    /// History of the last 10 upgrades and upgrade eligibility checks.
    public struct UpgradeHistory: Swift.Equatable {
        /// UTC timestamp at which the upgrade API call was made in "yyyy-MM-ddTHH:mm:ssZ" format.
        public var startTimestamp: ClientRuntime.Date?
        /// A list of [UpgradeStepItem] s representing information about each step performed as part of a specific upgrade or upgrade eligibility check.
        public var stepsList: [OpenSearchClientTypes.UpgradeStepItem]?
        /// A string that briefly describes the upgrade.
        public var upgradeName: Swift.String?
        /// The current status of the upgrade. The status can take one of the following values:
        ///
        /// * In Progress
        ///
        /// * Succeeded
        ///
        /// * Succeeded with Issues
        ///
        /// * Failed
        public var upgradeStatus: OpenSearchClientTypes.UpgradeStatus?

        public init (
            startTimestamp: ClientRuntime.Date? = nil,
            stepsList: [OpenSearchClientTypes.UpgradeStepItem]? = nil,
            upgradeName: Swift.String? = nil,
            upgradeStatus: OpenSearchClientTypes.UpgradeStatus? = nil
        )
        {
            self.startTimestamp = startTimestamp
            self.stepsList = stepsList
            self.upgradeName = upgradeName
            self.upgradeStatus = upgradeStatus
        }
    }

}

extension OpenSearchClientTypes {
    public enum UpgradeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case succeededWithIssues
        case sdkUnknown(Swift.String)

        public static var allCases: [UpgradeStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .succeededWithIssues,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case .succeededWithIssues: return "SUCCEEDED_WITH_ISSUES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpgradeStatus(rawValue: rawValue) ?? UpgradeStatus.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes {
    public enum UpgradeStep: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case preUpgradeCheck
        case snapshot
        case upgrade
        case sdkUnknown(Swift.String)

        public static var allCases: [UpgradeStep] {
            return [
                .preUpgradeCheck,
                .snapshot,
                .upgrade,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .preUpgradeCheck: return "PRE_UPGRADE_CHECK"
            case .snapshot: return "SNAPSHOT"
            case .upgrade: return "UPGRADE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpgradeStep(rawValue: rawValue) ?? UpgradeStep.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes.UpgradeStepItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case issues = "Issues"
        case progressPercent = "ProgressPercent"
        case upgradeStep = "UpgradeStep"
        case upgradeStepStatus = "UpgradeStepStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let issues = issues {
            var issuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .issues)
            for issues0 in issues {
                try issuesContainer.encode(issues0)
            }
        }
        if let progressPercent = self.progressPercent {
            try encodeContainer.encode(progressPercent, forKey: .progressPercent)
        }
        if let upgradeStep = self.upgradeStep {
            try encodeContainer.encode(upgradeStep.rawValue, forKey: .upgradeStep)
        }
        if let upgradeStepStatus = self.upgradeStepStatus {
            try encodeContainer.encode(upgradeStepStatus.rawValue, forKey: .upgradeStepStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let upgradeStepDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.UpgradeStep.self, forKey: .upgradeStep)
        upgradeStep = upgradeStepDecoded
        let upgradeStepStatusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.UpgradeStatus.self, forKey: .upgradeStepStatus)
        upgradeStepStatus = upgradeStepStatusDecoded
        let issuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .issues)
        var issuesDecoded0:[Swift.String]? = nil
        if let issuesContainer = issuesContainer {
            issuesDecoded0 = [Swift.String]()
            for string0 in issuesContainer {
                if let string0 = string0 {
                    issuesDecoded0?.append(string0)
                }
            }
        }
        issues = issuesDecoded0
        let progressPercentDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .progressPercent)
        progressPercent = progressPercentDecoded
    }
}

extension OpenSearchClientTypes {
    /// Represents a single step of the upgrade or upgrade eligibility check workflow.
    public struct UpgradeStepItem: Swift.Equatable {
        /// A list of strings containing detailed information about the errors encountered in a particular step.
        public var issues: [Swift.String]?
        /// The floating point value representing the progress percentage of a particular step.
        public var progressPercent: Swift.Double?
        /// One of three steps an upgrade or upgrade eligibility check goes through:
        ///
        /// * PreUpgradeCheck
        ///
        /// * Snapshot
        ///
        /// * Upgrade
        public var upgradeStep: OpenSearchClientTypes.UpgradeStep?
        /// The current status of the upgrade. The status can take one of the following values:
        ///
        /// * In Progress
        ///
        /// * Succeeded
        ///
        /// * Succeeded with Issues
        ///
        /// * Failed
        public var upgradeStepStatus: OpenSearchClientTypes.UpgradeStatus?

        public init (
            issues: [Swift.String]? = nil,
            progressPercent: Swift.Double? = nil,
            upgradeStep: OpenSearchClientTypes.UpgradeStep? = nil,
            upgradeStepStatus: OpenSearchClientTypes.UpgradeStatus? = nil
        )
        {
            self.issues = issues
            self.progressPercent = progressPercent
            self.upgradeStep = upgradeStep
            self.upgradeStepStatus = upgradeStepStatus
        }
    }

}

extension OpenSearchClientTypes.VPCDerivedInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vPCId = "VPCId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for stringlist0 in availabilityZones {
                try availabilityZonesContainer.encode(stringlist0)
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for stringlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(stringlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for stringlist0 in subnetIds {
                try subnetIdsContainer.encode(stringlist0)
            }
        }
        if let vPCId = self.vPCId {
            try encodeContainer.encode(vPCId, forKey: .vPCId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vPCIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vPCId)
        vPCId = vPCIdDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension OpenSearchClientTypes {
    /// Options to specify the subnets and security groups for the VPC endpoint. For more information, see [ Launching your Amazon OpenSearch Service domains using a VPC](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html).
    public struct VPCDerivedInfo: Swift.Equatable {
        /// The Availability Zones for the domain. Exists only if the domain was created with VPCOptions.
        public var availabilityZones: [Swift.String]?
        /// The security groups for the VPC endpoint.
        public var securityGroupIds: [Swift.String]?
        /// The subnets for the VPC endpoint.
        public var subnetIds: [Swift.String]?
        /// The VPC ID for the domain. Exists only if the domain was created with VPCOptions.
        public var vPCId: Swift.String?

        public init (
            availabilityZones: [Swift.String]? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vPCId: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vPCId = vPCId
        }
    }

}

extension OpenSearchClientTypes.VPCDerivedInfoStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.VPCDerivedInfo.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchClientTypes {
    /// Status of the VPC options for the specified domain.
    public struct VPCDerivedInfoStatus: Swift.Equatable {
        /// The VPC options for the specified domain.
        /// This member is required.
        public var options: OpenSearchClientTypes.VPCDerivedInfo?
        /// The status of the VPC options for the specified domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init (
            options: OpenSearchClientTypes.VPCDerivedInfo? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes.VPCOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for stringlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(stringlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for stringlist0 in subnetIds {
                try subnetIdsContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension OpenSearchClientTypes {
    /// Options to specify the subnets and security groups for the VPC endpoint. For more information, see [ Launching your Amazon OpenSearch Service domains using a VPC](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html).
    public struct VPCOptions: Swift.Equatable {
        /// The security groups for the VPC endpoint.
        public var securityGroupIds: [Swift.String]?
        /// The subnets for the VPC endpoint.
        public var subnetIds: [Swift.String]?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An exception for missing / invalid input fields. Gives http status code of 400.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A description of the error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpenSearchClientTypes.VersionStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .options)
        options = optionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpenSearchClientTypes.OptionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OpenSearchClientTypes {
    /// The status of the OpenSearch version options for the specified OpenSearch domain.
    public struct VersionStatus: Swift.Equatable {
        /// The OpenSearch version for the specified OpenSearch domain.
        /// This member is required.
        public var options: Swift.String?
        /// The status of the OpenSearch version options for the specified OpenSearch domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init (
            options: Swift.String? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    /// The type of EBS volume, standard, gp2, gp3 or io1. See [Configuring EBS-based Storage](http://docs.aws.amazon.com/opensearch-service/latest/developerguide/opensearch-createupdatedomains.html#opensearch-createdomain-configure-ebs) for more information.
    public enum VolumeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gp2
        case gp3
        case io1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [VolumeType] {
            return [
                .gp2,
                .gp3,
                .io1,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "gp2"
            case .gp3: return "gp3"
            case .io1: return "io1"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VolumeType(rawValue: rawValue) ?? VolumeType.sdkUnknown(rawValue)
        }
    }
}

extension OpenSearchClientTypes.ZoneAwarenessConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneCount = "AvailabilityZoneCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZoneCount = self.availabilityZoneCount {
            try encodeContainer.encode(availabilityZoneCount, forKey: .availabilityZoneCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availabilityZoneCount)
        availabilityZoneCount = availabilityZoneCountDecoded
    }
}

extension OpenSearchClientTypes {
    /// The zone awareness configuration for the domain cluster, such as the number of availability zones.
    public struct ZoneAwarenessConfig: Swift.Equatable {
        /// An integer value to indicate the number of availability zones for a domain when zone awareness is enabled. This should be equal to number of subnets if VPC endpoints is enabled.
        public var availabilityZoneCount: Swift.Int?

        public init (
            availabilityZoneCount: Swift.Int? = nil
        )
        {
            self.availabilityZoneCount = availabilityZoneCount
        }
    }

}
